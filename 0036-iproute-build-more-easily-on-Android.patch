From 9b0d1f60b01ac442ee3ec15c47c99d3756938034 Mon Sep 17 00:00:00 2001
From: Phil Sutter <psutter@redhat.com>
Date: Mon, 13 Nov 2017 18:09:56 +0100
Subject: [PATCH] iproute: build more easily on Android

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1472759
Upstream Status: iproute2.git commit 596b1c94aa38e

commit 596b1c94aa38e21b7a8c8562e8b61ccb744255d2
Author: Lorenzo Colitti <lorenzo@google.com>
Date:   Tue Oct 3 02:03:37 2017 +0900

    iproute: build more easily on Android

    iproute2 contains a bunch of kernel headers, including uapi ones.
    Android's libc uses uapi headers almost directly, and uses a
    script to fix kernel types that don't match what userspace
    expects.

    For example: https://issuetracker.google.com/36987220 reports
    that our struct ip_mreq_source contains "__be32 imr_multiaddr"
    rather than "struct in_addr imr_multiaddr". The script addresses
    this by replacing the uapi struct definition with a #include
    <bits/ip_mreq.h> which contains the traditional userspace
    definition.

    Unfortunately, when we compile iproute2, this definition
    conflicts with the one in iproute2's linux/in.h.

    Historically we've just solved this problem by running "git rm"
    on all the iproute2 include/linux headers that break Android's
    libc.  However, deleting the files in this way makes it harder to
    keep up with upstream, because every upstream change to
    an include file causes a merge conflict with the delete.

    This patch fixes the problem by moving the iproute2 linux headers
    from include/linux to include/uapi/linux.

    Tested: compiles on ubuntu trusty (glibc)

    Signed-off-by: Elliott Hughes <enh@google.com>
    Signed-off-by: Lorenzo Colitti <lorenzo@google.com>
---
 Makefile                                       |    2 +-
 include/linux/atm.h                            |  241 ------
 include/linux/atmapi.h                         |   29 -
 include/linux/atmarp.h                         |   41 -
 include/linux/atmdev.h                         |  215 -----
 include/linux/atmioc.h                         |   41 -
 include/linux/atmsap.h                         |  162 ----
 include/linux/bpf.h                            |  867 -------------------
 include/linux/bpf_common.h                     |   55 --
 include/linux/can.h                            |  201 -----
 include/linux/can/netlink.h                    |  142 ----
 include/linux/can/vxcan.h                      |   12 -
 include/linux/devlink.h                        |  247 ------
 include/linux/elf-em.h                         |   60 --
 include/linux/fib_rules.h                      |   80 --
 include/linux/filter.h                         |   89 --
 include/linux/fou.h                            |   41 -
 include/linux/gen_stats.h                      |   79 --
 include/linux/genetlink.h                      |   88 --
 include/linux/hdlc/ioctl.h                     |   84 --
 include/linux/icmpv6.h                         |  166 ----
 include/linux/if.h                             |  292 -------
 include/linux/if_addr.h                        |   67 --
 include/linux/if_addrlabel.h                   |   32 -
 include/linux/if_alg.h                         |   42 -
 include/linux/if_arp.h                         |  163 ----
 include/linux/if_bonding.h                     |  130 ---
 include/linux/if_bridge.h                      |  294 -------
 include/linux/if_ether.h                       |  158 ----
 include/linux/if_link.h                        |  928 --------------------
 include/linux/if_macsec.h                      |  171 ----
 include/linux/if_packet.h                      |  302 -------
 include/linux/if_tun.h                         |  107 ---
 include/linux/if_tunnel.h                      |  158 ----
 include/linux/if_vlan.h                        |   64 --
 include/linux/ife.h                            |   18 -
 include/linux/ila.h                            |   45 -
 include/linux/in.h                             |  300 -------
 include/linux/in6.h                            |  296 -------
 include/linux/in_route.h                       |   32 -
 include/linux/inet_diag.h                      |  196 -----
 include/linux/ip.h                             |  175 ----
 include/linux/ip6_tunnel.h                     |   53 --
 include/linux/ipsec.h                          |   47 -
 include/linux/kernel.h                         |   14 -
 include/linux/l2tp.h                           |  199 -----
 include/linux/libc-compat.h                    |  213 -----
 include/linux/limits.h                         |   20 -
 include/linux/lwtunnel.h                       |   70 --
 include/linux/magic.h                          |   91 --
 include/linux/mpls.h                           |   76 --
 include/linux/mpls_iptunnel.h                  |   30 -
 include/linux/neighbour.h                      |  171 ----
 include/linux/net_namespace.h                  |   23 -
 include/linux/netconf.h                        |   28 -
 include/linux/netdevice.h                      |   65 --
 include/linux/netfilter.h                      |   77 --
 include/linux/netfilter/ipset/ip_set.h         |  304 -------
 include/linux/netfilter/x_tables.h             |  185 ----
 include/linux/netfilter/xt_set.h               |   93 --
 include/linux/netfilter/xt_tcpudp.h            |   36 -
 include/linux/netfilter_ipv4.h                 |   79 --
 include/linux/netfilter_ipv4/ip_tables.h       |  228 -----
 include/linux/netfilter_ipv6.h                 |   77 --
 include/linux/netfilter_ipv6/ip6_tables.h      |  269 ------
 include/linux/netlink.h                        |  246 ------
 include/linux/netlink_diag.h                   |   64 --
 include/linux/packet_diag.h                    |   80 --
 include/linux/param.h                          |    6 -
 include/linux/pfkeyv2.h                        |  383 ---------
 include/linux/pkt_cls.h                        |  569 -------------
 include/linux/pkt_sched.h                      |  874 -------------------
 include/linux/posix_types.h                    |   37 -
 include/linux/rtnetlink.h                      |  718 ----------------
 include/linux/sctp.h                           | 1085 ------------------------
 include/linux/seg6.h                           |   54 --
 include/linux/seg6_genl.h                      |   32 -
 include/linux/seg6_hmac.h                      |   22 -
 include/linux/seg6_iptunnel.h                  |   40 -
 include/linux/seg6_local.h                     |   68 --
 include/linux/sock_diag.h                      |   38 -
 include/linux/socket.h                         |   21 -
 include/linux/sockios.h                        |  152 ----
 include/linux/stddef.h                         |    5 -
 include/linux/sysinfo.h                        |   24 -
 include/linux/tc_act/tc_bpf.h                  |   36 -
 include/linux/tc_act/tc_connmark.h             |   23 -
 include/linux/tc_act/tc_csum.h                 |   34 -
 include/linux/tc_act/tc_defact.h               |   20 -
 include/linux/tc_act/tc_gact.h                 |   33 -
 include/linux/tc_act/tc_ife.h                  |   32 -
 include/linux/tc_act/tc_ipt.h                  |   22 -
 include/linux/tc_act/tc_mirred.h               |   28 -
 include/linux/tc_act/tc_nat.h                  |   28 -
 include/linux/tc_act/tc_pedit.h                |   66 --
 include/linux/tc_act/tc_sample.h               |   26 -
 include/linux/tc_act/tc_skbedit.h              |   51 --
 include/linux/tc_act/tc_skbmod.h               |   39 -
 include/linux/tc_act/tc_tunnel_key.h           |   43 -
 include/linux/tc_act/tc_vlan.h                 |   38 -
 include/linux/tc_ematch/tc_em_cmp.h            |   25 -
 include/linux/tc_ematch/tc_em_meta.h           |   92 --
 include/linux/tc_ematch/tc_em_nbyte.h          |   13 -
 include/linux/tcp.h                            |  268 ------
 include/linux/tcp_metrics.h                    |   60 --
 include/linux/tipc.h                           |  256 ------
 include/linux/tipc_netlink.h                   |  294 -------
 include/linux/types.h                          |   47 -
 include/linux/unix_diag.h                      |   58 --
 include/linux/veth.h                           |   12 -
 include/linux/xfrm.h                           |  536 ------------
 include/uapi/linux/atm.h                       |  241 ++++++
 include/uapi/linux/atmapi.h                    |   29 +
 include/uapi/linux/atmarp.h                    |   41 +
 include/uapi/linux/atmdev.h                    |  215 +++++
 include/uapi/linux/atmioc.h                    |   41 +
 include/uapi/linux/atmsap.h                    |  162 ++++
 include/uapi/linux/bpf.h                       |  867 +++++++++++++++++++
 include/uapi/linux/bpf_common.h                |   55 ++
 include/uapi/linux/can.h                       |  201 +++++
 include/uapi/linux/can/netlink.h               |  142 ++++
 include/uapi/linux/can/vxcan.h                 |   12 +
 include/uapi/linux/devlink.h                   |  247 ++++++
 include/uapi/linux/elf-em.h                    |   60 ++
 include/uapi/linux/fib_rules.h                 |   80 ++
 include/uapi/linux/filter.h                    |   89 ++
 include/uapi/linux/fou.h                       |   41 +
 include/uapi/linux/gen_stats.h                 |   79 ++
 include/uapi/linux/genetlink.h                 |   88 ++
 include/uapi/linux/hdlc/ioctl.h                |   84 ++
 include/uapi/linux/icmpv6.h                    |  166 ++++
 include/uapi/linux/if.h                        |  292 +++++++
 include/uapi/linux/if_addr.h                   |   67 ++
 include/uapi/linux/if_addrlabel.h              |   32 +
 include/uapi/linux/if_alg.h                    |   42 +
 include/uapi/linux/if_arp.h                    |  163 ++++
 include/uapi/linux/if_bonding.h                |  130 +++
 include/uapi/linux/if_bridge.h                 |  294 +++++++
 include/uapi/linux/if_ether.h                  |  158 ++++
 include/uapi/linux/if_link.h                   |  928 ++++++++++++++++++++
 include/uapi/linux/if_macsec.h                 |  171 ++++
 include/uapi/linux/if_packet.h                 |  302 +++++++
 include/uapi/linux/if_tun.h                    |  107 +++
 include/uapi/linux/if_tunnel.h                 |  158 ++++
 include/uapi/linux/if_vlan.h                   |   64 ++
 include/uapi/linux/ife.h                       |   18 +
 include/uapi/linux/ila.h                       |   45 +
 include/uapi/linux/in.h                        |  300 +++++++
 include/uapi/linux/in6.h                       |  296 +++++++
 include/uapi/linux/in_route.h                  |   32 +
 include/uapi/linux/inet_diag.h                 |  196 +++++
 include/uapi/linux/ip.h                        |  175 ++++
 include/uapi/linux/ip6_tunnel.h                |   53 ++
 include/uapi/linux/ipsec.h                     |   47 +
 include/uapi/linux/kernel.h                    |   14 +
 include/uapi/linux/l2tp.h                      |  199 +++++
 include/uapi/linux/libc-compat.h               |  213 +++++
 include/uapi/linux/limits.h                    |   20 +
 include/uapi/linux/lwtunnel.h                  |   70 ++
 include/uapi/linux/magic.h                     |   91 ++
 include/uapi/linux/mpls.h                      |   76 ++
 include/uapi/linux/mpls_iptunnel.h             |   30 +
 include/uapi/linux/neighbour.h                 |  171 ++++
 include/uapi/linux/net_namespace.h             |   23 +
 include/uapi/linux/netconf.h                   |   28 +
 include/uapi/linux/netdevice.h                 |   65 ++
 include/uapi/linux/netfilter.h                 |   77 ++
 include/uapi/linux/netfilter/ipset/ip_set.h    |  304 +++++++
 include/uapi/linux/netfilter/x_tables.h        |  185 ++++
 include/uapi/linux/netfilter/xt_set.h          |   93 ++
 include/uapi/linux/netfilter/xt_tcpudp.h       |   36 +
 include/uapi/linux/netfilter_ipv4.h            |   79 ++
 include/uapi/linux/netfilter_ipv4/ip_tables.h  |  228 +++++
 include/uapi/linux/netfilter_ipv6.h            |   77 ++
 include/uapi/linux/netfilter_ipv6/ip6_tables.h |  269 ++++++
 include/uapi/linux/netlink.h                   |  246 ++++++
 include/uapi/linux/netlink_diag.h              |   64 ++
 include/uapi/linux/packet_diag.h               |   80 ++
 include/uapi/linux/param.h                     |    6 +
 include/uapi/linux/pfkeyv2.h                   |  383 +++++++++
 include/uapi/linux/pkt_cls.h                   |  569 +++++++++++++
 include/uapi/linux/pkt_sched.h                 |  874 +++++++++++++++++++
 include/uapi/linux/posix_types.h               |   37 +
 include/uapi/linux/rtnetlink.h                 |  718 ++++++++++++++++
 include/uapi/linux/sctp.h                      | 1085 ++++++++++++++++++++++++
 include/uapi/linux/seg6.h                      |   54 ++
 include/uapi/linux/seg6_genl.h                 |   32 +
 include/uapi/linux/seg6_hmac.h                 |   22 +
 include/uapi/linux/seg6_iptunnel.h             |   40 +
 include/uapi/linux/seg6_local.h                |   68 ++
 include/uapi/linux/sock_diag.h                 |   38 +
 include/uapi/linux/socket.h                    |   21 +
 include/uapi/linux/sockios.h                   |  152 ++++
 include/uapi/linux/stddef.h                    |    5 +
 include/uapi/linux/sysinfo.h                   |   24 +
 include/uapi/linux/tc_act/tc_bpf.h             |   36 +
 include/uapi/linux/tc_act/tc_connmark.h        |   23 +
 include/uapi/linux/tc_act/tc_csum.h            |   34 +
 include/uapi/linux/tc_act/tc_defact.h          |   20 +
 include/uapi/linux/tc_act/tc_gact.h            |   33 +
 include/uapi/linux/tc_act/tc_ife.h             |   32 +
 include/uapi/linux/tc_act/tc_ipt.h             |   22 +
 include/uapi/linux/tc_act/tc_mirred.h          |   28 +
 include/uapi/linux/tc_act/tc_nat.h             |   28 +
 include/uapi/linux/tc_act/tc_pedit.h           |   66 ++
 include/uapi/linux/tc_act/tc_sample.h          |   26 +
 include/uapi/linux/tc_act/tc_skbedit.h         |   51 ++
 include/uapi/linux/tc_act/tc_skbmod.h          |   39 +
 include/uapi/linux/tc_act/tc_tunnel_key.h      |   43 +
 include/uapi/linux/tc_act/tc_vlan.h            |   38 +
 include/uapi/linux/tc_ematch/tc_em_cmp.h       |   25 +
 include/uapi/linux/tc_ematch/tc_em_meta.h      |   92 ++
 include/uapi/linux/tc_ematch/tc_em_nbyte.h     |   13 +
 include/uapi/linux/tcp.h                       |  268 ++++++
 include/uapi/linux/tcp_metrics.h               |   60 ++
 include/uapi/linux/tipc.h                      |  256 ++++++
 include/uapi/linux/tipc_netlink.h              |  294 +++++++
 include/uapi/linux/types.h                     |   47 +
 include/uapi/linux/unix_diag.h                 |   58 ++
 include/uapi/linux/veth.h                      |   12 +
 include/uapi/linux/xfrm.h                      |  536 ++++++++++++
 221 files changed, 16057 insertions(+), 16057 deletions(-)
 delete mode 100644 include/linux/atm.h
 delete mode 100644 include/linux/atmapi.h
 delete mode 100644 include/linux/atmarp.h
 delete mode 100644 include/linux/atmdev.h
 delete mode 100644 include/linux/atmioc.h
 delete mode 100644 include/linux/atmsap.h
 delete mode 100644 include/linux/bpf.h
 delete mode 100644 include/linux/bpf_common.h
 delete mode 100644 include/linux/can.h
 delete mode 100644 include/linux/can/netlink.h
 delete mode 100644 include/linux/can/vxcan.h
 delete mode 100644 include/linux/devlink.h
 delete mode 100644 include/linux/elf-em.h
 delete mode 100644 include/linux/fib_rules.h
 delete mode 100644 include/linux/filter.h
 delete mode 100644 include/linux/fou.h
 delete mode 100644 include/linux/gen_stats.h
 delete mode 100644 include/linux/genetlink.h
 delete mode 100644 include/linux/hdlc/ioctl.h
 delete mode 100644 include/linux/icmpv6.h
 delete mode 100644 include/linux/if.h
 delete mode 100644 include/linux/if_addr.h
 delete mode 100644 include/linux/if_addrlabel.h
 delete mode 100644 include/linux/if_alg.h
 delete mode 100644 include/linux/if_arp.h
 delete mode 100644 include/linux/if_bonding.h
 delete mode 100644 include/linux/if_bridge.h
 delete mode 100644 include/linux/if_ether.h
 delete mode 100644 include/linux/if_link.h
 delete mode 100644 include/linux/if_macsec.h
 delete mode 100644 include/linux/if_packet.h
 delete mode 100644 include/linux/if_tun.h
 delete mode 100644 include/linux/if_tunnel.h
 delete mode 100644 include/linux/if_vlan.h
 delete mode 100644 include/linux/ife.h
 delete mode 100644 include/linux/ila.h
 delete mode 100644 include/linux/in.h
 delete mode 100644 include/linux/in6.h
 delete mode 100644 include/linux/in_route.h
 delete mode 100644 include/linux/inet_diag.h
 delete mode 100644 include/linux/ip.h
 delete mode 100644 include/linux/ip6_tunnel.h
 delete mode 100644 include/linux/ipsec.h
 delete mode 100644 include/linux/kernel.h
 delete mode 100644 include/linux/l2tp.h
 delete mode 100644 include/linux/libc-compat.h
 delete mode 100644 include/linux/limits.h
 delete mode 100644 include/linux/lwtunnel.h
 delete mode 100644 include/linux/magic.h
 delete mode 100644 include/linux/mpls.h
 delete mode 100644 include/linux/mpls_iptunnel.h
 delete mode 100644 include/linux/neighbour.h
 delete mode 100644 include/linux/net_namespace.h
 delete mode 100644 include/linux/netconf.h
 delete mode 100644 include/linux/netdevice.h
 delete mode 100644 include/linux/netfilter.h
 delete mode 100644 include/linux/netfilter/ipset/ip_set.h
 delete mode 100644 include/linux/netfilter/x_tables.h
 delete mode 100644 include/linux/netfilter/xt_set.h
 delete mode 100644 include/linux/netfilter/xt_tcpudp.h
 delete mode 100644 include/linux/netfilter_ipv4.h
 delete mode 100644 include/linux/netfilter_ipv4/ip_tables.h
 delete mode 100644 include/linux/netfilter_ipv6.h
 delete mode 100644 include/linux/netfilter_ipv6/ip6_tables.h
 delete mode 100644 include/linux/netlink.h
 delete mode 100644 include/linux/netlink_diag.h
 delete mode 100644 include/linux/packet_diag.h
 delete mode 100644 include/linux/param.h
 delete mode 100644 include/linux/pfkeyv2.h
 delete mode 100644 include/linux/pkt_cls.h
 delete mode 100644 include/linux/pkt_sched.h
 delete mode 100644 include/linux/posix_types.h
 delete mode 100644 include/linux/rtnetlink.h
 delete mode 100644 include/linux/sctp.h
 delete mode 100644 include/linux/seg6.h
 delete mode 100644 include/linux/seg6_genl.h
 delete mode 100644 include/linux/seg6_hmac.h
 delete mode 100644 include/linux/seg6_iptunnel.h
 delete mode 100644 include/linux/seg6_local.h
 delete mode 100644 include/linux/sock_diag.h
 delete mode 100644 include/linux/socket.h
 delete mode 100644 include/linux/sockios.h
 delete mode 100644 include/linux/stddef.h
 delete mode 100644 include/linux/sysinfo.h
 delete mode 100644 include/linux/tc_act/tc_bpf.h
 delete mode 100644 include/linux/tc_act/tc_connmark.h
 delete mode 100644 include/linux/tc_act/tc_csum.h
 delete mode 100644 include/linux/tc_act/tc_defact.h
 delete mode 100644 include/linux/tc_act/tc_gact.h
 delete mode 100644 include/linux/tc_act/tc_ife.h
 delete mode 100644 include/linux/tc_act/tc_ipt.h
 delete mode 100644 include/linux/tc_act/tc_mirred.h
 delete mode 100644 include/linux/tc_act/tc_nat.h
 delete mode 100644 include/linux/tc_act/tc_pedit.h
 delete mode 100644 include/linux/tc_act/tc_sample.h
 delete mode 100644 include/linux/tc_act/tc_skbedit.h
 delete mode 100644 include/linux/tc_act/tc_skbmod.h
 delete mode 100644 include/linux/tc_act/tc_tunnel_key.h
 delete mode 100644 include/linux/tc_act/tc_vlan.h
 delete mode 100644 include/linux/tc_ematch/tc_em_cmp.h
 delete mode 100644 include/linux/tc_ematch/tc_em_meta.h
 delete mode 100644 include/linux/tc_ematch/tc_em_nbyte.h
 delete mode 100644 include/linux/tcp.h
 delete mode 100644 include/linux/tcp_metrics.h
 delete mode 100644 include/linux/tipc.h
 delete mode 100644 include/linux/tipc_netlink.h
 delete mode 100644 include/linux/types.h
 delete mode 100644 include/linux/unix_diag.h
 delete mode 100644 include/linux/veth.h
 delete mode 100644 include/linux/xfrm.h
 create mode 100644 include/uapi/linux/atm.h
 create mode 100644 include/uapi/linux/atmapi.h
 create mode 100644 include/uapi/linux/atmarp.h
 create mode 100644 include/uapi/linux/atmdev.h
 create mode 100644 include/uapi/linux/atmioc.h
 create mode 100644 include/uapi/linux/atmsap.h
 create mode 100644 include/uapi/linux/bpf.h
 create mode 100644 include/uapi/linux/bpf_common.h
 create mode 100644 include/uapi/linux/can.h
 create mode 100644 include/uapi/linux/can/netlink.h
 create mode 100644 include/uapi/linux/can/vxcan.h
 create mode 100644 include/uapi/linux/devlink.h
 create mode 100644 include/uapi/linux/elf-em.h
 create mode 100644 include/uapi/linux/fib_rules.h
 create mode 100644 include/uapi/linux/filter.h
 create mode 100644 include/uapi/linux/fou.h
 create mode 100644 include/uapi/linux/gen_stats.h
 create mode 100644 include/uapi/linux/genetlink.h
 create mode 100644 include/uapi/linux/hdlc/ioctl.h
 create mode 100644 include/uapi/linux/icmpv6.h
 create mode 100644 include/uapi/linux/if.h
 create mode 100644 include/uapi/linux/if_addr.h
 create mode 100644 include/uapi/linux/if_addrlabel.h
 create mode 100644 include/uapi/linux/if_alg.h
 create mode 100644 include/uapi/linux/if_arp.h
 create mode 100644 include/uapi/linux/if_bonding.h
 create mode 100644 include/uapi/linux/if_bridge.h
 create mode 100644 include/uapi/linux/if_ether.h
 create mode 100644 include/uapi/linux/if_link.h
 create mode 100644 include/uapi/linux/if_macsec.h
 create mode 100644 include/uapi/linux/if_packet.h
 create mode 100644 include/uapi/linux/if_tun.h
 create mode 100644 include/uapi/linux/if_tunnel.h
 create mode 100644 include/uapi/linux/if_vlan.h
 create mode 100644 include/uapi/linux/ife.h
 create mode 100644 include/uapi/linux/ila.h
 create mode 100644 include/uapi/linux/in.h
 create mode 100644 include/uapi/linux/in6.h
 create mode 100644 include/uapi/linux/in_route.h
 create mode 100644 include/uapi/linux/inet_diag.h
 create mode 100644 include/uapi/linux/ip.h
 create mode 100644 include/uapi/linux/ip6_tunnel.h
 create mode 100644 include/uapi/linux/ipsec.h
 create mode 100644 include/uapi/linux/kernel.h
 create mode 100644 include/uapi/linux/l2tp.h
 create mode 100644 include/uapi/linux/libc-compat.h
 create mode 100644 include/uapi/linux/limits.h
 create mode 100644 include/uapi/linux/lwtunnel.h
 create mode 100644 include/uapi/linux/magic.h
 create mode 100644 include/uapi/linux/mpls.h
 create mode 100644 include/uapi/linux/mpls_iptunnel.h
 create mode 100644 include/uapi/linux/neighbour.h
 create mode 100644 include/uapi/linux/net_namespace.h
 create mode 100644 include/uapi/linux/netconf.h
 create mode 100644 include/uapi/linux/netdevice.h
 create mode 100644 include/uapi/linux/netfilter.h
 create mode 100644 include/uapi/linux/netfilter/ipset/ip_set.h
 create mode 100644 include/uapi/linux/netfilter/x_tables.h
 create mode 100644 include/uapi/linux/netfilter/xt_set.h
 create mode 100644 include/uapi/linux/netfilter/xt_tcpudp.h
 create mode 100644 include/uapi/linux/netfilter_ipv4.h
 create mode 100644 include/uapi/linux/netfilter_ipv4/ip_tables.h
 create mode 100644 include/uapi/linux/netfilter_ipv6.h
 create mode 100644 include/uapi/linux/netfilter_ipv6/ip6_tables.h
 create mode 100644 include/uapi/linux/netlink.h
 create mode 100644 include/uapi/linux/netlink_diag.h
 create mode 100644 include/uapi/linux/packet_diag.h
 create mode 100644 include/uapi/linux/param.h
 create mode 100644 include/uapi/linux/pfkeyv2.h
 create mode 100644 include/uapi/linux/pkt_cls.h
 create mode 100644 include/uapi/linux/pkt_sched.h
 create mode 100644 include/uapi/linux/posix_types.h
 create mode 100644 include/uapi/linux/rtnetlink.h
 create mode 100644 include/uapi/linux/sctp.h
 create mode 100644 include/uapi/linux/seg6.h
 create mode 100644 include/uapi/linux/seg6_genl.h
 create mode 100644 include/uapi/linux/seg6_hmac.h
 create mode 100644 include/uapi/linux/seg6_iptunnel.h
 create mode 100644 include/uapi/linux/seg6_local.h
 create mode 100644 include/uapi/linux/sock_diag.h
 create mode 100644 include/uapi/linux/socket.h
 create mode 100644 include/uapi/linux/sockios.h
 create mode 100644 include/uapi/linux/stddef.h
 create mode 100644 include/uapi/linux/sysinfo.h
 create mode 100644 include/uapi/linux/tc_act/tc_bpf.h
 create mode 100644 include/uapi/linux/tc_act/tc_connmark.h
 create mode 100644 include/uapi/linux/tc_act/tc_csum.h
 create mode 100644 include/uapi/linux/tc_act/tc_defact.h
 create mode 100644 include/uapi/linux/tc_act/tc_gact.h
 create mode 100644 include/uapi/linux/tc_act/tc_ife.h
 create mode 100644 include/uapi/linux/tc_act/tc_ipt.h
 create mode 100644 include/uapi/linux/tc_act/tc_mirred.h
 create mode 100644 include/uapi/linux/tc_act/tc_nat.h
 create mode 100644 include/uapi/linux/tc_act/tc_pedit.h
 create mode 100644 include/uapi/linux/tc_act/tc_sample.h
 create mode 100644 include/uapi/linux/tc_act/tc_skbedit.h
 create mode 100644 include/uapi/linux/tc_act/tc_skbmod.h
 create mode 100644 include/uapi/linux/tc_act/tc_tunnel_key.h
 create mode 100644 include/uapi/linux/tc_act/tc_vlan.h
 create mode 100644 include/uapi/linux/tc_ematch/tc_em_cmp.h
 create mode 100644 include/uapi/linux/tc_ematch/tc_em_meta.h
 create mode 100644 include/uapi/linux/tc_ematch/tc_em_nbyte.h
 create mode 100644 include/uapi/linux/tcp.h
 create mode 100644 include/uapi/linux/tcp_metrics.h
 create mode 100644 include/uapi/linux/tipc.h
 create mode 100644 include/uapi/linux/tipc_netlink.h
 create mode 100644 include/uapi/linux/types.h
 create mode 100644 include/uapi/linux/unix_diag.h
 create mode 100644 include/uapi/linux/veth.h
 create mode 100644 include/uapi/linux/xfrm.h

diff --git a/Makefile b/Makefile
index 18de7dc..df2fa33 100644
--- a/Makefile
+++ b/Makefile
@@ -49,7 +49,7 @@ CCOPTS = -O2
 WFLAGS := -Wall -Wstrict-prototypes  -Wmissing-prototypes
 WFLAGS += -Wmissing-declarations -Wold-style-definition -Wformat=2
 
-CFLAGS := $(WFLAGS) $(CCOPTS) -I../include $(DEFINES) $(CFLAGS)
+CFLAGS := $(WFLAGS) $(CCOPTS) -I../include -I../include/uapi $(DEFINES) $(CFLAGS)
 YACCFLAGS = -d -t -v
 
 SUBDIRS=lib ip tc bridge misc netem genl tipc devlink man
diff --git a/include/linux/atm.h b/include/linux/atm.h
deleted file mode 100644
index 08e27be..0000000
--- a/include/linux/atm.h
+++ /dev/null
@@ -1,241 +0,0 @@
-/* atm.h - general ATM declarations */
- 
-/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
- 
-
-/*
- * WARNING: User-space programs should not #include <linux/atm.h> directly.
- *          Instead, #include <atm.h>
- */
-
-#ifndef _LINUX_ATM_H
-#define _LINUX_ATM_H
-
-/*
- * BEGIN_xx and END_xx markers are used for automatic generation of
- * documentation. Do not change them.
- */
-
-
-#include <linux/atmapi.h>
-#include <linux/atmsap.h>
-#include <linux/atmioc.h>
-#include <linux/types.h>
-
-
-/* general ATM constants */
-#define ATM_CELL_SIZE		    53	/* ATM cell size incl. header */
-#define ATM_CELL_PAYLOAD	    48	/* ATM payload size */
-#define ATM_AAL0_SDU		    52	/* AAL0 SDU size */
-#define ATM_MAX_AAL34_PDU	 65535	/* maximum AAL3/4 PDU payload */
-#define ATM_AAL5_TRAILER	     8	/* AAL5 trailer size */
-#define ATM_MAX_AAL5_PDU	 65535	/* maximum AAL5 PDU payload */
-#define ATM_MAX_CDV		  9999	/* maximum (default) CDV */
-#define ATM_NOT_RSV_VCI		    32	/* first non-reserved VCI value */
-
-#define ATM_MAX_VPI		   255	/* maximum VPI at the UNI */
-#define ATM_MAX_VPI_NNI		  4096	/* maximum VPI at the NNI */
-#define ATM_MAX_VCI		 65535	/* maximum VCI */
-
-
-/* "protcol" values for the socket system call */
-#define ATM_NO_AAL	0		/* AAL not specified */
-#define ATM_AAL0	13		/* "raw" ATM cells */
-#define ATM_AAL1	1		/* AAL1 (CBR) */
-#define ATM_AAL2	2		/* AAL2 (VBR) */
-#define ATM_AAL34	3		/* AAL3/4 (data) */
-#define ATM_AAL5	5		/* AAL5 (data) */
-
-/*
- * socket option name coding functions
- *
- * Note that __SO_ENCODE and __SO_LEVEL are somewhat a hack since the
- * << 22 only reserves 9 bits for the level.  On some architectures
- * SOL_SOCKET is 0xFFFF, so that's a bit of a problem
- */
-
-#define __SO_ENCODE(l,n,t)	((((l) & 0x1FF) << 22) | ((n) << 16) | \
-				sizeof(t))
-#define __SO_LEVEL_MATCH(c,m)	(((c) >> 22) == ((m) & 0x1FF))
-#define __SO_NUMBER(c)		(((c) >> 16) & 0x3f)
-#define __SO_SIZE(c)		((c) & 0x3fff)
-
-/*
- * ATM layer
- */
-
-#define SO_SETCLP	__SO_ENCODE(SOL_ATM,0,int)
-			    /* set CLP bit value - TODO */
-#define SO_CIRANGE	__SO_ENCODE(SOL_ATM,1,struct atm_cirange)
-			    /* connection identifier range; socket must be
-			       bound or connected */
-#define SO_ATMQOS	__SO_ENCODE(SOL_ATM,2,struct atm_qos)
-			    /* Quality of Service setting */
-#define SO_ATMSAP	__SO_ENCODE(SOL_ATM,3,struct atm_sap)
-			    /* Service Access Point */
-#define SO_ATMPVC	__SO_ENCODE(SOL_ATM,4,struct sockaddr_atmpvc)
-			    /* "PVC" address (also for SVCs); get only */
-#define SO_MULTIPOINT	__SO_ENCODE(SOL_ATM, 5, int)
-			    /* make this vc a p2mp */
-
-
-/*
- * Note @@@: since the socket layers don't really distinguish the control and
- * the data plane but generally seems to be data plane-centric, any layer is
- * about equally wrong for the SAP. If you have a better idea about this,
- * please speak up ...
- */
-
-
-/* ATM cell header (for AAL0) */
-
-/* BEGIN_CH */
-#define ATM_HDR_GFC_MASK	0xf0000000
-#define ATM_HDR_GFC_SHIFT	28
-#define ATM_HDR_VPI_MASK	0x0ff00000
-#define ATM_HDR_VPI_SHIFT	20
-#define ATM_HDR_VCI_MASK	0x000ffff0
-#define ATM_HDR_VCI_SHIFT	4
-#define ATM_HDR_PTI_MASK	0x0000000e
-#define ATM_HDR_PTI_SHIFT	1
-#define ATM_HDR_CLP		0x00000001
-/* END_CH */
-
-
-/* PTI codings */
-
-/* BEGIN_PTI */
-#define ATM_PTI_US0	0  /* user data cell, congestion not exp, SDU-type 0 */
-#define ATM_PTI_US1	1  /* user data cell, congestion not exp, SDU-type 1 */
-#define ATM_PTI_UCES0	2  /* user data cell, cong. experienced, SDU-type 0 */
-#define ATM_PTI_UCES1	3  /* user data cell, cong. experienced, SDU-type 1 */
-#define ATM_PTI_SEGF5	4  /* segment OAM F5 flow related cell */
-#define ATM_PTI_E2EF5	5  /* end-to-end OAM F5 flow related cell */
-#define ATM_PTI_RSV_RM	6  /* reserved for traffic control/resource mgmt */
-#define ATM_PTI_RSV	7  /* reserved */
-/* END_PTI */
-
-
-/*
- * The following items should stay in linux/atm.h, which should be linked to
- * netatm/atm.h
- */
-
-/* Traffic description */
-
-#define ATM_NONE	0		/* no traffic */
-#define ATM_UBR		1
-#define ATM_CBR		2
-#define ATM_VBR		3
-#define ATM_ABR		4
-#define ATM_ANYCLASS	5		/* compatible with everything */
-
-#define ATM_MAX_PCR	-1		/* maximum available PCR */
-
-struct atm_trafprm {
-	unsigned char	traffic_class;	/* traffic class (ATM_UBR, ...) */
-	int		max_pcr;	/* maximum PCR in cells per second */
-	int		pcr;		/* desired PCR in cells per second */
-	int		min_pcr;	/* minimum PCR in cells per second */
-	int		max_cdv;	/* maximum CDV in microseconds */
-	int		max_sdu;	/* maximum SDU in bytes */
-        /* extra params for ABR */
-        unsigned int 	icr;         	/* Initial Cell Rate (24-bit) */
-        unsigned int	tbe;		/* Transient Buffer Exposure (24-bit) */ 
-        unsigned int 	frtt : 24;	/* Fixed Round Trip Time (24-bit) */
-        unsigned int 	rif  : 4;       /* Rate Increment Factor (4-bit) */
-        unsigned int 	rdf  : 4;       /* Rate Decrease Factor (4-bit) */
-        unsigned int nrm_pres  :1;      /* nrm present bit */
-        unsigned int trm_pres  :1;     	/* rm present bit */
-        unsigned int adtf_pres :1;     	/* adtf present bit */
-        unsigned int cdf_pres  :1;    	/* cdf present bit*/
-        unsigned int nrm       :3;     	/* Max # of Cells for each forward RM cell (3-bit) */
-        unsigned int trm       :3;    	/* Time between forward RM cells (3-bit) */    
-	unsigned int adtf      :10;     /* ACR Decrease Time Factor (10-bit) */
-	unsigned int cdf       :3;      /* Cutoff Decrease Factor (3-bit) */
-        unsigned int spare     :9;      /* spare bits */ 
-};
-
-struct atm_qos {
-	struct atm_trafprm txtp;	/* parameters in TX direction */
-	struct atm_trafprm rxtp __ATM_API_ALIGN;
-					/* parameters in RX direction */
-	unsigned char aal __ATM_API_ALIGN;
-};
-
-/* PVC addressing */
-
-#define ATM_ITF_ANY	-1		/* "magic" PVC address values */
-#define ATM_VPI_ANY	-1
-#define ATM_VCI_ANY	-1
-#define ATM_VPI_UNSPEC	-2
-#define ATM_VCI_UNSPEC	-2
-
-
-struct sockaddr_atmpvc {
-	unsigned short 	sap_family;	/* address family, AF_ATMPVC  */
-	struct {			/* PVC address */
-		short	itf;		/* ATM interface */
-		short	vpi;		/* VPI (only 8 bits at UNI) */
-		int	vci;		/* VCI (only 16 bits at UNI) */
-	} sap_addr __ATM_API_ALIGN;	/* PVC address */
-};
-
-/* SVC addressing */
-
-#define	ATM_ESA_LEN	20		/* ATM End System Address length */
-#define ATM_E164_LEN	12		/* maximum E.164 number length */
-
-#define ATM_AFI_DCC	0x39		/* DCC ATM Format */
-#define ATM_AFI_ICD	0x47		/* ICD ATM Format */
-#define ATM_AFI_E164	0x45		/* E.164 ATM Format */
-#define ATM_AFI_LOCAL	0x49		/* Local ATM Format */ 
-
-#define ATM_AFI_DCC_GROUP	0xBD	/* DCC ATM Group Format */
-#define ATM_AFI_ICD_GROUP	0xC5	/* ICD ATM Group Format */
-#define ATM_AFI_E164_GROUP	0xC3	/* E.164 ATM Group Format */
-#define ATM_AFI_LOCAL_GROUP	0xC7	/* Local ATM Group Format */
-
-#define ATM_LIJ_NONE	0		/* no leaf-initiated join */
-#define ATM_LIJ		1		/* request joining */
-#define ATM_LIJ_RPJ	2		/* set to root-prompted join */
-#define ATM_LIJ_NJ	3		/* set to network join */
-
-
-struct sockaddr_atmsvc {
-    unsigned short 	sas_family;	/* address family, AF_ATMSVC */
-    struct {				/* SVC address */
-        unsigned char	prv[ATM_ESA_LEN];/* private ATM address */
-        char		pub[ATM_E164_LEN+1]; /* public address (E.164) */
-    					/* unused addresses must be bzero'ed */
-	char		lij_type;	/* role in LIJ call; one of ATM_LIJ* */
-	__u32	lij_id;		/* LIJ call identifier */
-    } sas_addr __ATM_API_ALIGN;		/* SVC address */
-};
-
-
-static __inline__ int atmsvc_addr_in_use(struct sockaddr_atmsvc addr)
-{
-	return *addr.sas_addr.prv || *addr.sas_addr.pub;
-}
-
-
-static __inline__ int atmpvc_addr_in_use(struct sockaddr_atmpvc addr)
-{
-	return addr.sap_addr.itf || addr.sap_addr.vpi || addr.sap_addr.vci;
-}
-
-
-/*
- * Some stuff for linux/sockios.h
- */
-
-struct atmif_sioc {
-	int number;
-	int length;
-	void *arg;
-};
-
-
-typedef unsigned short atm_backend_t;
-#endif /* _LINUX_ATM_H */
diff --git a/include/linux/atmapi.h b/include/linux/atmapi.h
deleted file mode 100644
index 8fe54d9..0000000
--- a/include/linux/atmapi.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/* atmapi.h - ATM API user space/kernel compatibility */
- 
-/* Written 1999,2000 by Werner Almesberger, EPFL ICA */
- 
-
-#ifndef _LINUX_ATMAPI_H
-#define _LINUX_ATMAPI_H
-
-#if defined(__sparc__) || defined(__ia64__)
-/* such alignment is not required on 32 bit sparcs, but we can't
-   figure that we are on a sparc64 while compiling user-space programs. */
-#define __ATM_API_ALIGN	__attribute__((aligned(8)))
-#else
-#define __ATM_API_ALIGN
-#endif
-
-
-/*
- * Opaque type for kernel pointers. Note that _ is never accessed. We need
- * the struct in order hide the array, so that we can make simple assignments
- * instead of being forced to use memcpy. It also improves error reporting for
- * code that still assumes that we're passing unsigned longs.
- *
- * Convention: NULL pointers are passed as a field of all zeroes.
- */
- 
-typedef struct { unsigned char _[8]; } __ATM_API_ALIGN atm_kptr_t;
-
-#endif
diff --git a/include/linux/atmarp.h b/include/linux/atmarp.h
deleted file mode 100644
index 231f4bd..0000000
--- a/include/linux/atmarp.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/* atmarp.h - ATM ARP protocol and kernel-demon interface definitions */
- 
-/* Written 1995-1999 by Werner Almesberger, EPFL LRC/ICA */
- 
-
-#ifndef _LINUX_ATMARP_H
-#define _LINUX_ATMARP_H
-
-#include <linux/types.h>
-#include <linux/atmapi.h>
-#include <linux/atmioc.h>
-
-
-#define ATMARP_RETRY_DELAY 30		/* request next resolution or forget
-					   NAK after 30 sec - should go into
-					   atmclip.h */
-#define ATMARP_MAX_UNRES_PACKETS 5	/* queue that many packets while
-					   waiting for the resolver */
-
-
-#define ATMARPD_CTRL	_IO('a',ATMIOC_CLIP+1)	/* become atmarpd ctrl sock */
-#define ATMARP_MKIP	_IO('a',ATMIOC_CLIP+2)	/* attach socket to IP */
-#define ATMARP_SETENTRY	_IO('a',ATMIOC_CLIP+3)	/* fill or hide ARP entry */
-#define ATMARP_ENCAP	_IO('a',ATMIOC_CLIP+5)	/* change encapsulation */
-
-
-enum atmarp_ctrl_type {
-	act_invalid,		/* catch uninitialized structures */
-	act_need,		/* need address resolution */
-	act_up,			/* interface is coming up */
-	act_down,		/* interface is going down */
-	act_change		/* interface configuration has changed */
-};
-
-struct atmarp_ctrl {
-	enum atmarp_ctrl_type	type;	/* message type */
-	int			itf_num;/* interface number (if present) */
-	__be32			ip;	/* IP address (act_need only) */
-};
-
-#endif
diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
deleted file mode 100644
index 8faa8b9..0000000
--- a/include/linux/atmdev.h
+++ /dev/null
@@ -1,215 +0,0 @@
-/* atmdev.h - ATM device driver declarations and various related items */
- 
-/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
- 
-
-#ifndef LINUX_ATMDEV_H
-#define LINUX_ATMDEV_H
-
-
-#include <linux/atmapi.h>
-#include <linux/atm.h>
-#include <linux/atmioc.h>
-
-
-#define ESI_LEN		6
-
-#define ATM_OC3_PCR	(155520000/270*260/8/53)
-			/* OC3 link rate:  155520000 bps
-			   SONET overhead: /270*260 (9 section, 1 path)
-			   bits per cell:  /8/53
-			   max cell rate:  353207.547 cells/sec */
-#define ATM_25_PCR	((25600000/8-8000)/54)
-			/* 25 Mbps ATM cell rate (59111) */
-#define ATM_OC12_PCR	(622080000/1080*1040/8/53)
-			/* OC12 link rate: 622080000 bps
-			   SONET overhead: /1080*1040
-			   bits per cell:  /8/53
-			   max cell rate:  1412830.188 cells/sec */
-#define ATM_DS3_PCR	(8000*12)
-			/* DS3: 12 cells in a 125 usec time slot */
-
-
-#define __AAL_STAT_ITEMS \
-    __HANDLE_ITEM(tx);			/* TX okay */ \
-    __HANDLE_ITEM(tx_err);		/* TX errors */ \
-    __HANDLE_ITEM(rx);			/* RX okay */ \
-    __HANDLE_ITEM(rx_err);		/* RX errors */ \
-    __HANDLE_ITEM(rx_drop);		/* RX out of memory */
-
-struct atm_aal_stats {
-#define __HANDLE_ITEM(i) int i
-	__AAL_STAT_ITEMS
-#undef __HANDLE_ITEM
-};
-
-
-struct atm_dev_stats {
-	struct atm_aal_stats aal0;
-	struct atm_aal_stats aal34;
-	struct atm_aal_stats aal5;
-} __ATM_API_ALIGN;
-
-
-#define ATM_GETLINKRATE	_IOW('a',ATMIOC_ITF+1,struct atmif_sioc)
-					/* get link rate */
-#define ATM_GETNAMES	_IOW('a',ATMIOC_ITF+3,struct atm_iobuf)
-					/* get interface names (numbers) */
-#define ATM_GETTYPE	_IOW('a',ATMIOC_ITF+4,struct atmif_sioc)
-					/* get interface type name */
-#define ATM_GETESI	_IOW('a',ATMIOC_ITF+5,struct atmif_sioc)
-					/* get interface ESI */
-#define ATM_GETADDR	_IOW('a',ATMIOC_ITF+6,struct atmif_sioc)
-					/* get itf's local ATM addr. list */
-#define ATM_RSTADDR	_IOW('a',ATMIOC_ITF+7,struct atmif_sioc)
-					/* reset itf's ATM address list */
-#define ATM_ADDADDR	_IOW('a',ATMIOC_ITF+8,struct atmif_sioc)
-					/* add a local ATM address */
-#define ATM_DELADDR	_IOW('a',ATMIOC_ITF+9,struct atmif_sioc)
-					/* remove a local ATM address */
-#define ATM_GETCIRANGE	_IOW('a',ATMIOC_ITF+10,struct atmif_sioc)
-					/* get connection identifier range */
-#define ATM_SETCIRANGE	_IOW('a',ATMIOC_ITF+11,struct atmif_sioc)
-					/* set connection identifier range */
-#define ATM_SETESI	_IOW('a',ATMIOC_ITF+12,struct atmif_sioc)
-					/* set interface ESI */
-#define ATM_SETESIF	_IOW('a',ATMIOC_ITF+13,struct atmif_sioc)
-					/* force interface ESI */
-#define ATM_ADDLECSADDR	_IOW('a', ATMIOC_ITF+14, struct atmif_sioc)
-					/* register a LECS address */
-#define ATM_DELLECSADDR	_IOW('a', ATMIOC_ITF+15, struct atmif_sioc)
-					/* unregister a LECS address */
-#define ATM_GETLECSADDR	_IOW('a', ATMIOC_ITF+16, struct atmif_sioc)
-					/* retrieve LECS address(es) */
-
-#define ATM_GETSTAT	_IOW('a',ATMIOC_SARCOM+0,struct atmif_sioc)
-					/* get AAL layer statistics */
-#define ATM_GETSTATZ	_IOW('a',ATMIOC_SARCOM+1,struct atmif_sioc)
-					/* get AAL layer statistics and zero */
-#define ATM_GETLOOP	_IOW('a',ATMIOC_SARCOM+2,struct atmif_sioc)
-					/* get loopback mode */
-#define ATM_SETLOOP	_IOW('a',ATMIOC_SARCOM+3,struct atmif_sioc)
-					/* set loopback mode */
-#define ATM_QUERYLOOP	_IOW('a',ATMIOC_SARCOM+4,struct atmif_sioc)
-					/* query supported loopback modes */
-#define ATM_SETSC	_IOW('a',ATMIOC_SPECIAL+1,int)
-					/* enable or disable single-copy */
-#define ATM_SETBACKEND	_IOW('a',ATMIOC_SPECIAL+2,atm_backend_t)
-					/* set backend handler */
-#define ATM_NEWBACKENDIF _IOW('a',ATMIOC_SPECIAL+3,atm_backend_t)
-					/* use backend to make new if */
-#define ATM_ADDPARTY  	_IOW('a', ATMIOC_SPECIAL+4,struct atm_iobuf)
- 					/* add party to p2mp call */
-#ifdef CONFIG_COMPAT
-/* It actually takes struct sockaddr_atmsvc, not struct atm_iobuf */
-#define COMPAT_ATM_ADDPARTY  	_IOW('a', ATMIOC_SPECIAL+4,struct compat_atm_iobuf)
-#endif
-#define ATM_DROPPARTY 	_IOW('a', ATMIOC_SPECIAL+5,int)
-					/* drop party from p2mp call */
-
-/*
- * These are backend handkers that can be set via the ATM_SETBACKEND call
- * above.  In the future we may support dynamic loading of these - for now,
- * they're just being used to share the ATMIOC_BACKEND ioctls
- */
-#define ATM_BACKEND_RAW		0	
-#define ATM_BACKEND_PPP		1	/* PPPoATM - RFC2364 */
-#define ATM_BACKEND_BR2684	2	/* Bridged RFC1483/2684 */
-
-/* for ATM_GETTYPE */
-#define ATM_ITFTYP_LEN	8	/* maximum length of interface type name */
-
-/*
- * Loopback modes for ATM_{PHY,SAR}_{GET,SET}LOOP
- */
-
-/* Point of loopback				CPU-->SAR-->PHY-->line--> ... */
-#define __ATM_LM_NONE	0	/* no loop back     ^     ^     ^      ^      */
-#define __ATM_LM_AAL	1	/* loop back PDUs --'     |     |      |      */
-#define __ATM_LM_ATM	2	/* loop back ATM cells ---'     |      |      */
-/* RESERVED		4	loop back on PHY side  ---'		      */
-#define __ATM_LM_PHY	8	/* loop back bits (digital) ----'      |      */
-#define __ATM_LM_ANALOG 16	/* loop back the analog signal --------'      */
-
-/* Direction of loopback */
-#define __ATM_LM_MKLOC(n)	((n))	    /* Local (i.e. loop TX to RX) */
-#define __ATM_LM_MKRMT(n)	((n) << 8)  /* Remote (i.e. loop RX to TX) */
-
-#define __ATM_LM_XTLOC(n)	((n) & 0xff)
-#define __ATM_LM_XTRMT(n)	(((n) >> 8) & 0xff)
-
-#define ATM_LM_NONE	0	/* no loopback */
-
-#define ATM_LM_LOC_AAL	__ATM_LM_MKLOC(__ATM_LM_AAL)
-#define ATM_LM_LOC_ATM	__ATM_LM_MKLOC(__ATM_LM_ATM)
-#define ATM_LM_LOC_PHY	__ATM_LM_MKLOC(__ATM_LM_PHY)
-#define ATM_LM_LOC_ANALOG __ATM_LM_MKLOC(__ATM_LM_ANALOG)
-
-#define ATM_LM_RMT_AAL	__ATM_LM_MKRMT(__ATM_LM_AAL)
-#define ATM_LM_RMT_ATM	__ATM_LM_MKRMT(__ATM_LM_ATM)
-#define ATM_LM_RMT_PHY	__ATM_LM_MKRMT(__ATM_LM_PHY)
-#define ATM_LM_RMT_ANALOG __ATM_LM_MKRMT(__ATM_LM_ANALOG)
-
-/*
- * Note: ATM_LM_LOC_* and ATM_LM_RMT_* can be combined, provided that
- * __ATM_LM_XTLOC(x) <= __ATM_LM_XTRMT(x)
- */
-
-
-struct atm_iobuf {
-	int length;
-	void *buffer;
-};
-
-/* for ATM_GETCIRANGE / ATM_SETCIRANGE */
-
-#define ATM_CI_MAX      -1              /* use maximum range of VPI/VCI */
- 
-struct atm_cirange {
-	signed char	vpi_bits;	/* 1..8, ATM_CI_MAX (-1) for maximum */
-	signed char	vci_bits;	/* 1..16, ATM_CI_MAX (-1) for maximum */
-};
-
-/* for ATM_SETSC; actually taken from the ATM_VF number space */
-
-#define ATM_SC_RX	1024		/* enable RX single-copy */
-#define ATM_SC_TX	2048		/* enable TX single-copy */
-
-#define ATM_BACKLOG_DEFAULT 32 /* if we get more, we're likely to time out
-				  anyway */
-
-/* MF: change_qos (Modify) flags */
-
-#define ATM_MF_IMMED	 1	/* Block until change is effective */
-#define ATM_MF_INC_RSV	 2	/* Change reservation on increase */
-#define ATM_MF_INC_SHP	 4	/* Change shaping on increase */
-#define ATM_MF_DEC_RSV	 8	/* Change reservation on decrease */
-#define ATM_MF_DEC_SHP	16	/* Change shaping on decrease */
-#define ATM_MF_BWD	32	/* Set the backward direction parameters */
-
-#define ATM_MF_SET	(ATM_MF_INC_RSV | ATM_MF_INC_SHP | ATM_MF_DEC_RSV | \
-			  ATM_MF_DEC_SHP | ATM_MF_BWD)
-
-/*
- * ATM_VS_* are used to express VC state in a human-friendly way.
- */
-
-#define ATM_VS_IDLE	0	/* VC is not used */
-#define ATM_VS_CONNECTED 1	/* VC is connected */
-#define ATM_VS_CLOSING	2	/* VC is closing */
-#define ATM_VS_LISTEN	3	/* VC is listening for incoming setups */
-#define ATM_VS_INUSE	4	/* VC is in use (registered with atmsigd) */
-#define ATM_VS_BOUND	5	/* VC is bound */
-
-#define ATM_VS2TXT_MAP \
-    "IDLE", "CONNECTED", "CLOSING", "LISTEN", "INUSE", "BOUND"
-
-#define ATM_VF2TXT_MAP \
-    "ADDR",	"READY",	"PARTIAL",	"REGIS", \
-    "RELEASED", "HASQOS",	"LISTEN",	"META", \
-    "256",	"512",		"1024",		"2048", \
-    "SESSION",	"HASSAP",	"BOUND",	"CLOSE"
-
-
-
-#endif /* LINUX_ATMDEV_H */
diff --git a/include/linux/atmioc.h b/include/linux/atmioc.h
deleted file mode 100644
index 37f67aa..0000000
--- a/include/linux/atmioc.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/* atmioc.h - ranges for ATM-related ioctl numbers */
- 
-/* Written 1995-1999 by Werner Almesberger, EPFL LRC/ICA */
-
-
-/*
- * See http://icawww1.epfl.ch/linux-atm/magic.html for the complete list of
- * "magic" ioctl numbers.
- */
-
-
-#ifndef _LINUX_ATMIOC_H
-#define _LINUX_ATMIOC_H
-
-#include <asm/ioctl.h>
-		/* everybody including atmioc.h will also need _IO{,R,W,WR} */
-
-#define ATMIOC_PHYCOM	  0x00 /* PHY device common ioctls, globally unique */
-#define ATMIOC_PHYCOM_END 0x0f
-#define ATMIOC_PHYTYP	  0x10 /* PHY dev type ioctls, unique per PHY type */
-#define ATMIOC_PHYTYP_END 0x2f
-#define ATMIOC_PHYPRV	  0x30 /* PHY dev private ioctls, unique per driver */
-#define ATMIOC_PHYPRV_END 0x4f
-#define ATMIOC_SARCOM	  0x50 /* SAR device common ioctls, globally unique */
-#define ATMIOC_SARCOM_END 0x50
-#define ATMIOC_SARPRV	  0x60 /* SAR dev private ioctls, unique per driver */
-#define ATMIOC_SARPRV_END 0x7f
-#define ATMIOC_ITF	  0x80 /* Interface ioctls, globally unique */
-#define ATMIOC_ITF_END	  0x8f
-#define ATMIOC_BACKEND	  0x90 /* ATM generic backend ioctls, u. per backend */
-#define ATMIOC_BACKEND_END 0xaf
-/* 0xb0-0xbf: Reserved for future use */
-#define ATMIOC_AREQUIPA	  0xc0 /* Application requested IP over ATM, glob. u. */
-#define ATMIOC_LANE	  0xd0 /* LAN Emulation, globally unique */
-#define ATMIOC_MPOA       0xd8 /* MPOA, globally unique */
-#define	ATMIOC_CLIP	  0xe0 /* Classical IP over ATM control, globally u. */
-#define	ATMIOC_CLIP_END	  0xef
-#define	ATMIOC_SPECIAL	  0xf0 /* Special-purpose controls, globally unique */
-#define	ATMIOC_SPECIAL_END 0xff
-
-#endif
diff --git a/include/linux/atmsap.h b/include/linux/atmsap.h
deleted file mode 100644
index 799b104..0000000
--- a/include/linux/atmsap.h
+++ /dev/null
@@ -1,162 +0,0 @@
-/* atmsap.h - ATM Service Access Point addressing definitions */
-
-/* Written 1995-1999 by Werner Almesberger, EPFL LRC/ICA */
-
-
-#ifndef _LINUX_ATMSAP_H
-#define _LINUX_ATMSAP_H
-
-#include <linux/atmapi.h>
-
-/*
- * BEGIN_xx and END_xx markers are used for automatic generation of
- * documentation. Do not change them.
- */
-
-
-/*
- * Layer 2 protocol identifiers
- */
-
-/* BEGIN_L2 */
-#define ATM_L2_NONE	0	/* L2 not specified */
-#define ATM_L2_ISO1745  0x01	/* Basic mode ISO 1745 */
-#define ATM_L2_Q291	0x02	/* ITU-T Q.291 (Rec. I.441) */
-#define ATM_L2_X25_LL	0x06	/* ITU-T X.25, link layer */
-#define ATM_L2_X25_ML	0x07	/* ITU-T X.25, multilink */
-#define ATM_L2_LAPB	0x08	/* Extended LAPB, half-duplex (Rec. T.71) */
-#define ATM_L2_HDLC_ARM	0x09	/* HDLC ARM (ISO/IEC 4335) */
-#define ATM_L2_HDLC_NRM	0x0a	/* HDLC NRM (ISO/IEC 4335) */
-#define ATM_L2_HDLC_ABM	0x0b	/* HDLC ABM (ISO/IEC 4335) */
-#define ATM_L2_ISO8802	0x0c	/* LAN LLC (ISO/IEC 8802/2) */
-#define ATM_L2_X75	0x0d	/* ITU-T X.75, SLP */
-#define ATM_L2_Q922	0x0e	/* ITU-T Q.922 */
-#define ATM_L2_USER	0x10	/* user-specified */
-#define ATM_L2_ISO7776	0x11	/* ISO 7776 DTE-DTE */
-/* END_L2 */
-
-
-/*
- * Layer 3 protocol identifiers
- */
-
-/* BEGIN_L3 */
-#define ATM_L3_NONE	0	/* L3 not specified */
-#define ATM_L3_X25	0x06	/* ITU-T X.25, packet layer */
-#define ATM_L3_ISO8208	0x07	/* ISO/IEC 8208 */
-#define ATM_L3_X223	0x08	/* ITU-T X.223 | ISO/IEC 8878 */
-#define ATM_L3_ISO8473	0x09	/* ITU-T X.233 | ISO/IEC 8473 */
-#define ATM_L3_T70	0x0a	/* ITU-T T.70 minimum network layer */
-#define ATM_L3_TR9577	0x0b	/* ISO/IEC TR 9577 */
-#define ATM_L3_H310	0x0c	/* ITU-T Recommendation H.310 */
-#define ATM_L3_H321	0x0d	/* ITU-T Recommendation H.321 */
-#define ATM_L3_USER	0x10	/* user-specified */
-/* END_L3 */
-
-
-/*
- * High layer identifiers
- */
-
-/* BEGIN_HL */
-#define ATM_HL_NONE	0	/* HL not specified */
-#define ATM_HL_ISO	0x01	/* ISO */
-#define ATM_HL_USER	0x02	/* user-specific */
-#define ATM_HL_HLP	0x03	/* high layer profile - UNI 3.0 only */
-#define ATM_HL_VENDOR	0x04	/* vendor-specific application identifier */
-/* END_HL */
-
-
-/*
- * ITU-T coded mode of operation
- */
-
-/* BEGIN_IMD */
-#define ATM_IMD_NONE	 0	/* mode not specified */
-#define ATM_IMD_NORMAL	 1	/* normal mode of operation */
-#define ATM_IMD_EXTENDED 2	/* extended mode of operation */
-/* END_IMD */
-
-/*
- * H.310 code points
- */
-
-#define ATM_TT_NONE	0	/* terminal type not specified */
-#define ATM_TT_RX	1	/* receive only */
-#define ATM_TT_TX	2	/* send only */
-#define ATM_TT_RXTX	3	/* receive and send */
-
-#define ATM_MC_NONE	0	/* no multiplexing */
-#define ATM_MC_TS	1	/* transport stream (TS) */
-#define ATM_MC_TS_FEC	2	/* transport stream with forward error corr. */
-#define ATM_MC_PS	3	/* program stream (PS) */
-#define ATM_MC_PS_FEC	4	/* program stream with forward error corr. */
-#define ATM_MC_H221	5	/* ITU-T Rec. H.221 */
-
-/*
- * SAP structures
- */
-
-#define ATM_MAX_HLI	8	/* maximum high-layer information length */
-
-
-struct atm_blli {
-    unsigned char l2_proto;	/* layer 2 protocol */
-    union {
-	struct {
-	    unsigned char mode;	/* mode of operation (ATM_IMD_xxx), 0 if */
-				/* absent */
-	    unsigned char window; /* window size (k), 1-127 (0 to omit) */
-	} itu;			/* ITU-T encoding */
-	unsigned char user;	/* user-specified l2 information */
-    } l2;
-    unsigned char l3_proto;	/* layer 3 protocol */
-    union {
-	struct {
-	    unsigned char mode;	/* mode of operation (ATM_IMD_xxx), 0 if */
-				/* absent */
-	    unsigned char def_size; /* default packet size (log2), 4-12 (0 to */
-				    /* omit) */
-	    unsigned char window;/* packet window size, 1-127 (0 to omit) */
-	} itu;			/* ITU-T encoding */
-	unsigned char user;	/* user specified l3 information */
-	struct {		      /* if l3_proto = ATM_L3_H310 */
-	    unsigned char term_type;  /* terminal type */
-	    unsigned char fw_mpx_cap; /* forward multiplexing capability */
-				      /* only if term_type != ATM_TT_NONE */
-	    unsigned char bw_mpx_cap; /* backward multiplexing capability */
-				      /* only if term_type != ATM_TT_NONE */
-	} h310;
-	struct {		  /* if l3_proto = ATM_L3_TR9577 */
-	    unsigned char ipi;	  /* initial protocol id */
-	    unsigned char snap[5];/* IEEE 802.1 SNAP identifier */
-				  /* (only if ipi == NLPID_IEEE802_1_SNAP) */
-	} tr9577;
-    } l3;
-} __ATM_API_ALIGN;
-
-
-struct atm_bhli {
-    unsigned char hl_type;	/* high layer information type */
-    unsigned char hl_length;	/* length (only if hl_type == ATM_HL_USER || */
-				/* hl_type == ATM_HL_ISO) */
-    unsigned char hl_info[ATM_MAX_HLI];/* high layer information */
-};
-
-
-#define ATM_MAX_BLLI	3		/* maximum number of BLLI elements */
-
-
-struct atm_sap {
-	struct atm_bhli bhli;		/* local SAP, high-layer information */
-	struct atm_blli blli[ATM_MAX_BLLI] __ATM_API_ALIGN;
-					/* local SAP, low-layer info */
-};
-
-
-static __inline__ int blli_in_use(struct atm_blli blli)
-{
-	return blli.l2_proto || blli.l3_proto;
-}
-
-#endif
diff --git a/include/linux/bpf.h b/include/linux/bpf.h
deleted file mode 100644
index 0895a52..0000000
--- a/include/linux/bpf.h
+++ /dev/null
@@ -1,867 +0,0 @@
-/* Copyright (c) 2011-2014 PLUMgrid, http://plumgrid.com
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of version 2 of the GNU General Public
- * License as published by the Free Software Foundation.
- */
-#ifndef __LINUX_BPF_H__
-#define __LINUX_BPF_H__
-
-#include <linux/types.h>
-#include <linux/bpf_common.h>
-
-/* Extended instruction set based on top of classic BPF */
-
-/* instruction classes */
-#define BPF_ALU64	0x07	/* alu mode in double word width */
-
-/* ld/ldx fields */
-#define BPF_DW		0x18	/* double word */
-#define BPF_XADD	0xc0	/* exclusive add */
-
-/* alu/jmp fields */
-#define BPF_MOV		0xb0	/* mov reg to reg */
-#define BPF_ARSH	0xc0	/* sign extending arithmetic shift right */
-
-/* change endianness of a register */
-#define BPF_END		0xd0	/* flags for endianness conversion: */
-#define BPF_TO_LE	0x00	/* convert to little-endian */
-#define BPF_TO_BE	0x08	/* convert to big-endian */
-#define BPF_FROM_LE	BPF_TO_LE
-#define BPF_FROM_BE	BPF_TO_BE
-
-/* jmp encodings */
-#define BPF_JNE		0x50	/* jump != */
-#define BPF_JLT		0xa0	/* LT is unsigned, '<' */
-#define BPF_JLE		0xb0	/* LE is unsigned, '<=' */
-#define BPF_JSGT	0x60	/* SGT is signed '>', GT in x86 */
-#define BPF_JSGE	0x70	/* SGE is signed '>=', GE in x86 */
-#define BPF_JSLT	0xc0	/* SLT is signed, '<' */
-#define BPF_JSLE	0xd0	/* SLE is signed, '<=' */
-#define BPF_CALL	0x80	/* function call */
-#define BPF_EXIT	0x90	/* function return */
-
-/* Register numbers */
-enum {
-	BPF_REG_0 = 0,
-	BPF_REG_1,
-	BPF_REG_2,
-	BPF_REG_3,
-	BPF_REG_4,
-	BPF_REG_5,
-	BPF_REG_6,
-	BPF_REG_7,
-	BPF_REG_8,
-	BPF_REG_9,
-	BPF_REG_10,
-	__MAX_BPF_REG,
-};
-
-/* BPF has 10 general purpose 64-bit registers and stack frame. */
-#define MAX_BPF_REG	__MAX_BPF_REG
-
-struct bpf_insn {
-	__u8	code;		/* opcode */
-	__u8	dst_reg:4;	/* dest register */
-	__u8	src_reg:4;	/* source register */
-	__s16	off;		/* signed offset */
-	__s32	imm;		/* signed immediate constant */
-};
-
-/* Key of an a BPF_MAP_TYPE_LPM_TRIE entry */
-struct bpf_lpm_trie_key {
-	__u32	prefixlen;	/* up to 32 for AF_INET, 128 for AF_INET6 */
-	__u8	data[0];	/* Arbitrary size */
-};
-
-/* BPF syscall commands, see bpf(2) man-page for details. */
-enum bpf_cmd {
-	BPF_MAP_CREATE,
-	BPF_MAP_LOOKUP_ELEM,
-	BPF_MAP_UPDATE_ELEM,
-	BPF_MAP_DELETE_ELEM,
-	BPF_MAP_GET_NEXT_KEY,
-	BPF_PROG_LOAD,
-	BPF_OBJ_PIN,
-	BPF_OBJ_GET,
-	BPF_PROG_ATTACH,
-	BPF_PROG_DETACH,
-	BPF_PROG_TEST_RUN,
-	BPF_PROG_GET_NEXT_ID,
-	BPF_MAP_GET_NEXT_ID,
-	BPF_PROG_GET_FD_BY_ID,
-	BPF_MAP_GET_FD_BY_ID,
-	BPF_OBJ_GET_INFO_BY_FD,
-};
-
-enum bpf_map_type {
-	BPF_MAP_TYPE_UNSPEC,
-	BPF_MAP_TYPE_HASH,
-	BPF_MAP_TYPE_ARRAY,
-	BPF_MAP_TYPE_PROG_ARRAY,
-	BPF_MAP_TYPE_PERF_EVENT_ARRAY,
-	BPF_MAP_TYPE_PERCPU_HASH,
-	BPF_MAP_TYPE_PERCPU_ARRAY,
-	BPF_MAP_TYPE_STACK_TRACE,
-	BPF_MAP_TYPE_CGROUP_ARRAY,
-	BPF_MAP_TYPE_LRU_HASH,
-	BPF_MAP_TYPE_LRU_PERCPU_HASH,
-	BPF_MAP_TYPE_LPM_TRIE,
-	BPF_MAP_TYPE_ARRAY_OF_MAPS,
-	BPF_MAP_TYPE_HASH_OF_MAPS,
-	BPF_MAP_TYPE_DEVMAP,
-	BPF_MAP_TYPE_SOCKMAP,
-};
-
-enum bpf_prog_type {
-	BPF_PROG_TYPE_UNSPEC,
-	BPF_PROG_TYPE_SOCKET_FILTER,
-	BPF_PROG_TYPE_KPROBE,
-	BPF_PROG_TYPE_SCHED_CLS,
-	BPF_PROG_TYPE_SCHED_ACT,
-	BPF_PROG_TYPE_TRACEPOINT,
-	BPF_PROG_TYPE_XDP,
-	BPF_PROG_TYPE_PERF_EVENT,
-	BPF_PROG_TYPE_CGROUP_SKB,
-	BPF_PROG_TYPE_CGROUP_SOCK,
-	BPF_PROG_TYPE_LWT_IN,
-	BPF_PROG_TYPE_LWT_OUT,
-	BPF_PROG_TYPE_LWT_XMIT,
-	BPF_PROG_TYPE_SOCK_OPS,
-	BPF_PROG_TYPE_SK_SKB,
-};
-
-enum bpf_attach_type {
-	BPF_CGROUP_INET_INGRESS,
-	BPF_CGROUP_INET_EGRESS,
-	BPF_CGROUP_INET_SOCK_CREATE,
-	BPF_CGROUP_SOCK_OPS,
-	BPF_SK_SKB_STREAM_PARSER,
-	BPF_SK_SKB_STREAM_VERDICT,
-	__MAX_BPF_ATTACH_TYPE
-};
-
-#define MAX_BPF_ATTACH_TYPE __MAX_BPF_ATTACH_TYPE
-
-/* If BPF_F_ALLOW_OVERRIDE flag is used in BPF_PROG_ATTACH command
- * to the given target_fd cgroup the descendent cgroup will be able to
- * override effective bpf program that was inherited from this cgroup
- */
-#define BPF_F_ALLOW_OVERRIDE	(1U << 0)
-
-/* If BPF_F_STRICT_ALIGNMENT is used in BPF_PROG_LOAD command, the
- * verifier will perform strict alignment checking as if the kernel
- * has been built with CONFIG_EFFICIENT_UNALIGNED_ACCESS not set,
- * and NET_IP_ALIGN defined to 2.
- */
-#define BPF_F_STRICT_ALIGNMENT	(1U << 0)
-
-#define BPF_PSEUDO_MAP_FD	1
-
-/* flags for BPF_MAP_UPDATE_ELEM command */
-#define BPF_ANY		0 /* create new element or update existing */
-#define BPF_NOEXIST	1 /* create new element if it didn't exist */
-#define BPF_EXIST	2 /* update existing element */
-
-/* flags for BPF_MAP_CREATE command */
-#define BPF_F_NO_PREALLOC	(1U << 0)
-/* Instead of having one common LRU list in the
- * BPF_MAP_TYPE_LRU_[PERCPU_]HASH map, use a percpu LRU list
- * which can scale and perform better.
- * Note, the LRU nodes (including free nodes) cannot be moved
- * across different LRU lists.
- */
-#define BPF_F_NO_COMMON_LRU	(1U << 1)
-/* Specify numa node during map creation */
-#define BPF_F_NUMA_NODE		(1U << 2)
-
-union bpf_attr {
-	struct { /* anonymous struct used by BPF_MAP_CREATE command */
-		__u32	map_type;	/* one of enum bpf_map_type */
-		__u32	key_size;	/* size of key in bytes */
-		__u32	value_size;	/* size of value in bytes */
-		__u32	max_entries;	/* max number of entries in a map */
-		__u32	map_flags;	/* BPF_MAP_CREATE related
-					 * flags defined above.
-					 */
-		__u32	inner_map_fd;	/* fd pointing to the inner map */
-		__u32	numa_node;	/* numa node (effective only if
-					 * BPF_F_NUMA_NODE is set).
-					 */
-	};
-
-	struct { /* anonymous struct used by BPF_MAP_*_ELEM commands */
-		__u32		map_fd;
-		__aligned_u64	key;
-		union {
-			__aligned_u64 value;
-			__aligned_u64 next_key;
-		};
-		__u64		flags;
-	};
-
-	struct { /* anonymous struct used by BPF_PROG_LOAD command */
-		__u32		prog_type;	/* one of enum bpf_prog_type */
-		__u32		insn_cnt;
-		__aligned_u64	insns;
-		__aligned_u64	license;
-		__u32		log_level;	/* verbosity level of verifier */
-		__u32		log_size;	/* size of user buffer */
-		__aligned_u64	log_buf;	/* user supplied buffer */
-		__u32		kern_version;	/* checked when prog_type=kprobe */
-		__u32		prog_flags;
-	};
-
-	struct { /* anonymous struct used by BPF_OBJ_* commands */
-		__aligned_u64	pathname;
-		__u32		bpf_fd;
-	};
-
-	struct { /* anonymous struct used by BPF_PROG_ATTACH/DETACH commands */
-		__u32		target_fd;	/* container object to attach to */
-		__u32		attach_bpf_fd;	/* eBPF program to attach */
-		__u32		attach_type;
-		__u32		attach_flags;
-	};
-
-	struct { /* anonymous struct used by BPF_PROG_TEST_RUN command */
-		__u32		prog_fd;
-		__u32		retval;
-		__u32		data_size_in;
-		__u32		data_size_out;
-		__aligned_u64	data_in;
-		__aligned_u64	data_out;
-		__u32		repeat;
-		__u32		duration;
-	} test;
-
-	struct { /* anonymous struct used by BPF_*_GET_*_ID */
-		union {
-			__u32		start_id;
-			__u32		prog_id;
-			__u32		map_id;
-		};
-		__u32		next_id;
-	};
-
-	struct { /* anonymous struct used by BPF_OBJ_GET_INFO_BY_FD */
-		__u32		bpf_fd;
-		__u32		info_len;
-		__aligned_u64	info;
-	} info;
-} __attribute__((aligned(8)));
-
-/* BPF helper function descriptions:
- *
- * void *bpf_map_lookup_elem(&map, &key)
- *     Return: Map value or NULL
- *
- * int bpf_map_update_elem(&map, &key, &value, flags)
- *     Return: 0 on success or negative error
- *
- * int bpf_map_delete_elem(&map, &key)
- *     Return: 0 on success or negative error
- *
- * int bpf_probe_read(void *dst, int size, void *src)
- *     Return: 0 on success or negative error
- *
- * u64 bpf_ktime_get_ns(void)
- *     Return: current ktime
- *
- * int bpf_trace_printk(const char *fmt, int fmt_size, ...)
- *     Return: length of buffer written or negative error
- *
- * u32 bpf_prandom_u32(void)
- *     Return: random value
- *
- * u32 bpf_raw_smp_processor_id(void)
- *     Return: SMP processor ID
- *
- * int bpf_skb_store_bytes(skb, offset, from, len, flags)
- *     store bytes into packet
- *     @skb: pointer to skb
- *     @offset: offset within packet from skb->mac_header
- *     @from: pointer where to copy bytes from
- *     @len: number of bytes to store into packet
- *     @flags: bit 0 - if true, recompute skb->csum
- *             other bits - reserved
- *     Return: 0 on success or negative error
- *
- * int bpf_l3_csum_replace(skb, offset, from, to, flags)
- *     recompute IP checksum
- *     @skb: pointer to skb
- *     @offset: offset within packet where IP checksum is located
- *     @from: old value of header field
- *     @to: new value of header field
- *     @flags: bits 0-3 - size of header field
- *             other bits - reserved
- *     Return: 0 on success or negative error
- *
- * int bpf_l4_csum_replace(skb, offset, from, to, flags)
- *     recompute TCP/UDP checksum
- *     @skb: pointer to skb
- *     @offset: offset within packet where TCP/UDP checksum is located
- *     @from: old value of header field
- *     @to: new value of header field
- *     @flags: bits 0-3 - size of header field
- *             bit 4 - is pseudo header
- *             other bits - reserved
- *     Return: 0 on success or negative error
- *
- * int bpf_tail_call(ctx, prog_array_map, index)
- *     jump into another BPF program
- *     @ctx: context pointer passed to next program
- *     @prog_array_map: pointer to map which type is BPF_MAP_TYPE_PROG_ARRAY
- *     @index: index inside array that selects specific program to run
- *     Return: 0 on success or negative error
- *
- * int bpf_clone_redirect(skb, ifindex, flags)
- *     redirect to another netdev
- *     @skb: pointer to skb
- *     @ifindex: ifindex of the net device
- *     @flags: bit 0 - if set, redirect to ingress instead of egress
- *             other bits - reserved
- *     Return: 0 on success or negative error
- *
- * u64 bpf_get_current_pid_tgid(void)
- *     Return: current->tgid << 32 | current->pid
- *
- * u64 bpf_get_current_uid_gid(void)
- *     Return: current_gid << 32 | current_uid
- *
- * int bpf_get_current_comm(char *buf, int size_of_buf)
- *     stores current->comm into buf
- *     Return: 0 on success or negative error
- *
- * u32 bpf_get_cgroup_classid(skb)
- *     retrieve a proc's classid
- *     @skb: pointer to skb
- *     Return: classid if != 0
- *
- * int bpf_skb_vlan_push(skb, vlan_proto, vlan_tci)
- *     Return: 0 on success or negative error
- *
- * int bpf_skb_vlan_pop(skb)
- *     Return: 0 on success or negative error
- *
- * int bpf_skb_get_tunnel_key(skb, key, size, flags)
- * int bpf_skb_set_tunnel_key(skb, key, size, flags)
- *     retrieve or populate tunnel metadata
- *     @skb: pointer to skb
- *     @key: pointer to 'struct bpf_tunnel_key'
- *     @size: size of 'struct bpf_tunnel_key'
- *     @flags: room for future extensions
- *     Return: 0 on success or negative error
- *
- * u64 bpf_perf_event_read(map, flags)
- *     read perf event counter value
- *     @map: pointer to perf_event_array map
- *     @flags: index of event in the map or bitmask flags
- *     Return: value of perf event counter read or error code
- *
- * int bpf_redirect(ifindex, flags)
- *     redirect to another netdev
- *     @ifindex: ifindex of the net device
- *     @flags:
- *	  cls_bpf:
- *          bit 0 - if set, redirect to ingress instead of egress
- *          other bits - reserved
- *	  xdp_bpf:
- *	    all bits - reserved
- *     Return: cls_bpf: TC_ACT_REDIRECT on success or TC_ACT_SHOT on error
- *	       xdp_bfp: XDP_REDIRECT on success or XDP_ABORT on error
- * int bpf_redirect_map(map, key, flags)
- *     redirect to endpoint in map
- *     @map: pointer to dev map
- *     @key: index in map to lookup
- *     @flags: --
- *     Return: XDP_REDIRECT on success or XDP_ABORT on error
- *
- * u32 bpf_get_route_realm(skb)
- *     retrieve a dst's tclassid
- *     @skb: pointer to skb
- *     Return: realm if != 0
- *
- * int bpf_perf_event_output(ctx, map, flags, data, size)
- *     output perf raw sample
- *     @ctx: struct pt_regs*
- *     @map: pointer to perf_event_array map
- *     @flags: index of event in the map or bitmask flags
- *     @data: data on stack to be output as raw data
- *     @size: size of data
- *     Return: 0 on success or negative error
- *
- * int bpf_get_stackid(ctx, map, flags)
- *     walk user or kernel stack and return id
- *     @ctx: struct pt_regs*
- *     @map: pointer to stack_trace map
- *     @flags: bits 0-7 - numer of stack frames to skip
- *             bit 8 - collect user stack instead of kernel
- *             bit 9 - compare stacks by hash only
- *             bit 10 - if two different stacks hash into the same stackid
- *                      discard old
- *             other bits - reserved
- *     Return: >= 0 stackid on success or negative error
- *
- * s64 bpf_csum_diff(from, from_size, to, to_size, seed)
- *     calculate csum diff
- *     @from: raw from buffer
- *     @from_size: length of from buffer
- *     @to: raw to buffer
- *     @to_size: length of to buffer
- *     @seed: optional seed
- *     Return: csum result or negative error code
- *
- * int bpf_skb_get_tunnel_opt(skb, opt, size)
- *     retrieve tunnel options metadata
- *     @skb: pointer to skb
- *     @opt: pointer to raw tunnel option data
- *     @size: size of @opt
- *     Return: option size
- *
- * int bpf_skb_set_tunnel_opt(skb, opt, size)
- *     populate tunnel options metadata
- *     @skb: pointer to skb
- *     @opt: pointer to raw tunnel option data
- *     @size: size of @opt
- *     Return: 0 on success or negative error
- *
- * int bpf_skb_change_proto(skb, proto, flags)
- *     Change protocol of the skb. Currently supported is v4 -> v6,
- *     v6 -> v4 transitions. The helper will also resize the skb. eBPF
- *     program is expected to fill the new headers via skb_store_bytes
- *     and lX_csum_replace.
- *     @skb: pointer to skb
- *     @proto: new skb->protocol type
- *     @flags: reserved
- *     Return: 0 on success or negative error
- *
- * int bpf_skb_change_type(skb, type)
- *     Change packet type of skb.
- *     @skb: pointer to skb
- *     @type: new skb->pkt_type type
- *     Return: 0 on success or negative error
- *
- * int bpf_skb_under_cgroup(skb, map, index)
- *     Check cgroup2 membership of skb
- *     @skb: pointer to skb
- *     @map: pointer to bpf_map in BPF_MAP_TYPE_CGROUP_ARRAY type
- *     @index: index of the cgroup in the bpf_map
- *     Return:
- *       == 0 skb failed the cgroup2 descendant test
- *       == 1 skb succeeded the cgroup2 descendant test
- *        < 0 error
- *
- * u32 bpf_get_hash_recalc(skb)
- *     Retrieve and possibly recalculate skb->hash.
- *     @skb: pointer to skb
- *     Return: hash
- *
- * u64 bpf_get_current_task(void)
- *     Returns current task_struct
- *     Return: current
- *
- * int bpf_probe_write_user(void *dst, void *src, int len)
- *     safely attempt to write to a location
- *     @dst: destination address in userspace
- *     @src: source address on stack
- *     @len: number of bytes to copy
- *     Return: 0 on success or negative error
- *
- * int bpf_current_task_under_cgroup(map, index)
- *     Check cgroup2 membership of current task
- *     @map: pointer to bpf_map in BPF_MAP_TYPE_CGROUP_ARRAY type
- *     @index: index of the cgroup in the bpf_map
- *     Return:
- *       == 0 current failed the cgroup2 descendant test
- *       == 1 current succeeded the cgroup2 descendant test
- *        < 0 error
- *
- * int bpf_skb_change_tail(skb, len, flags)
- *     The helper will resize the skb to the given new size, to be used f.e.
- *     with control messages.
- *     @skb: pointer to skb
- *     @len: new skb length
- *     @flags: reserved
- *     Return: 0 on success or negative error
- *
- * int bpf_skb_pull_data(skb, len)
- *     The helper will pull in non-linear data in case the skb is non-linear
- *     and not all of len are part of the linear section. Only needed for
- *     read/write with direct packet access.
- *     @skb: pointer to skb
- *     @len: len to make read/writeable
- *     Return: 0 on success or negative error
- *
- * s64 bpf_csum_update(skb, csum)
- *     Adds csum into skb->csum in case of CHECKSUM_COMPLETE.
- *     @skb: pointer to skb
- *     @csum: csum to add
- *     Return: csum on success or negative error
- *
- * void bpf_set_hash_invalid(skb)
- *     Invalidate current skb->hash.
- *     @skb: pointer to skb
- *
- * int bpf_get_numa_node_id()
- *     Return: Id of current NUMA node.
- *
- * int bpf_skb_change_head()
- *     Grows headroom of skb and adjusts MAC header offset accordingly.
- *     Will extends/reallocae as required automatically.
- *     May change skb data pointer and will thus invalidate any check
- *     performed for direct packet access.
- *     @skb: pointer to skb
- *     @len: length of header to be pushed in front
- *     @flags: Flags (unused for now)
- *     Return: 0 on success or negative error
- *
- * int bpf_xdp_adjust_head(xdp_md, delta)
- *     Adjust the xdp_md.data by delta
- *     @xdp_md: pointer to xdp_md
- *     @delta: An positive/negative integer to be added to xdp_md.data
- *     Return: 0 on success or negative on error
- *
- * int bpf_probe_read_str(void *dst, int size, const void *unsafe_ptr)
- *     Copy a NUL terminated string from unsafe address. In case the string
- *     length is smaller than size, the target is not padded with further NUL
- *     bytes. In case the string length is larger than size, just count-1
- *     bytes are copied and the last byte is set to NUL.
- *     @dst: destination address
- *     @size: maximum number of bytes to copy, including the trailing NUL
- *     @unsafe_ptr: unsafe address
- *     Return:
- *       > 0 length of the string including the trailing NUL on success
- *       < 0 error
- *
- * u64 bpf_get_socket_cookie(skb)
- *     Get the cookie for the socket stored inside sk_buff.
- *     @skb: pointer to skb
- *     Return: 8 Bytes non-decreasing number on success or 0 if the socket
- *     field is missing inside sk_buff
- *
- * u32 bpf_get_socket_uid(skb)
- *     Get the owner uid of the socket stored inside sk_buff.
- *     @skb: pointer to skb
- *     Return: uid of the socket owner on success or overflowuid if failed.
- *
- * u32 bpf_set_hash(skb, hash)
- *     Set full skb->hash.
- *     @skb: pointer to skb
- *     @hash: hash to set
- *
- * int bpf_setsockopt(bpf_socket, level, optname, optval, optlen)
- *     Calls setsockopt. Not all opts are available, only those with
- *     integer optvals plus TCP_CONGESTION.
- *     Supported levels: SOL_SOCKET and IPROTO_TCP
- *     @bpf_socket: pointer to bpf_socket
- *     @level: SOL_SOCKET or IPROTO_TCP
- *     @optname: option name
- *     @optval: pointer to option value
- *     @optlen: length of optval in byes
- *     Return: 0 or negative error
- *
- * int bpf_skb_adjust_room(skb, len_diff, mode, flags)
- *     Grow or shrink room in sk_buff.
- *     @skb: pointer to skb
- *     @len_diff: (signed) amount of room to grow/shrink
- *     @mode: operation mode (enum bpf_adj_room_mode)
- *     @flags: reserved for future use
- *     Return: 0 on success or negative error code
- *
- * int bpf_sk_redirect_map(map, key, flags)
- *     Redirect skb to a sock in map using key as a lookup key for the
- *     sock in map.
- *     @map: pointer to sockmap
- *     @key: key to lookup sock in map
- *     @flags: reserved for future use
- *     Return: SK_REDIRECT
- *
- * int bpf_sock_map_update(skops, map, key, flags)
- *	@skops: pointer to bpf_sock_ops
- *	@map: pointer to sockmap to update
- *	@key: key to insert/update sock in map
- *	@flags: same flags as map update elem
- */
-#define __BPF_FUNC_MAPPER(FN)		\
-	FN(unspec),			\
-	FN(map_lookup_elem),		\
-	FN(map_update_elem),		\
-	FN(map_delete_elem),		\
-	FN(probe_read),			\
-	FN(ktime_get_ns),		\
-	FN(trace_printk),		\
-	FN(get_prandom_u32),		\
-	FN(get_smp_processor_id),	\
-	FN(skb_store_bytes),		\
-	FN(l3_csum_replace),		\
-	FN(l4_csum_replace),		\
-	FN(tail_call),			\
-	FN(clone_redirect),		\
-	FN(get_current_pid_tgid),	\
-	FN(get_current_uid_gid),	\
-	FN(get_current_comm),		\
-	FN(get_cgroup_classid),		\
-	FN(skb_vlan_push),		\
-	FN(skb_vlan_pop),		\
-	FN(skb_get_tunnel_key),		\
-	FN(skb_set_tunnel_key),		\
-	FN(perf_event_read),		\
-	FN(redirect),			\
-	FN(get_route_realm),		\
-	FN(perf_event_output),		\
-	FN(skb_load_bytes),		\
-	FN(get_stackid),		\
-	FN(csum_diff),			\
-	FN(skb_get_tunnel_opt),		\
-	FN(skb_set_tunnel_opt),		\
-	FN(skb_change_proto),		\
-	FN(skb_change_type),		\
-	FN(skb_under_cgroup),		\
-	FN(get_hash_recalc),		\
-	FN(get_current_task),		\
-	FN(probe_write_user),		\
-	FN(current_task_under_cgroup),	\
-	FN(skb_change_tail),		\
-	FN(skb_pull_data),		\
-	FN(csum_update),		\
-	FN(set_hash_invalid),		\
-	FN(get_numa_node_id),		\
-	FN(skb_change_head),		\
-	FN(xdp_adjust_head),		\
-	FN(probe_read_str),		\
-	FN(get_socket_cookie),		\
-	FN(get_socket_uid),		\
-	FN(set_hash),			\
-	FN(setsockopt),			\
-	FN(skb_adjust_room),		\
-	FN(redirect_map),		\
-	FN(sk_redirect_map),		\
-	FN(sock_map_update),		\
-
-/* integer value in 'imm' field of BPF_CALL instruction selects which helper
- * function eBPF program intends to call
- */
-#define __BPF_ENUM_FN(x) BPF_FUNC_ ## x
-enum bpf_func_id {
-	__BPF_FUNC_MAPPER(__BPF_ENUM_FN)
-	__BPF_FUNC_MAX_ID,
-};
-#undef __BPF_ENUM_FN
-
-/* All flags used by eBPF helper functions, placed here. */
-
-/* BPF_FUNC_skb_store_bytes flags. */
-#define BPF_F_RECOMPUTE_CSUM		(1ULL << 0)
-#define BPF_F_INVALIDATE_HASH		(1ULL << 1)
-
-/* BPF_FUNC_l3_csum_replace and BPF_FUNC_l4_csum_replace flags.
- * First 4 bits are for passing the header field size.
- */
-#define BPF_F_HDR_FIELD_MASK		0xfULL
-
-/* BPF_FUNC_l4_csum_replace flags. */
-#define BPF_F_PSEUDO_HDR		(1ULL << 4)
-#define BPF_F_MARK_MANGLED_0		(1ULL << 5)
-#define BPF_F_MARK_ENFORCE		(1ULL << 6)
-
-/* BPF_FUNC_clone_redirect and BPF_FUNC_redirect flags. */
-#define BPF_F_INGRESS			(1ULL << 0)
-
-/* BPF_FUNC_skb_set_tunnel_key and BPF_FUNC_skb_get_tunnel_key flags. */
-#define BPF_F_TUNINFO_IPV6		(1ULL << 0)
-
-/* BPF_FUNC_get_stackid flags. */
-#define BPF_F_SKIP_FIELD_MASK		0xffULL
-#define BPF_F_USER_STACK		(1ULL << 8)
-#define BPF_F_FAST_STACK_CMP		(1ULL << 9)
-#define BPF_F_REUSE_STACKID		(1ULL << 10)
-
-/* BPF_FUNC_skb_set_tunnel_key flags. */
-#define BPF_F_ZERO_CSUM_TX		(1ULL << 1)
-#define BPF_F_DONT_FRAGMENT		(1ULL << 2)
-
-/* BPF_FUNC_perf_event_output and BPF_FUNC_perf_event_read flags. */
-#define BPF_F_INDEX_MASK		0xffffffffULL
-#define BPF_F_CURRENT_CPU		BPF_F_INDEX_MASK
-/* BPF_FUNC_perf_event_output for sk_buff input context. */
-#define BPF_F_CTXLEN_MASK		(0xfffffULL << 32)
-
-/* Mode for BPF_FUNC_skb_adjust_room helper. */
-enum bpf_adj_room_mode {
-	BPF_ADJ_ROOM_NET,
-};
-
-/* user accessible mirror of in-kernel sk_buff.
- * new fields can only be added to the end of this structure
- */
-struct __sk_buff {
-	__u32 len;
-	__u32 pkt_type;
-	__u32 mark;
-	__u32 queue_mapping;
-	__u32 protocol;
-	__u32 vlan_present;
-	__u32 vlan_tci;
-	__u32 vlan_proto;
-	__u32 priority;
-	__u32 ingress_ifindex;
-	__u32 ifindex;
-	__u32 tc_index;
-	__u32 cb[5];
-	__u32 hash;
-	__u32 tc_classid;
-	__u32 data;
-	__u32 data_end;
-	__u32 napi_id;
-
-	/* accessed by BPF_PROG_TYPE_sk_skb types */
-	__u32 family;
-	__u32 remote_ip4;	/* Stored in network byte order */
-	__u32 local_ip4;	/* Stored in network byte order */
-	__u32 remote_ip6[4];	/* Stored in network byte order */
-	__u32 local_ip6[4];	/* Stored in network byte order */
-	__u32 remote_port;	/* Stored in network byte order */
-	__u32 local_port;	/* stored in host byte order */
-};
-
-struct bpf_tunnel_key {
-	__u32 tunnel_id;
-	union {
-		__u32 remote_ipv4;
-		__u32 remote_ipv6[4];
-	};
-	__u8 tunnel_tos;
-	__u8 tunnel_ttl;
-	__u16 tunnel_ext;
-	__u32 tunnel_label;
-};
-
-/* Generic BPF return codes which all BPF program types may support.
- * The values are binary compatible with their TC_ACT_* counter-part to
- * provide backwards compatibility with existing SCHED_CLS and SCHED_ACT
- * programs.
- *
- * XDP is handled seprately, see XDP_*.
- */
-enum bpf_ret_code {
-	BPF_OK = 0,
-	/* 1 reserved */
-	BPF_DROP = 2,
-	/* 3-6 reserved */
-	BPF_REDIRECT = 7,
-	/* >127 are reserved for prog type specific return codes */
-};
-
-struct bpf_sock {
-	__u32 bound_dev_if;
-	__u32 family;
-	__u32 type;
-	__u32 protocol;
-	__u32 mark;
-	__u32 priority;
-};
-
-#define XDP_PACKET_HEADROOM 256
-
-/* User return codes for XDP prog type.
- * A valid XDP program must return one of these defined values. All other
- * return codes are reserved for future use. Unknown return codes will
- * result in packet drops and a warning via bpf_warn_invalid_xdp_action().
- */
-enum xdp_action {
-	XDP_ABORTED = 0,
-	XDP_DROP,
-	XDP_PASS,
-	XDP_TX,
-	XDP_REDIRECT,
-};
-
-/* user accessible metadata for XDP packet hook
- * new fields must be added to the end of this structure
- */
-struct xdp_md {
-	__u32 data;
-	__u32 data_end;
-};
-
-enum sk_action {
-	SK_ABORTED = 0,
-	SK_DROP,
-	SK_REDIRECT,
-};
-
-#define BPF_TAG_SIZE	8
-
-struct bpf_prog_info {
-	__u32 type;
-	__u32 id;
-	__u8  tag[BPF_TAG_SIZE];
-	__u32 jited_prog_len;
-	__u32 xlated_prog_len;
-	__aligned_u64 jited_prog_insns;
-	__aligned_u64 xlated_prog_insns;
-} __attribute__((aligned(8)));
-
-struct bpf_map_info {
-	__u32 type;
-	__u32 id;
-	__u32 key_size;
-	__u32 value_size;
-	__u32 max_entries;
-	__u32 map_flags;
-} __attribute__((aligned(8)));
-
-/* User bpf_sock_ops struct to access socket values and specify request ops
- * and their replies.
- * Some of this fields are in network (bigendian) byte order and may need
- * to be converted before use (bpf_ntohl() defined in samples/bpf/bpf_endian.h).
- * New fields can only be added at the end of this structure
- */
-struct bpf_sock_ops {
-	__u32 op;
-	union {
-		__u32 reply;
-		__u32 replylong[4];
-	};
-	__u32 family;
-	__u32 remote_ip4;	/* Stored in network byte order */
-	__u32 local_ip4;	/* Stored in network byte order */
-	__u32 remote_ip6[4];	/* Stored in network byte order */
-	__u32 local_ip6[4];	/* Stored in network byte order */
-	__u32 remote_port;	/* Stored in network byte order */
-	__u32 local_port;	/* stored in host byte order */
-};
-
-/* List of known BPF sock_ops operators.
- * New entries can only be added at the end
- */
-enum {
-	BPF_SOCK_OPS_VOID,
-	BPF_SOCK_OPS_TIMEOUT_INIT,	/* Should return SYN-RTO value to use or
-					 * -1 if default value should be used
-					 */
-	BPF_SOCK_OPS_RWND_INIT,		/* Should return initial advertized
-					 * window (in packets) or -1 if default
-					 * value should be used
-					 */
-	BPF_SOCK_OPS_TCP_CONNECT_CB,	/* Calls BPF program right before an
-					 * active connection is initialized
-					 */
-	BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB,	/* Calls BPF program when an
-						 * active connection is
-						 * established
-						 */
-	BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB,	/* Calls BPF program when a
-						 * passive connection is
-						 * established
-						 */
-	BPF_SOCK_OPS_NEEDS_ECN,		/* If connection's congestion control
-					 * needs ECN
-					 */
-};
-
-#define TCP_BPF_IW		1001	/* Set TCP initial congestion window */
-#define TCP_BPF_SNDCWND_CLAMP	1002	/* Set sndcwnd_clamp */
-
-#endif /* __LINUX_BPF_H__ */
diff --git a/include/linux/bpf_common.h b/include/linux/bpf_common.h
deleted file mode 100644
index afe7433..0000000
--- a/include/linux/bpf_common.h
+++ /dev/null
@@ -1,55 +0,0 @@
-#ifndef __LINUX_BPF_COMMON_H__
-#define __LINUX_BPF_COMMON_H__
-
-/* Instruction classes */
-#define BPF_CLASS(code) ((code) & 0x07)
-#define		BPF_LD		0x00
-#define		BPF_LDX		0x01
-#define		BPF_ST		0x02
-#define		BPF_STX		0x03
-#define		BPF_ALU		0x04
-#define		BPF_JMP		0x05
-#define		BPF_RET		0x06
-#define		BPF_MISC        0x07
-
-/* ld/ldx fields */
-#define BPF_SIZE(code)  ((code) & 0x18)
-#define		BPF_W		0x00
-#define		BPF_H		0x08
-#define		BPF_B		0x10
-#define BPF_MODE(code)  ((code) & 0xe0)
-#define		BPF_IMM		0x00
-#define		BPF_ABS		0x20
-#define		BPF_IND		0x40
-#define		BPF_MEM		0x60
-#define		BPF_LEN		0x80
-#define		BPF_MSH		0xa0
-
-/* alu/jmp fields */
-#define BPF_OP(code)    ((code) & 0xf0)
-#define		BPF_ADD		0x00
-#define		BPF_SUB		0x10
-#define		BPF_MUL		0x20
-#define		BPF_DIV		0x30
-#define		BPF_OR		0x40
-#define		BPF_AND		0x50
-#define		BPF_LSH		0x60
-#define		BPF_RSH		0x70
-#define		BPF_NEG		0x80
-#define		BPF_MOD		0x90
-#define		BPF_XOR		0xa0
-
-#define		BPF_JA		0x00
-#define		BPF_JEQ		0x10
-#define		BPF_JGT		0x20
-#define		BPF_JGE		0x30
-#define		BPF_JSET        0x40
-#define BPF_SRC(code)   ((code) & 0x08)
-#define		BPF_K		0x00
-#define		BPF_X		0x08
-
-#ifndef BPF_MAXINSNS
-#define BPF_MAXINSNS 4096
-#endif
-
-#endif /* __LINUX_BPF_COMMON_H__ */
diff --git a/include/linux/can.h b/include/linux/can.h
deleted file mode 100644
index f7a810d..0000000
--- a/include/linux/can.h
+++ /dev/null
@@ -1,201 +0,0 @@
-/*
- * linux/can.h
- *
- * Definitions for CAN network layer (socket addr / CAN frame / CAN filter)
- *
- * Authors: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
- *          Urs Thuermann   <urs.thuermann@volkswagen.de>
- * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of Volkswagen nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * Alternatively, provided that this notice is retained in full, this
- * software may be distributed under the terms of the GNU General
- * Public License ("GPL") version 2, in which case the provisions of the
- * GPL apply INSTEAD OF those given above.
- *
- * The provided data structures and external interfaces from this code
- * are not restricted to be used by modules with a GPL compatible license.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
- * DAMAGE.
- */
-
-#ifndef _CAN_H
-#define _CAN_H
-
-#include <linux/types.h>
-#include <linux/socket.h>
-
-/* controller area network (CAN) kernel definitions */
-
-/* special address description flags for the CAN_ID */
-#define CAN_EFF_FLAG 0x80000000U /* EFF/SFF is set in the MSB */
-#define CAN_RTR_FLAG 0x40000000U /* remote transmission request */
-#define CAN_ERR_FLAG 0x20000000U /* error message frame */
-
-/* valid bits in CAN ID for frame formats */
-#define CAN_SFF_MASK 0x000007FFU /* standard frame format (SFF) */
-#define CAN_EFF_MASK 0x1FFFFFFFU /* extended frame format (EFF) */
-#define CAN_ERR_MASK 0x1FFFFFFFU /* omit EFF, RTR, ERR flags */
-
-/*
- * Controller Area Network Identifier structure
- *
- * bit 0-28	: CAN identifier (11/29 bit)
- * bit 29	: error message frame flag (0 = data frame, 1 = error message)
- * bit 30	: remote transmission request flag (1 = rtr frame)
- * bit 31	: frame format flag (0 = standard 11 bit, 1 = extended 29 bit)
- */
-typedef __u32 canid_t;
-
-#define CAN_SFF_ID_BITS		11
-#define CAN_EFF_ID_BITS		29
-
-/*
- * Controller Area Network Error Message Frame Mask structure
- *
- * bit 0-28	: error class mask (see include/linux/can/error.h)
- * bit 29-31	: set to zero
- */
-typedef __u32 can_err_mask_t;
-
-/* CAN payload length and DLC definitions according to ISO 11898-1 */
-#define CAN_MAX_DLC 8
-#define CAN_MAX_DLEN 8
-
-/* CAN FD payload length and DLC definitions according to ISO 11898-7 */
-#define CANFD_MAX_DLC 15
-#define CANFD_MAX_DLEN 64
-
-/**
- * struct can_frame - basic CAN frame structure
- * @can_id:  CAN ID of the frame and CAN_*_FLAG flags, see canid_t definition
- * @can_dlc: frame payload length in byte (0 .. 8) aka data length code
- *           N.B. the DLC field from ISO 11898-1 Chapter 8.4.2.3 has a 1:1
- *           mapping of the 'data length code' to the real payload length
- * @__pad:   padding
- * @__res0:  reserved / padding
- * @__res1:  reserved / padding
- * @data:    CAN frame payload (up to 8 byte)
- */
-struct can_frame {
-	canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */
-	__u8    can_dlc; /* frame payload length in byte (0 .. CAN_MAX_DLEN) */
-	__u8    __pad;   /* padding */
-	__u8    __res0;  /* reserved / padding */
-	__u8    __res1;  /* reserved / padding */
-	__u8    data[CAN_MAX_DLEN] __attribute__((aligned(8)));
-};
-
-/*
- * defined bits for canfd_frame.flags
- *
- * The use of struct canfd_frame implies the Extended Data Length (EDL) bit to
- * be set in the CAN frame bitstream on the wire. The EDL bit switch turns
- * the CAN controllers bitstream processor into the CAN FD mode which creates
- * two new options within the CAN FD frame specification:
- *
- * Bit Rate Switch - to indicate a second bitrate is/was used for the payload
- * Error State Indicator - represents the error state of the transmitting node
- *
- * As the CANFD_ESI bit is internally generated by the transmitting CAN
- * controller only the CANFD_BRS bit is relevant for real CAN controllers when
- * building a CAN FD frame for transmission. Setting the CANFD_ESI bit can make
- * sense for virtual CAN interfaces to test applications with echoed frames.
- */
-#define CANFD_BRS 0x01 /* bit rate switch (second bitrate for payload data) */
-#define CANFD_ESI 0x02 /* error state indicator of the transmitting node */
-
-/**
- * struct canfd_frame - CAN flexible data rate frame structure
- * @can_id: CAN ID of the frame and CAN_*_FLAG flags, see canid_t definition
- * @len:    frame payload length in byte (0 .. CANFD_MAX_DLEN)
- * @flags:  additional flags for CAN FD
- * @__res0: reserved / padding
- * @__res1: reserved / padding
- * @data:   CAN FD frame payload (up to CANFD_MAX_DLEN byte)
- */
-struct canfd_frame {
-	canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */
-	__u8    len;     /* frame payload length in byte */
-	__u8    flags;   /* additional flags for CAN FD */
-	__u8    __res0;  /* reserved / padding */
-	__u8    __res1;  /* reserved / padding */
-	__u8    data[CANFD_MAX_DLEN] __attribute__((aligned(8)));
-};
-
-#define CAN_MTU		(sizeof(struct can_frame))
-#define CANFD_MTU	(sizeof(struct canfd_frame))
-
-/* particular protocols of the protocol family PF_CAN */
-#define CAN_RAW		1 /* RAW sockets */
-#define CAN_BCM		2 /* Broadcast Manager */
-#define CAN_TP16	3 /* VAG Transport Protocol v1.6 */
-#define CAN_TP20	4 /* VAG Transport Protocol v2.0 */
-#define CAN_MCNET	5 /* Bosch MCNet */
-#define CAN_ISOTP	6 /* ISO 15765-2 Transport Protocol */
-#define CAN_NPROTO	7
-
-#define SOL_CAN_BASE 100
-
-/**
- * struct sockaddr_can - the sockaddr structure for CAN sockets
- * @can_family:  address family number AF_CAN.
- * @can_ifindex: CAN network interface index.
- * @can_addr:    protocol specific address information
- */
-struct sockaddr_can {
-	__kernel_sa_family_t can_family;
-	int         can_ifindex;
-	union {
-		/* transport protocol class address information (e.g. ISOTP) */
-		struct { canid_t rx_id, tx_id; } tp;
-
-		/* reserved for future CAN protocols address information */
-	} can_addr;
-};
-
-/**
- * struct can_filter - CAN ID based filter in can_register().
- * @can_id:   relevant bits of CAN ID which are not masked out.
- * @can_mask: CAN mask (see description)
- *
- * Description:
- * A filter matches, when
- *
- *          <received_can_id> & mask == can_id & mask
- *
- * The filter can be inverted (CAN_INV_FILTER bit set in can_id) or it can
- * filter for error message frames (CAN_ERR_FLAG bit set in mask).
- */
-struct can_filter {
-	canid_t can_id;
-	canid_t can_mask;
-};
-
-#define CAN_INV_FILTER 0x20000000U /* to be set in can_filter.can_id */
-#define CAN_RAW_FILTER_MAX 512 /* maximum number of can_filter set via setsockopt() */
-
-#endif /* !_UAPI_CAN_H */
diff --git a/include/linux/can/netlink.h b/include/linux/can/netlink.h
deleted file mode 100644
index b9214bd..0000000
--- a/include/linux/can/netlink.h
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * linux/can/netlink.h
- *
- * Definitions for the CAN netlink interface
- *
- * Copyright (c) 2009 Wolfgang Grandegger <wg@grandegger.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the version 2 of the GNU General Public License
- * as published by the Free Software Foundation
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- */
-
-#ifndef _CAN_NETLINK_H
-#define _CAN_NETLINK_H
-
-#include <linux/types.h>
-
-/*
- * CAN bit-timing parameters
- *
- * For further information, please read chapter "8 BIT TIMING
- * REQUIREMENTS" of the "Bosch CAN Specification version 2.0"
- * at http://www.semiconductors.bosch.de/pdf/can2spec.pdf.
- */
-struct can_bittiming {
-	__u32 bitrate;		/* Bit-rate in bits/second */
-	__u32 sample_point;	/* Sample point in one-tenth of a percent */
-	__u32 tq;		/* Time quanta (TQ) in nanoseconds */
-	__u32 prop_seg;		/* Propagation segment in TQs */
-	__u32 phase_seg1;	/* Phase buffer segment 1 in TQs */
-	__u32 phase_seg2;	/* Phase buffer segment 2 in TQs */
-	__u32 sjw;		/* Synchronisation jump width in TQs */
-	__u32 brp;		/* Bit-rate prescaler */
-};
-
-/*
- * CAN harware-dependent bit-timing constant
- *
- * Used for calculating and checking bit-timing parameters
- */
-struct can_bittiming_const {
-	char name[16];		/* Name of the CAN controller hardware */
-	__u32 tseg1_min;	/* Time segement 1 = prop_seg + phase_seg1 */
-	__u32 tseg1_max;
-	__u32 tseg2_min;	/* Time segement 2 = phase_seg2 */
-	__u32 tseg2_max;
-	__u32 sjw_max;		/* Synchronisation jump width */
-	__u32 brp_min;		/* Bit-rate prescaler */
-	__u32 brp_max;
-	__u32 brp_inc;
-};
-
-/*
- * CAN clock parameters
- */
-struct can_clock {
-	__u32 freq;		/* CAN system clock frequency in Hz */
-};
-
-/*
- * CAN operational and error states
- */
-enum can_state {
-	CAN_STATE_ERROR_ACTIVE = 0,	/* RX/TX error count < 96 */
-	CAN_STATE_ERROR_WARNING,	/* RX/TX error count < 128 */
-	CAN_STATE_ERROR_PASSIVE,	/* RX/TX error count < 256 */
-	CAN_STATE_BUS_OFF,		/* RX/TX error count >= 256 */
-	CAN_STATE_STOPPED,		/* Device is stopped */
-	CAN_STATE_SLEEPING,		/* Device is sleeping */
-	CAN_STATE_MAX
-};
-
-/*
- * CAN bus error counters
- */
-struct can_berr_counter {
-	__u16 txerr;
-	__u16 rxerr;
-};
-
-/*
- * CAN controller mode
- */
-struct can_ctrlmode {
-	__u32 mask;
-	__u32 flags;
-};
-
-#define CAN_CTRLMODE_LOOPBACK		0x01	/* Loopback mode */
-#define CAN_CTRLMODE_LISTENONLY		0x02	/* Listen-only mode */
-#define CAN_CTRLMODE_3_SAMPLES		0x04	/* Triple sampling mode */
-#define CAN_CTRLMODE_ONE_SHOT		0x08	/* One-Shot mode */
-#define CAN_CTRLMODE_BERR_REPORTING	0x10	/* Bus-error reporting */
-#define CAN_CTRLMODE_FD			0x20	/* CAN FD mode */
-#define CAN_CTRLMODE_PRESUME_ACK	0x40	/* Ignore missing CAN ACKs */
-#define CAN_CTRLMODE_FD_NON_ISO		0x80	/* CAN FD in non-ISO mode */
-
-/*
- * CAN device statistics
- */
-struct can_device_stats {
-	__u32 bus_error;	/* Bus errors */
-	__u32 error_warning;	/* Changes to error warning state */
-	__u32 error_passive;	/* Changes to error passive state */
-	__u32 bus_off;		/* Changes to bus off state */
-	__u32 arbitration_lost; /* Arbitration lost errors */
-	__u32 restarts;		/* CAN controller re-starts */
-};
-
-/*
- * CAN netlink interface
- */
-enum {
-	IFLA_CAN_UNSPEC,
-	IFLA_CAN_BITTIMING,
-	IFLA_CAN_BITTIMING_CONST,
-	IFLA_CAN_CLOCK,
-	IFLA_CAN_STATE,
-	IFLA_CAN_CTRLMODE,
-	IFLA_CAN_RESTART_MS,
-	IFLA_CAN_RESTART,
-	IFLA_CAN_BERR_COUNTER,
-	IFLA_CAN_DATA_BITTIMING,
-	IFLA_CAN_DATA_BITTIMING_CONST,
-	IFLA_CAN_TERMINATION,
-	IFLA_CAN_TERMINATION_CONST,
-	IFLA_CAN_BITRATE_CONST,
-	IFLA_CAN_DATA_BITRATE_CONST,
-	__IFLA_CAN_MAX
-};
-
-#define IFLA_CAN_MAX	(__IFLA_CAN_MAX - 1)
-
-/* u16 termination range: 1..65535 Ohms */
-#define CAN_TERMINATION_DISABLED 0
-
-#endif /* !_UAPI_CAN_NETLINK_H */
diff --git a/include/linux/can/vxcan.h b/include/linux/can/vxcan.h
deleted file mode 100644
index 5b29e8a..0000000
--- a/include/linux/can/vxcan.h
+++ /dev/null
@@ -1,12 +0,0 @@
-#ifndef _CAN_VXCAN_H
-#define _CAN_VXCAN_H
-
-enum {
-	VXCAN_INFO_UNSPEC,
-	VXCAN_INFO_PEER,
-
-	__VXCAN_INFO_MAX
-#define VXCAN_INFO_MAX	(__VXCAN_INFO_MAX - 1)
-};
-
-#endif
diff --git a/include/linux/devlink.h b/include/linux/devlink.h
deleted file mode 100644
index a62695e..0000000
--- a/include/linux/devlink.h
+++ /dev/null
@@ -1,247 +0,0 @@
-/*
- * include/uapi/linux/devlink.h - Network physical device Netlink interface
- * Copyright (c) 2016 Mellanox Technologies. All rights reserved.
- * Copyright (c) 2016 Jiri Pirko <jiri@mellanox.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#ifndef _LINUX_DEVLINK_H_
-#define _LINUX_DEVLINK_H_
-
-#define DEVLINK_GENL_NAME "devlink"
-#define DEVLINK_GENL_VERSION 0x1
-#define DEVLINK_GENL_MCGRP_CONFIG_NAME "config"
-
-enum devlink_command {
-	/* don't change the order or add anything between, this is ABI! */
-	DEVLINK_CMD_UNSPEC,
-
-	DEVLINK_CMD_GET,		/* can dump */
-	DEVLINK_CMD_SET,
-	DEVLINK_CMD_NEW,
-	DEVLINK_CMD_DEL,
-
-	DEVLINK_CMD_PORT_GET,		/* can dump */
-	DEVLINK_CMD_PORT_SET,
-	DEVLINK_CMD_PORT_NEW,
-	DEVLINK_CMD_PORT_DEL,
-
-	DEVLINK_CMD_PORT_SPLIT,
-	DEVLINK_CMD_PORT_UNSPLIT,
-
-	DEVLINK_CMD_SB_GET,		/* can dump */
-	DEVLINK_CMD_SB_SET,
-	DEVLINK_CMD_SB_NEW,
-	DEVLINK_CMD_SB_DEL,
-
-	DEVLINK_CMD_SB_POOL_GET,	/* can dump */
-	DEVLINK_CMD_SB_POOL_SET,
-	DEVLINK_CMD_SB_POOL_NEW,
-	DEVLINK_CMD_SB_POOL_DEL,
-
-	DEVLINK_CMD_SB_PORT_POOL_GET,	/* can dump */
-	DEVLINK_CMD_SB_PORT_POOL_SET,
-	DEVLINK_CMD_SB_PORT_POOL_NEW,
-	DEVLINK_CMD_SB_PORT_POOL_DEL,
-
-	DEVLINK_CMD_SB_TC_POOL_BIND_GET,	/* can dump */
-	DEVLINK_CMD_SB_TC_POOL_BIND_SET,
-	DEVLINK_CMD_SB_TC_POOL_BIND_NEW,
-	DEVLINK_CMD_SB_TC_POOL_BIND_DEL,
-
-	/* Shared buffer occupancy monitoring commands */
-	DEVLINK_CMD_SB_OCC_SNAPSHOT,
-	DEVLINK_CMD_SB_OCC_MAX_CLEAR,
-
-	DEVLINK_CMD_ESWITCH_GET,
-#define DEVLINK_CMD_ESWITCH_MODE_GET /* obsolete, never use this! */ \
-	DEVLINK_CMD_ESWITCH_GET
-
-	DEVLINK_CMD_ESWITCH_SET,
-#define DEVLINK_CMD_ESWITCH_MODE_SET /* obsolete, never use this! */ \
-	DEVLINK_CMD_ESWITCH_SET
-
-	DEVLINK_CMD_DPIPE_TABLE_GET,
-	DEVLINK_CMD_DPIPE_ENTRIES_GET,
-	DEVLINK_CMD_DPIPE_HEADERS_GET,
-	DEVLINK_CMD_DPIPE_TABLE_COUNTERS_SET,
-
-	/* add new commands above here */
-	__DEVLINK_CMD_MAX,
-	DEVLINK_CMD_MAX = __DEVLINK_CMD_MAX - 1
-};
-
-enum devlink_port_type {
-	DEVLINK_PORT_TYPE_NOTSET,
-	DEVLINK_PORT_TYPE_AUTO,
-	DEVLINK_PORT_TYPE_ETH,
-	DEVLINK_PORT_TYPE_IB,
-};
-
-enum devlink_sb_pool_type {
-	DEVLINK_SB_POOL_TYPE_INGRESS,
-	DEVLINK_SB_POOL_TYPE_EGRESS,
-};
-
-/* static threshold - limiting the maximum number of bytes.
- * dynamic threshold - limiting the maximum number of bytes
- *   based on the currently available free space in the shared buffer pool.
- *   In this mode, the maximum quota is calculated based
- *   on the following formula:
- *     max_quota = alpha / (1 + alpha) * Free_Buffer
- *   While Free_Buffer is the amount of none-occupied buffer associated to
- *   the relevant pool.
- *   The value range which can be passed is 0-20 and serves
- *   for computation of alpha by following formula:
- *     alpha = 2 ^ (passed_value - 10)
- */
-
-enum devlink_sb_threshold_type {
-	DEVLINK_SB_THRESHOLD_TYPE_STATIC,
-	DEVLINK_SB_THRESHOLD_TYPE_DYNAMIC,
-};
-
-#define DEVLINK_SB_THRESHOLD_TO_ALPHA_MAX 20
-
-enum devlink_eswitch_mode {
-	DEVLINK_ESWITCH_MODE_LEGACY,
-	DEVLINK_ESWITCH_MODE_SWITCHDEV,
-};
-
-enum devlink_eswitch_inline_mode {
-	DEVLINK_ESWITCH_INLINE_MODE_NONE,
-	DEVLINK_ESWITCH_INLINE_MODE_LINK,
-	DEVLINK_ESWITCH_INLINE_MODE_NETWORK,
-	DEVLINK_ESWITCH_INLINE_MODE_TRANSPORT,
-};
-
-enum devlink_eswitch_encap_mode {
-	DEVLINK_ESWITCH_ENCAP_MODE_NONE,
-	DEVLINK_ESWITCH_ENCAP_MODE_BASIC,
-};
-
-enum devlink_attr {
-	/* don't change the order or add anything between, this is ABI! */
-	DEVLINK_ATTR_UNSPEC,
-
-	/* bus name + dev name together are a handle for devlink entity */
-	DEVLINK_ATTR_BUS_NAME,			/* string */
-	DEVLINK_ATTR_DEV_NAME,			/* string */
-
-	DEVLINK_ATTR_PORT_INDEX,		/* u32 */
-	DEVLINK_ATTR_PORT_TYPE,			/* u16 */
-	DEVLINK_ATTR_PORT_DESIRED_TYPE,		/* u16 */
-	DEVLINK_ATTR_PORT_NETDEV_IFINDEX,	/* u32 */
-	DEVLINK_ATTR_PORT_NETDEV_NAME,		/* string */
-	DEVLINK_ATTR_PORT_IBDEV_NAME,		/* string */
-	DEVLINK_ATTR_PORT_SPLIT_COUNT,		/* u32 */
-	DEVLINK_ATTR_PORT_SPLIT_GROUP,		/* u32 */
-	DEVLINK_ATTR_SB_INDEX,			/* u32 */
-	DEVLINK_ATTR_SB_SIZE,			/* u32 */
-	DEVLINK_ATTR_SB_INGRESS_POOL_COUNT,	/* u16 */
-	DEVLINK_ATTR_SB_EGRESS_POOL_COUNT,	/* u16 */
-	DEVLINK_ATTR_SB_INGRESS_TC_COUNT,	/* u16 */
-	DEVLINK_ATTR_SB_EGRESS_TC_COUNT,	/* u16 */
-	DEVLINK_ATTR_SB_POOL_INDEX,		/* u16 */
-	DEVLINK_ATTR_SB_POOL_TYPE,		/* u8 */
-	DEVLINK_ATTR_SB_POOL_SIZE,		/* u32 */
-	DEVLINK_ATTR_SB_POOL_THRESHOLD_TYPE,	/* u8 */
-	DEVLINK_ATTR_SB_THRESHOLD,		/* u32 */
-	DEVLINK_ATTR_SB_TC_INDEX,		/* u16 */
-	DEVLINK_ATTR_SB_OCC_CUR,		/* u32 */
-	DEVLINK_ATTR_SB_OCC_MAX,		/* u32 */
-	DEVLINK_ATTR_ESWITCH_MODE,		/* u16 */
-	DEVLINK_ATTR_ESWITCH_INLINE_MODE,	/* u8 */
-
-	DEVLINK_ATTR_DPIPE_TABLES,		/* nested */
-	DEVLINK_ATTR_DPIPE_TABLE,		/* nested */
-	DEVLINK_ATTR_DPIPE_TABLE_NAME,		/* string */
-	DEVLINK_ATTR_DPIPE_TABLE_SIZE,		/* u64 */
-	DEVLINK_ATTR_DPIPE_TABLE_MATCHES,	/* nested */
-	DEVLINK_ATTR_DPIPE_TABLE_ACTIONS,	/* nested */
-	DEVLINK_ATTR_DPIPE_TABLE_COUNTERS_ENABLED,	/* u8 */
-
-	DEVLINK_ATTR_DPIPE_ENTRIES,		/* nested */
-	DEVLINK_ATTR_DPIPE_ENTRY,		/* nested */
-	DEVLINK_ATTR_DPIPE_ENTRY_INDEX,		/* u64 */
-	DEVLINK_ATTR_DPIPE_ENTRY_MATCH_VALUES,	/* nested */
-	DEVLINK_ATTR_DPIPE_ENTRY_ACTION_VALUES,	/* nested */
-	DEVLINK_ATTR_DPIPE_ENTRY_COUNTER,	/* u64 */
-
-	DEVLINK_ATTR_DPIPE_MATCH,		/* nested */
-	DEVLINK_ATTR_DPIPE_MATCH_VALUE,		/* nested */
-	DEVLINK_ATTR_DPIPE_MATCH_TYPE,		/* u32 */
-
-	DEVLINK_ATTR_DPIPE_ACTION,		/* nested */
-	DEVLINK_ATTR_DPIPE_ACTION_VALUE,	/* nested */
-	DEVLINK_ATTR_DPIPE_ACTION_TYPE,		/* u32 */
-
-	DEVLINK_ATTR_DPIPE_VALUE,
-	DEVLINK_ATTR_DPIPE_VALUE_MASK,
-	DEVLINK_ATTR_DPIPE_VALUE_MAPPING,	/* u32 */
-
-	DEVLINK_ATTR_DPIPE_HEADERS,		/* nested */
-	DEVLINK_ATTR_DPIPE_HEADER,		/* nested */
-	DEVLINK_ATTR_DPIPE_HEADER_NAME,		/* string */
-	DEVLINK_ATTR_DPIPE_HEADER_ID,		/* u32 */
-	DEVLINK_ATTR_DPIPE_HEADER_FIELDS,	/* nested */
-	DEVLINK_ATTR_DPIPE_HEADER_GLOBAL,	/* u8 */
-	DEVLINK_ATTR_DPIPE_HEADER_INDEX,	/* u32 */
-
-	DEVLINK_ATTR_DPIPE_FIELD,		/* nested */
-	DEVLINK_ATTR_DPIPE_FIELD_NAME,		/* string */
-	DEVLINK_ATTR_DPIPE_FIELD_ID,		/* u32 */
-	DEVLINK_ATTR_DPIPE_FIELD_BITWIDTH,	/* u32 */
-	DEVLINK_ATTR_DPIPE_FIELD_MAPPING_TYPE,	/* u32 */
-
-	DEVLINK_ATTR_PAD,
-
-	DEVLINK_ATTR_ESWITCH_ENCAP_MODE,	/* u8 */
-
-	/* add new attributes above here, update the policy in devlink.c */
-
-	__DEVLINK_ATTR_MAX,
-	DEVLINK_ATTR_MAX = __DEVLINK_ATTR_MAX - 1
-};
-
-/* Mapping between internal resource described by the field and system
- * structure
- */
-enum devlink_dpipe_field_mapping_type {
-	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_NONE,
-	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_IFINDEX,
-};
-
-/* Match type - specify the type of the match */
-enum devlink_dpipe_match_type {
-	DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT,
-};
-
-/* Action type - specify the action type */
-enum devlink_dpipe_action_type {
-	DEVLINK_DPIPE_ACTION_TYPE_FIELD_MODIFY,
-};
-
-enum devlink_dpipe_field_ethernet_id {
-	DEVLINK_DPIPE_FIELD_ETHERNET_DST_MAC,
-};
-
-enum devlink_dpipe_field_ipv4_id {
-	DEVLINK_DPIPE_FIELD_IPV4_DST_IP,
-};
-
-enum devlink_dpipe_field_ipv6_id {
-	DEVLINK_DPIPE_FIELD_IPV6_DST_IP,
-};
-
-enum devlink_dpipe_header_id {
-	DEVLINK_DPIPE_HEADER_ETHERNET,
-	DEVLINK_DPIPE_HEADER_IPV4,
-	DEVLINK_DPIPE_HEADER_IPV6,
-};
-
-#endif /* _LINUX_DEVLINK_H_ */
diff --git a/include/linux/elf-em.h b/include/linux/elf-em.h
deleted file mode 100644
index 9cd1de9..0000000
--- a/include/linux/elf-em.h
+++ /dev/null
@@ -1,60 +0,0 @@
-#ifndef _LINUX_ELF_EM_H
-#define _LINUX_ELF_EM_H
-
-/* These constants define the various ELF target machines */
-#define EM_NONE		0
-#define EM_M32		1
-#define EM_SPARC	2
-#define EM_386		3
-#define EM_68K		4
-#define EM_88K		5
-#define EM_486		6	/* Perhaps disused */
-#define EM_860		7
-#define EM_MIPS		8	/* MIPS R3000 (officially, big-endian only) */
-				/* Next two are historical and binaries and
-				   modules of these types will be rejected by
-				   Linux.  */
-#define EM_MIPS_RS3_LE	10	/* MIPS R3000 little-endian */
-#define EM_MIPS_RS4_BE	10	/* MIPS R4000 big-endian */
-
-#define EM_PARISC	15	/* HPPA */
-#define EM_SPARC32PLUS	18	/* Sun's "v8plus" */
-#define EM_PPC		20	/* PowerPC */
-#define EM_PPC64	21	 /* PowerPC64 */
-#define EM_SPU		23	/* Cell BE SPU */
-#define EM_ARM		40	/* ARM 32 bit */
-#define EM_SH		42	/* SuperH */
-#define EM_SPARCV9	43	/* SPARC v9 64-bit */
-#define EM_H8_300	46	/* Renesas H8/300 */
-#define EM_IA_64	50	/* HP/Intel IA-64 */
-#define EM_X86_64	62	/* AMD x86-64 */
-#define EM_S390		22	/* IBM S/390 */
-#define EM_CRIS		76	/* Axis Communications 32-bit embedded processor */
-#define EM_M32R		88	/* Renesas M32R */
-#define EM_MN10300	89	/* Panasonic/MEI MN10300, AM33 */
-#define EM_OPENRISC     92     /* OpenRISC 32-bit embedded processor */
-#define EM_BLACKFIN     106     /* ADI Blackfin Processor */
-#define EM_ALTERA_NIOS2	113	/* Altera Nios II soft-core processor */
-#define EM_TI_C6000	140	/* TI C6X DSPs */
-#define EM_AARCH64	183	/* ARM 64 bit */
-#define EM_TILEPRO	188	/* Tilera TILEPro */
-#define EM_MICROBLAZE	189	/* Xilinx MicroBlaze */
-#define EM_TILEGX	191	/* Tilera TILE-Gx */
-#define EM_BPF		247	/* Linux BPF - in-kernel virtual machine */
-#define EM_FRV		0x5441	/* Fujitsu FR-V */
-
-/*
- * This is an interim value that we will use until the committee comes
- * up with a final number.
- */
-#define EM_ALPHA	0x9026
-
-/* Bogus old m32r magic number, used by old tools. */
-#define EM_CYGNUS_M32R	0x9041
-/* This is the old interim value for S/390 architecture */
-#define EM_S390_OLD	0xA390
-/* Also Panasonic/MEI MN10300, AM33 */
-#define EM_CYGNUS_MN10300 0xbeef
-
-
-#endif /* _LINUX_ELF_EM_H */
diff --git a/include/linux/fib_rules.h b/include/linux/fib_rules.h
deleted file mode 100644
index bbf02a6..0000000
--- a/include/linux/fib_rules.h
+++ /dev/null
@@ -1,80 +0,0 @@
-#ifndef __LINUX_FIB_RULES_H
-#define __LINUX_FIB_RULES_H
-
-#include <linux/types.h>
-#include <linux/rtnetlink.h>
-
-/* rule is permanent, and cannot be deleted */
-#define FIB_RULE_PERMANENT	0x00000001
-#define FIB_RULE_INVERT		0x00000002
-#define FIB_RULE_UNRESOLVED	0x00000004
-#define FIB_RULE_IIF_DETACHED	0x00000008
-#define FIB_RULE_DEV_DETACHED	FIB_RULE_IIF_DETACHED
-#define FIB_RULE_OIF_DETACHED	0x00000010
-
-/* try to find source address in routing lookups */
-#define FIB_RULE_FIND_SADDR	0x00010000
-
-struct fib_rule_hdr {
-	__u8		family;
-	__u8		dst_len;
-	__u8		src_len;
-	__u8		tos;
-
-	__u8		table;
-	__u8		res1;	/* reserved */
-	__u8		res2;	/* reserved */
-	__u8		action;
-
-	__u32		flags;
-};
-
-struct fib_rule_uid_range {
-	__u32		start;
-	__u32		end;
-};
-
-enum {
-	FRA_UNSPEC,
-	FRA_DST,	/* destination address */
-	FRA_SRC,	/* source address */
-	FRA_IIFNAME,	/* interface name */
-#define FRA_IFNAME	FRA_IIFNAME
-	FRA_GOTO,	/* target to jump to (FR_ACT_GOTO) */
-	FRA_UNUSED2,
-	FRA_PRIORITY,	/* priority/preference */
-	FRA_UNUSED3,
-	FRA_UNUSED4,
-	FRA_UNUSED5,
-	FRA_FWMARK,	/* mark */
-	FRA_FLOW,	/* flow/class id */
-	FRA_TUN_ID,
-	FRA_SUPPRESS_IFGROUP,
-	FRA_SUPPRESS_PREFIXLEN,
-	FRA_TABLE,	/* Extended table id */
-	FRA_FWMASK,	/* mask for netfilter mark */
-	FRA_OIFNAME,
-	FRA_PAD,
-	FRA_L3MDEV,	/* iif or oif is l3mdev goto its table */
-	FRA_UID_RANGE,	/* UID range */
-	__FRA_MAX
-};
-
-#define FRA_MAX (__FRA_MAX - 1)
-
-enum {
-	FR_ACT_UNSPEC,
-	FR_ACT_TO_TBL,		/* Pass to fixed table */
-	FR_ACT_GOTO,		/* Jump to another rule */
-	FR_ACT_NOP,		/* No operation */
-	FR_ACT_RES3,
-	FR_ACT_RES4,
-	FR_ACT_BLACKHOLE,	/* Drop without notification */
-	FR_ACT_UNREACHABLE,	/* Drop with ENETUNREACH */
-	FR_ACT_PROHIBIT,	/* Drop with EACCES */
-	__FR_ACT_MAX,
-};
-
-#define FR_ACT_MAX (__FR_ACT_MAX - 1)
-
-#endif
diff --git a/include/linux/filter.h b/include/linux/filter.h
deleted file mode 100644
index e4f2f74..0000000
--- a/include/linux/filter.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Linux Socket Filter Data Structures
- */
-
-#ifndef __LINUX_FILTER_H__
-#define __LINUX_FILTER_H__
-
-
-#include <linux/types.h>
-#include <linux/bpf_common.h>
-
-/*
- * Current version of the filter code architecture.
- */
-#define BPF_MAJOR_VERSION 1
-#define BPF_MINOR_VERSION 1
-
-/*
- *	Try and keep these values and structures similar to BSD, especially
- *	the BPF code definitions which need to match so you can share filters
- */
- 
-struct sock_filter {	/* Filter block */
-	__u16	code;   /* Actual filter code */
-	__u8	jt;	/* Jump true */
-	__u8	jf;	/* Jump false */
-	__u32	k;      /* Generic multiuse field */
-};
-
-struct sock_fprog {	/* Required for SO_ATTACH_FILTER. */
-	unsigned short		len;	/* Number of filter blocks */
-	struct sock_filter *filter;
-};
-
-/* ret - BPF_K and BPF_X also apply */
-#define BPF_RVAL(code)  ((code) & 0x18)
-#define         BPF_A           0x10
-
-/* misc */
-#define BPF_MISCOP(code) ((code) & 0xf8)
-#define         BPF_TAX         0x00
-#define         BPF_TXA         0x80
-
-/*
- * Macros for filter block array initializers.
- */
-#ifndef BPF_STMT
-#define BPF_STMT(code, k) { (unsigned short)(code), 0, 0, k }
-#endif
-#ifndef BPF_JUMP
-#define BPF_JUMP(code, k, jt, jf) { (unsigned short)(code), jt, jf, k }
-#endif
-
-/*
- * Number of scratch memory words for: BPF_ST and BPF_STX
- */
-#define BPF_MEMWORDS 16
-
-/* RATIONALE. Negative offsets are invalid in BPF.
-   We use them to reference ancillary data.
-   Unlike introduction new instructions, it does not break
-   existing compilers/optimizers.
- */
-#define SKF_AD_OFF    (-0x1000)
-#define SKF_AD_PROTOCOL 0
-#define SKF_AD_PKTTYPE 	4
-#define SKF_AD_IFINDEX 	8
-#define SKF_AD_NLATTR	12
-#define SKF_AD_NLATTR_NEST	16
-#define SKF_AD_MARK 	20
-#define SKF_AD_QUEUE	24
-#define SKF_AD_HATYPE	28
-#define SKF_AD_RXHASH	32
-#define SKF_AD_CPU	36
-#define SKF_AD_ALU_XOR_X	40
-#define SKF_AD_VLAN_TAG	44
-#define SKF_AD_VLAN_TAG_PRESENT 48
-#define SKF_AD_PAY_OFFSET	52
-#define SKF_AD_RANDOM	56
-#define SKF_AD_VLAN_TPID	60
-#define SKF_AD_MAX	64
-
-#define SKF_NET_OFF	(-0x100000)
-#define SKF_LL_OFF	(-0x200000)
-
-#define BPF_NET_OFF	SKF_NET_OFF
-#define BPF_LL_OFF	SKF_LL_OFF
-
-#endif /* __LINUX_FILTER_H__ */
diff --git a/include/linux/fou.h b/include/linux/fou.h
deleted file mode 100644
index 744c323..0000000
--- a/include/linux/fou.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/* fou.h - FOU Interface */
-
-#ifndef _LINUX_FOU_H
-#define _LINUX_FOU_H
-
-/* NETLINK_GENERIC related info
- */
-#define FOU_GENL_NAME		"fou"
-#define FOU_GENL_VERSION	0x1
-
-enum {
-	FOU_ATTR_UNSPEC,
-	FOU_ATTR_PORT,				/* u16 */
-	FOU_ATTR_AF,				/* u8 */
-	FOU_ATTR_IPPROTO,			/* u8 */
-	FOU_ATTR_TYPE,				/* u8 */
-	FOU_ATTR_REMCSUM_NOPARTIAL,		/* flag */
-
-	__FOU_ATTR_MAX,
-};
-
-#define FOU_ATTR_MAX		(__FOU_ATTR_MAX - 1)
-
-enum {
-	FOU_CMD_UNSPEC,
-	FOU_CMD_ADD,
-	FOU_CMD_DEL,
-	FOU_CMD_GET,
-
-	__FOU_CMD_MAX,
-};
-
-enum {
-	FOU_ENCAP_UNSPEC,
-	FOU_ENCAP_DIRECT,
-	FOU_ENCAP_GUE,
-};
-
-#define FOU_CMD_MAX	(__FOU_CMD_MAX - 1)
-
-#endif /* _LINUX_FOU_H */
diff --git a/include/linux/gen_stats.h b/include/linux/gen_stats.h
deleted file mode 100644
index 52deccc..0000000
--- a/include/linux/gen_stats.h
+++ /dev/null
@@ -1,79 +0,0 @@
-#ifndef __LINUX_GEN_STATS_H
-#define __LINUX_GEN_STATS_H
-
-#include <linux/types.h>
-
-enum {
-	TCA_STATS_UNSPEC,
-	TCA_STATS_BASIC,
-	TCA_STATS_RATE_EST,
-	TCA_STATS_QUEUE,
-	TCA_STATS_APP,
-	TCA_STATS_RATE_EST64,
-	TCA_STATS_PAD,
-	__TCA_STATS_MAX,
-};
-#define TCA_STATS_MAX (__TCA_STATS_MAX - 1)
-
-/**
- * struct gnet_stats_basic - byte/packet throughput statistics
- * @bytes: number of seen bytes
- * @packets: number of seen packets
- */
-struct gnet_stats_basic {
-	__u64	bytes;
-	__u32	packets;
-};
-struct gnet_stats_basic_packed {
-	__u64	bytes;
-	__u32	packets;
-} __attribute__ ((packed));
-
-/**
- * struct gnet_stats_rate_est - rate estimator
- * @bps: current byte rate
- * @pps: current packet rate
- */
-struct gnet_stats_rate_est {
-	__u32	bps;
-	__u32	pps;
-};
-
-/**
- * struct gnet_stats_rate_est64 - rate estimator
- * @bps: current byte rate
- * @pps: current packet rate
- */
-struct gnet_stats_rate_est64 {
-	__u64	bps;
-	__u64	pps;
-};
-
-/**
- * struct gnet_stats_queue - queuing statistics
- * @qlen: queue length
- * @backlog: backlog size of queue
- * @drops: number of dropped packets
- * @requeues: number of requeues
- * @overlimits: number of enqueues over the limit
- */
-struct gnet_stats_queue {
-	__u32	qlen;
-	__u32	backlog;
-	__u32	drops;
-	__u32	requeues;
-	__u32	overlimits;
-};
-
-/**
- * struct gnet_estimator - rate estimator configuration
- * @interval: sampling period
- * @ewma_log: the log of measurement window weight
- */
-struct gnet_estimator {
-	signed char	interval;
-	unsigned char	ewma_log;
-};
-
-
-#endif /* __LINUX_GEN_STATS_H */
diff --git a/include/linux/genetlink.h b/include/linux/genetlink.h
deleted file mode 100644
index 08239d8..0000000
--- a/include/linux/genetlink.h
+++ /dev/null
@@ -1,88 +0,0 @@
-#ifndef __LINUX_GENERIC_NETLINK_H
-#define __LINUX_GENERIC_NETLINK_H
-
-#include <linux/types.h>
-#include <linux/netlink.h>
-
-#define GENL_NAMSIZ	16	/* length of family name */
-
-#define GENL_MIN_ID	NLMSG_MIN_TYPE
-#define GENL_MAX_ID	1023
-
-struct genlmsghdr {
-	__u8	cmd;
-	__u8	version;
-	__u16	reserved;
-};
-
-#define GENL_HDRLEN	NLMSG_ALIGN(sizeof(struct genlmsghdr))
-
-#define GENL_ADMIN_PERM		0x01
-#define GENL_CMD_CAP_DO		0x02
-#define GENL_CMD_CAP_DUMP	0x04
-#define GENL_CMD_CAP_HASPOL	0x08
-#define GENL_UNS_ADMIN_PERM	0x10
-
-/*
- * List of reserved static generic netlink identifiers:
- */
-#define GENL_ID_CTRL		NLMSG_MIN_TYPE
-#define GENL_ID_VFS_DQUOT	(NLMSG_MIN_TYPE + 1)
-#define GENL_ID_PMCRAID		(NLMSG_MIN_TYPE + 2)
-/* must be last reserved + 1 */
-#define GENL_START_ALLOC	(NLMSG_MIN_TYPE + 3)
-
-/**************************************************************************
- * Controller
- **************************************************************************/
-
-enum {
-	CTRL_CMD_UNSPEC,
-	CTRL_CMD_NEWFAMILY,
-	CTRL_CMD_DELFAMILY,
-	CTRL_CMD_GETFAMILY,
-	CTRL_CMD_NEWOPS,
-	CTRL_CMD_DELOPS,
-	CTRL_CMD_GETOPS,
-	CTRL_CMD_NEWMCAST_GRP,
-	CTRL_CMD_DELMCAST_GRP,
-	CTRL_CMD_GETMCAST_GRP, /* unused */
-	__CTRL_CMD_MAX,
-};
-
-#define CTRL_CMD_MAX (__CTRL_CMD_MAX - 1)
-
-enum {
-	CTRL_ATTR_UNSPEC,
-	CTRL_ATTR_FAMILY_ID,
-	CTRL_ATTR_FAMILY_NAME,
-	CTRL_ATTR_VERSION,
-	CTRL_ATTR_HDRSIZE,
-	CTRL_ATTR_MAXATTR,
-	CTRL_ATTR_OPS,
-	CTRL_ATTR_MCAST_GROUPS,
-	__CTRL_ATTR_MAX,
-};
-
-#define CTRL_ATTR_MAX (__CTRL_ATTR_MAX - 1)
-
-enum {
-	CTRL_ATTR_OP_UNSPEC,
-	CTRL_ATTR_OP_ID,
-	CTRL_ATTR_OP_FLAGS,
-	__CTRL_ATTR_OP_MAX,
-};
-
-#define CTRL_ATTR_OP_MAX (__CTRL_ATTR_OP_MAX - 1)
-
-enum {
-	CTRL_ATTR_MCAST_GRP_UNSPEC,
-	CTRL_ATTR_MCAST_GRP_NAME,
-	CTRL_ATTR_MCAST_GRP_ID,
-	__CTRL_ATTR_MCAST_GRP_MAX,
-};
-
-#define CTRL_ATTR_MCAST_GRP_MAX (__CTRL_ATTR_MCAST_GRP_MAX - 1)
-
-
-#endif /* __LINUX_GENERIC_NETLINK_H */
diff --git a/include/linux/hdlc/ioctl.h b/include/linux/hdlc/ioctl.h
deleted file mode 100644
index 04bc027..0000000
--- a/include/linux/hdlc/ioctl.h
+++ /dev/null
@@ -1,84 +0,0 @@
-#ifndef __HDLC_IOCTL_H__
-#define __HDLC_IOCTL_H__
-
-
-#define GENERIC_HDLC_VERSION 4	/* For synchronization with sethdlc utility */
-
-#define CLOCK_DEFAULT   0	/* Default setting */
-#define CLOCK_EXT	1	/* External TX and RX clock - DTE */
-#define CLOCK_INT	2	/* Internal TX and RX clock - DCE */
-#define CLOCK_TXINT	3	/* Internal TX and external RX clock */
-#define CLOCK_TXFROMRX	4	/* TX clock derived from external RX clock */
-
-
-#define ENCODING_DEFAULT	0 /* Default setting */
-#define ENCODING_NRZ		1
-#define ENCODING_NRZI		2
-#define ENCODING_FM_MARK	3
-#define ENCODING_FM_SPACE	4
-#define ENCODING_MANCHESTER	5
-
-
-#define PARITY_DEFAULT		0 /* Default setting */
-#define PARITY_NONE		1 /* No parity */
-#define PARITY_CRC16_PR0	2 /* CRC16, initial value 0x0000 */
-#define PARITY_CRC16_PR1	3 /* CRC16, initial value 0xFFFF */
-#define PARITY_CRC16_PR0_CCITT	4 /* CRC16, initial 0x0000, ITU-T version */
-#define PARITY_CRC16_PR1_CCITT	5 /* CRC16, initial 0xFFFF, ITU-T version */
-#define PARITY_CRC32_PR0_CCITT	6 /* CRC32, initial value 0x00000000 */
-#define PARITY_CRC32_PR1_CCITT	7 /* CRC32, initial value 0xFFFFFFFF */
-
-#define LMI_DEFAULT		0 /* Default setting */
-#define LMI_NONE		1 /* No LMI, all PVCs are static */
-#define LMI_ANSI		2 /* ANSI Annex D */
-#define LMI_CCITT		3 /* ITU-T Annex A */
-#define LMI_CISCO		4 /* The "original" LMI, aka Gang of Four */
-
-#ifndef __ASSEMBLY__
-
-typedef struct {
-	unsigned int clock_rate; /* bits per second */
-	unsigned int clock_type; /* internal, external, TX-internal etc. */
-	unsigned short loopback;
-} sync_serial_settings;          /* V.35, V.24, X.21 */
-
-typedef struct {
-	unsigned int clock_rate; /* bits per second */
-	unsigned int clock_type; /* internal, external, TX-internal etc. */
-	unsigned short loopback;
-	unsigned int slot_map;
-} te1_settings;                  /* T1, E1 */
-
-typedef struct {
-	unsigned short encoding;
-	unsigned short parity;
-} raw_hdlc_proto;
-
-typedef struct {
-	unsigned int t391;
-	unsigned int t392;
-	unsigned int n391;
-	unsigned int n392;
-	unsigned int n393;
-	unsigned short lmi;
-	unsigned short dce; /* 1 for DCE (network side) operation */
-} fr_proto;
-
-typedef struct {
-	unsigned int dlci;
-} fr_proto_pvc;          /* for creating/deleting FR PVCs */
-
-typedef struct {
-	unsigned int dlci;
-	char master[IFNAMSIZ];	/* Name of master FRAD device */
-}fr_proto_pvc_info;		/* for returning PVC information only */
-
-typedef struct {
-    unsigned int interval;
-    unsigned int timeout;
-} cisco_proto;
-
-/* PPP doesn't need any info now - supply length = 0 to ioctl */
-
-#endif /* __ASSEMBLY__ */
-#endif /* __HDLC_IOCTL_H__ */
diff --git a/include/linux/icmpv6.h b/include/linux/icmpv6.h
deleted file mode 100644
index a2e839e..0000000
--- a/include/linux/icmpv6.h
+++ /dev/null
@@ -1,166 +0,0 @@
-#ifndef _LINUX_ICMPV6_H
-#define _LINUX_ICMPV6_H
-
-#include <linux/types.h>
-#include <asm/byteorder.h>
-
-struct icmp6hdr {
-
-	__u8		icmp6_type;
-	__u8		icmp6_code;
-	__sum16		icmp6_cksum;
-
-
-	union {
-		__be32			un_data32[1];
-		__be16			un_data16[2];
-		__u8			un_data8[4];
-
-		struct icmpv6_echo {
-			__be16		identifier;
-			__be16		sequence;
-		} u_echo;
-
-                struct icmpv6_nd_advt {
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-                        __u32		reserved:5,
-                        		override:1,
-                        		solicited:1,
-                        		router:1,
-					reserved2:24;
-#elif defined(__BIG_ENDIAN_BITFIELD)
-                        __u32		router:1,
-					solicited:1,
-                        		override:1,
-                        		reserved:29;
-#else
-#error	"Please fix <asm/byteorder.h>"
-#endif						
-                } u_nd_advt;
-
-                struct icmpv6_nd_ra {
-			__u8		hop_limit;
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-			__u8		reserved:3,
-					router_pref:2,
-					home_agent:1,
-					other:1,
-					managed:1;
-
-#elif defined(__BIG_ENDIAN_BITFIELD)
-			__u8		managed:1,
-					other:1,
-					home_agent:1,
-					router_pref:2,
-					reserved:3;
-#else
-#error	"Please fix <asm/byteorder.h>"
-#endif
-			__be16		rt_lifetime;
-                } u_nd_ra;
-
-	} icmp6_dataun;
-
-#define icmp6_identifier	icmp6_dataun.u_echo.identifier
-#define icmp6_sequence		icmp6_dataun.u_echo.sequence
-#define icmp6_pointer		icmp6_dataun.un_data32[0]
-#define icmp6_mtu		icmp6_dataun.un_data32[0]
-#define icmp6_unused		icmp6_dataun.un_data32[0]
-#define icmp6_maxdelay		icmp6_dataun.un_data16[0]
-#define icmp6_router		icmp6_dataun.u_nd_advt.router
-#define icmp6_solicited		icmp6_dataun.u_nd_advt.solicited
-#define icmp6_override		icmp6_dataun.u_nd_advt.override
-#define icmp6_ndiscreserved	icmp6_dataun.u_nd_advt.reserved
-#define icmp6_hop_limit		icmp6_dataun.u_nd_ra.hop_limit
-#define icmp6_addrconf_managed	icmp6_dataun.u_nd_ra.managed
-#define icmp6_addrconf_other	icmp6_dataun.u_nd_ra.other
-#define icmp6_rt_lifetime	icmp6_dataun.u_nd_ra.rt_lifetime
-#define icmp6_router_pref	icmp6_dataun.u_nd_ra.router_pref
-};
-
-
-#define ICMPV6_ROUTER_PREF_LOW		0x3
-#define ICMPV6_ROUTER_PREF_MEDIUM	0x0
-#define ICMPV6_ROUTER_PREF_HIGH		0x1
-#define ICMPV6_ROUTER_PREF_INVALID	0x2
-
-#define ICMPV6_DEST_UNREACH		1
-#define ICMPV6_PKT_TOOBIG		2
-#define ICMPV6_TIME_EXCEED		3
-#define ICMPV6_PARAMPROB		4
-
-#define ICMPV6_INFOMSG_MASK		0x80
-
-#define ICMPV6_ECHO_REQUEST		128
-#define ICMPV6_ECHO_REPLY		129
-#define ICMPV6_MGM_QUERY		130
-#define ICMPV6_MGM_REPORT       	131
-#define ICMPV6_MGM_REDUCTION    	132
-
-#define ICMPV6_NI_QUERY			139
-#define ICMPV6_NI_REPLY			140
-
-#define ICMPV6_MLD2_REPORT		143
-
-#define ICMPV6_DHAAD_REQUEST		144
-#define ICMPV6_DHAAD_REPLY		145
-#define ICMPV6_MOBILE_PREFIX_SOL	146
-#define ICMPV6_MOBILE_PREFIX_ADV	147
-
-/*
- *	Codes for Destination Unreachable
- */
-#define ICMPV6_NOROUTE			0
-#define ICMPV6_ADM_PROHIBITED		1
-#define ICMPV6_NOT_NEIGHBOUR		2
-#define ICMPV6_ADDR_UNREACH		3
-#define ICMPV6_PORT_UNREACH		4
-#define ICMPV6_POLICY_FAIL		5
-#define ICMPV6_REJECT_ROUTE		6
-
-/*
- *	Codes for Time Exceeded
- */
-#define ICMPV6_EXC_HOPLIMIT		0
-#define ICMPV6_EXC_FRAGTIME		1
-
-/*
- *	Codes for Parameter Problem
- */
-#define ICMPV6_HDR_FIELD		0
-#define ICMPV6_UNK_NEXTHDR		1
-#define ICMPV6_UNK_OPTION		2
-
-/*
- *	constants for (set|get)sockopt
- */
-
-#define ICMPV6_FILTER			1
-
-/*
- *	ICMPV6 filter
- */
-
-#define ICMPV6_FILTER_BLOCK		1
-#define ICMPV6_FILTER_PASS		2
-#define ICMPV6_FILTER_BLOCKOTHERS	3
-#define ICMPV6_FILTER_PASSONLY		4
-
-struct icmp6_filter {
-	__u32		data[8];
-};
-
-/*
- *	Definitions for MLDv2
- */
-#define MLD2_MODE_IS_INCLUDE	1
-#define MLD2_MODE_IS_EXCLUDE	2
-#define MLD2_CHANGE_TO_INCLUDE	3
-#define MLD2_CHANGE_TO_EXCLUDE	4
-#define MLD2_ALLOW_NEW_SOURCES	5
-#define MLD2_BLOCK_OLD_SOURCES	6
-
-#define MLD2_ALL_MCR_INIT { { { 0xff,0x02,0,0,0,0,0,0,0,0,0,0,0,0,0,0x16 } } }
-
-
-#endif /* _LINUX_ICMPV6_H */
diff --git a/include/linux/if.h b/include/linux/if.h
deleted file mode 100644
index b4ba020..0000000
--- a/include/linux/if.h
+++ /dev/null
@@ -1,292 +0,0 @@
-/*
- * INET		An implementation of the TCP/IP protocol suite for the LINUX
- *		operating system.  INET is implemented using the  BSD Socket
- *		interface as the means of communication with the user level.
- *
- *		Global definitions for the INET interface module.
- *
- * Version:	@(#)if.h	1.0.2	04/18/93
- *
- * Authors:	Original taken from Berkeley UNIX 4.3, (c) UCB 1982-1988
- *		Ross Biro
- *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
- */
-#ifndef _LINUX_IF_H
-#define _LINUX_IF_H
-
-#include <linux/libc-compat.h>          /* for compatibility with glibc */
-#include <linux/types.h>		/* for "__kernel_caddr_t" et al	*/
-#include <linux/socket.h>		/* for "struct sockaddr" et al	*/
-		/* for "__user" et al           */
-
-#include <sys/socket.h>			/* for struct sockaddr.		*/
-
-#if __UAPI_DEF_IF_IFNAMSIZ
-#define	IFNAMSIZ	16
-#endif /* __UAPI_DEF_IF_IFNAMSIZ */
-#define	IFALIASZ	256
-#include <linux/hdlc/ioctl.h>
-
-/* For glibc compatibility. An empty enum does not compile. */
-#if __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO != 0 || \
-    __UAPI_DEF_IF_NET_DEVICE_FLAGS != 0
-/**
- * enum net_device_flags - &struct net_device flags
- *
- * These are the &struct net_device flags, they can be set by drivers, the
- * kernel and some can be triggered by userspace. Userspace can query and
- * set these flags using userspace utilities but there is also a sysfs
- * entry available for all dev flags which can be queried and set. These flags
- * are shared for all types of net_devices. The sysfs entries are available
- * via /sys/class/net/<dev>/flags. Flags which can be toggled through sysfs
- * are annotated below, note that only a few flags can be toggled and some
- * other flags are always preserved from the original net_device flags
- * even if you try to set them via sysfs. Flags which are always preserved
- * are kept under the flag grouping @IFF_VOLATILE. Flags which are __volatile__
- * are annotated below as such.
- *
- * You should have a pretty good reason to be extending these flags.
- *
- * @IFF_UP: interface is up. Can be toggled through sysfs.
- * @IFF_BROADCAST: broadcast address valid. Volatile.
- * @IFF_DEBUG: turn on debugging. Can be toggled through sysfs.
- * @IFF_LOOPBACK: is a loopback net. Volatile.
- * @IFF_POINTOPOINT: interface is has p-p link. Volatile.
- * @IFF_NOTRAILERS: avoid use of trailers. Can be toggled through sysfs.
- *	Volatile.
- * @IFF_RUNNING: interface RFC2863 OPER_UP. Volatile.
- * @IFF_NOARP: no ARP protocol. Can be toggled through sysfs. Volatile.
- * @IFF_PROMISC: receive all packets. Can be toggled through sysfs.
- * @IFF_ALLMULTI: receive all multicast packets. Can be toggled through
- *	sysfs.
- * @IFF_MASTER: master of a load balancer. Volatile.
- * @IFF_SLAVE: slave of a load balancer. Volatile.
- * @IFF_MULTICAST: Supports multicast. Can be toggled through sysfs.
- * @IFF_PORTSEL: can set media type. Can be toggled through sysfs.
- * @IFF_AUTOMEDIA: auto media select active. Can be toggled through sysfs.
- * @IFF_DYNAMIC: dialup device with changing addresses. Can be toggled
- *	through sysfs.
- * @IFF_LOWER_UP: driver signals L1 up. Volatile.
- * @IFF_DORMANT: driver signals dormant. Volatile.
- * @IFF_ECHO: echo sent packets. Volatile.
- */
-enum net_device_flags {
-/* for compatibility with glibc net/if.h */
-#if __UAPI_DEF_IF_NET_DEVICE_FLAGS
-	IFF_UP				= 1<<0,  /* sysfs */
-	IFF_BROADCAST			= 1<<1,  /* __volatile__ */
-	IFF_DEBUG			= 1<<2,  /* sysfs */
-	IFF_LOOPBACK			= 1<<3,  /* __volatile__ */
-	IFF_POINTOPOINT			= 1<<4,  /* __volatile__ */
-	IFF_NOTRAILERS			= 1<<5,  /* sysfs */
-	IFF_RUNNING			= 1<<6,  /* __volatile__ */
-	IFF_NOARP			= 1<<7,  /* sysfs */
-	IFF_PROMISC			= 1<<8,  /* sysfs */
-	IFF_ALLMULTI			= 1<<9,  /* sysfs */
-	IFF_MASTER			= 1<<10, /* __volatile__ */
-	IFF_SLAVE			= 1<<11, /* __volatile__ */
-	IFF_MULTICAST			= 1<<12, /* sysfs */
-	IFF_PORTSEL			= 1<<13, /* sysfs */
-	IFF_AUTOMEDIA			= 1<<14, /* sysfs */
-	IFF_DYNAMIC			= 1<<15, /* sysfs */
-#endif /* __UAPI_DEF_IF_NET_DEVICE_FLAGS */
-#if __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO
-	IFF_LOWER_UP			= 1<<16, /* __volatile__ */
-	IFF_DORMANT			= 1<<17, /* __volatile__ */
-	IFF_ECHO			= 1<<18, /* __volatile__ */
-#endif /* __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO */
-};
-#endif /* __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO != 0 || __UAPI_DEF_IF_NET_DEVICE_FLAGS != 0 */
-
-/* for compatibility with glibc net/if.h */
-#if __UAPI_DEF_IF_NET_DEVICE_FLAGS
-#define IFF_UP				IFF_UP
-#define IFF_BROADCAST			IFF_BROADCAST
-#define IFF_DEBUG			IFF_DEBUG
-#define IFF_LOOPBACK			IFF_LOOPBACK
-#define IFF_POINTOPOINT			IFF_POINTOPOINT
-#define IFF_NOTRAILERS			IFF_NOTRAILERS
-#define IFF_RUNNING			IFF_RUNNING
-#define IFF_NOARP			IFF_NOARP
-#define IFF_PROMISC			IFF_PROMISC
-#define IFF_ALLMULTI			IFF_ALLMULTI
-#define IFF_MASTER			IFF_MASTER
-#define IFF_SLAVE			IFF_SLAVE
-#define IFF_MULTICAST			IFF_MULTICAST
-#define IFF_PORTSEL			IFF_PORTSEL
-#define IFF_AUTOMEDIA			IFF_AUTOMEDIA
-#define IFF_DYNAMIC			IFF_DYNAMIC
-#endif /* __UAPI_DEF_IF_NET_DEVICE_FLAGS */
-
-#if __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO
-#define IFF_LOWER_UP			IFF_LOWER_UP
-#define IFF_DORMANT			IFF_DORMANT
-#define IFF_ECHO			IFF_ECHO
-#endif /* __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO */
-
-#define IFF_VOLATILE	(IFF_LOOPBACK|IFF_POINTOPOINT|IFF_BROADCAST|IFF_ECHO|\
-		IFF_MASTER|IFF_SLAVE|IFF_RUNNING|IFF_LOWER_UP|IFF_DORMANT)
-
-#define IF_GET_IFACE	0x0001		/* for querying only */
-#define IF_GET_PROTO	0x0002
-
-/* For definitions see hdlc.h */
-#define IF_IFACE_V35	0x1000		/* V.35 serial interface	*/
-#define IF_IFACE_V24	0x1001		/* V.24 serial interface	*/
-#define IF_IFACE_X21	0x1002		/* X.21 serial interface	*/
-#define IF_IFACE_T1	0x1003		/* T1 telco serial interface	*/
-#define IF_IFACE_E1	0x1004		/* E1 telco serial interface	*/
-#define IF_IFACE_SYNC_SERIAL 0x1005	/* can't be set by software	*/
-#define IF_IFACE_X21D   0x1006          /* X.21 Dual Clocking (FarSite) */
-
-/* For definitions see hdlc.h */
-#define IF_PROTO_HDLC	0x2000		/* raw HDLC protocol		*/
-#define IF_PROTO_PPP	0x2001		/* PPP protocol			*/
-#define IF_PROTO_CISCO	0x2002		/* Cisco HDLC protocol		*/
-#define IF_PROTO_FR	0x2003		/* Frame Relay protocol		*/
-#define IF_PROTO_FR_ADD_PVC 0x2004	/*    Create FR PVC		*/
-#define IF_PROTO_FR_DEL_PVC 0x2005	/*    Delete FR PVC		*/
-#define IF_PROTO_X25	0x2006		/* X.25				*/
-#define IF_PROTO_HDLC_ETH 0x2007	/* raw HDLC, Ethernet emulation	*/
-#define IF_PROTO_FR_ADD_ETH_PVC 0x2008	/*  Create FR Ethernet-bridged PVC */
-#define IF_PROTO_FR_DEL_ETH_PVC 0x2009	/*  Delete FR Ethernet-bridged PVC */
-#define IF_PROTO_FR_PVC	0x200A		/* for reading PVC status	*/
-#define IF_PROTO_FR_ETH_PVC 0x200B
-#define IF_PROTO_RAW    0x200C          /* RAW Socket                   */
-
-/* RFC 2863 operational status */
-enum {
-	IF_OPER_UNKNOWN,
-	IF_OPER_NOTPRESENT,
-	IF_OPER_DOWN,
-	IF_OPER_LOWERLAYERDOWN,
-	IF_OPER_TESTING,
-	IF_OPER_DORMANT,
-	IF_OPER_UP,
-};
-
-/* link modes */
-enum {
-	IF_LINK_MODE_DEFAULT,
-	IF_LINK_MODE_DORMANT,	/* limit upward transition to dormant */
-};
-
-/*
- *	Device mapping structure. I'd just gone off and designed a 
- *	beautiful scheme using only loadable modules with arguments
- *	for driver options and along come the PCMCIA people 8)
- *
- *	Ah well. The get() side of this is good for WDSETUP, and it'll
- *	be handy for debugging things. The set side is fine for now and
- *	being very small might be worth keeping for clean configuration.
- */
-
-/* for compatibility with glibc net/if.h */
-#if __UAPI_DEF_IF_IFMAP
-struct ifmap {
-	unsigned long mem_start;
-	unsigned long mem_end;
-	unsigned short base_addr; 
-	unsigned char irq;
-	unsigned char dma;
-	unsigned char port;
-	/* 3 bytes spare */
-};
-#endif /* __UAPI_DEF_IF_IFMAP */
-
-struct if_settings {
-	unsigned int type;	/* Type of physical device or protocol */
-	unsigned int size;	/* Size of the data allocated by the caller */
-	union {
-		/* {atm/eth/dsl}_settings anyone ? */
-		raw_hdlc_proto		*raw_hdlc;
-		cisco_proto		*cisco;
-		fr_proto		*fr;
-		fr_proto_pvc		*fr_pvc;
-		fr_proto_pvc_info	*fr_pvc_info;
-
-		/* interface settings */
-		sync_serial_settings	*sync;
-		te1_settings		*te1;
-	} ifs_ifsu;
-};
-
-/*
- * Interface request structure used for socket
- * ioctl's.  All interface ioctl's must have parameter
- * definitions which begin with ifr_name.  The
- * remainder may be interface specific.
- */
-
-/* for compatibility with glibc net/if.h */
-#if __UAPI_DEF_IF_IFREQ
-struct ifreq {
-#define IFHWADDRLEN	6
-	union
-	{
-		char	ifrn_name[IFNAMSIZ];		/* if name, e.g. "en0" */
-	} ifr_ifrn;
-	
-	union {
-		struct	sockaddr ifru_addr;
-		struct	sockaddr ifru_dstaddr;
-		struct	sockaddr ifru_broadaddr;
-		struct	sockaddr ifru_netmask;
-		struct  sockaddr ifru_hwaddr;
-		short	ifru_flags;
-		int	ifru_ivalue;
-		int	ifru_mtu;
-		struct  ifmap ifru_map;
-		char	ifru_slave[IFNAMSIZ];	/* Just fits the size */
-		char	ifru_newname[IFNAMSIZ];
-		void *	ifru_data;
-		struct	if_settings ifru_settings;
-	} ifr_ifru;
-};
-#endif /* __UAPI_DEF_IF_IFREQ */
-
-#define ifr_name	ifr_ifrn.ifrn_name	/* interface name 	*/
-#define ifr_hwaddr	ifr_ifru.ifru_hwaddr	/* MAC address 		*/
-#define	ifr_addr	ifr_ifru.ifru_addr	/* address		*/
-#define	ifr_dstaddr	ifr_ifru.ifru_dstaddr	/* other end of p-p lnk	*/
-#define	ifr_broadaddr	ifr_ifru.ifru_broadaddr	/* broadcast address	*/
-#define	ifr_netmask	ifr_ifru.ifru_netmask	/* interface net mask	*/
-#define	ifr_flags	ifr_ifru.ifru_flags	/* flags		*/
-#define	ifr_metric	ifr_ifru.ifru_ivalue	/* metric		*/
-#define	ifr_mtu		ifr_ifru.ifru_mtu	/* mtu			*/
-#define ifr_map		ifr_ifru.ifru_map	/* device map		*/
-#define ifr_slave	ifr_ifru.ifru_slave	/* slave device		*/
-#define	ifr_data	ifr_ifru.ifru_data	/* for use by interface	*/
-#define ifr_ifindex	ifr_ifru.ifru_ivalue	/* interface index	*/
-#define ifr_bandwidth	ifr_ifru.ifru_ivalue    /* link bandwidth	*/
-#define ifr_qlen	ifr_ifru.ifru_ivalue	/* Queue length 	*/
-#define ifr_newname	ifr_ifru.ifru_newname	/* New name		*/
-#define ifr_settings	ifr_ifru.ifru_settings	/* Device/proto settings*/
-
-/*
- * Structure used in SIOCGIFCONF request.
- * Used to retrieve interface configuration
- * for machine (useful for programs which
- * must know all networks accessible).
- */
-
-/* for compatibility with glibc net/if.h */
-#if __UAPI_DEF_IF_IFCONF
-struct ifconf  {
-	int	ifc_len;			/* size of buffer	*/
-	union {
-		char *ifcu_buf;
-		struct ifreq *ifcu_req;
-	} ifc_ifcu;
-};
-#endif /* __UAPI_DEF_IF_IFCONF */
-
-#define	ifc_buf	ifc_ifcu.ifcu_buf		/* buffer address	*/
-#define	ifc_req	ifc_ifcu.ifcu_req		/* array of structures	*/
-
-#endif /* _LINUX_IF_H */
diff --git a/include/linux/if_addr.h b/include/linux/if_addr.h
deleted file mode 100644
index 26f0ecf..0000000
--- a/include/linux/if_addr.h
+++ /dev/null
@@ -1,67 +0,0 @@
-#ifndef __LINUX_IF_ADDR_H
-#define __LINUX_IF_ADDR_H
-
-#include <linux/types.h>
-#include <linux/netlink.h>
-
-struct ifaddrmsg {
-	__u8		ifa_family;
-	__u8		ifa_prefixlen;	/* The prefix length		*/
-	__u8		ifa_flags;	/* Flags			*/
-	__u8		ifa_scope;	/* Address scope		*/
-	__u32		ifa_index;	/* Link index			*/
-};
-
-/*
- * Important comment:
- * IFA_ADDRESS is prefix address, rather than local interface address.
- * It makes no difference for normally configured broadcast interfaces,
- * but for point-to-point IFA_ADDRESS is DESTINATION address,
- * local address is supplied in IFA_LOCAL attribute.
- *
- * IFA_FLAGS is a u32 attribute that extends the u8 field ifa_flags.
- * If present, the value from struct ifaddrmsg will be ignored.
- */
-enum {
-	IFA_UNSPEC,
-	IFA_ADDRESS,
-	IFA_LOCAL,
-	IFA_LABEL,
-	IFA_BROADCAST,
-	IFA_ANYCAST,
-	IFA_CACHEINFO,
-	IFA_MULTICAST,
-	IFA_FLAGS,
-	__IFA_MAX,
-};
-
-#define IFA_MAX (__IFA_MAX - 1)
-
-/* ifa_flags */
-#define IFA_F_SECONDARY		0x01
-#define IFA_F_TEMPORARY		IFA_F_SECONDARY
-
-#define	IFA_F_NODAD		0x02
-#define IFA_F_OPTIMISTIC	0x04
-#define IFA_F_DADFAILED		0x08
-#define	IFA_F_HOMEADDRESS	0x10
-#define IFA_F_DEPRECATED	0x20
-#define IFA_F_TENTATIVE		0x40
-#define IFA_F_PERMANENT		0x80
-#define IFA_F_MANAGETEMPADDR	0x100
-#define IFA_F_NOPREFIXROUTE	0x200
-#define IFA_F_MCAUTOJOIN	0x400
-#define IFA_F_STABLE_PRIVACY	0x800
-
-struct ifa_cacheinfo {
-	__u32	ifa_prefered;
-	__u32	ifa_valid;
-	__u32	cstamp; /* created timestamp, hundredths of seconds */
-	__u32	tstamp; /* updated timestamp, hundredths of seconds */
-};
-
-/* backwards compatibility for userspace */
-#define IFA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct ifaddrmsg))))
-#define IFA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct ifaddrmsg))
-
-#endif
diff --git a/include/linux/if_addrlabel.h b/include/linux/if_addrlabel.h
deleted file mode 100644
index 54580c2..0000000
--- a/include/linux/if_addrlabel.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * if_addrlabel.h - netlink interface for address labels
- *
- * Copyright (C)2007 USAGI/WIDE Project,  All Rights Reserved.
- *
- * Authors:
- *	YOSHIFUJI Hideaki @ USAGI/WIDE <yoshfuji@linux-ipv6.org>
- */
-
-#ifndef __LINUX_IF_ADDRLABEL_H
-#define __LINUX_IF_ADDRLABEL_H
-
-#include <linux/types.h>
-
-struct ifaddrlblmsg {
-	__u8		ifal_family;		/* Address family */
-	__u8		__ifal_reserved;	/* Reserved */
-	__u8		ifal_prefixlen;		/* Prefix length */
-	__u8		ifal_flags;		/* Flags */
-	__u32		ifal_index;		/* Link index */
-	__u32		ifal_seq;		/* sequence number */
-};
-
-enum {
-	IFAL_ADDRESS = 1,
-	IFAL_LABEL = 2,
-	__IFAL_MAX
-};
-
-#define IFAL_MAX	(__IFAL_MAX - 1)
-
-#endif
diff --git a/include/linux/if_alg.h b/include/linux/if_alg.h
deleted file mode 100644
index f2acd2f..0000000
--- a/include/linux/if_alg.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * if_alg: User-space algorithm interface
- *
- * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
- *
- */
-
-#ifndef _LINUX_IF_ALG_H
-#define _LINUX_IF_ALG_H
-
-#include <linux/types.h>
-
-struct sockaddr_alg {
-	__u16	salg_family;
-	__u8	salg_type[14];
-	__u32	salg_feat;
-	__u32	salg_mask;
-	__u8	salg_name[64];
-};
-
-struct af_alg_iv {
-	__u32	ivlen;
-	__u8	iv[0];
-};
-
-/* Socket options */
-#define ALG_SET_KEY			1
-#define ALG_SET_IV			2
-#define ALG_SET_OP			3
-#define ALG_SET_AEAD_ASSOCLEN		4
-#define ALG_SET_AEAD_AUTHSIZE		5
-
-/* Operations */
-#define ALG_OP_DECRYPT			0
-#define ALG_OP_ENCRYPT			1
-
-#endif	/* _LINUX_IF_ALG_H */
diff --git a/include/linux/if_arp.h b/include/linux/if_arp.h
deleted file mode 100644
index 199f253..0000000
--- a/include/linux/if_arp.h
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
- * INET		An implementation of the TCP/IP protocol suite for the LINUX
- *		operating system.  INET is implemented using the  BSD Socket
- *		interface as the means of communication with the user level.
- *
- *		Global definitions for the ARP (RFC 826) protocol.
- *
- * Version:	@(#)if_arp.h	1.0.1	04/16/93
- *
- * Authors:	Original taken from Berkeley UNIX 4.3, (c) UCB 1986-1988
- *		Portions taken from the KA9Q/NOS (v2.00m PA0GRI) source.
- *		Ross Biro
- *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
- *		Florian La Roche,
- *		Jonathan Layes <layes@loran.com>
- *		Arnaldo Carvalho de Melo <acme@conectiva.com.br> ARPHRD_HWX25
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
- */
-#ifndef _LINUX_IF_ARP_H
-#define _LINUX_IF_ARP_H
-
-#include <linux/netdevice.h>
-
-/* ARP protocol HARDWARE identifiers. */
-#define ARPHRD_NETROM	0		/* from KA9Q: NET/ROM pseudo	*/
-#define ARPHRD_ETHER 	1		/* Ethernet 10Mbps		*/
-#define	ARPHRD_EETHER	2		/* Experimental Ethernet	*/
-#define	ARPHRD_AX25	3		/* AX.25 Level 2		*/
-#define	ARPHRD_PRONET	4		/* PROnet token ring		*/
-#define	ARPHRD_CHAOS	5		/* Chaosnet			*/
-#define	ARPHRD_IEEE802	6		/* IEEE 802.2 Ethernet/TR/TB	*/
-#define	ARPHRD_ARCNET	7		/* ARCnet			*/
-#define	ARPHRD_APPLETLK	8		/* APPLEtalk			*/
-#define ARPHRD_DLCI	15		/* Frame Relay DLCI		*/
-#define ARPHRD_ATM	19		/* ATM 				*/
-#define ARPHRD_METRICOM	23		/* Metricom STRIP (new IANA id)	*/
-#define	ARPHRD_IEEE1394	24		/* IEEE 1394 IPv4 - RFC 2734	*/
-#define ARPHRD_EUI64	27		/* EUI-64                       */
-#define ARPHRD_INFINIBAND 32		/* InfiniBand			*/
-
-/* Dummy types for non ARP hardware */
-#define ARPHRD_SLIP	256
-#define ARPHRD_CSLIP	257
-#define ARPHRD_SLIP6	258
-#define ARPHRD_CSLIP6	259
-#define ARPHRD_RSRVD	260		/* Notional KISS type 		*/
-#define ARPHRD_ADAPT	264
-#define ARPHRD_ROSE	270
-#define ARPHRD_X25	271		/* CCITT X.25			*/
-#define ARPHRD_HWX25	272		/* Boards with X.25 in firmware	*/
-#define ARPHRD_CAN	280		/* Controller Area Network      */
-#define ARPHRD_PPP	512
-#define ARPHRD_CISCO	513		/* Cisco HDLC	 		*/
-#define ARPHRD_HDLC	ARPHRD_CISCO
-#define ARPHRD_LAPB	516		/* LAPB				*/
-#define ARPHRD_DDCMP    517		/* Digital's DDCMP protocol     */
-#define ARPHRD_RAWHDLC	518		/* Raw HDLC			*/
-#define ARPHRD_RAWIP    519		/* Raw IP                       */
-
-#define ARPHRD_TUNNEL	768		/* IPIP tunnel			*/
-#define ARPHRD_TUNNEL6	769		/* IP6IP6 tunnel       		*/
-#define ARPHRD_FRAD	770             /* Frame Relay Access Device    */
-#define ARPHRD_SKIP	771		/* SKIP vif			*/
-#define ARPHRD_LOOPBACK	772		/* Loopback device		*/
-#define ARPHRD_LOCALTLK 773		/* Localtalk device		*/
-#define ARPHRD_FDDI	774		/* Fiber Distributed Data Interface */
-#define ARPHRD_BIF      775             /* AP1000 BIF                   */
-#define ARPHRD_SIT	776		/* sit0 device - IPv6-in-IPv4	*/
-#define ARPHRD_IPDDP	777		/* IP over DDP tunneller	*/
-#define ARPHRD_IPGRE	778		/* GRE over IP			*/
-#define ARPHRD_PIMREG	779		/* PIMSM register interface	*/
-#define ARPHRD_HIPPI	780		/* High Performance Parallel Interface */
-#define ARPHRD_ASH	781		/* Nexus 64Mbps Ash		*/
-#define ARPHRD_ECONET	782		/* Acorn Econet			*/
-#define ARPHRD_IRDA 	783		/* Linux-IrDA			*/
-/* ARP works differently on different FC media .. so  */
-#define ARPHRD_FCPP	784		/* Point to point fibrechannel	*/
-#define ARPHRD_FCAL	785		/* Fibrechannel arbitrated loop */
-#define ARPHRD_FCPL	786		/* Fibrechannel public loop	*/
-#define ARPHRD_FCFABRIC	787		/* Fibrechannel fabric		*/
-	/* 787->799 reserved for fibrechannel media types */
-#define ARPHRD_IEEE802_TR 800		/* Magic type ident for TR	*/
-#define ARPHRD_IEEE80211 801		/* IEEE 802.11			*/
-#define ARPHRD_IEEE80211_PRISM 802	/* IEEE 802.11 + Prism2 header  */
-#define ARPHRD_IEEE80211_RADIOTAP 803	/* IEEE 802.11 + radiotap header */
-#define ARPHRD_IEEE802154	  804
-#define ARPHRD_IEEE802154_MONITOR 805	/* IEEE 802.15.4 network monitor */
-
-#define ARPHRD_PHONET	820		/* PhoNet media type		*/
-#define ARPHRD_PHONET_PIPE 821		/* PhoNet pipe header		*/
-#define ARPHRD_CAIF	822		/* CAIF media type		*/
-#define ARPHRD_IP6GRE	823		/* GRE over IPv6		*/
-#define ARPHRD_NETLINK	824		/* Netlink header		*/
-#define ARPHRD_6LOWPAN	825		/* IPv6 over LoWPAN             */
-#define ARPHRD_VSOCKMON	826		/* Vsock monitor header		*/
-
-#define ARPHRD_VOID	  0xFFFF	/* Void type, nothing is known */
-#define ARPHRD_NONE	  0xFFFE	/* zero header length */
-
-/* ARP protocol opcodes. */
-#define	ARPOP_REQUEST	1		/* ARP request			*/
-#define	ARPOP_REPLY	2		/* ARP reply			*/
-#define	ARPOP_RREQUEST	3		/* RARP request			*/
-#define	ARPOP_RREPLY	4		/* RARP reply			*/
-#define	ARPOP_InREQUEST	8		/* InARP request		*/
-#define	ARPOP_InREPLY	9		/* InARP reply			*/
-#define	ARPOP_NAK	10		/* (ATM)ARP NAK			*/
-
-
-/* ARP ioctl request. */
-struct arpreq {
-  struct sockaddr	arp_pa;		/* protocol address		*/
-  struct sockaddr	arp_ha;		/* hardware address		*/
-  int			arp_flags;	/* flags			*/
-  struct sockaddr       arp_netmask;    /* netmask (only for proxy arps) */
-  char			arp_dev[16];
-};
-
-struct arpreq_old {
-  struct sockaddr	arp_pa;		/* protocol address		*/
-  struct sockaddr	arp_ha;		/* hardware address		*/
-  int			arp_flags;	/* flags			*/
-  struct sockaddr       arp_netmask;    /* netmask (only for proxy arps) */
-};
-
-/* ARP Flag values. */
-#define ATF_COM		0x02		/* completed entry (ha valid)	*/
-#define	ATF_PERM	0x04		/* permanent entry		*/
-#define	ATF_PUBL	0x08		/* publish entry		*/
-#define	ATF_USETRAILERS	0x10		/* has requested trailers	*/
-#define ATF_NETMASK     0x20            /* want to use a netmask (only
-					   for proxy entries) */
-#define ATF_DONTPUB	0x40		/* don't answer this addresses	*/
-
-/*
- *	This structure defines an ethernet arp header.
- */
-
-struct arphdr {
-	__be16		ar_hrd;		/* format of hardware address	*/
-	__be16		ar_pro;		/* format of protocol address	*/
-	unsigned char	ar_hln;		/* length of hardware address	*/
-	unsigned char	ar_pln;		/* length of protocol address	*/
-	__be16		ar_op;		/* ARP opcode (command)		*/
-
-#if 0
-	 /*
-	  *	 Ethernet looks like this : This bit is variable sized however...
-	  */
-	unsigned char		ar_sha[ETH_ALEN];	/* sender hardware address	*/
-	unsigned char		ar_sip[4];		/* sender IP address		*/
-	unsigned char		ar_tha[ETH_ALEN];	/* target hardware address	*/
-	unsigned char		ar_tip[4];		/* target IP address		*/
-#endif
-
-};
-
-
-#endif /* _LINUX_IF_ARP_H */
diff --git a/include/linux/if_bonding.h b/include/linux/if_bonding.h
deleted file mode 100644
index 9635a62..0000000
--- a/include/linux/if_bonding.h
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * Bond several ethernet interfaces into a Cisco, running 'Etherchannel'.
- *
- *
- * Portions are (c) Copyright 1995 Simon "Guru Aleph-Null" Janes
- * NCM: Network and Communications Management, Inc.
- *
- * BUT, I'm the one who modified it for ethernet, so:
- * (c) Copyright 1999, Thomas Davis, tadavis@lbl.gov
- *
- *	This software may be used and distributed according to the terms
- *	of the GNU Public License, incorporated herein by reference.
- *
- * 2003/03/18 - Amir Noam <amir.noam at intel dot com>
- *	- Added support for getting slave's speed and duplex via ethtool.
- *	  Needed for 802.3ad and other future modes.
- *
- * 2003/03/18 - Tsippy Mendelson <tsippy.mendelson at intel dot com> and
- *		Shmulik Hen <shmulik.hen at intel dot com>
- *	- Enable support of modes that need to use the unique mac address of
- *	  each slave.
- *
- * 2003/03/18 - Tsippy Mendelson <tsippy.mendelson at intel dot com> and
- *		Amir Noam <amir.noam at intel dot com>
- *	- Moved driver's private data types to bonding.h
- *
- * 2003/03/18 - Amir Noam <amir.noam at intel dot com>,
- *		Tsippy Mendelson <tsippy.mendelson at intel dot com> and
- *		Shmulik Hen <shmulik.hen at intel dot com>
- *	- Added support for IEEE 802.3ad Dynamic link aggregation mode.
- *
- * 2003/05/01 - Amir Noam <amir.noam at intel dot com>
- *	- Added ABI version control to restore compatibility between
- *	  new/old ifenslave and new/old bonding.
- *
- * 2003/12/01 - Shmulik Hen <shmulik.hen at intel dot com>
- *	- Code cleanup and style changes
- *
- * 2005/05/05 - Jason Gabler <jygabler at lbl dot gov>
- *      - added definitions for various XOR hashing policies
- */
-
-#ifndef _LINUX_IF_BONDING_H
-#define _LINUX_IF_BONDING_H
-
-#include <linux/if.h>
-#include <linux/types.h>
-#include <linux/if_ether.h>
-
-/* userland - kernel ABI version (2003/05/08) */
-#define BOND_ABI_VERSION 2
-
-/*
- * We can remove these ioctl definitions in 2.5.  People should use the
- * SIOC*** versions of them instead
- */
-#define BOND_ENSLAVE_OLD		(SIOCDEVPRIVATE)
-#define BOND_RELEASE_OLD		(SIOCDEVPRIVATE + 1)
-#define BOND_SETHWADDR_OLD		(SIOCDEVPRIVATE + 2)
-#define BOND_SLAVE_INFO_QUERY_OLD	(SIOCDEVPRIVATE + 11)
-#define BOND_INFO_QUERY_OLD		(SIOCDEVPRIVATE + 12)
-#define BOND_CHANGE_ACTIVE_OLD		(SIOCDEVPRIVATE + 13)
-
-#define BOND_CHECK_MII_STATUS	(SIOCGMIIPHY)
-
-#define BOND_MODE_ROUNDROBIN	0
-#define BOND_MODE_ACTIVEBACKUP	1
-#define BOND_MODE_XOR		2
-#define BOND_MODE_BROADCAST	3
-#define BOND_MODE_8023AD        4
-#define BOND_MODE_TLB           5
-#define BOND_MODE_ALB		6 /* TLB + RLB (receive load balancing) */
-
-/* each slave's link has 4 states */
-#define BOND_LINK_UP    0           /* link is up and running */
-#define BOND_LINK_FAIL  1           /* link has just gone down */
-#define BOND_LINK_DOWN  2           /* link has been down for too long time */
-#define BOND_LINK_BACK  3           /* link is going back */
-
-/* each slave has several states */
-#define BOND_STATE_ACTIVE       0   /* link is active */
-#define BOND_STATE_BACKUP       1   /* link is backup */
-
-#define BOND_DEFAULT_MAX_BONDS  1   /* Default maximum number of devices to support */
-
-#define BOND_DEFAULT_TX_QUEUES 16   /* Default number of tx queues per device */
-
-#define BOND_DEFAULT_RESEND_IGMP	1 /* Default number of IGMP membership reports */
-
-/* hashing types */
-#define BOND_XMIT_POLICY_LAYER2		0 /* layer 2 (MAC only), default */
-#define BOND_XMIT_POLICY_LAYER34	1 /* layer 3+4 (IP ^ (TCP || UDP)) */
-#define BOND_XMIT_POLICY_LAYER23	2 /* layer 2+3 (IP ^ MAC) */
-#define BOND_XMIT_POLICY_ENCAP23	3 /* encapsulated layer 2+3 */
-#define BOND_XMIT_POLICY_ENCAP34	4 /* encapsulated layer 3+4 */
-
-typedef struct ifbond {
-	__s32 bond_mode;
-	__s32 num_slaves;
-	__s32 miimon;
-} ifbond;
-
-typedef struct ifslave {
-	__s32 slave_id; /* Used as an IN param to the BOND_SLAVE_INFO_QUERY ioctl */
-	char slave_name[IFNAMSIZ];
-	__s8 link;
-	__s8 state;
-	__u32  link_failure_count;
-} ifslave;
-
-struct ad_info {
-	__u16 aggregator_id;
-	__u16 ports;
-	__u16 actor_key;
-	__u16 partner_key;
-	__u8 partner_system[ETH_ALEN];
-};
-
-#endif /* _LINUX_IF_BONDING_H */
-
-/*
- * Local variables:
- *  version-control: t
- *  kept-new-versions: 5
- *  c-indent-level: 8
- *  c-basic-offset: 8
- *  tab-width: 8
- * End:
- */
-
diff --git a/include/linux/if_bridge.h b/include/linux/if_bridge.h
deleted file mode 100644
index 156f443..0000000
--- a/include/linux/if_bridge.h
+++ /dev/null
@@ -1,294 +0,0 @@
-/*
- *	Linux ethernet bridge
- *
- *	Authors:
- *	Lennert Buytenhek		<buytenh@gnu.org>
- *
- *	This program is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU General Public License
- *	as published by the Free Software Foundation; either version
- *	2 of the License, or (at your option) any later version.
- */
-
-#ifndef _LINUX_IF_BRIDGE_H
-#define _LINUX_IF_BRIDGE_H
-
-#include <linux/types.h>
-#include <linux/if_ether.h>
-#include <linux/in6.h>
-
-#define SYSFS_BRIDGE_ATTR	"bridge"
-#define SYSFS_BRIDGE_FDB	"brforward"
-#define SYSFS_BRIDGE_PORT_SUBDIR "brif"
-#define SYSFS_BRIDGE_PORT_ATTR	"brport"
-#define SYSFS_BRIDGE_PORT_LINK	"bridge"
-
-#define BRCTL_VERSION 1
-
-#define BRCTL_GET_VERSION 0
-#define BRCTL_GET_BRIDGES 1
-#define BRCTL_ADD_BRIDGE 2
-#define BRCTL_DEL_BRIDGE 3
-#define BRCTL_ADD_IF 4
-#define BRCTL_DEL_IF 5
-#define BRCTL_GET_BRIDGE_INFO 6
-#define BRCTL_GET_PORT_LIST 7
-#define BRCTL_SET_BRIDGE_FORWARD_DELAY 8
-#define BRCTL_SET_BRIDGE_HELLO_TIME 9
-#define BRCTL_SET_BRIDGE_MAX_AGE 10
-#define BRCTL_SET_AGEING_TIME 11
-#define BRCTL_SET_GC_INTERVAL 12
-#define BRCTL_GET_PORT_INFO 13
-#define BRCTL_SET_BRIDGE_STP_STATE 14
-#define BRCTL_SET_BRIDGE_PRIORITY 15
-#define BRCTL_SET_PORT_PRIORITY 16
-#define BRCTL_SET_PATH_COST 17
-#define BRCTL_GET_FDB_ENTRIES 18
-
-#define BR_STATE_DISABLED 0
-#define BR_STATE_LISTENING 1
-#define BR_STATE_LEARNING 2
-#define BR_STATE_FORWARDING 3
-#define BR_STATE_BLOCKING 4
-
-struct __bridge_info {
-	__u64 designated_root;
-	__u64 bridge_id;
-	__u32 root_path_cost;
-	__u32 max_age;
-	__u32 hello_time;
-	__u32 forward_delay;
-	__u32 bridge_max_age;
-	__u32 bridge_hello_time;
-	__u32 bridge_forward_delay;
-	__u8 topology_change;
-	__u8 topology_change_detected;
-	__u8 root_port;
-	__u8 stp_enabled;
-	__u32 ageing_time;
-	__u32 gc_interval;
-	__u32 hello_timer_value;
-	__u32 tcn_timer_value;
-	__u32 topology_change_timer_value;
-	__u32 gc_timer_value;
-};
-
-struct __port_info {
-	__u64 designated_root;
-	__u64 designated_bridge;
-	__u16 port_id;
-	__u16 designated_port;
-	__u32 path_cost;
-	__u32 designated_cost;
-	__u8 state;
-	__u8 top_change_ack;
-	__u8 config_pending;
-	__u8 unused0;
-	__u32 message_age_timer_value;
-	__u32 forward_delay_timer_value;
-	__u32 hold_timer_value;
-};
-
-struct __fdb_entry {
-	__u8 mac_addr[ETH_ALEN];
-	__u8 port_no;
-	__u8 is_local;
-	__u32 ageing_timer_value;
-	__u8 port_hi;
-	__u8 pad0;
-	__u16 unused;
-};
-
-/* Bridge Flags */
-#define BRIDGE_FLAGS_MASTER	1	/* Bridge command to/from master */
-#define BRIDGE_FLAGS_SELF	2	/* Bridge command to/from lowerdev */
-
-#define BRIDGE_MODE_VEB		0	/* Default loopback mode */
-#define BRIDGE_MODE_VEPA	1	/* 802.1Qbg defined VEPA mode */
-#define BRIDGE_MODE_UNDEF	0xFFFF  /* mode undefined */
-
-/* Bridge management nested attributes
- * [IFLA_AF_SPEC] = {
- *     [IFLA_BRIDGE_FLAGS]
- *     [IFLA_BRIDGE_MODE]
- *     [IFLA_BRIDGE_VLAN_INFO]
- * }
- */
-enum {
-	IFLA_BRIDGE_FLAGS,
-	IFLA_BRIDGE_MODE,
-	IFLA_BRIDGE_VLAN_INFO,
-	IFLA_BRIDGE_VLAN_TUNNEL_INFO,
-	__IFLA_BRIDGE_MAX,
-};
-#define IFLA_BRIDGE_MAX (__IFLA_BRIDGE_MAX - 1)
-
-#define BRIDGE_VLAN_INFO_MASTER	(1<<0)	/* Operate on Bridge device as well */
-#define BRIDGE_VLAN_INFO_PVID	(1<<1)	/* VLAN is PVID, ingress untagged */
-#define BRIDGE_VLAN_INFO_UNTAGGED	(1<<2)	/* VLAN egresses untagged */
-#define BRIDGE_VLAN_INFO_RANGE_BEGIN	(1<<3) /* VLAN is start of vlan range */
-#define BRIDGE_VLAN_INFO_RANGE_END	(1<<4) /* VLAN is end of vlan range */
-#define BRIDGE_VLAN_INFO_BRENTRY	(1<<5) /* Global bridge VLAN entry */
-
-struct bridge_vlan_info {
-	__u16 flags;
-	__u16 vid;
-};
-
-enum {
-	IFLA_BRIDGE_VLAN_TUNNEL_UNSPEC,
-	IFLA_BRIDGE_VLAN_TUNNEL_ID,
-	IFLA_BRIDGE_VLAN_TUNNEL_VID,
-	IFLA_BRIDGE_VLAN_TUNNEL_FLAGS,
-	__IFLA_BRIDGE_VLAN_TUNNEL_MAX,
-};
-
-#define IFLA_BRIDGE_VLAN_TUNNEL_MAX (__IFLA_BRIDGE_VLAN_TUNNEL_MAX - 1)
-
-struct bridge_vlan_xstats {
-	__u64 rx_bytes;
-	__u64 rx_packets;
-	__u64 tx_bytes;
-	__u64 tx_packets;
-	__u16 vid;
-	__u16 flags;
-	__u32 pad2;
-};
-
-/* Bridge multicast database attributes
- * [MDBA_MDB] = {
- *     [MDBA_MDB_ENTRY] = {
- *         [MDBA_MDB_ENTRY_INFO] {
- *		struct br_mdb_entry
- *		[MDBA_MDB_EATTR attributes]
- *         }
- *     }
- * }
- * [MDBA_ROUTER] = {
- *    [MDBA_ROUTER_PORT] = {
- *        u32 ifindex
- *        [MDBA_ROUTER_PATTR attributes]
- *    }
- * }
- */
-enum {
-	MDBA_UNSPEC,
-	MDBA_MDB,
-	MDBA_ROUTER,
-	__MDBA_MAX,
-};
-#define MDBA_MAX (__MDBA_MAX - 1)
-
-enum {
-	MDBA_MDB_UNSPEC,
-	MDBA_MDB_ENTRY,
-	__MDBA_MDB_MAX,
-};
-#define MDBA_MDB_MAX (__MDBA_MDB_MAX - 1)
-
-enum {
-	MDBA_MDB_ENTRY_UNSPEC,
-	MDBA_MDB_ENTRY_INFO,
-	__MDBA_MDB_ENTRY_MAX,
-};
-#define MDBA_MDB_ENTRY_MAX (__MDBA_MDB_ENTRY_MAX - 1)
-
-/* per mdb entry additional attributes */
-enum {
-	MDBA_MDB_EATTR_UNSPEC,
-	MDBA_MDB_EATTR_TIMER,
-	__MDBA_MDB_EATTR_MAX
-};
-#define MDBA_MDB_EATTR_MAX (__MDBA_MDB_EATTR_MAX - 1)
-
-/* multicast router types */
-enum {
-	MDB_RTR_TYPE_DISABLED,
-	MDB_RTR_TYPE_TEMP_QUERY,
-	MDB_RTR_TYPE_PERM,
-	MDB_RTR_TYPE_TEMP
-};
-
-enum {
-	MDBA_ROUTER_UNSPEC,
-	MDBA_ROUTER_PORT,
-	__MDBA_ROUTER_MAX,
-};
-#define MDBA_ROUTER_MAX (__MDBA_ROUTER_MAX - 1)
-
-/* router port attributes */
-enum {
-	MDBA_ROUTER_PATTR_UNSPEC,
-	MDBA_ROUTER_PATTR_TIMER,
-	MDBA_ROUTER_PATTR_TYPE,
-	__MDBA_ROUTER_PATTR_MAX
-};
-#define MDBA_ROUTER_PATTR_MAX (__MDBA_ROUTER_PATTR_MAX - 1)
-
-struct br_port_msg {
-	__u8  family;
-	__u32 ifindex;
-};
-
-struct br_mdb_entry {
-	__u32 ifindex;
-#define MDB_TEMPORARY 0
-#define MDB_PERMANENT 1
-	__u8 state;
-#define MDB_FLAGS_OFFLOAD	(1 << 0)
-	__u8 flags;
-	__u16 vid;
-	struct {
-		union {
-			__be32	ip4;
-			struct in6_addr ip6;
-		} u;
-		__be16		proto;
-	} addr;
-};
-
-enum {
-	MDBA_SET_ENTRY_UNSPEC,
-	MDBA_SET_ENTRY,
-	__MDBA_SET_ENTRY_MAX,
-};
-#define MDBA_SET_ENTRY_MAX (__MDBA_SET_ENTRY_MAX - 1)
-
-/* Embedded inside LINK_XSTATS_TYPE_BRIDGE */
-enum {
-	BRIDGE_XSTATS_UNSPEC,
-	BRIDGE_XSTATS_VLAN,
-	BRIDGE_XSTATS_MCAST,
-	BRIDGE_XSTATS_PAD,
-	__BRIDGE_XSTATS_MAX
-};
-#define BRIDGE_XSTATS_MAX (__BRIDGE_XSTATS_MAX - 1)
-
-enum {
-	BR_MCAST_DIR_RX,
-	BR_MCAST_DIR_TX,
-	BR_MCAST_DIR_SIZE
-};
-
-/* IGMP/MLD statistics */
-struct br_mcast_stats {
-	__u64 igmp_v1queries[BR_MCAST_DIR_SIZE];
-	__u64 igmp_v2queries[BR_MCAST_DIR_SIZE];
-	__u64 igmp_v3queries[BR_MCAST_DIR_SIZE];
-	__u64 igmp_leaves[BR_MCAST_DIR_SIZE];
-	__u64 igmp_v1reports[BR_MCAST_DIR_SIZE];
-	__u64 igmp_v2reports[BR_MCAST_DIR_SIZE];
-	__u64 igmp_v3reports[BR_MCAST_DIR_SIZE];
-	__u64 igmp_parse_errors;
-
-	__u64 mld_v1queries[BR_MCAST_DIR_SIZE];
-	__u64 mld_v2queries[BR_MCAST_DIR_SIZE];
-	__u64 mld_leaves[BR_MCAST_DIR_SIZE];
-	__u64 mld_v1reports[BR_MCAST_DIR_SIZE];
-	__u64 mld_v2reports[BR_MCAST_DIR_SIZE];
-	__u64 mld_parse_errors;
-
-	__u64 mcast_bytes[BR_MCAST_DIR_SIZE];
-	__u64 mcast_packets[BR_MCAST_DIR_SIZE];
-};
-#endif /* _LINUX_IF_BRIDGE_H */
diff --git a/include/linux/if_ether.h b/include/linux/if_ether.h
deleted file mode 100644
index 7dde037..0000000
--- a/include/linux/if_ether.h
+++ /dev/null
@@ -1,158 +0,0 @@
-/*
- * INET		An implementation of the TCP/IP protocol suite for the LINUX
- *		operating system.  INET is implemented using the  BSD Socket
- *		interface as the means of communication with the user level.
- *
- *		Global definitions for the Ethernet IEEE 802.3 interface.
- *
- * Version:	@(#)if_ether.h	1.0.1a	02/08/94
- *
- * Author:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
- *		Donald Becker, <becker@super.org>
- *		Alan Cox, <alan@lxorguk.ukuu.org.uk>
- *		Steve Whitehouse, <gw7rrm@eeshack3.swan.ac.uk>
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
- */
-
-#ifndef _LINUX_IF_ETHER_H
-#define _LINUX_IF_ETHER_H
-
-#include <linux/types.h>
-
-/*
- *	IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
- *	and FCS/CRC (frame check sequence).
- */
-
-#define ETH_ALEN	6		/* Octets in one ethernet addr	 */
-#define ETH_HLEN	14		/* Total octets in header.	 */
-#define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
-#define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
-#define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */
-#define ETH_FCS_LEN	4		/* Octets in the FCS		 */
-
-#define ETH_MIN_MTU	68		/* Min IPv4 MTU per RFC791	*/
-#define ETH_MAX_MTU	0xFFFFU		/* 65535, same as IP_MAX_MTU	*/
-
-/*
- *	These are the defined Ethernet Protocol ID's.
- */
-
-#define ETH_P_LOOP	0x0060		/* Ethernet Loopback packet	*/
-#define ETH_P_PUP	0x0200		/* Xerox PUP packet		*/
-#define ETH_P_PUPAT	0x0201		/* Xerox PUP Addr Trans packet	*/
-#define ETH_P_TSN	0x22F0		/* TSN (IEEE 1722) packet	*/
-#define ETH_P_IP	0x0800		/* Internet Protocol packet	*/
-#define ETH_P_X25	0x0805		/* CCITT X.25			*/
-#define ETH_P_ARP	0x0806		/* Address Resolution packet	*/
-#define	ETH_P_BPQ	0x08FF		/* G8BPQ AX.25 Ethernet Packet	[ NOT AN OFFICIALLY REGISTERED ID ] */
-#define ETH_P_IEEEPUP	0x0a00		/* Xerox IEEE802.3 PUP packet */
-#define ETH_P_IEEEPUPAT	0x0a01		/* Xerox IEEE802.3 PUP Addr Trans packet */
-#define ETH_P_BATMAN	0x4305		/* B.A.T.M.A.N.-Advanced packet [ NOT AN OFFICIALLY REGISTERED ID ] */
-#define ETH_P_DEC       0x6000          /* DEC Assigned proto           */
-#define ETH_P_DNA_DL    0x6001          /* DEC DNA Dump/Load            */
-#define ETH_P_DNA_RC    0x6002          /* DEC DNA Remote Console       */
-#define ETH_P_DNA_RT    0x6003          /* DEC DNA Routing              */
-#define ETH_P_LAT       0x6004          /* DEC LAT                      */
-#define ETH_P_DIAG      0x6005          /* DEC Diagnostics              */
-#define ETH_P_CUST      0x6006          /* DEC Customer use             */
-#define ETH_P_SCA       0x6007          /* DEC Systems Comms Arch       */
-#define ETH_P_TEB	0x6558		/* Trans Ether Bridging		*/
-#define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
-#define ETH_P_ATALK	0x809B		/* Appletalk DDP		*/
-#define ETH_P_AARP	0x80F3		/* Appletalk AARP		*/
-#define ETH_P_8021Q	0x8100          /* 802.1Q VLAN Extended Header  */
-#define ETH_P_ERSPAN	0x88BE		/* ERSPAN type II		*/
-#define ETH_P_IPX	0x8137		/* IPX over DIX			*/
-#define ETH_P_IPV6	0x86DD		/* IPv6 over bluebook		*/
-#define ETH_P_PAUSE	0x8808		/* IEEE Pause frames. See 802.3 31B */
-#define ETH_P_SLOW	0x8809		/* Slow Protocol. See 802.3ad 43B */
-#define ETH_P_WCCP	0x883E		/* Web-cache coordination protocol
-					 * defined in draft-wilson-wrec-wccp-v2-00.txt */
-#define ETH_P_MPLS_UC	0x8847		/* MPLS Unicast traffic		*/
-#define ETH_P_MPLS_MC	0x8848		/* MPLS Multicast traffic	*/
-#define ETH_P_ATMMPOA	0x884c		/* MultiProtocol Over ATM	*/
-#define ETH_P_PPP_DISC	0x8863		/* PPPoE discovery messages     */
-#define ETH_P_PPP_SES	0x8864		/* PPPoE session messages	*/
-#define ETH_P_LINK_CTL	0x886c		/* HPNA, wlan link local tunnel */
-#define ETH_P_ATMFATE	0x8884		/* Frame-based ATM Transport
-					 * over Ethernet
-					 */
-#define ETH_P_PAE	0x888E		/* Port Access Entity (IEEE 802.1X) */
-#define ETH_P_AOE	0x88A2		/* ATA over Ethernet		*/
-#define ETH_P_8021AD	0x88A8          /* 802.1ad Service VLAN		*/
-#define ETH_P_802_EX1	0x88B5		/* 802.1 Local Experimental 1.  */
-#define ETH_P_TIPC	0x88CA		/* TIPC 			*/
-#define ETH_P_MACSEC	0x88E5		/* 802.1ae MACsec */
-#define ETH_P_8021AH	0x88E7          /* 802.1ah Backbone Service Tag */
-#define ETH_P_MVRP	0x88F5          /* 802.1Q MVRP                  */
-#define ETH_P_1588	0x88F7		/* IEEE 1588 Timesync */
-#define ETH_P_NCSI	0x88F8		/* NCSI protocol		*/
-#define ETH_P_PRP	0x88FB		/* IEC 62439-3 PRP/HSRv0	*/
-#define ETH_P_FCOE	0x8906		/* Fibre Channel over Ethernet  */
-#define ETH_P_IBOE	0x8915		/* Infiniband over Ethernet	*/
-#define ETH_P_TDLS	0x890D          /* TDLS */
-#define ETH_P_FIP	0x8914		/* FCoE Initialization Protocol */
-#define ETH_P_80221	0x8917		/* IEEE 802.21 Media Independent Handover Protocol */
-#define ETH_P_HSR	0x892F		/* IEC 62439-3 HSRv1	*/
-#define ETH_P_NSH	0x894F		/* Network Service Header */
-#define ETH_P_LOOPBACK	0x9000		/* Ethernet loopback packet, per IEEE 802.3 */
-#define ETH_P_QINQ1	0x9100		/* deprecated QinQ VLAN [ NOT AN OFFICIALLY REGISTERED ID ] */
-#define ETH_P_QINQ2	0x9200		/* deprecated QinQ VLAN [ NOT AN OFFICIALLY REGISTERED ID ] */
-#define ETH_P_QINQ3	0x9300		/* deprecated QinQ VLAN [ NOT AN OFFICIALLY REGISTERED ID ] */
-#define ETH_P_EDSA	0xDADA		/* Ethertype DSA [ NOT AN OFFICIALLY REGISTERED ID ] */
-#define ETH_P_IFE	0xED3E		/* ForCES inter-FE LFB type */
-#define ETH_P_AF_IUCV   0xFBFB		/* IBM af_iucv [ NOT AN OFFICIALLY REGISTERED ID ] */
-
-#define ETH_P_802_3_MIN	0x0600		/* If the value in the ethernet type is less than this value
-					 * then the frame is Ethernet II. Else it is 802.3 */
-
-/*
- *	Non DIX types. Won't clash for 1500 types.
- */
-
-#define ETH_P_802_3	0x0001		/* Dummy type for 802.3 frames  */
-#define ETH_P_AX25	0x0002		/* Dummy protocol id for AX.25  */
-#define ETH_P_ALL	0x0003		/* Every packet (be careful!!!) */
-#define ETH_P_802_2	0x0004		/* 802.2 frames 		*/
-#define ETH_P_SNAP	0x0005		/* Internal only		*/
-#define ETH_P_DDCMP     0x0006          /* DEC DDCMP: Internal only     */
-#define ETH_P_WAN_PPP   0x0007          /* Dummy type for WAN PPP frames*/
-#define ETH_P_PPP_MP    0x0008          /* Dummy type for PPP MP frames */
-#define ETH_P_LOCALTALK 0x0009		/* Localtalk pseudo type 	*/
-#define ETH_P_CAN	0x000C		/* CAN: Controller Area Network */
-#define ETH_P_CANFD	0x000D		/* CANFD: CAN flexible data rate*/
-#define ETH_P_PPPTALK	0x0010		/* Dummy type for Atalk over PPP*/
-#define ETH_P_TR_802_2	0x0011		/* 802.2 frames 		*/
-#define ETH_P_MOBITEX	0x0015		/* Mobitex (kaz@cafe.net)	*/
-#define ETH_P_CONTROL	0x0016		/* Card specific control frames */
-#define ETH_P_IRDA	0x0017		/* Linux-IrDA			*/
-#define ETH_P_ECONET	0x0018		/* Acorn Econet			*/
-#define ETH_P_HDLC	0x0019		/* HDLC frames			*/
-#define ETH_P_ARCNET	0x001A		/* 1A for ArcNet :-)            */
-#define ETH_P_DSA	0x001B		/* Distributed Switch Arch.	*/
-#define ETH_P_TRAILER	0x001C		/* Trailer switch tagging	*/
-#define ETH_P_PHONET	0x00F5		/* Nokia Phonet frames          */
-#define ETH_P_IEEE802154 0x00F6		/* IEEE802.15.4 frame		*/
-#define ETH_P_CAIF	0x00F7		/* ST-Ericsson CAIF protocol	*/
-#define ETH_P_XDSA	0x00F8		/* Multiplexed DSA protocol	*/
-#define ETH_P_MAP	0x00F9		/* Qualcomm multiplexing and
-					 * aggregation protocol
-					 */
-
-/*
- *	This is an Ethernet frame header.
- */
-
-struct ethhdr {
-	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
-	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
-	__be16		h_proto;		/* packet type ID field	*/
-} __attribute__((packed));
-
-
-#endif /* _LINUX_IF_ETHER_H */
diff --git a/include/linux/if_link.h b/include/linux/if_link.h
deleted file mode 100644
index 1f97d05..0000000
--- a/include/linux/if_link.h
+++ /dev/null
@@ -1,928 +0,0 @@
-#ifndef _LINUX_IF_LINK_H
-#define _LINUX_IF_LINK_H
-
-#include <linux/types.h>
-#include <linux/netlink.h>
-
-/* This struct should be in sync with struct rtnl_link_stats64 */
-struct rtnl_link_stats {
-	__u32	rx_packets;		/* total packets received	*/
-	__u32	tx_packets;		/* total packets transmitted	*/
-	__u32	rx_bytes;		/* total bytes received 	*/
-	__u32	tx_bytes;		/* total bytes transmitted	*/
-	__u32	rx_errors;		/* bad packets received		*/
-	__u32	tx_errors;		/* packet transmit problems	*/
-	__u32	rx_dropped;		/* no space in linux buffers	*/
-	__u32	tx_dropped;		/* no space available in linux	*/
-	__u32	multicast;		/* multicast packets received	*/
-	__u32	collisions;
-
-	/* detailed rx_errors: */
-	__u32	rx_length_errors;
-	__u32	rx_over_errors;		/* receiver ring buff overflow	*/
-	__u32	rx_crc_errors;		/* recved pkt with crc error	*/
-	__u32	rx_frame_errors;	/* recv'd frame alignment error */
-	__u32	rx_fifo_errors;		/* recv'r fifo overrun		*/
-	__u32	rx_missed_errors;	/* receiver missed packet	*/
-
-	/* detailed tx_errors */
-	__u32	tx_aborted_errors;
-	__u32	tx_carrier_errors;
-	__u32	tx_fifo_errors;
-	__u32	tx_heartbeat_errors;
-	__u32	tx_window_errors;
-
-	/* for cslip etc */
-	__u32	rx_compressed;
-	__u32	tx_compressed;
-
-	__u32	rx_nohandler;		/* dropped, no handler found	*/
-};
-
-/* The main device statistics structure */
-struct rtnl_link_stats64 {
-	__u64	rx_packets;		/* total packets received	*/
-	__u64	tx_packets;		/* total packets transmitted	*/
-	__u64	rx_bytes;		/* total bytes received 	*/
-	__u64	tx_bytes;		/* total bytes transmitted	*/
-	__u64	rx_errors;		/* bad packets received		*/
-	__u64	tx_errors;		/* packet transmit problems	*/
-	__u64	rx_dropped;		/* no space in linux buffers	*/
-	__u64	tx_dropped;		/* no space available in linux	*/
-	__u64	multicast;		/* multicast packets received	*/
-	__u64	collisions;
-
-	/* detailed rx_errors: */
-	__u64	rx_length_errors;
-	__u64	rx_over_errors;		/* receiver ring buff overflow	*/
-	__u64	rx_crc_errors;		/* recved pkt with crc error	*/
-	__u64	rx_frame_errors;	/* recv'd frame alignment error */
-	__u64	rx_fifo_errors;		/* recv'r fifo overrun		*/
-	__u64	rx_missed_errors;	/* receiver missed packet	*/
-
-	/* detailed tx_errors */
-	__u64	tx_aborted_errors;
-	__u64	tx_carrier_errors;
-	__u64	tx_fifo_errors;
-	__u64	tx_heartbeat_errors;
-	__u64	tx_window_errors;
-
-	/* for cslip etc */
-	__u64	rx_compressed;
-	__u64	tx_compressed;
-
-	__u64	rx_nohandler;		/* dropped, no handler found	*/
-};
-
-/* The struct should be in sync with struct ifmap */
-struct rtnl_link_ifmap {
-	__u64	mem_start;
-	__u64	mem_end;
-	__u64	base_addr;
-	__u16	irq;
-	__u8	dma;
-	__u8	port;
-};
-
-/*
- * IFLA_AF_SPEC
- *   Contains nested attributes for address family specific attributes.
- *   Each address family may create a attribute with the address family
- *   number as type and create its own attribute structure in it.
- *
- *   Example:
- *   [IFLA_AF_SPEC] = {
- *       [AF_INET] = {
- *           [IFLA_INET_CONF] = ...,
- *       },
- *       [AF_INET6] = {
- *           [IFLA_INET6_FLAGS] = ...,
- *           [IFLA_INET6_CONF] = ...,
- *       }
- *   }
- */
-
-enum {
-	IFLA_UNSPEC,
-	IFLA_ADDRESS,
-	IFLA_BROADCAST,
-	IFLA_IFNAME,
-	IFLA_MTU,
-	IFLA_LINK,
-	IFLA_QDISC,
-	IFLA_STATS,
-	IFLA_COST,
-#define IFLA_COST IFLA_COST
-	IFLA_PRIORITY,
-#define IFLA_PRIORITY IFLA_PRIORITY
-	IFLA_MASTER,
-#define IFLA_MASTER IFLA_MASTER
-	IFLA_WIRELESS,		/* Wireless Extension event - see wireless.h */
-#define IFLA_WIRELESS IFLA_WIRELESS
-	IFLA_PROTINFO,		/* Protocol specific information for a link */
-#define IFLA_PROTINFO IFLA_PROTINFO
-	IFLA_TXQLEN,
-#define IFLA_TXQLEN IFLA_TXQLEN
-	IFLA_MAP,
-#define IFLA_MAP IFLA_MAP
-	IFLA_WEIGHT,
-#define IFLA_WEIGHT IFLA_WEIGHT
-	IFLA_OPERSTATE,
-	IFLA_LINKMODE,
-	IFLA_LINKINFO,
-#define IFLA_LINKINFO IFLA_LINKINFO
-	IFLA_NET_NS_PID,
-	IFLA_IFALIAS,
-	IFLA_NUM_VF,		/* Number of VFs if device is SR-IOV PF */
-	IFLA_VFINFO_LIST,
-	IFLA_STATS64,
-	IFLA_VF_PORTS,
-	IFLA_PORT_SELF,
-	IFLA_AF_SPEC,
-	IFLA_GROUP,		/* Group the device belongs to */
-	IFLA_NET_NS_FD,
-	IFLA_EXT_MASK,		/* Extended info mask, VFs, etc */
-	IFLA_PROMISCUITY,	/* Promiscuity count: > 0 means acts PROMISC */
-#define IFLA_PROMISCUITY IFLA_PROMISCUITY
-	IFLA_NUM_TX_QUEUES,
-	IFLA_NUM_RX_QUEUES,
-	IFLA_CARRIER,
-	IFLA_PHYS_PORT_ID,
-	IFLA_CARRIER_CHANGES,
-	IFLA_PHYS_SWITCH_ID,
-	IFLA_LINK_NETNSID,
-	IFLA_PHYS_PORT_NAME,
-	IFLA_PROTO_DOWN,
-	IFLA_GSO_MAX_SEGS,
-	IFLA_GSO_MAX_SIZE,
-	IFLA_PAD,
-	IFLA_XDP,
-	IFLA_EVENT,
-	__IFLA_MAX
-};
-
-
-#define IFLA_MAX (__IFLA_MAX - 1)
-
-/* backwards compatibility for userspace */
-#define IFLA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct ifinfomsg))))
-#define IFLA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct ifinfomsg))
-
-enum {
-	IFLA_INET_UNSPEC,
-	IFLA_INET_CONF,
-	__IFLA_INET_MAX,
-};
-
-#define IFLA_INET_MAX (__IFLA_INET_MAX - 1)
-
-/* ifi_flags.
-
-   IFF_* flags.
-
-   The only change is:
-   IFF_LOOPBACK, IFF_BROADCAST and IFF_POINTOPOINT are
-   more not changeable by user. They describe link media
-   characteristics and set by device driver.
-
-   Comments:
-   - Combination IFF_BROADCAST|IFF_POINTOPOINT is invalid
-   - If neither of these three flags are set;
-     the interface is NBMA.
-
-   - IFF_MULTICAST does not mean anything special:
-   multicasts can be used on all not-NBMA links.
-   IFF_MULTICAST means that this media uses special encapsulation
-   for multicast frames. Apparently, all IFF_POINTOPOINT and
-   IFF_BROADCAST devices are able to use multicasts too.
- */
-
-/* IFLA_LINK.
-   For usual devices it is equal ifi_index.
-   If it is a "virtual interface" (f.e. tunnel), ifi_link
-   can point to real physical interface (f.e. for bandwidth calculations),
-   or maybe 0, what means, that real media is unknown (usual
-   for IPIP tunnels, when route to endpoint is allowed to change)
- */
-
-/* Subtype attributes for IFLA_PROTINFO */
-enum {
-	IFLA_INET6_UNSPEC,
-	IFLA_INET6_FLAGS,	/* link flags			*/
-	IFLA_INET6_CONF,	/* sysctl parameters		*/
-	IFLA_INET6_STATS,	/* statistics			*/
-	IFLA_INET6_MCAST,	/* MC things. What of them?	*/
-	IFLA_INET6_CACHEINFO,	/* time values and max reasm size */
-	IFLA_INET6_ICMP6STATS,	/* statistics (icmpv6)		*/
-	IFLA_INET6_TOKEN,	/* device token			*/
-	IFLA_INET6_ADDR_GEN_MODE, /* implicit address generator mode */
-	__IFLA_INET6_MAX
-};
-
-#define IFLA_INET6_MAX	(__IFLA_INET6_MAX - 1)
-
-enum in6_addr_gen_mode {
-	IN6_ADDR_GEN_MODE_EUI64,
-	IN6_ADDR_GEN_MODE_NONE,
-	IN6_ADDR_GEN_MODE_STABLE_PRIVACY,
-	IN6_ADDR_GEN_MODE_RANDOM,
-};
-
-/* Bridge section */
-
-enum {
-	IFLA_BR_UNSPEC,
-	IFLA_BR_FORWARD_DELAY,
-	IFLA_BR_HELLO_TIME,
-	IFLA_BR_MAX_AGE,
-	IFLA_BR_AGEING_TIME,
-	IFLA_BR_STP_STATE,
-	IFLA_BR_PRIORITY,
-	IFLA_BR_VLAN_FILTERING,
-	IFLA_BR_VLAN_PROTOCOL,
-	IFLA_BR_GROUP_FWD_MASK,
-	IFLA_BR_ROOT_ID,
-	IFLA_BR_BRIDGE_ID,
-	IFLA_BR_ROOT_PORT,
-	IFLA_BR_ROOT_PATH_COST,
-	IFLA_BR_TOPOLOGY_CHANGE,
-	IFLA_BR_TOPOLOGY_CHANGE_DETECTED,
-	IFLA_BR_HELLO_TIMER,
-	IFLA_BR_TCN_TIMER,
-	IFLA_BR_TOPOLOGY_CHANGE_TIMER,
-	IFLA_BR_GC_TIMER,
-	IFLA_BR_GROUP_ADDR,
-	IFLA_BR_FDB_FLUSH,
-	IFLA_BR_MCAST_ROUTER,
-	IFLA_BR_MCAST_SNOOPING,
-	IFLA_BR_MCAST_QUERY_USE_IFADDR,
-	IFLA_BR_MCAST_QUERIER,
-	IFLA_BR_MCAST_HASH_ELASTICITY,
-	IFLA_BR_MCAST_HASH_MAX,
-	IFLA_BR_MCAST_LAST_MEMBER_CNT,
-	IFLA_BR_MCAST_STARTUP_QUERY_CNT,
-	IFLA_BR_MCAST_LAST_MEMBER_INTVL,
-	IFLA_BR_MCAST_MEMBERSHIP_INTVL,
-	IFLA_BR_MCAST_QUERIER_INTVL,
-	IFLA_BR_MCAST_QUERY_INTVL,
-	IFLA_BR_MCAST_QUERY_RESPONSE_INTVL,
-	IFLA_BR_MCAST_STARTUP_QUERY_INTVL,
-	IFLA_BR_NF_CALL_IPTABLES,
-	IFLA_BR_NF_CALL_IP6TABLES,
-	IFLA_BR_NF_CALL_ARPTABLES,
-	IFLA_BR_VLAN_DEFAULT_PVID,
-	IFLA_BR_PAD,
-	IFLA_BR_VLAN_STATS_ENABLED,
-	IFLA_BR_MCAST_STATS_ENABLED,
-	IFLA_BR_MCAST_IGMP_VERSION,
-	IFLA_BR_MCAST_MLD_VERSION,
-	__IFLA_BR_MAX,
-};
-
-#define IFLA_BR_MAX	(__IFLA_BR_MAX - 1)
-
-struct ifla_bridge_id {
-	__u8	prio[2];
-	__u8	addr[6]; /* ETH_ALEN */
-};
-
-enum {
-	BRIDGE_MODE_UNSPEC,
-	BRIDGE_MODE_HAIRPIN,
-};
-
-enum {
-	IFLA_BRPORT_UNSPEC,
-	IFLA_BRPORT_STATE,	/* Spanning tree state     */
-	IFLA_BRPORT_PRIORITY,	/* "             priority  */
-	IFLA_BRPORT_COST,	/* "             cost      */
-	IFLA_BRPORT_MODE,	/* mode (hairpin)          */
-	IFLA_BRPORT_GUARD,	/* bpdu guard              */
-	IFLA_BRPORT_PROTECT,	/* root port protection    */
-	IFLA_BRPORT_FAST_LEAVE,	/* multicast fast leave    */
-	IFLA_BRPORT_LEARNING,	/* mac learning */
-	IFLA_BRPORT_UNICAST_FLOOD, /* flood unicast traffic */
-	IFLA_BRPORT_PROXYARP,	/* proxy ARP */
-	IFLA_BRPORT_LEARNING_SYNC, /* mac learning sync from device */
-	IFLA_BRPORT_PROXYARP_WIFI, /* proxy ARP for Wi-Fi */
-	IFLA_BRPORT_ROOT_ID,	/* designated root */
-	IFLA_BRPORT_BRIDGE_ID,	/* designated bridge */
-	IFLA_BRPORT_DESIGNATED_PORT,
-	IFLA_BRPORT_DESIGNATED_COST,
-	IFLA_BRPORT_ID,
-	IFLA_BRPORT_NO,
-	IFLA_BRPORT_TOPOLOGY_CHANGE_ACK,
-	IFLA_BRPORT_CONFIG_PENDING,
-	IFLA_BRPORT_MESSAGE_AGE_TIMER,
-	IFLA_BRPORT_FORWARD_DELAY_TIMER,
-	IFLA_BRPORT_HOLD_TIMER,
-	IFLA_BRPORT_FLUSH,
-	IFLA_BRPORT_MULTICAST_ROUTER,
-	IFLA_BRPORT_PAD,
-	IFLA_BRPORT_MCAST_FLOOD,
-	IFLA_BRPORT_MCAST_TO_UCAST,
-	IFLA_BRPORT_VLAN_TUNNEL,
-	IFLA_BRPORT_BCAST_FLOOD,
-	__IFLA_BRPORT_MAX
-};
-#define IFLA_BRPORT_MAX (__IFLA_BRPORT_MAX - 1)
-
-struct ifla_cacheinfo {
-	__u32	max_reasm_len;
-	__u32	tstamp;		/* ipv6InterfaceTable updated timestamp */
-	__u32	reachable_time;
-	__u32	retrans_time;
-};
-
-enum {
-	IFLA_INFO_UNSPEC,
-	IFLA_INFO_KIND,
-	IFLA_INFO_DATA,
-	IFLA_INFO_XSTATS,
-	IFLA_INFO_SLAVE_KIND,
-	IFLA_INFO_SLAVE_DATA,
-	__IFLA_INFO_MAX,
-};
-
-#define IFLA_INFO_MAX	(__IFLA_INFO_MAX - 1)
-
-/* VLAN section */
-
-enum {
-	IFLA_VLAN_UNSPEC,
-	IFLA_VLAN_ID,
-	IFLA_VLAN_FLAGS,
-	IFLA_VLAN_EGRESS_QOS,
-	IFLA_VLAN_INGRESS_QOS,
-	IFLA_VLAN_PROTOCOL,
-	__IFLA_VLAN_MAX,
-};
-
-#define IFLA_VLAN_MAX	(__IFLA_VLAN_MAX - 1)
-
-struct ifla_vlan_flags {
-	__u32	flags;
-	__u32	mask;
-};
-
-enum {
-	IFLA_VLAN_QOS_UNSPEC,
-	IFLA_VLAN_QOS_MAPPING,
-	__IFLA_VLAN_QOS_MAX
-};
-
-#define IFLA_VLAN_QOS_MAX	(__IFLA_VLAN_QOS_MAX - 1)
-
-struct ifla_vlan_qos_mapping {
-	__u32 from;
-	__u32 to;
-};
-
-/* MACVLAN section */
-enum {
-	IFLA_MACVLAN_UNSPEC,
-	IFLA_MACVLAN_MODE,
-	IFLA_MACVLAN_FLAGS,
-	IFLA_MACVLAN_MACADDR_MODE,
-	IFLA_MACVLAN_MACADDR,
-	IFLA_MACVLAN_MACADDR_DATA,
-	IFLA_MACVLAN_MACADDR_COUNT,
-	__IFLA_MACVLAN_MAX,
-};
-
-#define IFLA_MACVLAN_MAX (__IFLA_MACVLAN_MAX - 1)
-
-enum macvlan_mode {
-	MACVLAN_MODE_PRIVATE = 1, /* don't talk to other macvlans */
-	MACVLAN_MODE_VEPA    = 2, /* talk to other ports through ext bridge */
-	MACVLAN_MODE_BRIDGE  = 4, /* talk to bridge ports directly */
-	MACVLAN_MODE_PASSTHRU = 8,/* take over the underlying device */
-	MACVLAN_MODE_SOURCE  = 16,/* use source MAC address list to assign */
-};
-
-enum macvlan_macaddr_mode {
-	MACVLAN_MACADDR_ADD,
-	MACVLAN_MACADDR_DEL,
-	MACVLAN_MACADDR_FLUSH,
-	MACVLAN_MACADDR_SET,
-};
-
-#define MACVLAN_FLAG_NOPROMISC	1
-
-/* VRF section */
-enum {
-	IFLA_VRF_UNSPEC,
-	IFLA_VRF_TABLE,
-	__IFLA_VRF_MAX
-};
-
-#define IFLA_VRF_MAX (__IFLA_VRF_MAX - 1)
-
-enum {
-	IFLA_VRF_PORT_UNSPEC,
-	IFLA_VRF_PORT_TABLE,
-	__IFLA_VRF_PORT_MAX
-};
-
-#define IFLA_VRF_PORT_MAX (__IFLA_VRF_PORT_MAX - 1)
-
-/* MACSEC section */
-enum {
-	IFLA_MACSEC_UNSPEC,
-	IFLA_MACSEC_SCI,
-	IFLA_MACSEC_PORT,
-	IFLA_MACSEC_ICV_LEN,
-	IFLA_MACSEC_CIPHER_SUITE,
-	IFLA_MACSEC_WINDOW,
-	IFLA_MACSEC_ENCODING_SA,
-	IFLA_MACSEC_ENCRYPT,
-	IFLA_MACSEC_PROTECT,
-	IFLA_MACSEC_INC_SCI,
-	IFLA_MACSEC_ES,
-	IFLA_MACSEC_SCB,
-	IFLA_MACSEC_REPLAY_PROTECT,
-	IFLA_MACSEC_VALIDATION,
-	IFLA_MACSEC_PAD,
-	__IFLA_MACSEC_MAX,
-};
-
-#define IFLA_MACSEC_MAX (__IFLA_MACSEC_MAX - 1)
-
-enum macsec_validation_type {
-	MACSEC_VALIDATE_DISABLED = 0,
-	MACSEC_VALIDATE_CHECK = 1,
-	MACSEC_VALIDATE_STRICT = 2,
-	__MACSEC_VALIDATE_END,
-	MACSEC_VALIDATE_MAX = __MACSEC_VALIDATE_END - 1,
-};
-
-/* IPVLAN section */
-enum {
-	IFLA_IPVLAN_UNSPEC,
-	IFLA_IPVLAN_MODE,
-	__IFLA_IPVLAN_MAX
-};
-
-#define IFLA_IPVLAN_MAX (__IFLA_IPVLAN_MAX - 1)
-
-enum ipvlan_mode {
-	IPVLAN_MODE_L2 = 0,
-	IPVLAN_MODE_L3,
-	IPVLAN_MODE_L3S,
-	IPVLAN_MODE_MAX
-};
-
-/* VXLAN section */
-enum {
-	IFLA_VXLAN_UNSPEC,
-	IFLA_VXLAN_ID,
-	IFLA_VXLAN_GROUP,	/* group or remote address */
-	IFLA_VXLAN_LINK,
-	IFLA_VXLAN_LOCAL,
-	IFLA_VXLAN_TTL,
-	IFLA_VXLAN_TOS,
-	IFLA_VXLAN_LEARNING,
-	IFLA_VXLAN_AGEING,
-	IFLA_VXLAN_LIMIT,
-	IFLA_VXLAN_PORT_RANGE,	/* source port */
-	IFLA_VXLAN_PROXY,
-	IFLA_VXLAN_RSC,
-	IFLA_VXLAN_L2MISS,
-	IFLA_VXLAN_L3MISS,
-	IFLA_VXLAN_PORT,	/* destination port */
-	IFLA_VXLAN_GROUP6,
-	IFLA_VXLAN_LOCAL6,
-	IFLA_VXLAN_UDP_CSUM,
-	IFLA_VXLAN_UDP_ZERO_CSUM6_TX,
-	IFLA_VXLAN_UDP_ZERO_CSUM6_RX,
-	IFLA_VXLAN_REMCSUM_TX,
-	IFLA_VXLAN_REMCSUM_RX,
-	IFLA_VXLAN_GBP,
-	IFLA_VXLAN_REMCSUM_NOPARTIAL,
-	IFLA_VXLAN_COLLECT_METADATA,
-	IFLA_VXLAN_LABEL,
-	IFLA_VXLAN_GPE,
-	__IFLA_VXLAN_MAX
-};
-#define IFLA_VXLAN_MAX	(__IFLA_VXLAN_MAX - 1)
-
-struct ifla_vxlan_port_range {
-	__be16	low;
-	__be16	high;
-};
-
-/* GENEVE section */
-enum {
-	IFLA_GENEVE_UNSPEC,
-	IFLA_GENEVE_ID,
-	IFLA_GENEVE_REMOTE,
-	IFLA_GENEVE_TTL,
-	IFLA_GENEVE_TOS,
-	IFLA_GENEVE_PORT,	/* destination port */
-	IFLA_GENEVE_COLLECT_METADATA,
-	IFLA_GENEVE_REMOTE6,
-	IFLA_GENEVE_UDP_CSUM,
-	IFLA_GENEVE_UDP_ZERO_CSUM6_TX,
-	IFLA_GENEVE_UDP_ZERO_CSUM6_RX,
-	IFLA_GENEVE_LABEL,
-	__IFLA_GENEVE_MAX
-};
-#define IFLA_GENEVE_MAX	(__IFLA_GENEVE_MAX - 1)
-
-/* PPP section */
-enum {
-	IFLA_PPP_UNSPEC,
-	IFLA_PPP_DEV_FD,
-	__IFLA_PPP_MAX
-};
-#define IFLA_PPP_MAX (__IFLA_PPP_MAX - 1)
-
-/* GTP section */
-
-enum ifla_gtp_role {
-	GTP_ROLE_GGSN = 0,
-	GTP_ROLE_SGSN,
-};
-
-enum {
-	IFLA_GTP_UNSPEC,
-	IFLA_GTP_FD0,
-	IFLA_GTP_FD1,
-	IFLA_GTP_PDP_HASHSIZE,
-	IFLA_GTP_ROLE,
-	__IFLA_GTP_MAX,
-};
-#define IFLA_GTP_MAX (__IFLA_GTP_MAX - 1)
-
-/* Bonding section */
-
-enum {
-	IFLA_BOND_UNSPEC,
-	IFLA_BOND_MODE,
-	IFLA_BOND_ACTIVE_SLAVE,
-	IFLA_BOND_MIIMON,
-	IFLA_BOND_UPDELAY,
-	IFLA_BOND_DOWNDELAY,
-	IFLA_BOND_USE_CARRIER,
-	IFLA_BOND_ARP_INTERVAL,
-	IFLA_BOND_ARP_IP_TARGET,
-	IFLA_BOND_ARP_VALIDATE,
-	IFLA_BOND_ARP_ALL_TARGETS,
-	IFLA_BOND_PRIMARY,
-	IFLA_BOND_PRIMARY_RESELECT,
-	IFLA_BOND_FAIL_OVER_MAC,
-	IFLA_BOND_XMIT_HASH_POLICY,
-	IFLA_BOND_RESEND_IGMP,
-	IFLA_BOND_NUM_PEER_NOTIF,
-	IFLA_BOND_ALL_SLAVES_ACTIVE,
-	IFLA_BOND_MIN_LINKS,
-	IFLA_BOND_LP_INTERVAL,
-	IFLA_BOND_PACKETS_PER_SLAVE,
-	IFLA_BOND_AD_LACP_RATE,
-	IFLA_BOND_AD_SELECT,
-	IFLA_BOND_AD_INFO,
-	IFLA_BOND_AD_ACTOR_SYS_PRIO,
-	IFLA_BOND_AD_USER_PORT_KEY,
-	IFLA_BOND_AD_ACTOR_SYSTEM,
-	IFLA_BOND_TLB_DYNAMIC_LB,
-	__IFLA_BOND_MAX,
-};
-
-#define IFLA_BOND_MAX	(__IFLA_BOND_MAX - 1)
-
-enum {
-	IFLA_BOND_AD_INFO_UNSPEC,
-	IFLA_BOND_AD_INFO_AGGREGATOR,
-	IFLA_BOND_AD_INFO_NUM_PORTS,
-	IFLA_BOND_AD_INFO_ACTOR_KEY,
-	IFLA_BOND_AD_INFO_PARTNER_KEY,
-	IFLA_BOND_AD_INFO_PARTNER_MAC,
-	__IFLA_BOND_AD_INFO_MAX,
-};
-
-#define IFLA_BOND_AD_INFO_MAX	(__IFLA_BOND_AD_INFO_MAX - 1)
-
-enum {
-	IFLA_BOND_SLAVE_UNSPEC,
-	IFLA_BOND_SLAVE_STATE,
-	IFLA_BOND_SLAVE_MII_STATUS,
-	IFLA_BOND_SLAVE_LINK_FAILURE_COUNT,
-	IFLA_BOND_SLAVE_PERM_HWADDR,
-	IFLA_BOND_SLAVE_QUEUE_ID,
-	IFLA_BOND_SLAVE_AD_AGGREGATOR_ID,
-	IFLA_BOND_SLAVE_AD_ACTOR_OPER_PORT_STATE,
-	IFLA_BOND_SLAVE_AD_PARTNER_OPER_PORT_STATE,
-	__IFLA_BOND_SLAVE_MAX,
-};
-
-#define IFLA_BOND_SLAVE_MAX	(__IFLA_BOND_SLAVE_MAX - 1)
-
-/* SR-IOV virtual function management section */
-
-enum {
-	IFLA_VF_INFO_UNSPEC,
-	IFLA_VF_INFO,
-	__IFLA_VF_INFO_MAX,
-};
-
-#define IFLA_VF_INFO_MAX (__IFLA_VF_INFO_MAX - 1)
-
-enum {
-	IFLA_VF_UNSPEC,
-	IFLA_VF_MAC,		/* Hardware queue specific attributes */
-	IFLA_VF_VLAN,		/* VLAN ID and QoS */
-	IFLA_VF_TX_RATE,	/* Max TX Bandwidth Allocation */
-	IFLA_VF_SPOOFCHK,	/* Spoof Checking on/off switch */
-	IFLA_VF_LINK_STATE,	/* link state enable/disable/auto switch */
-	IFLA_VF_RATE,		/* Min and Max TX Bandwidth Allocation */
-	IFLA_VF_RSS_QUERY_EN,	/* RSS Redirection Table and Hash Key query
-				 * on/off switch
-				 */
-	IFLA_VF_STATS,		/* network device statistics */
-	IFLA_VF_TRUST,		/* Trust VF */
-	IFLA_VF_IB_NODE_GUID,	/* VF Infiniband node GUID */
-	IFLA_VF_IB_PORT_GUID,	/* VF Infiniband port GUID */
-	IFLA_VF_VLAN_LIST,	/* nested list of vlans, option for QinQ */
-	__IFLA_VF_MAX,
-};
-
-#define IFLA_VF_MAX (__IFLA_VF_MAX - 1)
-
-struct ifla_vf_mac {
-	__u32 vf;
-	__u8 mac[32]; /* MAX_ADDR_LEN */
-};
-
-struct ifla_vf_vlan {
-	__u32 vf;
-	__u32 vlan; /* 0 - 4095, 0 disables VLAN filter */
-	__u32 qos;
-};
-
-enum {
-	IFLA_VF_VLAN_INFO_UNSPEC,
-	IFLA_VF_VLAN_INFO,	/* VLAN ID, QoS and VLAN protocol */
-	__IFLA_VF_VLAN_INFO_MAX,
-};
-
-#define IFLA_VF_VLAN_INFO_MAX (__IFLA_VF_VLAN_INFO_MAX - 1)
-#define MAX_VLAN_LIST_LEN 1
-
-struct ifla_vf_vlan_info {
-	__u32 vf;
-	__u32 vlan; /* 0 - 4095, 0 disables VLAN filter */
-	__u32 qos;
-	__be16 vlan_proto; /* VLAN protocol either 802.1Q or 802.1ad */
-};
-
-struct ifla_vf_tx_rate {
-	__u32 vf;
-	__u32 rate; /* Max TX bandwidth in Mbps, 0 disables throttling */
-};
-
-struct ifla_vf_rate {
-	__u32 vf;
-	__u32 min_tx_rate; /* Min Bandwidth in Mbps */
-	__u32 max_tx_rate; /* Max Bandwidth in Mbps */
-};
-
-struct ifla_vf_spoofchk {
-	__u32 vf;
-	__u32 setting;
-};
-
-struct ifla_vf_guid {
-	__u32 vf;
-	__u64 guid;
-};
-
-enum {
-	IFLA_VF_LINK_STATE_AUTO,	/* link state of the uplink */
-	IFLA_VF_LINK_STATE_ENABLE,	/* link always up */
-	IFLA_VF_LINK_STATE_DISABLE,	/* link always down */
-	__IFLA_VF_LINK_STATE_MAX,
-};
-
-struct ifla_vf_link_state {
-	__u32 vf;
-	__u32 link_state;
-};
-
-struct ifla_vf_rss_query_en {
-	__u32 vf;
-	__u32 setting;
-};
-
-enum {
-	IFLA_VF_STATS_RX_PACKETS,
-	IFLA_VF_STATS_TX_PACKETS,
-	IFLA_VF_STATS_RX_BYTES,
-	IFLA_VF_STATS_TX_BYTES,
-	IFLA_VF_STATS_BROADCAST,
-	IFLA_VF_STATS_MULTICAST,
-	IFLA_VF_STATS_PAD,
-	__IFLA_VF_STATS_MAX,
-};
-
-#define IFLA_VF_STATS_MAX (__IFLA_VF_STATS_MAX - 1)
-
-struct ifla_vf_trust {
-	__u32 vf;
-	__u32 setting;
-};
-
-/* VF ports management section
- *
- *	Nested layout of set/get msg is:
- *
- *		[IFLA_NUM_VF]
- *		[IFLA_VF_PORTS]
- *			[IFLA_VF_PORT]
- *				[IFLA_PORT_*], ...
- *			[IFLA_VF_PORT]
- *				[IFLA_PORT_*], ...
- *			...
- *		[IFLA_PORT_SELF]
- *			[IFLA_PORT_*], ...
- */
-
-enum {
-	IFLA_VF_PORT_UNSPEC,
-	IFLA_VF_PORT,			/* nest */
-	__IFLA_VF_PORT_MAX,
-};
-
-#define IFLA_VF_PORT_MAX (__IFLA_VF_PORT_MAX - 1)
-
-enum {
-	IFLA_PORT_UNSPEC,
-	IFLA_PORT_VF,			/* __u32 */
-	IFLA_PORT_PROFILE,		/* string */
-	IFLA_PORT_VSI_TYPE,		/* 802.1Qbg (pre-)standard VDP */
-	IFLA_PORT_INSTANCE_UUID,	/* binary UUID */
-	IFLA_PORT_HOST_UUID,		/* binary UUID */
-	IFLA_PORT_REQUEST,		/* __u8 */
-	IFLA_PORT_RESPONSE,		/* __u16, output only */
-	__IFLA_PORT_MAX,
-};
-
-#define IFLA_PORT_MAX (__IFLA_PORT_MAX - 1)
-
-#define PORT_PROFILE_MAX	40
-#define PORT_UUID_MAX		16
-#define PORT_SELF_VF		-1
-
-enum {
-	PORT_REQUEST_PREASSOCIATE = 0,
-	PORT_REQUEST_PREASSOCIATE_RR,
-	PORT_REQUEST_ASSOCIATE,
-	PORT_REQUEST_DISASSOCIATE,
-};
-
-enum {
-	PORT_VDP_RESPONSE_SUCCESS = 0,
-	PORT_VDP_RESPONSE_INVALID_FORMAT,
-	PORT_VDP_RESPONSE_INSUFFICIENT_RESOURCES,
-	PORT_VDP_RESPONSE_UNUSED_VTID,
-	PORT_VDP_RESPONSE_VTID_VIOLATION,
-	PORT_VDP_RESPONSE_VTID_VERSION_VIOALTION,
-	PORT_VDP_RESPONSE_OUT_OF_SYNC,
-	/* 0x08-0xFF reserved for future VDP use */
-	PORT_PROFILE_RESPONSE_SUCCESS = 0x100,
-	PORT_PROFILE_RESPONSE_INPROGRESS,
-	PORT_PROFILE_RESPONSE_INVALID,
-	PORT_PROFILE_RESPONSE_BADSTATE,
-	PORT_PROFILE_RESPONSE_INSUFFICIENT_RESOURCES,
-	PORT_PROFILE_RESPONSE_ERROR,
-};
-
-struct ifla_port_vsi {
-	__u8 vsi_mgr_id;
-	__u8 vsi_type_id[3];
-	__u8 vsi_type_version;
-	__u8 pad[3];
-};
-
-
-/* IPoIB section */
-
-enum {
-	IFLA_IPOIB_UNSPEC,
-	IFLA_IPOIB_PKEY,
-	IFLA_IPOIB_MODE,
-	IFLA_IPOIB_UMCAST,
-	__IFLA_IPOIB_MAX
-};
-
-enum {
-	IPOIB_MODE_DATAGRAM  = 0, /* using unreliable datagram QPs */
-	IPOIB_MODE_CONNECTED = 1, /* using connected QPs */
-};
-
-#define IFLA_IPOIB_MAX (__IFLA_IPOIB_MAX - 1)
-
-
-/* HSR section */
-
-enum {
-	IFLA_HSR_UNSPEC,
-	IFLA_HSR_SLAVE1,
-	IFLA_HSR_SLAVE2,
-	IFLA_HSR_MULTICAST_SPEC,	/* Last byte of supervision addr */
-	IFLA_HSR_SUPERVISION_ADDR,	/* Supervision frame multicast addr */
-	IFLA_HSR_SEQ_NR,
-	IFLA_HSR_VERSION,		/* HSR version */
-	__IFLA_HSR_MAX,
-};
-
-#define IFLA_HSR_MAX (__IFLA_HSR_MAX - 1)
-
-/* STATS section */
-
-struct if_stats_msg {
-	__u8  family;
-	__u8  pad1;
-	__u16 pad2;
-	__u32 ifindex;
-	__u32 filter_mask;
-};
-
-/* A stats attribute can be netdev specific or a global stat.
- * For netdev stats, lets use the prefix IFLA_STATS_LINK_*
- */
-enum {
-	IFLA_STATS_UNSPEC, /* also used as 64bit pad attribute */
-	IFLA_STATS_LINK_64,
-	IFLA_STATS_LINK_XSTATS,
-	IFLA_STATS_LINK_XSTATS_SLAVE,
-	IFLA_STATS_LINK_OFFLOAD_XSTATS,
-	IFLA_STATS_AF_SPEC,
-	__IFLA_STATS_MAX,
-};
-
-#define IFLA_STATS_MAX (__IFLA_STATS_MAX - 1)
-
-#define IFLA_STATS_FILTER_BIT(ATTR)	(1 << (ATTR - 1))
-
-/* These are embedded into IFLA_STATS_LINK_XSTATS:
- * [IFLA_STATS_LINK_XSTATS]
- * -> [LINK_XSTATS_TYPE_xxx]
- *    -> [rtnl link type specific attributes]
- */
-enum {
-	LINK_XSTATS_TYPE_UNSPEC,
-	LINK_XSTATS_TYPE_BRIDGE,
-	__LINK_XSTATS_TYPE_MAX
-};
-#define LINK_XSTATS_TYPE_MAX (__LINK_XSTATS_TYPE_MAX - 1)
-
-/* These are stats embedded into IFLA_STATS_LINK_OFFLOAD_XSTATS */
-enum {
-	IFLA_OFFLOAD_XSTATS_UNSPEC,
-	IFLA_OFFLOAD_XSTATS_CPU_HIT, /* struct rtnl_link_stats64 */
-	__IFLA_OFFLOAD_XSTATS_MAX
-};
-#define IFLA_OFFLOAD_XSTATS_MAX (__IFLA_OFFLOAD_XSTATS_MAX - 1)
-
-/* XDP section */
-
-#define XDP_FLAGS_UPDATE_IF_NOEXIST	(1U << 0)
-#define XDP_FLAGS_SKB_MODE		(1U << 1)
-#define XDP_FLAGS_DRV_MODE		(1U << 2)
-#define XDP_FLAGS_HW_MODE		(1U << 3)
-#define XDP_FLAGS_MODES			(XDP_FLAGS_SKB_MODE | \
-					 XDP_FLAGS_DRV_MODE | \
-					 XDP_FLAGS_HW_MODE)
-#define XDP_FLAGS_MASK			(XDP_FLAGS_UPDATE_IF_NOEXIST | \
-					 XDP_FLAGS_MODES)
-
-/* These are stored into IFLA_XDP_ATTACHED on dump. */
-enum {
-	XDP_ATTACHED_NONE = 0,
-	XDP_ATTACHED_DRV,
-	XDP_ATTACHED_SKB,
-	XDP_ATTACHED_HW,
-};
-
-enum {
-	IFLA_XDP_UNSPEC,
-	IFLA_XDP_FD,
-	IFLA_XDP_ATTACHED,
-	IFLA_XDP_FLAGS,
-	IFLA_XDP_PROG_ID,
-	__IFLA_XDP_MAX,
-};
-
-#define IFLA_XDP_MAX (__IFLA_XDP_MAX - 1)
-
-enum {
-	IFLA_EVENT_NONE,
-	IFLA_EVENT_REBOOT,		/* internal reset / reboot */
-	IFLA_EVENT_FEATURES,		/* change in offload features */
-	IFLA_EVENT_BONDING_FAILOVER,	/* change in active slave */
-	IFLA_EVENT_NOTIFY_PEERS,	/* re-sent grat. arp/ndisc */
-	IFLA_EVENT_IGMP_RESEND,		/* re-sent IGMP JOIN */
-	IFLA_EVENT_BONDING_OPTIONS,	/* change in bonding options */
-};
-
-#endif /* _LINUX_IF_LINK_H */
diff --git a/include/linux/if_macsec.h b/include/linux/if_macsec.h
deleted file mode 100644
index 22939a3..0000000
--- a/include/linux/if_macsec.h
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- * include/uapi/linux/if_macsec.h - MACsec device
- *
- * Copyright (c) 2015 Sabrina Dubroca <sd@queasysnail.net>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#ifndef _MACSEC_H
-#define _MACSEC_H
-
-#include <linux/types.h>
-
-#define MACSEC_GENL_NAME "macsec"
-#define MACSEC_GENL_VERSION 1
-
-#define MACSEC_MAX_KEY_LEN 128
-
-#define MACSEC_KEYID_LEN 16
-
-#define MACSEC_DEFAULT_CIPHER_ID   0x0080020001000001ULL
-#define MACSEC_DEFAULT_CIPHER_ALT  0x0080C20001000001ULL
-
-#define MACSEC_MIN_ICV_LEN 8
-#define MACSEC_MAX_ICV_LEN 32
-/* upper limit for ICV length as recommended by IEEE802.1AE-2006 */
-#define MACSEC_STD_ICV_LEN 16
-
-enum macsec_attrs {
-	MACSEC_ATTR_UNSPEC,
-	MACSEC_ATTR_IFINDEX,     /* u32, ifindex of the MACsec netdevice */
-	MACSEC_ATTR_RXSC_CONFIG, /* config, nested macsec_rxsc_attrs */
-	MACSEC_ATTR_SA_CONFIG,   /* config, nested macsec_sa_attrs */
-	MACSEC_ATTR_SECY,        /* dump, nested macsec_secy_attrs */
-	MACSEC_ATTR_TXSA_LIST,   /* dump, nested, macsec_sa_attrs for each TXSA */
-	MACSEC_ATTR_RXSC_LIST,   /* dump, nested, macsec_rxsc_attrs for each RXSC */
-	MACSEC_ATTR_TXSC_STATS,  /* dump, nested, macsec_txsc_stats_attr */
-	MACSEC_ATTR_SECY_STATS,  /* dump, nested, macsec_secy_stats_attr */
-	__MACSEC_ATTR_END,
-	NUM_MACSEC_ATTR = __MACSEC_ATTR_END,
-	MACSEC_ATTR_MAX = __MACSEC_ATTR_END - 1,
-};
-
-enum macsec_secy_attrs {
-	MACSEC_SECY_ATTR_UNSPEC,
-	MACSEC_SECY_ATTR_SCI,
-	MACSEC_SECY_ATTR_ENCODING_SA,
-	MACSEC_SECY_ATTR_WINDOW,
-	MACSEC_SECY_ATTR_CIPHER_SUITE,
-	MACSEC_SECY_ATTR_ICV_LEN,
-	MACSEC_SECY_ATTR_PROTECT,
-	MACSEC_SECY_ATTR_REPLAY,
-	MACSEC_SECY_ATTR_OPER,
-	MACSEC_SECY_ATTR_VALIDATE,
-	MACSEC_SECY_ATTR_ENCRYPT,
-	MACSEC_SECY_ATTR_INC_SCI,
-	MACSEC_SECY_ATTR_ES,
-	MACSEC_SECY_ATTR_SCB,
-	MACSEC_SECY_ATTR_PAD,
-	__MACSEC_SECY_ATTR_END,
-	NUM_MACSEC_SECY_ATTR = __MACSEC_SECY_ATTR_END,
-	MACSEC_SECY_ATTR_MAX = __MACSEC_SECY_ATTR_END - 1,
-};
-
-enum macsec_rxsc_attrs {
-	MACSEC_RXSC_ATTR_UNSPEC,
-	MACSEC_RXSC_ATTR_SCI,     /* config/dump, u64 */
-	MACSEC_RXSC_ATTR_ACTIVE,  /* config/dump, u8 0..1 */
-	MACSEC_RXSC_ATTR_SA_LIST, /* dump, nested */
-	MACSEC_RXSC_ATTR_STATS,   /* dump, nested, macsec_rxsc_stats_attr */
-	MACSEC_RXSC_ATTR_PAD,
-	__MACSEC_RXSC_ATTR_END,
-	NUM_MACSEC_RXSC_ATTR = __MACSEC_RXSC_ATTR_END,
-	MACSEC_RXSC_ATTR_MAX = __MACSEC_RXSC_ATTR_END - 1,
-};
-
-enum macsec_sa_attrs {
-	MACSEC_SA_ATTR_UNSPEC,
-	MACSEC_SA_ATTR_AN,     /* config/dump, u8 0..3 */
-	MACSEC_SA_ATTR_ACTIVE, /* config/dump, u8 0..1 */
-	MACSEC_SA_ATTR_PN,     /* config/dump, u32 */
-	MACSEC_SA_ATTR_KEY,    /* config, data */
-	MACSEC_SA_ATTR_KEYID,  /* config/dump, 128-bit */
-	MACSEC_SA_ATTR_STATS,  /* dump, nested, macsec_sa_stats_attr */
-	MACSEC_SA_ATTR_PAD,
-	__MACSEC_SA_ATTR_END,
-	NUM_MACSEC_SA_ATTR = __MACSEC_SA_ATTR_END,
-	MACSEC_SA_ATTR_MAX = __MACSEC_SA_ATTR_END - 1,
-};
-
-enum macsec_nl_commands {
-	MACSEC_CMD_GET_TXSC,
-	MACSEC_CMD_ADD_RXSC,
-	MACSEC_CMD_DEL_RXSC,
-	MACSEC_CMD_UPD_RXSC,
-	MACSEC_CMD_ADD_TXSA,
-	MACSEC_CMD_DEL_TXSA,
-	MACSEC_CMD_UPD_TXSA,
-	MACSEC_CMD_ADD_RXSA,
-	MACSEC_CMD_DEL_RXSA,
-	MACSEC_CMD_UPD_RXSA,
-};
-
-/* u64 per-RXSC stats */
-enum macsec_rxsc_stats_attr {
-	MACSEC_RXSC_STATS_ATTR_UNSPEC,
-	MACSEC_RXSC_STATS_ATTR_IN_OCTETS_VALIDATED,
-	MACSEC_RXSC_STATS_ATTR_IN_OCTETS_DECRYPTED,
-	MACSEC_RXSC_STATS_ATTR_IN_PKTS_UNCHECKED,
-	MACSEC_RXSC_STATS_ATTR_IN_PKTS_DELAYED,
-	MACSEC_RXSC_STATS_ATTR_IN_PKTS_OK,
-	MACSEC_RXSC_STATS_ATTR_IN_PKTS_INVALID,
-	MACSEC_RXSC_STATS_ATTR_IN_PKTS_LATE,
-	MACSEC_RXSC_STATS_ATTR_IN_PKTS_NOT_VALID,
-	MACSEC_RXSC_STATS_ATTR_IN_PKTS_NOT_USING_SA,
-	MACSEC_RXSC_STATS_ATTR_IN_PKTS_UNUSED_SA,
-	MACSEC_RXSC_STATS_ATTR_PAD,
-	__MACSEC_RXSC_STATS_ATTR_END,
-	NUM_MACSEC_RXSC_STATS_ATTR = __MACSEC_RXSC_STATS_ATTR_END,
-	MACSEC_RXSC_STATS_ATTR_MAX = __MACSEC_RXSC_STATS_ATTR_END - 1,
-};
-
-/* u32 per-{RX,TX}SA stats */
-enum macsec_sa_stats_attr {
-	MACSEC_SA_STATS_ATTR_UNSPEC,
-	MACSEC_SA_STATS_ATTR_IN_PKTS_OK,
-	MACSEC_SA_STATS_ATTR_IN_PKTS_INVALID,
-	MACSEC_SA_STATS_ATTR_IN_PKTS_NOT_VALID,
-	MACSEC_SA_STATS_ATTR_IN_PKTS_NOT_USING_SA,
-	MACSEC_SA_STATS_ATTR_IN_PKTS_UNUSED_SA,
-	MACSEC_SA_STATS_ATTR_OUT_PKTS_PROTECTED,
-	MACSEC_SA_STATS_ATTR_OUT_PKTS_ENCRYPTED,
-	__MACSEC_SA_STATS_ATTR_END,
-	NUM_MACSEC_SA_STATS_ATTR = __MACSEC_SA_STATS_ATTR_END,
-	MACSEC_SA_STATS_ATTR_MAX = __MACSEC_SA_STATS_ATTR_END - 1,
-};
-
-/* u64 per-TXSC stats */
-enum macsec_txsc_stats_attr {
-	MACSEC_TXSC_STATS_ATTR_UNSPEC,
-	MACSEC_TXSC_STATS_ATTR_OUT_PKTS_PROTECTED,
-	MACSEC_TXSC_STATS_ATTR_OUT_PKTS_ENCRYPTED,
-	MACSEC_TXSC_STATS_ATTR_OUT_OCTETS_PROTECTED,
-	MACSEC_TXSC_STATS_ATTR_OUT_OCTETS_ENCRYPTED,
-	MACSEC_TXSC_STATS_ATTR_PAD,
-	__MACSEC_TXSC_STATS_ATTR_END,
-	NUM_MACSEC_TXSC_STATS_ATTR = __MACSEC_TXSC_STATS_ATTR_END,
-	MACSEC_TXSC_STATS_ATTR_MAX = __MACSEC_TXSC_STATS_ATTR_END - 1,
-};
-
-/* u64 per-SecY stats */
-enum macsec_secy_stats_attr {
-	MACSEC_SECY_STATS_ATTR_UNSPEC,
-	MACSEC_SECY_STATS_ATTR_OUT_PKTS_UNTAGGED,
-	MACSEC_SECY_STATS_ATTR_IN_PKTS_UNTAGGED,
-	MACSEC_SECY_STATS_ATTR_OUT_PKTS_TOO_LONG,
-	MACSEC_SECY_STATS_ATTR_IN_PKTS_NO_TAG,
-	MACSEC_SECY_STATS_ATTR_IN_PKTS_BAD_TAG,
-	MACSEC_SECY_STATS_ATTR_IN_PKTS_UNKNOWN_SCI,
-	MACSEC_SECY_STATS_ATTR_IN_PKTS_NO_SCI,
-	MACSEC_SECY_STATS_ATTR_IN_PKTS_OVERRUN,
-	MACSEC_SECY_STATS_ATTR_PAD,
-	__MACSEC_SECY_STATS_ATTR_END,
-	NUM_MACSEC_SECY_STATS_ATTR = __MACSEC_SECY_STATS_ATTR_END,
-	MACSEC_SECY_STATS_ATTR_MAX = __MACSEC_SECY_STATS_ATTR_END - 1,
-};
-
-#endif /* _MACSEC_H */
diff --git a/include/linux/if_packet.h b/include/linux/if_packet.h
deleted file mode 100644
index 4df96a7..0000000
--- a/include/linux/if_packet.h
+++ /dev/null
@@ -1,302 +0,0 @@
-#ifndef __LINUX_IF_PACKET_H
-#define __LINUX_IF_PACKET_H
-
-#include <linux/types.h>
-
-struct sockaddr_pkt {
-	unsigned short spkt_family;
-	unsigned char spkt_device[14];
-	__be16 spkt_protocol;
-};
-
-struct sockaddr_ll {
-	unsigned short	sll_family;
-	__be16		sll_protocol;
-	int		sll_ifindex;
-	unsigned short	sll_hatype;
-	unsigned char	sll_pkttype;
-	unsigned char	sll_halen;
-	unsigned char	sll_addr[8];
-};
-
-/* Packet types */
-
-#define PACKET_HOST		0		/* To us		*/
-#define PACKET_BROADCAST	1		/* To all		*/
-#define PACKET_MULTICAST	2		/* To group		*/
-#define PACKET_OTHERHOST	3		/* To someone else 	*/
-#define PACKET_OUTGOING		4		/* Outgoing of any type */
-#define PACKET_LOOPBACK		5		/* MC/BRD frame looped back */
-#define PACKET_USER		6		/* To user space	*/
-#define PACKET_KERNEL		7		/* To kernel space	*/
-/* Unused, PACKET_FASTROUTE and PACKET_LOOPBACK are invisible to user space */
-#define PACKET_FASTROUTE	6		/* Fastrouted frame	*/
-
-/* Packet socket options */
-
-#define PACKET_ADD_MEMBERSHIP		1
-#define PACKET_DROP_MEMBERSHIP		2
-#define PACKET_RECV_OUTPUT		3
-/* Value 4 is still used by obsolete turbo-packet. */
-#define PACKET_RX_RING			5
-#define PACKET_STATISTICS		6
-#define PACKET_COPY_THRESH		7
-#define PACKET_AUXDATA			8
-#define PACKET_ORIGDEV			9
-#define PACKET_VERSION			10
-#define PACKET_HDRLEN			11
-#define PACKET_RESERVE			12
-#define PACKET_TX_RING			13
-#define PACKET_LOSS			14
-#define PACKET_VNET_HDR			15
-#define PACKET_TX_TIMESTAMP		16
-#define PACKET_TIMESTAMP		17
-#define PACKET_FANOUT			18
-#define PACKET_TX_HAS_OFF		19
-#define PACKET_QDISC_BYPASS		20
-#define PACKET_ROLLOVER_STATS		21
-#define PACKET_FANOUT_DATA		22
-
-#define PACKET_FANOUT_HASH		0
-#define PACKET_FANOUT_LB		1
-#define PACKET_FANOUT_CPU		2
-#define PACKET_FANOUT_ROLLOVER		3
-#define PACKET_FANOUT_RND		4
-#define PACKET_FANOUT_QM		5
-#define PACKET_FANOUT_CBPF		6
-#define PACKET_FANOUT_EBPF		7
-#define PACKET_FANOUT_FLAG_ROLLOVER	0x1000
-#define PACKET_FANOUT_FLAG_UNIQUEID	0x2000
-#define PACKET_FANOUT_FLAG_DEFRAG	0x8000
-
-struct tpacket_stats {
-	unsigned int	tp_packets;
-	unsigned int	tp_drops;
-};
-
-struct tpacket_stats_v3 {
-	unsigned int	tp_packets;
-	unsigned int	tp_drops;
-	unsigned int	tp_freeze_q_cnt;
-};
-
-struct tpacket_rollover_stats {
-	__aligned_u64	tp_all;
-	__aligned_u64	tp_huge;
-	__aligned_u64	tp_failed;
-};
-
-union tpacket_stats_u {
-	struct tpacket_stats stats1;
-	struct tpacket_stats_v3 stats3;
-};
-
-struct tpacket_auxdata {
-	__u32		tp_status;
-	__u32		tp_len;
-	__u32		tp_snaplen;
-	__u16		tp_mac;
-	__u16		tp_net;
-	__u16		tp_vlan_tci;
-	__u16		tp_vlan_tpid;
-};
-
-/* Rx ring - header status */
-#define TP_STATUS_KERNEL		      0
-#define TP_STATUS_USER			(1 << 0)
-#define TP_STATUS_COPY			(1 << 1)
-#define TP_STATUS_LOSING		(1 << 2)
-#define TP_STATUS_CSUMNOTREADY		(1 << 3)
-#define TP_STATUS_VLAN_VALID		(1 << 4) /* auxdata has valid tp_vlan_tci */
-#define TP_STATUS_BLK_TMO		(1 << 5)
-#define TP_STATUS_VLAN_TPID_VALID	(1 << 6) /* auxdata has valid tp_vlan_tpid */
-#define TP_STATUS_CSUM_VALID		(1 << 7)
-
-/* Tx ring - header status */
-#define TP_STATUS_AVAILABLE	      0
-#define TP_STATUS_SEND_REQUEST	(1 << 0)
-#define TP_STATUS_SENDING	(1 << 1)
-#define TP_STATUS_WRONG_FORMAT	(1 << 2)
-
-/* Rx and Tx ring - header status */
-#define TP_STATUS_TS_SOFTWARE		(1 << 29)
-#define TP_STATUS_TS_SYS_HARDWARE	(1 << 30) /* deprecated, never set */
-#define TP_STATUS_TS_RAW_HARDWARE	(1 << 31)
-
-/* Rx ring - feature request bits */
-#define TP_FT_REQ_FILL_RXHASH	0x1
-
-struct tpacket_hdr {
-	unsigned long	tp_status;
-	unsigned int	tp_len;
-	unsigned int	tp_snaplen;
-	unsigned short	tp_mac;
-	unsigned short	tp_net;
-	unsigned int	tp_sec;
-	unsigned int	tp_usec;
-};
-
-#define TPACKET_ALIGNMENT	16
-#define TPACKET_ALIGN(x)	(((x)+TPACKET_ALIGNMENT-1)&~(TPACKET_ALIGNMENT-1))
-#define TPACKET_HDRLEN		(TPACKET_ALIGN(sizeof(struct tpacket_hdr)) + sizeof(struct sockaddr_ll))
-
-struct tpacket2_hdr {
-	__u32		tp_status;
-	__u32		tp_len;
-	__u32		tp_snaplen;
-	__u16		tp_mac;
-	__u16		tp_net;
-	__u32		tp_sec;
-	__u32		tp_nsec;
-	__u16		tp_vlan_tci;
-	__u16		tp_vlan_tpid;
-	__u8		tp_padding[4];
-};
-
-struct tpacket_hdr_variant1 {
-	__u32	tp_rxhash;
-	__u32	tp_vlan_tci;
-	__u16	tp_vlan_tpid;
-	__u16	tp_padding;
-};
-
-struct tpacket3_hdr {
-	__u32		tp_next_offset;
-	__u32		tp_sec;
-	__u32		tp_nsec;
-	__u32		tp_snaplen;
-	__u32		tp_len;
-	__u32		tp_status;
-	__u16		tp_mac;
-	__u16		tp_net;
-	/* pkt_hdr variants */
-	union {
-		struct tpacket_hdr_variant1 hv1;
-	};
-	__u8		tp_padding[8];
-};
-
-struct tpacket_bd_ts {
-	unsigned int ts_sec;
-	union {
-		unsigned int ts_usec;
-		unsigned int ts_nsec;
-	};
-};
-
-struct tpacket_hdr_v1 {
-	__u32	block_status;
-	__u32	num_pkts;
-	__u32	offset_to_first_pkt;
-
-	/* Number of valid bytes (including padding)
-	 * blk_len <= tp_block_size
-	 */
-	__u32	blk_len;
-
-	/*
-	 * Quite a few uses of sequence number:
-	 * 1. Make sure cache flush etc worked.
-	 *    Well, one can argue - why not use the increasing ts below?
-	 *    But look at 2. below first.
-	 * 2. When you pass around blocks to other user space decoders,
-	 *    you can see which blk[s] is[are] outstanding etc.
-	 * 3. Validate kernel code.
-	 */
-	__aligned_u64	seq_num;
-
-	/*
-	 * ts_last_pkt:
-	 *
-	 * Case 1.	Block has 'N'(N >=1) packets and TMO'd(timed out)
-	 *		ts_last_pkt == 'time-stamp of last packet' and NOT the
-	 *		time when the timer fired and the block was closed.
-	 *		By providing the ts of the last packet we can absolutely
-	 *		guarantee that time-stamp wise, the first packet in the
-	 *		next block will never precede the last packet of the
-	 *		previous block.
-	 * Case 2.	Block has zero packets and TMO'd
-	 *		ts_last_pkt = time when the timer fired and the block
-	 *		was closed.
-	 * Case 3.	Block has 'N' packets and NO TMO.
-	 *		ts_last_pkt = time-stamp of the last pkt in the block.
-	 *
-	 * ts_first_pkt:
-	 *		Is always the time-stamp when the block was opened.
-	 *		Case a)	ZERO packets
-	 *			No packets to deal with but atleast you know the
-	 *			time-interval of this block.
-	 *		Case b) Non-zero packets
-	 *			Use the ts of the first packet in the block.
-	 *
-	 */
-	struct tpacket_bd_ts	ts_first_pkt, ts_last_pkt;
-};
-
-union tpacket_bd_header_u {
-	struct tpacket_hdr_v1 bh1;
-};
-
-struct tpacket_block_desc {
-	__u32 version;
-	__u32 offset_to_priv;
-	union tpacket_bd_header_u hdr;
-};
-
-#define TPACKET2_HDRLEN		(TPACKET_ALIGN(sizeof(struct tpacket2_hdr)) + sizeof(struct sockaddr_ll))
-#define TPACKET3_HDRLEN		(TPACKET_ALIGN(sizeof(struct tpacket3_hdr)) + sizeof(struct sockaddr_ll))
-
-enum tpacket_versions {
-	TPACKET_V1,
-	TPACKET_V2,
-	TPACKET_V3
-};
-
-/*
-   Frame structure:
-
-   - Start. Frame must be aligned to TPACKET_ALIGNMENT=16
-   - struct tpacket_hdr
-   - pad to TPACKET_ALIGNMENT=16
-   - struct sockaddr_ll
-   - Gap, chosen so that packet data (Start+tp_net) alignes to TPACKET_ALIGNMENT=16
-   - Start+tp_mac: [ Optional MAC header ]
-   - Start+tp_net: Packet data, aligned to TPACKET_ALIGNMENT=16.
-   - Pad to align to TPACKET_ALIGNMENT=16
- */
-
-struct tpacket_req {
-	unsigned int	tp_block_size;	/* Minimal size of contiguous block */
-	unsigned int	tp_block_nr;	/* Number of blocks */
-	unsigned int	tp_frame_size;	/* Size of frame */
-	unsigned int	tp_frame_nr;	/* Total number of frames */
-};
-
-struct tpacket_req3 {
-	unsigned int	tp_block_size;	/* Minimal size of contiguous block */
-	unsigned int	tp_block_nr;	/* Number of blocks */
-	unsigned int	tp_frame_size;	/* Size of frame */
-	unsigned int	tp_frame_nr;	/* Total number of frames */
-	unsigned int	tp_retire_blk_tov; /* timeout in msecs */
-	unsigned int	tp_sizeof_priv; /* offset to private data area */
-	unsigned int	tp_feature_req_word;
-};
-
-union tpacket_req_u {
-	struct tpacket_req	req;
-	struct tpacket_req3	req3;
-};
-
-struct packet_mreq {
-	int		mr_ifindex;
-	unsigned short	mr_type;
-	unsigned short	mr_alen;
-	unsigned char	mr_address[8];
-};
-
-#define PACKET_MR_MULTICAST	0
-#define PACKET_MR_PROMISC	1
-#define PACKET_MR_ALLMULTI	2
-#define PACKET_MR_UNICAST	3
-
-#endif
diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
deleted file mode 100644
index d5ecb42..0000000
--- a/include/linux/if_tun.h
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- *  Universal TUN/TAP device driver.
- *  Copyright (C) 1999-2000 Maxim Krasnyansky <max_mk@yahoo.com>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- */
-
-#ifndef __IF_TUN_H
-#define __IF_TUN_H
-
-#include <linux/types.h>
-#include <linux/if_ether.h>
-#include <linux/filter.h>
-
-/* Read queue size */
-#define TUN_READQ_SIZE	500
-/* TUN device type flags: deprecated. Use IFF_TUN/IFF_TAP instead. */
-#define TUN_TUN_DEV 	IFF_TUN
-#define TUN_TAP_DEV	IFF_TAP
-#define TUN_TYPE_MASK   0x000f
-
-/* Ioctl defines */
-#define TUNSETNOCSUM  _IOW('T', 200, int) 
-#define TUNSETDEBUG   _IOW('T', 201, int) 
-#define TUNSETIFF     _IOW('T', 202, int) 
-#define TUNSETPERSIST _IOW('T', 203, int) 
-#define TUNSETOWNER   _IOW('T', 204, int)
-#define TUNSETLINK    _IOW('T', 205, int)
-#define TUNSETGROUP   _IOW('T', 206, int)
-#define TUNGETFEATURES _IOR('T', 207, unsigned int)
-#define TUNSETOFFLOAD  _IOW('T', 208, unsigned int)
-#define TUNSETTXFILTER _IOW('T', 209, unsigned int)
-#define TUNGETIFF      _IOR('T', 210, unsigned int)
-#define TUNGETSNDBUF   _IOR('T', 211, int)
-#define TUNSETSNDBUF   _IOW('T', 212, int)
-#define TUNATTACHFILTER _IOW('T', 213, struct sock_fprog)
-#define TUNDETACHFILTER _IOW('T', 214, struct sock_fprog)
-#define TUNGETVNETHDRSZ _IOR('T', 215, int)
-#define TUNSETVNETHDRSZ _IOW('T', 216, int)
-#define TUNSETQUEUE  _IOW('T', 217, int)
-#define TUNSETIFINDEX	_IOW('T', 218, unsigned int)
-#define TUNGETFILTER _IOR('T', 219, struct sock_fprog)
-#define TUNSETVNETLE _IOW('T', 220, int)
-#define TUNGETVNETLE _IOR('T', 221, int)
-/* The TUNSETVNETBE and TUNGETVNETBE ioctls are for cross-endian support on
- * little-endian hosts. Not all kernel configurations support them, but all
- * configurations that support SET also support GET.
- */
-#define TUNSETVNETBE _IOW('T', 222, int)
-#define TUNGETVNETBE _IOR('T', 223, int)
-
-/* TUNSETIFF ifr flags */
-#define IFF_TUN		0x0001
-#define IFF_TAP		0x0002
-#define IFF_NO_PI	0x1000
-/* This flag has no real effect */
-#define IFF_ONE_QUEUE	0x2000
-#define IFF_VNET_HDR	0x4000
-#define IFF_TUN_EXCL	0x8000
-#define IFF_MULTI_QUEUE 0x0100
-#define IFF_ATTACH_QUEUE 0x0200
-#define IFF_DETACH_QUEUE 0x0400
-/* read-only flag */
-#define IFF_PERSIST	0x0800
-#define IFF_NOFILTER	0x1000
-
-/* Socket options */
-#define TUN_TX_TIMESTAMP 1
-
-/* Features for GSO (TUNSETOFFLOAD). */
-#define TUN_F_CSUM	0x01	/* You can hand me unchecksummed packets. */
-#define TUN_F_TSO4	0x02	/* I can handle TSO for IPv4 packets */
-#define TUN_F_TSO6	0x04	/* I can handle TSO for IPv6 packets */
-#define TUN_F_TSO_ECN	0x08	/* I can handle TSO with ECN bits. */
-#define TUN_F_UFO	0x10	/* I can handle UFO packets */
-
-/* Protocol info prepended to the packets (when IFF_NO_PI is not set) */
-#define TUN_PKT_STRIP	0x0001
-struct tun_pi {
-	__u16  flags;
-	__be16 proto;
-};
-
-/*
- * Filter spec (used for SETXXFILTER ioctls)
- * This stuff is applicable only to the TAP (Ethernet) devices.
- * If the count is zero the filter is disabled and the driver accepts
- * all packets (promisc mode).
- * If the filter is enabled in order to accept broadcast packets
- * broadcast addr must be explicitly included in the addr list.
- */
-#define TUN_FLT_ALLMULTI 0x0001 /* Accept all multicast packets */
-struct tun_filter {
-	__u16  flags; /* TUN_FLT_ flags see above */
-	__u16  count; /* Number of addresses */
-	__u8   addr[0][ETH_ALEN];
-};
-
-#endif /* __IF_TUN_H */
diff --git a/include/linux/if_tunnel.h b/include/linux/if_tunnel.h
deleted file mode 100644
index 21834ca..0000000
--- a/include/linux/if_tunnel.h
+++ /dev/null
@@ -1,158 +0,0 @@
-#ifndef _IF_TUNNEL_H_
-#define _IF_TUNNEL_H_
-
-#include <linux/types.h>
-#include <linux/if.h>
-#include <linux/ip.h>
-#include <linux/in6.h>
-#include <asm/byteorder.h>
-
-
-#define SIOCGETTUNNEL   (SIOCDEVPRIVATE + 0)
-#define SIOCADDTUNNEL   (SIOCDEVPRIVATE + 1)
-#define SIOCDELTUNNEL   (SIOCDEVPRIVATE + 2)
-#define SIOCCHGTUNNEL   (SIOCDEVPRIVATE + 3)
-#define SIOCGETPRL      (SIOCDEVPRIVATE + 4)
-#define SIOCADDPRL      (SIOCDEVPRIVATE + 5)
-#define SIOCDELPRL      (SIOCDEVPRIVATE + 6)
-#define SIOCCHGPRL      (SIOCDEVPRIVATE + 7)
-#define SIOCGET6RD      (SIOCDEVPRIVATE + 8)
-#define SIOCADD6RD      (SIOCDEVPRIVATE + 9)
-#define SIOCDEL6RD      (SIOCDEVPRIVATE + 10)
-#define SIOCCHG6RD      (SIOCDEVPRIVATE + 11)
-
-#define GRE_CSUM	__cpu_to_be16(0x8000)
-#define GRE_ROUTING	__cpu_to_be16(0x4000)
-#define GRE_KEY		__cpu_to_be16(0x2000)
-#define GRE_SEQ		__cpu_to_be16(0x1000)
-#define GRE_STRICT	__cpu_to_be16(0x0800)
-#define GRE_REC		__cpu_to_be16(0x0700)
-#define GRE_ACK		__cpu_to_be16(0x0080)
-#define GRE_FLAGS	__cpu_to_be16(0x0078)
-#define GRE_VERSION	__cpu_to_be16(0x0007)
-
-#define GRE_IS_CSUM(f)		((f) & GRE_CSUM)
-#define GRE_IS_ROUTING(f)	((f) & GRE_ROUTING)
-#define GRE_IS_KEY(f)		((f) & GRE_KEY)
-#define GRE_IS_SEQ(f)		((f) & GRE_SEQ)
-#define GRE_IS_STRICT(f)	((f) & GRE_STRICT)
-#define GRE_IS_REC(f)		((f) & GRE_REC)
-#define GRE_IS_ACK(f)		((f) & GRE_ACK)
-
-#define GRE_VERSION_0		__cpu_to_be16(0x0000)
-#define GRE_VERSION_1		__cpu_to_be16(0x0001)
-#define GRE_PROTO_PPP		__cpu_to_be16(0x880b)
-#define GRE_PPTP_KEY_MASK	__cpu_to_be32(0xffff)
-
-struct ip_tunnel_parm {
-	char			name[IFNAMSIZ];
-	int			link;
-	__be16			i_flags;
-	__be16			o_flags;
-	__be32			i_key;
-	__be32			o_key;
-	struct iphdr		iph;
-};
-
-enum {
-	IFLA_IPTUN_UNSPEC,
-	IFLA_IPTUN_LINK,
-	IFLA_IPTUN_LOCAL,
-	IFLA_IPTUN_REMOTE,
-	IFLA_IPTUN_TTL,
-	IFLA_IPTUN_TOS,
-	IFLA_IPTUN_ENCAP_LIMIT,
-	IFLA_IPTUN_FLOWINFO,
-	IFLA_IPTUN_FLAGS,
-	IFLA_IPTUN_PROTO,
-	IFLA_IPTUN_PMTUDISC,
-	IFLA_IPTUN_6RD_PREFIX,
-	IFLA_IPTUN_6RD_RELAY_PREFIX,
-	IFLA_IPTUN_6RD_PREFIXLEN,
-	IFLA_IPTUN_6RD_RELAY_PREFIXLEN,
-	IFLA_IPTUN_ENCAP_TYPE,
-	IFLA_IPTUN_ENCAP_FLAGS,
-	IFLA_IPTUN_ENCAP_SPORT,
-	IFLA_IPTUN_ENCAP_DPORT,
-	IFLA_IPTUN_COLLECT_METADATA,
-	IFLA_IPTUN_FWMARK,
-	__IFLA_IPTUN_MAX,
-};
-#define IFLA_IPTUN_MAX	(__IFLA_IPTUN_MAX - 1)
-
-enum tunnel_encap_types {
-	TUNNEL_ENCAP_NONE,
-	TUNNEL_ENCAP_FOU,
-	TUNNEL_ENCAP_GUE,
-};
-
-#define TUNNEL_ENCAP_FLAG_CSUM		(1<<0)
-#define TUNNEL_ENCAP_FLAG_CSUM6		(1<<1)
-#define TUNNEL_ENCAP_FLAG_REMCSUM	(1<<2)
-
-/* SIT-mode i_flags */
-#define	SIT_ISATAP	0x0001
-
-struct ip_tunnel_prl {
-	__be32			addr;
-	__u16			flags;
-	__u16			__reserved;
-	__u32			datalen;
-	__u32			__reserved2;
-	/* data follows */
-};
-
-/* PRL flags */
-#define	PRL_DEFAULT		0x0001
-
-struct ip_tunnel_6rd {
-	struct in6_addr		prefix;
-	__be32			relay_prefix;
-	__u16			prefixlen;
-	__u16			relay_prefixlen;
-};
-
-enum {
-	IFLA_GRE_UNSPEC,
-	IFLA_GRE_LINK,
-	IFLA_GRE_IFLAGS,
-	IFLA_GRE_OFLAGS,
-	IFLA_GRE_IKEY,
-	IFLA_GRE_OKEY,
-	IFLA_GRE_LOCAL,
-	IFLA_GRE_REMOTE,
-	IFLA_GRE_TTL,
-	IFLA_GRE_TOS,
-	IFLA_GRE_PMTUDISC,
-	IFLA_GRE_ENCAP_LIMIT,
-	IFLA_GRE_FLOWINFO,
-	IFLA_GRE_FLAGS,
-	IFLA_GRE_ENCAP_TYPE,
-	IFLA_GRE_ENCAP_FLAGS,
-	IFLA_GRE_ENCAP_SPORT,
-	IFLA_GRE_ENCAP_DPORT,
-	IFLA_GRE_COLLECT_METADATA,
-	IFLA_GRE_IGNORE_DF,
-	IFLA_GRE_FWMARK,
-	IFLA_GRE_ERSPAN_INDEX,
-	__IFLA_GRE_MAX,
-};
-
-#define IFLA_GRE_MAX	(__IFLA_GRE_MAX - 1)
-
-/* VTI-mode i_flags */
-#define VTI_ISVTI ((__be16)0x0001)
-
-enum {
-	IFLA_VTI_UNSPEC,
-	IFLA_VTI_LINK,
-	IFLA_VTI_IKEY,
-	IFLA_VTI_OKEY,
-	IFLA_VTI_LOCAL,
-	IFLA_VTI_REMOTE,
-	IFLA_VTI_FWMARK,
-	__IFLA_VTI_MAX,
-};
-
-#define IFLA_VTI_MAX	(__IFLA_VTI_MAX - 1)
-#endif /* _IF_TUNNEL_H_ */
diff --git a/include/linux/if_vlan.h b/include/linux/if_vlan.h
deleted file mode 100644
index 24ae007..0000000
--- a/include/linux/if_vlan.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * VLAN		An implementation of 802.1Q VLAN tagging.
- *
- * Authors:	Ben Greear <greearb@candelatech.com>
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
- *
- */
-
-#ifndef _LINUX_IF_VLAN_H_
-#define _LINUX_IF_VLAN_H_
-
-
-/* VLAN IOCTLs are found in sockios.h */
-
-/* Passed in vlan_ioctl_args structure to determine behaviour. */
-enum vlan_ioctl_cmds {
-	ADD_VLAN_CMD,
-	DEL_VLAN_CMD,
-	SET_VLAN_INGRESS_PRIORITY_CMD,
-	SET_VLAN_EGRESS_PRIORITY_CMD,
-	GET_VLAN_INGRESS_PRIORITY_CMD,
-	GET_VLAN_EGRESS_PRIORITY_CMD,
-	SET_VLAN_NAME_TYPE_CMD,
-	SET_VLAN_FLAG_CMD,
-	GET_VLAN_REALDEV_NAME_CMD, /* If this works, you know it's a VLAN device, btw */
-	GET_VLAN_VID_CMD /* Get the VID of this VLAN (specified by name) */
-};
-
-enum vlan_flags {
-	VLAN_FLAG_REORDER_HDR	= 0x1,
-	VLAN_FLAG_GVRP		= 0x2,
-	VLAN_FLAG_LOOSE_BINDING	= 0x4,
-	VLAN_FLAG_MVRP		= 0x8,
-};
-
-enum vlan_name_types {
-	VLAN_NAME_TYPE_PLUS_VID, /* Name will look like:  vlan0005 */
-	VLAN_NAME_TYPE_RAW_PLUS_VID, /* name will look like:  eth1.0005 */
-	VLAN_NAME_TYPE_PLUS_VID_NO_PAD, /* Name will look like:  vlan5 */
-	VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD, /* Name will look like:  eth0.5 */
-	VLAN_NAME_TYPE_HIGHEST
-};
-
-struct vlan_ioctl_args {
-	int cmd; /* Should be one of the vlan_ioctl_cmds enum above. */
-	char device1[24];
-
-        union {
-		char device2[24];
-		int VID;
-		unsigned int skb_priority;
-		unsigned int name_type;
-		unsigned int bind_type;
-		unsigned int flag; /* Matches vlan_dev_priv flags */
-        } u;
-
-	short vlan_qos;   
-};
-
-#endif /* _LINUX_IF_VLAN_H_ */
diff --git a/include/linux/ife.h b/include/linux/ife.h
deleted file mode 100644
index 2954da3..0000000
--- a/include/linux/ife.h
+++ /dev/null
@@ -1,18 +0,0 @@
-#ifndef __UAPI_IFE_H
-#define __UAPI_IFE_H
-
-#define IFE_METAHDRLEN 2
-
-enum {
-	IFE_META_SKBMARK = 1,
-	IFE_META_HASHID,
-	IFE_META_PRIO,
-	IFE_META_QMAP,
-	IFE_META_TCINDEX,
-	__IFE_META_MAX
-};
-
-/*Can be overridden at runtime by module option*/
-#define IFE_META_MAX (__IFE_META_MAX - 1)
-
-#endif
diff --git a/include/linux/ila.h b/include/linux/ila.h
deleted file mode 100644
index 7e328d7..0000000
--- a/include/linux/ila.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/* ila.h - ILA Interface */
-
-#ifndef _LINUX_ILA_H
-#define _LINUX_ILA_H
-
-/* NETLINK_GENERIC related info */
-#define ILA_GENL_NAME		"ila"
-#define ILA_GENL_VERSION	0x1
-
-enum {
-	ILA_ATTR_UNSPEC,
-	ILA_ATTR_LOCATOR,			/* u64 */
-	ILA_ATTR_IDENTIFIER,			/* u64 */
-	ILA_ATTR_LOCATOR_MATCH,			/* u64 */
-	ILA_ATTR_IFINDEX,			/* s32 */
-	ILA_ATTR_DIR,				/* u32 */
-	ILA_ATTR_PAD,
-	ILA_ATTR_CSUM_MODE,			/* u8 */
-
-	__ILA_ATTR_MAX,
-};
-
-#define ILA_ATTR_MAX		(__ILA_ATTR_MAX - 1)
-
-enum {
-	ILA_CMD_UNSPEC,
-	ILA_CMD_ADD,
-	ILA_CMD_DEL,
-	ILA_CMD_GET,
-
-	__ILA_CMD_MAX,
-};
-
-#define ILA_CMD_MAX	(__ILA_CMD_MAX - 1)
-
-#define ILA_DIR_IN	(1 << 0)
-#define ILA_DIR_OUT	(1 << 1)
-
-enum {
-	ILA_CSUM_ADJUST_TRANSPORT,
-	ILA_CSUM_NEUTRAL_MAP,
-	ILA_CSUM_NO_ACTION,
-};
-
-#endif /* _LINUX_ILA_H */
diff --git a/include/linux/in.h b/include/linux/in.h
deleted file mode 100644
index 9439efa..0000000
--- a/include/linux/in.h
+++ /dev/null
@@ -1,300 +0,0 @@
-/*
- * INET		An implementation of the TCP/IP protocol suite for the LINUX
- *		operating system.  INET is implemented using the  BSD Socket
- *		interface as the means of communication with the user level.
- *
- *		Definitions of the Internet Protocol.
- *
- * Version:	@(#)in.h	1.0.1	04/21/93
- *
- * Authors:	Original taken from the GNU Project <netinet/in.h> file.
- *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
- */
-#ifndef _LINUX_IN_H
-#define _LINUX_IN_H
-
-#include <linux/types.h>
-#include <linux/libc-compat.h>
-#include <linux/socket.h>
-
-#if __UAPI_DEF_IN_IPPROTO
-/* Standard well-defined IP protocols.  */
-enum {
-  IPPROTO_IP = 0,		/* Dummy protocol for TCP		*/
-#define IPPROTO_IP		IPPROTO_IP
-  IPPROTO_ICMP = 1,		/* Internet Control Message Protocol	*/
-#define IPPROTO_ICMP		IPPROTO_ICMP
-  IPPROTO_IGMP = 2,		/* Internet Group Management Protocol	*/
-#define IPPROTO_IGMP		IPPROTO_IGMP
-  IPPROTO_IPIP = 4,		/* IPIP tunnels (older KA9Q tunnels use 94) */
-#define IPPROTO_IPIP		IPPROTO_IPIP
-  IPPROTO_TCP = 6,		/* Transmission Control Protocol	*/
-#define IPPROTO_TCP		IPPROTO_TCP
-  IPPROTO_EGP = 8,		/* Exterior Gateway Protocol		*/
-#define IPPROTO_EGP		IPPROTO_EGP
-  IPPROTO_PUP = 12,		/* PUP protocol				*/
-#define IPPROTO_PUP		IPPROTO_PUP
-  IPPROTO_UDP = 17,		/* User Datagram Protocol		*/
-#define IPPROTO_UDP		IPPROTO_UDP
-  IPPROTO_IDP = 22,		/* XNS IDP protocol			*/
-#define IPPROTO_IDP		IPPROTO_IDP
-  IPPROTO_TP = 29,		/* SO Transport Protocol Class 4	*/
-#define IPPROTO_TP		IPPROTO_TP
-  IPPROTO_DCCP = 33,		/* Datagram Congestion Control Protocol */
-#define IPPROTO_DCCP		IPPROTO_DCCP
-  IPPROTO_IPV6 = 41,		/* IPv6-in-IPv4 tunnelling		*/
-#define IPPROTO_IPV6		IPPROTO_IPV6
-  IPPROTO_RSVP = 46,		/* RSVP Protocol			*/
-#define IPPROTO_RSVP		IPPROTO_RSVP
-  IPPROTO_GRE = 47,		/* Cisco GRE tunnels (rfc 1701,1702)	*/
-#define IPPROTO_GRE		IPPROTO_GRE
-  IPPROTO_ESP = 50,		/* Encapsulation Security Payload protocol */
-#define IPPROTO_ESP		IPPROTO_ESP
-  IPPROTO_AH = 51,		/* Authentication Header protocol	*/
-#define IPPROTO_AH		IPPROTO_AH
-  IPPROTO_MTP = 92,		/* Multicast Transport Protocol		*/
-#define IPPROTO_MTP		IPPROTO_MTP
-  IPPROTO_BEETPH = 94,		/* IP option pseudo header for BEET	*/
-#define IPPROTO_BEETPH		IPPROTO_BEETPH
-  IPPROTO_ENCAP = 98,		/* Encapsulation Header			*/
-#define IPPROTO_ENCAP		IPPROTO_ENCAP
-  IPPROTO_PIM = 103,		/* Protocol Independent Multicast	*/
-#define IPPROTO_PIM		IPPROTO_PIM
-  IPPROTO_COMP = 108,		/* Compression Header Protocol		*/
-#define IPPROTO_COMP		IPPROTO_COMP
-  IPPROTO_SCTP = 132,		/* Stream Control Transport Protocol	*/
-#define IPPROTO_SCTP		IPPROTO_SCTP
-  IPPROTO_UDPLITE = 136,	/* UDP-Lite (RFC 3828)			*/
-#define IPPROTO_UDPLITE		IPPROTO_UDPLITE
-  IPPROTO_MPLS = 137,		/* MPLS in IP (RFC 4023)		*/
-#define IPPROTO_MPLS		IPPROTO_MPLS
-  IPPROTO_RAW = 255,		/* Raw IP packets			*/
-#define IPPROTO_RAW		IPPROTO_RAW
-  IPPROTO_MAX
-};
-#endif
-
-#if __UAPI_DEF_IN_ADDR
-/* Internet address. */
-struct in_addr {
-	__be32	s_addr;
-};
-#endif
-
-#define IP_TOS		1
-#define IP_TTL		2
-#define IP_HDRINCL	3
-#define IP_OPTIONS	4
-#define IP_ROUTER_ALERT	5
-#define IP_RECVOPTS	6
-#define IP_RETOPTS	7
-#define IP_PKTINFO	8
-#define IP_PKTOPTIONS	9
-#define IP_MTU_DISCOVER	10
-#define IP_RECVERR	11
-#define IP_RECVTTL	12
-#define	IP_RECVTOS	13
-#define IP_MTU		14
-#define IP_FREEBIND	15
-#define IP_IPSEC_POLICY	16
-#define IP_XFRM_POLICY	17
-#define IP_PASSSEC	18
-#define IP_TRANSPARENT	19
-
-/* BSD compatibility */
-#define IP_RECVRETOPTS	IP_RETOPTS
-
-/* TProxy original addresses */
-#define IP_ORIGDSTADDR       20
-#define IP_RECVORIGDSTADDR   IP_ORIGDSTADDR
-
-#define IP_MINTTL       21
-#define IP_NODEFRAG     22
-#define IP_CHECKSUM	23
-#define IP_BIND_ADDRESS_NO_PORT	24
-#define IP_RECVFRAGSIZE	25
-
-/* IP_MTU_DISCOVER values */
-#define IP_PMTUDISC_DONT		0	/* Never send DF frames */
-#define IP_PMTUDISC_WANT		1	/* Use per route hints	*/
-#define IP_PMTUDISC_DO			2	/* Always DF		*/
-#define IP_PMTUDISC_PROBE		3       /* Ignore dst pmtu      */
-/* Always use interface mtu (ignores dst pmtu) but don't set DF flag.
- * Also incoming ICMP frag_needed notifications will be ignored on
- * this socket to prevent accepting spoofed ones.
- */
-#define IP_PMTUDISC_INTERFACE		4
-/* weaker version of IP_PMTUDISC_INTERFACE, which allos packets to get
- * fragmented if they exeed the interface mtu
- */
-#define IP_PMTUDISC_OMIT		5
-
-#define IP_MULTICAST_IF			32
-#define IP_MULTICAST_TTL 		33
-#define IP_MULTICAST_LOOP 		34
-#define IP_ADD_MEMBERSHIP		35
-#define IP_DROP_MEMBERSHIP		36
-#define IP_UNBLOCK_SOURCE		37
-#define IP_BLOCK_SOURCE			38
-#define IP_ADD_SOURCE_MEMBERSHIP	39
-#define IP_DROP_SOURCE_MEMBERSHIP	40
-#define IP_MSFILTER			41
-#define MCAST_JOIN_GROUP		42
-#define MCAST_BLOCK_SOURCE		43
-#define MCAST_UNBLOCK_SOURCE		44
-#define MCAST_LEAVE_GROUP		45
-#define MCAST_JOIN_SOURCE_GROUP		46
-#define MCAST_LEAVE_SOURCE_GROUP	47
-#define MCAST_MSFILTER			48
-#define IP_MULTICAST_ALL		49
-#define IP_UNICAST_IF			50
-
-#define MCAST_EXCLUDE	0
-#define MCAST_INCLUDE	1
-
-/* These need to appear somewhere around here */
-#define IP_DEFAULT_MULTICAST_TTL        1
-#define IP_DEFAULT_MULTICAST_LOOP       1
-
-/* Request struct for multicast socket ops */
-
-#if __UAPI_DEF_IP_MREQ
-struct ip_mreq  {
-	struct in_addr imr_multiaddr;	/* IP multicast address of group */
-	struct in_addr imr_interface;	/* local IP address of interface */
-};
-
-struct ip_mreqn {
-	struct in_addr	imr_multiaddr;		/* IP multicast address of group */
-	struct in_addr	imr_address;		/* local IP address of interface */
-	int		imr_ifindex;		/* Interface index */
-};
-
-struct ip_mreq_source {
-	__be32		imr_multiaddr;
-	__be32		imr_interface;
-	__be32		imr_sourceaddr;
-};
-
-struct ip_msfilter {
-	__be32		imsf_multiaddr;
-	__be32		imsf_interface;
-	__u32		imsf_fmode;
-	__u32		imsf_numsrc;
-	__be32		imsf_slist[1];
-};
-
-#define IP_MSFILTER_SIZE(numsrc) \
-	(sizeof(struct ip_msfilter) - sizeof(__u32) \
-	+ (numsrc) * sizeof(__u32))
-
-struct group_req {
-	__u32				 gr_interface;	/* interface index */
-	struct __kernel_sockaddr_storage gr_group;	/* group address */
-};
-
-struct group_source_req {
-	__u32				 gsr_interface;	/* interface index */
-	struct __kernel_sockaddr_storage gsr_group;	/* group address */
-	struct __kernel_sockaddr_storage gsr_source;	/* source address */
-};
-
-struct group_filter {
-	__u32				 gf_interface;	/* interface index */
-	struct __kernel_sockaddr_storage gf_group;	/* multicast address */
-	__u32				 gf_fmode;	/* filter mode */
-	__u32				 gf_numsrc;	/* number of sources */
-	struct __kernel_sockaddr_storage gf_slist[1];	/* interface index */
-};
-
-#define GROUP_FILTER_SIZE(numsrc) \
-	(sizeof(struct group_filter) - sizeof(struct __kernel_sockaddr_storage) \
-	+ (numsrc) * sizeof(struct __kernel_sockaddr_storage))
-#endif
-
-#if __UAPI_DEF_IN_PKTINFO
-struct in_pktinfo {
-	int		ipi_ifindex;
-	struct in_addr	ipi_spec_dst;
-	struct in_addr	ipi_addr;
-};
-#endif
-
-/* Structure describing an Internet (IP) socket address. */
-#if  __UAPI_DEF_SOCKADDR_IN
-#define __SOCK_SIZE__	16		/* sizeof(struct sockaddr)	*/
-struct sockaddr_in {
-  __kernel_sa_family_t	sin_family;	/* Address family		*/
-  __be16		sin_port;	/* Port number			*/
-  struct in_addr	sin_addr;	/* Internet address		*/
-
-  /* Pad to size of `struct sockaddr'. */
-  unsigned char		__pad[__SOCK_SIZE__ - sizeof(short int) -
-			sizeof(unsigned short int) - sizeof(struct in_addr)];
-};
-#define sin_zero	__pad		/* for BSD UNIX comp. -FvK	*/
-#endif
-
-#if __UAPI_DEF_IN_CLASS
-/*
- * Definitions of the bits in an Internet address integer.
- * On subnets, host and network parts are found according
- * to the subnet mask, not these masks.
- */
-#define	IN_CLASSA(a)		((((long int) (a)) & 0x80000000) == 0)
-#define	IN_CLASSA_NET		0xff000000
-#define	IN_CLASSA_NSHIFT	24
-#define	IN_CLASSA_HOST		(0xffffffff & ~IN_CLASSA_NET)
-#define	IN_CLASSA_MAX		128
-
-#define	IN_CLASSB(a)		((((long int) (a)) & 0xc0000000) == 0x80000000)
-#define	IN_CLASSB_NET		0xffff0000
-#define	IN_CLASSB_NSHIFT	16
-#define	IN_CLASSB_HOST		(0xffffffff & ~IN_CLASSB_NET)
-#define	IN_CLASSB_MAX		65536
-
-#define	IN_CLASSC(a)		((((long int) (a)) & 0xe0000000) == 0xc0000000)
-#define	IN_CLASSC_NET		0xffffff00
-#define	IN_CLASSC_NSHIFT	8
-#define	IN_CLASSC_HOST		(0xffffffff & ~IN_CLASSC_NET)
-
-#define	IN_CLASSD(a)		((((long int) (a)) & 0xf0000000) == 0xe0000000)
-#define	IN_MULTICAST(a)		IN_CLASSD(a)
-#define IN_MULTICAST_NET	0xF0000000
-
-#define	IN_EXPERIMENTAL(a)	((((long int) (a)) & 0xf0000000) == 0xf0000000)
-#define	IN_BADCLASS(a)		IN_EXPERIMENTAL((a))
-
-/* Address to accept any incoming messages. */
-#define	INADDR_ANY		((unsigned long int) 0x00000000)
-
-/* Address to send to all hosts. */
-#define	INADDR_BROADCAST	((unsigned long int) 0xffffffff)
-
-/* Address indicating an error return. */
-#define	INADDR_NONE		((unsigned long int) 0xffffffff)
-
-/* Network number for local host loopback. */
-#define	IN_LOOPBACKNET		127
-
-/* Address to loopback in software to local host.  */
-#define	INADDR_LOOPBACK		0x7f000001	/* 127.0.0.1   */
-#define	IN_LOOPBACK(a)		((((long int) (a)) & 0xff000000) == 0x7f000000)
-
-/* Defines for Multicast INADDR */
-#define INADDR_UNSPEC_GROUP   	0xe0000000U	/* 224.0.0.0   */
-#define INADDR_ALLHOSTS_GROUP 	0xe0000001U	/* 224.0.0.1   */
-#define INADDR_ALLRTRS_GROUP    0xe0000002U	/* 224.0.0.2 */
-#define INADDR_MAX_LOCAL_GROUP  0xe00000ffU	/* 224.0.0.255 */
-#endif
-
-/* <asm/byteorder.h> contains the htonl type stuff.. */
-#include <asm/byteorder.h> 
-
-
-#endif /* _LINUX_IN_H */
diff --git a/include/linux/in6.h b/include/linux/in6.h
deleted file mode 100644
index 6f3bdee..0000000
--- a/include/linux/in6.h
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
- *	Types and definitions for AF_INET6 
- *	Linux INET6 implementation 
- *
- *	Authors:
- *	Pedro Roque		<roque@di.fc.ul.pt>	
- *
- *	Sources:
- *	IPv6 Program Interfaces for BSD Systems
- *      <draft-ietf-ipngwg-bsd-api-05.txt>
- *
- *	Advanced Sockets API for IPv6
- *	<draft-stevens-advanced-api-00.txt>
- *
- *	This program is free software; you can redistribute it and/or
- *      modify it under the terms of the GNU General Public License
- *      as published by the Free Software Foundation; either version
- *      2 of the License, or (at your option) any later version.
- */
-
-#ifndef _LINUX_IN6_H
-#define _LINUX_IN6_H
-
-#include <linux/types.h>
-#include <linux/libc-compat.h>
-
-/*
- *	IPv6 address structure
- */
-
-#if __UAPI_DEF_IN6_ADDR
-struct in6_addr {
-	union {
-		__u8		u6_addr8[16];
-#if __UAPI_DEF_IN6_ADDR_ALT
-		__be16		u6_addr16[8];
-		__be32		u6_addr32[4];
-#endif
-	} in6_u;
-#define s6_addr			in6_u.u6_addr8
-#if __UAPI_DEF_IN6_ADDR_ALT
-#define s6_addr16		in6_u.u6_addr16
-#define s6_addr32		in6_u.u6_addr32
-#endif
-};
-#endif /* __UAPI_DEF_IN6_ADDR */
-
-#if __UAPI_DEF_SOCKADDR_IN6
-struct sockaddr_in6 {
-	unsigned short int	sin6_family;    /* AF_INET6 */
-	__be16			sin6_port;      /* Transport layer port # */
-	__be32			sin6_flowinfo;  /* IPv6 flow information */
-	struct in6_addr		sin6_addr;      /* IPv6 address */
-	__u32			sin6_scope_id;  /* scope id (new in RFC2553) */
-};
-#endif /* __UAPI_DEF_SOCKADDR_IN6 */
-
-#if __UAPI_DEF_IPV6_MREQ
-struct ipv6_mreq {
-	/* IPv6 multicast address of group */
-	struct in6_addr ipv6mr_multiaddr;
-
-	/* local IPv6 address of interface */
-	int		ipv6mr_ifindex;
-};
-#endif /* __UAPI_DEF_IVP6_MREQ */
-
-#define ipv6mr_acaddr	ipv6mr_multiaddr
-
-struct in6_flowlabel_req {
-	struct in6_addr	flr_dst;
-	__be32	flr_label;
-	__u8	flr_action;
-	__u8	flr_share;
-	__u16	flr_flags;
-	__u16 	flr_expires;
-	__u16	flr_linger;
-	__u32	__flr_pad;
-	/* Options in format of IPV6_PKTOPTIONS */
-};
-
-#define IPV6_FL_A_GET	0
-#define IPV6_FL_A_PUT	1
-#define IPV6_FL_A_RENEW	2
-
-#define IPV6_FL_F_CREATE	1
-#define IPV6_FL_F_EXCL		2
-#define IPV6_FL_F_REFLECT	4
-#define IPV6_FL_F_REMOTE	8
-
-#define IPV6_FL_S_NONE		0
-#define IPV6_FL_S_EXCL		1
-#define IPV6_FL_S_PROCESS	2
-#define IPV6_FL_S_USER		3
-#define IPV6_FL_S_ANY		255
-
-
-/*
- *	Bitmask constant declarations to help applications select out the 
- *	flow label and priority fields.
- *
- *	Note that this are in host byte order while the flowinfo field of
- *	sockaddr_in6 is in network byte order.
- */
-
-#define IPV6_FLOWINFO_FLOWLABEL		0x000fffff
-#define IPV6_FLOWINFO_PRIORITY		0x0ff00000
-
-/* These definitions are obsolete */
-#define IPV6_PRIORITY_UNCHARACTERIZED	0x0000
-#define IPV6_PRIORITY_FILLER		0x0100
-#define IPV6_PRIORITY_UNATTENDED	0x0200
-#define IPV6_PRIORITY_RESERVED1		0x0300
-#define IPV6_PRIORITY_BULK		0x0400
-#define IPV6_PRIORITY_RESERVED2		0x0500
-#define IPV6_PRIORITY_INTERACTIVE	0x0600
-#define IPV6_PRIORITY_CONTROL		0x0700
-#define IPV6_PRIORITY_8			0x0800
-#define IPV6_PRIORITY_9			0x0900
-#define IPV6_PRIORITY_10		0x0a00
-#define IPV6_PRIORITY_11		0x0b00
-#define IPV6_PRIORITY_12		0x0c00
-#define IPV6_PRIORITY_13		0x0d00
-#define IPV6_PRIORITY_14		0x0e00
-#define IPV6_PRIORITY_15		0x0f00
-
-/*
- *	IPV6 extension headers
- */
-#if __UAPI_DEF_IPPROTO_V6
-#define IPPROTO_HOPOPTS		0	/* IPv6 hop-by-hop options	*/
-#define IPPROTO_ROUTING		43	/* IPv6 routing header		*/
-#define IPPROTO_FRAGMENT	44	/* IPv6 fragmentation header	*/
-#define IPPROTO_ICMPV6		58	/* ICMPv6			*/
-#define IPPROTO_NONE		59	/* IPv6 no next header		*/
-#define IPPROTO_DSTOPTS		60	/* IPv6 destination options	*/
-#define IPPROTO_MH		135	/* IPv6 mobility header		*/
-#endif /* __UAPI_DEF_IPPROTO_V6 */
-
-/*
- *	IPv6 TLV options.
- */
-#define IPV6_TLV_PAD1		0
-#define IPV6_TLV_PADN		1
-#define IPV6_TLV_ROUTERALERT	5
-#define IPV6_TLV_CALIPSO	7	/* RFC 5570 */
-#define IPV6_TLV_JUMBO		194
-#define IPV6_TLV_HAO		201	/* home address option */
-
-/*
- *	IPV6 socket options
- */
-#if __UAPI_DEF_IPV6_OPTIONS
-#define IPV6_ADDRFORM		1
-#define IPV6_2292PKTINFO	2
-#define IPV6_2292HOPOPTS	3
-#define IPV6_2292DSTOPTS	4
-#define IPV6_2292RTHDR		5
-#define IPV6_2292PKTOPTIONS	6
-#define IPV6_CHECKSUM		7
-#define IPV6_2292HOPLIMIT	8
-#define IPV6_NEXTHOP		9
-#define IPV6_AUTHHDR		10	/* obsolete */
-#define IPV6_FLOWINFO		11
-
-#define IPV6_UNICAST_HOPS	16
-#define IPV6_MULTICAST_IF	17
-#define IPV6_MULTICAST_HOPS	18
-#define IPV6_MULTICAST_LOOP	19
-#define IPV6_ADD_MEMBERSHIP	20
-#define IPV6_DROP_MEMBERSHIP	21
-#define IPV6_ROUTER_ALERT	22
-#define IPV6_MTU_DISCOVER	23
-#define IPV6_MTU		24
-#define IPV6_RECVERR		25
-#define IPV6_V6ONLY		26
-#define IPV6_JOIN_ANYCAST	27
-#define IPV6_LEAVE_ANYCAST	28
-
-/* IPV6_MTU_DISCOVER values */
-#define IPV6_PMTUDISC_DONT		0
-#define IPV6_PMTUDISC_WANT		1
-#define IPV6_PMTUDISC_DO		2
-#define IPV6_PMTUDISC_PROBE		3
-/* same as IPV6_PMTUDISC_PROBE, provided for symetry with IPv4
- * also see comments on IP_PMTUDISC_INTERFACE
- */
-#define IPV6_PMTUDISC_INTERFACE		4
-/* weaker version of IPV6_PMTUDISC_INTERFACE, which allows packets to
- * get fragmented if they exceed the interface mtu
- */
-#define IPV6_PMTUDISC_OMIT		5
-
-/* Flowlabel */
-#define IPV6_FLOWLABEL_MGR	32
-#define IPV6_FLOWINFO_SEND	33
-
-#define IPV6_IPSEC_POLICY	34
-#define IPV6_XFRM_POLICY	35
-#define IPV6_HDRINCL		36
-#endif
-
-/*
- * Multicast:
- * Following socket options are shared between IPv4 and IPv6.
- *
- * MCAST_JOIN_GROUP		42
- * MCAST_BLOCK_SOURCE		43
- * MCAST_UNBLOCK_SOURCE		44
- * MCAST_LEAVE_GROUP		45
- * MCAST_JOIN_SOURCE_GROUP	46
- * MCAST_LEAVE_SOURCE_GROUP	47
- * MCAST_MSFILTER		48
- */
-
-/*
- * Advanced API (RFC3542) (1)
- *
- * Note: IPV6_RECVRTHDRDSTOPTS does not exist. see net/ipv6/datagram.c.
- */
-
-#define IPV6_RECVPKTINFO	49
-#define IPV6_PKTINFO		50
-#define IPV6_RECVHOPLIMIT	51
-#define IPV6_HOPLIMIT		52
-#define IPV6_RECVHOPOPTS	53
-#define IPV6_HOPOPTS		54
-#define IPV6_RTHDRDSTOPTS	55
-#define IPV6_RECVRTHDR		56
-#define IPV6_RTHDR		57
-#define IPV6_RECVDSTOPTS	58
-#define IPV6_DSTOPTS		59
-#define IPV6_RECVPATHMTU	60
-#define IPV6_PATHMTU		61
-#define IPV6_DONTFRAG		62
-#if 0	/* not yet */
-#define IPV6_USE_MIN_MTU	63
-#endif
-
-/*
- * Netfilter (1)
- *
- * Following socket options are used in ip6_tables;
- * see include/linux/netfilter_ipv6/ip6_tables.h.
- *
- * IP6T_SO_SET_REPLACE / IP6T_SO_GET_INFO		64
- * IP6T_SO_SET_ADD_COUNTERS / IP6T_SO_GET_ENTRIES	65
- */
-
-/*
- * Advanced API (RFC3542) (2)
- */
-#define IPV6_RECVTCLASS		66
-#define IPV6_TCLASS		67
-
-/*
- * Netfilter (2)
- *
- * Following socket options are used in ip6_tables;
- * see include/linux/netfilter_ipv6/ip6_tables.h.
- *
- * IP6T_SO_GET_REVISION_MATCH	68
- * IP6T_SO_GET_REVISION_TARGET	69
- * IP6T_SO_ORIGINAL_DST		80
- */
-
-#define IPV6_AUTOFLOWLABEL	70
-/* RFC5014: Source address selection */
-#define IPV6_ADDR_PREFERENCES	72
-
-#define IPV6_PREFER_SRC_TMP		0x0001
-#define IPV6_PREFER_SRC_PUBLIC		0x0002
-#define IPV6_PREFER_SRC_PUBTMP_DEFAULT	0x0100
-#define IPV6_PREFER_SRC_COA		0x0004
-#define IPV6_PREFER_SRC_HOME		0x0400
-#define IPV6_PREFER_SRC_CGA		0x0008
-#define IPV6_PREFER_SRC_NONCGA		0x0800
-
-/* RFC5082: Generalized Ttl Security Mechanism */
-#define IPV6_MINHOPCOUNT		73
-
-#define IPV6_ORIGDSTADDR        74
-#define IPV6_RECVORIGDSTADDR    IPV6_ORIGDSTADDR
-#define IPV6_TRANSPARENT        75
-#define IPV6_UNICAST_IF         76
-#define IPV6_RECVFRAGSIZE	77
-
-/*
- * Multicast Routing:
- * see include/uapi/linux/mroute6.h.
- *
- * MRT6_BASE			200
- * ...
- * MRT6_MAX
- */
-#endif /* _LINUX_IN6_H */
diff --git a/include/linux/in_route.h b/include/linux/in_route.h
deleted file mode 100644
index b261b8c..0000000
--- a/include/linux/in_route.h
+++ /dev/null
@@ -1,32 +0,0 @@
-#ifndef _LINUX_IN_ROUTE_H
-#define _LINUX_IN_ROUTE_H
-
-/* IPv4 routing cache flags */
-
-#define RTCF_DEAD	RTNH_F_DEAD
-#define RTCF_ONLINK	RTNH_F_ONLINK
-
-/* Obsolete flag. About to be deleted */
-#define RTCF_NOPMTUDISC RTM_F_NOPMTUDISC
-
-#define RTCF_NOTIFY	0x00010000
-#define RTCF_DIRECTDST	0x00020000 /* unused */
-#define RTCF_REDIRECTED	0x00040000
-#define RTCF_TPROXY	0x00080000 /* unused */
-
-#define RTCF_FAST	0x00200000 /* unused */
-#define RTCF_MASQ	0x00400000 /* unused */
-#define RTCF_SNAT	0x00800000 /* unused */
-#define RTCF_DOREDIRECT 0x01000000
-#define RTCF_DIRECTSRC	0x04000000
-#define RTCF_DNAT	0x08000000
-#define RTCF_BROADCAST	0x10000000
-#define RTCF_MULTICAST	0x20000000
-#define RTCF_REJECT	0x40000000 /* unused */
-#define RTCF_LOCAL	0x80000000
-
-#define RTCF_NAT	(RTCF_DNAT|RTCF_SNAT)
-
-#define RT_TOS(tos)	((tos)&IPTOS_TOS_MASK)
-
-#endif /* _LINUX_IN_ROUTE_H */
diff --git a/include/linux/inet_diag.h b/include/linux/inet_diag.h
deleted file mode 100644
index bada4d7..0000000
--- a/include/linux/inet_diag.h
+++ /dev/null
@@ -1,196 +0,0 @@
-#ifndef _INET_DIAG_H_
-#define _INET_DIAG_H_
-
-#include <linux/types.h>
-
-/* Just some random number */
-#define TCPDIAG_GETSOCK 18
-#define DCCPDIAG_GETSOCK 19
-
-#define INET_DIAG_GETSOCK_MAX 24
-
-/* Socket identity */
-struct inet_diag_sockid {
-	__be16	idiag_sport;
-	__be16	idiag_dport;
-	__be32	idiag_src[4];
-	__be32	idiag_dst[4];
-	__u32	idiag_if;
-	__u32	idiag_cookie[2];
-#define INET_DIAG_NOCOOKIE (~0U)
-};
-
-/* Request structure */
-
-struct inet_diag_req {
-	__u8	idiag_family;		/* Family of addresses. */
-	__u8	idiag_src_len;
-	__u8	idiag_dst_len;
-	__u8	idiag_ext;		/* Query extended information */
-
-	struct inet_diag_sockid id;
-
-	__u32	idiag_states;		/* States to dump */
-	__u32	idiag_dbs;		/* Tables to dump (NI) */
-};
-
-struct inet_diag_req_v2 {
-	__u8	sdiag_family;
-	__u8	sdiag_protocol;
-	__u8	idiag_ext;
-	__u8	pad;
-	__u32	idiag_states;
-	struct inet_diag_sockid id;
-};
-
-/*
- * SOCK_RAW sockets require the underlied protocol to be
- * additionally specified so we can use @pad member for
- * this, but we can't rename it because userspace programs
- * still may depend on this name. Instead lets use another
- * structure definition as an alias for struct
- * @inet_diag_req_v2.
- */
-struct inet_diag_req_raw {
-	__u8	sdiag_family;
-	__u8	sdiag_protocol;
-	__u8	idiag_ext;
-	__u8	sdiag_raw_protocol;
-	__u32	idiag_states;
-	struct inet_diag_sockid id;
-};
-
-enum {
-	INET_DIAG_REQ_NONE,
-	INET_DIAG_REQ_BYTECODE,
-};
-
-#define INET_DIAG_REQ_MAX INET_DIAG_REQ_BYTECODE
-
-/* Bytecode is sequence of 4 byte commands followed by variable arguments.
- * All the commands identified by "code" are conditional jumps forward:
- * to offset cc+"yes" or to offset cc+"no". "yes" is supposed to be
- * length of the command and its arguments.
- */
- 
-struct inet_diag_bc_op {
-	unsigned char	code;
-	unsigned char	yes;
-	unsigned short	no;
-};
-
-enum {
-	INET_DIAG_BC_NOP,
-	INET_DIAG_BC_JMP,
-	INET_DIAG_BC_S_GE,
-	INET_DIAG_BC_S_LE,
-	INET_DIAG_BC_D_GE,
-	INET_DIAG_BC_D_LE,
-	INET_DIAG_BC_AUTO,
-	INET_DIAG_BC_S_COND,
-	INET_DIAG_BC_D_COND,
-	INET_DIAG_BC_DEV_COND,   /* u32 ifindex */
-	INET_DIAG_BC_MARK_COND,
-};
-
-struct inet_diag_hostcond {
-	__u8	family;
-	__u8	prefix_len;
-	int	port;
-	__be32	addr[0];
-};
-
-struct inet_diag_markcond {
-	__u32 mark;
-	__u32 mask;
-};
-
-/* Base info structure. It contains socket identity (addrs/ports/cookie)
- * and, alas, the information shown by netstat. */
-struct inet_diag_msg {
-	__u8	idiag_family;
-	__u8	idiag_state;
-	__u8	idiag_timer;
-	__u8	idiag_retrans;
-
-	struct inet_diag_sockid id;
-
-	__u32	idiag_expires;
-	__u32	idiag_rqueue;
-	__u32	idiag_wqueue;
-	__u32	idiag_uid;
-	__u32	idiag_inode;
-};
-
-/* Extensions */
-
-enum {
-	INET_DIAG_NONE,
-	INET_DIAG_MEMINFO,
-	INET_DIAG_INFO,
-	INET_DIAG_VEGASINFO,
-	INET_DIAG_CONG,
-	INET_DIAG_TOS,
-	INET_DIAG_TCLASS,
-	INET_DIAG_SKMEMINFO,
-	INET_DIAG_SHUTDOWN,
-	INET_DIAG_DCTCPINFO,
-	INET_DIAG_PROTOCOL,  /* response attribute only */
-	INET_DIAG_SKV6ONLY,
-	INET_DIAG_LOCALS,
-	INET_DIAG_PEERS,
-	INET_DIAG_PAD,
-	INET_DIAG_MARK,
-	INET_DIAG_BBRINFO,
-	INET_DIAG_CLASS_ID,
-	INET_DIAG_MD5SIG,
-	__INET_DIAG_MAX,
-};
-
-#define INET_DIAG_MAX (__INET_DIAG_MAX - 1)
-
-/* INET_DIAG_MEM */
-
-struct inet_diag_meminfo {
-	__u32	idiag_rmem;
-	__u32	idiag_wmem;
-	__u32	idiag_fmem;
-	__u32	idiag_tmem;
-};
-
-/* INET_DIAG_VEGASINFO */
-
-struct tcpvegas_info {
-	__u32	tcpv_enabled;
-	__u32	tcpv_rttcnt;
-	__u32	tcpv_rtt;
-	__u32	tcpv_minrtt;
-};
-
-/* INET_DIAG_DCTCPINFO */
-
-struct tcp_dctcp_info {
-	__u16	dctcp_enabled;
-	__u16	dctcp_ce_state;
-	__u32	dctcp_alpha;
-	__u32	dctcp_ab_ecn;
-	__u32	dctcp_ab_tot;
-};
-
-/* INET_DIAG_BBRINFO */
-
-struct tcp_bbr_info {
-	/* u64 bw: max-filtered BW (app throughput) estimate in Byte per sec: */
-	__u32	bbr_bw_lo;		/* lower 32 bits of bw */
-	__u32	bbr_bw_hi;		/* upper 32 bits of bw */
-	__u32	bbr_min_rtt;		/* min-filtered RTT in uSec */
-	__u32	bbr_pacing_gain;	/* pacing gain shifted left 8 bits */
-	__u32	bbr_cwnd_gain;		/* cwnd gain shifted left 8 bits */
-};
-
-union tcp_cc_info {
-	struct tcpvegas_info	vegas;
-	struct tcp_dctcp_info	dctcp;
-	struct tcp_bbr_info	bbr;
-};
-#endif /* _INET_DIAG_H_ */
diff --git a/include/linux/ip.h b/include/linux/ip.h
deleted file mode 100644
index 1907284..0000000
--- a/include/linux/ip.h
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * INET		An implementation of the TCP/IP protocol suite for the LINUX
- *		operating system.  INET is implemented using the  BSD Socket
- *		interface as the means of communication with the user level.
- *
- *		Definitions for the IP protocol.
- *
- * Version:	@(#)ip.h	1.0.2	04/28/93
- *
- * Authors:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
- */
-#ifndef _LINUX_IP_H
-#define _LINUX_IP_H
-#include <linux/types.h>
-#include <asm/byteorder.h>
-
-#define IPTOS_TOS_MASK		0x1E
-#define IPTOS_TOS(tos)		((tos)&IPTOS_TOS_MASK)
-#define	IPTOS_LOWDELAY		0x10
-#define	IPTOS_THROUGHPUT	0x08
-#define	IPTOS_RELIABILITY	0x04
-#define	IPTOS_MINCOST		0x02
-
-#define IPTOS_PREC_MASK		0xE0
-#define IPTOS_PREC(tos)		((tos)&IPTOS_PREC_MASK)
-#define IPTOS_PREC_NETCONTROL           0xe0
-#define IPTOS_PREC_INTERNETCONTROL      0xc0
-#define IPTOS_PREC_CRITIC_ECP           0xa0
-#define IPTOS_PREC_FLASHOVERRIDE        0x80
-#define IPTOS_PREC_FLASH                0x60
-#define IPTOS_PREC_IMMEDIATE            0x40
-#define IPTOS_PREC_PRIORITY             0x20
-#define IPTOS_PREC_ROUTINE              0x00
-
-
-/* IP options */
-#define IPOPT_COPY		0x80
-#define IPOPT_CLASS_MASK	0x60
-#define IPOPT_NUMBER_MASK	0x1f
-
-#define	IPOPT_COPIED(o)		((o)&IPOPT_COPY)
-#define	IPOPT_CLASS(o)		((o)&IPOPT_CLASS_MASK)
-#define	IPOPT_NUMBER(o)		((o)&IPOPT_NUMBER_MASK)
-
-#define	IPOPT_CONTROL		0x00
-#define	IPOPT_RESERVED1		0x20
-#define	IPOPT_MEASUREMENT	0x40
-#define	IPOPT_RESERVED2		0x60
-
-#define IPOPT_END	(0 |IPOPT_CONTROL)
-#define IPOPT_NOOP	(1 |IPOPT_CONTROL)
-#define IPOPT_SEC	(2 |IPOPT_CONTROL|IPOPT_COPY)
-#define IPOPT_LSRR	(3 |IPOPT_CONTROL|IPOPT_COPY)
-#define IPOPT_TIMESTAMP	(4 |IPOPT_MEASUREMENT)
-#define IPOPT_CIPSO	(6 |IPOPT_CONTROL|IPOPT_COPY)
-#define IPOPT_RR	(7 |IPOPT_CONTROL)
-#define IPOPT_SID	(8 |IPOPT_CONTROL|IPOPT_COPY)
-#define IPOPT_SSRR	(9 |IPOPT_CONTROL|IPOPT_COPY)
-#define IPOPT_RA	(20|IPOPT_CONTROL|IPOPT_COPY)
-
-#define IPVERSION	4
-#define MAXTTL		255
-#define IPDEFTTL	64
-
-#define IPOPT_OPTVAL 0
-#define IPOPT_OLEN   1
-#define IPOPT_OFFSET 2
-#define IPOPT_MINOFF 4
-#define MAX_IPOPTLEN 40
-#define IPOPT_NOP IPOPT_NOOP
-#define IPOPT_EOL IPOPT_END
-#define IPOPT_TS  IPOPT_TIMESTAMP
-
-#define	IPOPT_TS_TSONLY		0		/* timestamps only */
-#define	IPOPT_TS_TSANDADDR	1		/* timestamps and addresses */
-#define	IPOPT_TS_PRESPEC	3		/* specified modules only */
-
-#define IPV4_BEET_PHMAXLEN 8
-
-struct iphdr {
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-	__u8	ihl:4,
-		version:4;
-#elif defined (__BIG_ENDIAN_BITFIELD)
-	__u8	version:4,
-  		ihl:4;
-#else
-#error	"Please fix <asm/byteorder.h>"
-#endif
-	__u8	tos;
-	__be16	tot_len;
-	__be16	id;
-	__be16	frag_off;
-	__u8	ttl;
-	__u8	protocol;
-	__sum16	check;
-	__be32	saddr;
-	__be32	daddr;
-	/*The options start here. */
-};
-
-
-struct ip_auth_hdr {
-	__u8  nexthdr;
-	__u8  hdrlen;		/* This one is measured in 32 bit units! */
-	__be16 reserved;
-	__be32 spi;
-	__be32 seq_no;		/* Sequence number */
-	__u8  auth_data[0];	/* Variable len but >=4. Mind the 64 bit alignment! */
-};
-
-struct ip_esp_hdr {
-	__be32 spi;
-	__be32 seq_no;		/* Sequence number */
-	__u8  enc_data[0];	/* Variable len but >=8. Mind the 64 bit alignment! */
-};
-
-struct ip_comp_hdr {
-	__u8 nexthdr;
-	__u8 flags;
-	__be16 cpi;
-};
-
-struct ip_beet_phdr {
-	__u8 nexthdr;
-	__u8 hdrlen;
-	__u8 padlen;
-	__u8 reserved;
-};
-
-/* index values for the variables in ipv4_devconf */
-enum
-{
-	IPV4_DEVCONF_FORWARDING=1,
-	IPV4_DEVCONF_MC_FORWARDING,
-	IPV4_DEVCONF_PROXY_ARP,
-	IPV4_DEVCONF_ACCEPT_REDIRECTS,
-	IPV4_DEVCONF_SECURE_REDIRECTS,
-	IPV4_DEVCONF_SEND_REDIRECTS,
-	IPV4_DEVCONF_SHARED_MEDIA,
-	IPV4_DEVCONF_RP_FILTER,
-	IPV4_DEVCONF_ACCEPT_SOURCE_ROUTE,
-	IPV4_DEVCONF_BOOTP_RELAY,
-	IPV4_DEVCONF_LOG_MARTIANS,
-	IPV4_DEVCONF_TAG,
-	IPV4_DEVCONF_ARPFILTER,
-	IPV4_DEVCONF_MEDIUM_ID,
-	IPV4_DEVCONF_NOXFRM,
-	IPV4_DEVCONF_NOPOLICY,
-	IPV4_DEVCONF_FORCE_IGMP_VERSION,
-	IPV4_DEVCONF_ARP_ANNOUNCE,
-	IPV4_DEVCONF_ARP_IGNORE,
-	IPV4_DEVCONF_PROMOTE_SECONDARIES,
-	IPV4_DEVCONF_ARP_ACCEPT,
-	IPV4_DEVCONF_ARP_NOTIFY,
-	IPV4_DEVCONF_ACCEPT_LOCAL,
-	IPV4_DEVCONF_SRC_VMARK,
-	IPV4_DEVCONF_PROXY_ARP_PVLAN,
-	IPV4_DEVCONF_ROUTE_LOCALNET,
-	IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL,
-	IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL,
-	IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN,
-	IPV4_DEVCONF_DROP_UNICAST_IN_L2_MULTICAST,
-	IPV4_DEVCONF_DROP_GRATUITOUS_ARP,
-	__IPV4_DEVCONF_MAX
-};
-
-#define IPV4_DEVCONF_MAX (__IPV4_DEVCONF_MAX - 1)
-
-#endif /* _LINUX_IP_H */
diff --git a/include/linux/ip6_tunnel.h b/include/linux/ip6_tunnel.h
deleted file mode 100644
index 425926c..0000000
--- a/include/linux/ip6_tunnel.h
+++ /dev/null
@@ -1,53 +0,0 @@
-#ifndef _IP6_TUNNEL_H
-#define _IP6_TUNNEL_H
-
-#include <linux/types.h>
-#include <linux/if.h>		/* For IFNAMSIZ. */
-#include <linux/in6.h>		/* For struct in6_addr. */
-
-#define IPV6_TLV_TNL_ENCAP_LIMIT 4
-#define IPV6_DEFAULT_TNL_ENCAP_LIMIT 4
-
-/* don't add encapsulation limit if one isn't present in inner packet */
-#define IP6_TNL_F_IGN_ENCAP_LIMIT 0x1
-/* copy the traffic class field from the inner packet */
-#define IP6_TNL_F_USE_ORIG_TCLASS 0x2
-/* copy the flowlabel from the inner packet */
-#define IP6_TNL_F_USE_ORIG_FLOWLABEL 0x4
-/* being used for Mobile IPv6 */
-#define IP6_TNL_F_MIP6_DEV 0x8
-/* copy DSCP from the outer packet */
-#define IP6_TNL_F_RCV_DSCP_COPY 0x10
-/* copy fwmark from inner packet */
-#define IP6_TNL_F_USE_ORIG_FWMARK 0x20
-
-struct ip6_tnl_parm {
-	char name[IFNAMSIZ];	/* name of tunnel device */
-	int link;		/* ifindex of underlying L2 interface */
-	__u8 proto;		/* tunnel protocol */
-	__u8 encap_limit;	/* encapsulation limit for tunnel */
-	__u8 hop_limit;		/* hop limit for tunnel */
-	__be32 flowinfo;	/* traffic class and flowlabel for tunnel */
-	__u32 flags;		/* tunnel flags */
-	struct in6_addr laddr;	/* local tunnel end-point address */
-	struct in6_addr raddr;	/* remote tunnel end-point address */
-};
-
-struct ip6_tnl_parm2 {
-	char name[IFNAMSIZ];	/* name of tunnel device */
-	int link;		/* ifindex of underlying L2 interface */
-	__u8 proto;		/* tunnel protocol */
-	__u8 encap_limit;	/* encapsulation limit for tunnel */
-	__u8 hop_limit;		/* hop limit for tunnel */
-	__be32 flowinfo;	/* traffic class and flowlabel for tunnel */
-	__u32 flags;		/* tunnel flags */
-	struct in6_addr laddr;	/* local tunnel end-point address */
-	struct in6_addr raddr;	/* remote tunnel end-point address */
-
-	__be16			i_flags;
-	__be16			o_flags;
-	__be32			i_key;
-	__be32			o_key;
-};
-
-#endif
diff --git a/include/linux/ipsec.h b/include/linux/ipsec.h
deleted file mode 100644
index d17a630..0000000
--- a/include/linux/ipsec.h
+++ /dev/null
@@ -1,47 +0,0 @@
-#ifndef _LINUX_IPSEC_H
-#define _LINUX_IPSEC_H
-
-/* The definitions, required to talk to KAME racoon IKE. */
-
-#include <linux/pfkeyv2.h>
-
-#define IPSEC_PORT_ANY		0
-#define IPSEC_ULPROTO_ANY	255
-#define IPSEC_PROTO_ANY		255
-
-enum {
-	IPSEC_MODE_ANY		= 0,	/* We do not support this for SA */
-	IPSEC_MODE_TRANSPORT	= 1,
-	IPSEC_MODE_TUNNEL	= 2,
-	IPSEC_MODE_BEET         = 3
-};
-
-enum {
-	IPSEC_DIR_ANY		= 0,
-	IPSEC_DIR_INBOUND	= 1,
-	IPSEC_DIR_OUTBOUND	= 2,
-	IPSEC_DIR_FWD		= 3,	/* It is our own */
-	IPSEC_DIR_MAX		= 4,
-	IPSEC_DIR_INVALID	= 5
-};
-
-enum {
-	IPSEC_POLICY_DISCARD	= 0,
-	IPSEC_POLICY_NONE	= 1,
-	IPSEC_POLICY_IPSEC	= 2,
-	IPSEC_POLICY_ENTRUST	= 3,
-	IPSEC_POLICY_BYPASS	= 4
-};
-
-enum {
-	IPSEC_LEVEL_DEFAULT	= 0,
-	IPSEC_LEVEL_USE		= 1,
-	IPSEC_LEVEL_REQUIRE	= 2,
-	IPSEC_LEVEL_UNIQUE	= 3
-};
-
-#define IPSEC_MANUAL_REQID_MAX	0x3fff
-
-#define IPSEC_REPLAYWSIZE  32
-
-#endif	/* _LINUX_IPSEC_H */
diff --git a/include/linux/kernel.h b/include/linux/kernel.h
deleted file mode 100644
index 527549f..0000000
--- a/include/linux/kernel.h
+++ /dev/null
@@ -1,14 +0,0 @@
-#ifndef _LINUX_KERNEL_H
-#define _LINUX_KERNEL_H
-
-#include <linux/sysinfo.h>
-
-/*
- * 'kernel.h' contains some often-used function prototypes etc
- */
-#define __ALIGN_KERNEL(x, a)		__ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)
-#define __ALIGN_KERNEL_MASK(x, mask)	(((x) + (mask)) & ~(mask))
-
-#define __KERNEL_DIV_ROUND_UP(n, d) (((n) + (d) - 1) / (d))
-
-#endif /* _LINUX_KERNEL_H */
diff --git a/include/linux/l2tp.h b/include/linux/l2tp.h
deleted file mode 100644
index 8a80007..0000000
--- a/include/linux/l2tp.h
+++ /dev/null
@@ -1,199 +0,0 @@
-/*
- * L2TP-over-IP socket for L2TPv3.
- *
- * Author: James Chapman <jchapman@katalix.com>
- */
-
-#ifndef _LINUX_L2TP_H_
-#define _LINUX_L2TP_H_
-
-#include <linux/types.h>
-#include <linux/socket.h>
-#include <linux/in.h>
-#include <linux/in6.h>
-
-#define IPPROTO_L2TP		115
-
-/**
- * struct sockaddr_l2tpip - the sockaddr structure for L2TP-over-IP sockets
- * @l2tp_family:  address family number AF_L2TPIP.
- * @l2tp_addr:    protocol specific address information
- * @l2tp_conn_id: connection id of tunnel
- */
-#define __SOCK_SIZE__	16		/* sizeof(struct sockaddr)	*/
-struct sockaddr_l2tpip {
-	/* The first fields must match struct sockaddr_in */
-	__kernel_sa_family_t l2tp_family; /* AF_INET */
-	__be16		l2tp_unused;	/* INET port number (unused) */
-	struct in_addr	l2tp_addr;	/* Internet address */
-
-	__u32		l2tp_conn_id;	/* Connection ID of tunnel */
-
-	/* Pad to size of `struct sockaddr'. */
-	unsigned char	__pad[__SOCK_SIZE__ -
-			      sizeof(__kernel_sa_family_t) -
-			      sizeof(__be16) - sizeof(struct in_addr) -
-			      sizeof(__u32)];
-};
-
-/**
- * struct sockaddr_l2tpip6 - the sockaddr structure for L2TP-over-IPv6 sockets
- * @l2tp_family:  address family number AF_L2TPIP.
- * @l2tp_addr:    protocol specific address information
- * @l2tp_conn_id: connection id of tunnel
- */
-struct sockaddr_l2tpip6 {
-	/* The first fields must match struct sockaddr_in6 */
-	__kernel_sa_family_t l2tp_family; /* AF_INET6 */
-	__be16		l2tp_unused;	/* INET port number (unused) */
-	__be32		l2tp_flowinfo;	/* IPv6 flow information */
-	struct in6_addr	l2tp_addr;	/* IPv6 address */
-	__u32		l2tp_scope_id;	/* scope id (new in RFC2553) */
-	__u32		l2tp_conn_id;	/* Connection ID of tunnel */
-};
-
-/*****************************************************************************
- *  NETLINK_GENERIC netlink family.
- *****************************************************************************/
-
-/*
- * Commands.
- * Valid TLVs of each command are:-
- * TUNNEL_CREATE	- CONN_ID, pw_type, netns, ifname, ipinfo, udpinfo, udpcsum, vlanid
- * TUNNEL_DELETE	- CONN_ID
- * TUNNEL_MODIFY	- CONN_ID, udpcsum
- * TUNNEL_GETSTATS	- CONN_ID, (stats)
- * TUNNEL_GET		- CONN_ID, (...)
- * SESSION_CREATE	- SESSION_ID, PW_TYPE, offset, data_seq, cookie, peer_cookie, offset, l2spec
- * SESSION_DELETE	- SESSION_ID
- * SESSION_MODIFY	- SESSION_ID, data_seq
- * SESSION_GET		- SESSION_ID, (...)
- * SESSION_GETSTATS	- SESSION_ID, (stats)
- *
- */
-enum {
-	L2TP_CMD_NOOP,
-	L2TP_CMD_TUNNEL_CREATE,
-	L2TP_CMD_TUNNEL_DELETE,
-	L2TP_CMD_TUNNEL_MODIFY,
-	L2TP_CMD_TUNNEL_GET,
-	L2TP_CMD_SESSION_CREATE,
-	L2TP_CMD_SESSION_DELETE,
-	L2TP_CMD_SESSION_MODIFY,
-	L2TP_CMD_SESSION_GET,
-	__L2TP_CMD_MAX,
-};
-
-#define L2TP_CMD_MAX			(__L2TP_CMD_MAX - 1)
-
-/*
- * ATTR types defined for L2TP
- */
-enum {
-	L2TP_ATTR_NONE,			/* no data */
-	L2TP_ATTR_PW_TYPE,		/* u16, enum l2tp_pwtype */
-	L2TP_ATTR_ENCAP_TYPE,		/* u16, enum l2tp_encap_type */
-	L2TP_ATTR_OFFSET,		/* u16 */
-	L2TP_ATTR_DATA_SEQ,		/* u16 */
-	L2TP_ATTR_L2SPEC_TYPE,		/* u8, enum l2tp_l2spec_type */
-	L2TP_ATTR_L2SPEC_LEN,		/* u8, enum l2tp_l2spec_type */
-	L2TP_ATTR_PROTO_VERSION,	/* u8 */
-	L2TP_ATTR_IFNAME,		/* string */
-	L2TP_ATTR_CONN_ID,		/* u32 */
-	L2TP_ATTR_PEER_CONN_ID,		/* u32 */
-	L2TP_ATTR_SESSION_ID,		/* u32 */
-	L2TP_ATTR_PEER_SESSION_ID,	/* u32 */
-	L2TP_ATTR_UDP_CSUM,		/* u8 */
-	L2TP_ATTR_VLAN_ID,		/* u16 */
-	L2TP_ATTR_COOKIE,		/* 0, 4 or 8 bytes */
-	L2TP_ATTR_PEER_COOKIE,		/* 0, 4 or 8 bytes */
-	L2TP_ATTR_DEBUG,		/* u32, enum l2tp_debug_flags */
-	L2TP_ATTR_RECV_SEQ,		/* u8 */
-	L2TP_ATTR_SEND_SEQ,		/* u8 */
-	L2TP_ATTR_LNS_MODE,		/* u8 */
-	L2TP_ATTR_USING_IPSEC,		/* u8 */
-	L2TP_ATTR_RECV_TIMEOUT,		/* msec */
-	L2TP_ATTR_FD,			/* int */
-	L2TP_ATTR_IP_SADDR,		/* u32 */
-	L2TP_ATTR_IP_DADDR,		/* u32 */
-	L2TP_ATTR_UDP_SPORT,		/* u16 */
-	L2TP_ATTR_UDP_DPORT,		/* u16 */
-	L2TP_ATTR_MTU,			/* u16 */
-	L2TP_ATTR_MRU,			/* u16 */
-	L2TP_ATTR_STATS,		/* nested */
-	L2TP_ATTR_IP6_SADDR,		/* struct in6_addr */
-	L2TP_ATTR_IP6_DADDR,		/* struct in6_addr */
-	L2TP_ATTR_UDP_ZERO_CSUM6_TX,	/* flag */
-	L2TP_ATTR_UDP_ZERO_CSUM6_RX,	/* flag */
-	L2TP_ATTR_PAD,
-	__L2TP_ATTR_MAX,
-};
-
-#define L2TP_ATTR_MAX			(__L2TP_ATTR_MAX - 1)
-
-/* Nested in L2TP_ATTR_STATS */
-enum {
-	L2TP_ATTR_STATS_NONE,		/* no data */
-	L2TP_ATTR_TX_PACKETS,		/* u64 */
-	L2TP_ATTR_TX_BYTES,		/* u64 */
-	L2TP_ATTR_TX_ERRORS,		/* u64 */
-	L2TP_ATTR_RX_PACKETS,		/* u64 */
-	L2TP_ATTR_RX_BYTES,		/* u64 */
-	L2TP_ATTR_RX_SEQ_DISCARDS,	/* u64 */
-	L2TP_ATTR_RX_OOS_PACKETS,	/* u64 */
-	L2TP_ATTR_RX_ERRORS,		/* u64 */
-	L2TP_ATTR_STATS_PAD,
-	__L2TP_ATTR_STATS_MAX,
-};
-
-#define L2TP_ATTR_STATS_MAX		(__L2TP_ATTR_STATS_MAX - 1)
-
-enum l2tp_pwtype {
-	L2TP_PWTYPE_NONE = 0x0000,
-	L2TP_PWTYPE_ETH_VLAN = 0x0004,
-	L2TP_PWTYPE_ETH = 0x0005,
-	L2TP_PWTYPE_PPP = 0x0007,
-	L2TP_PWTYPE_PPP_AC = 0x0008,
-	L2TP_PWTYPE_IP = 0x000b,
-	__L2TP_PWTYPE_MAX
-};
-
-enum l2tp_l2spec_type {
-	L2TP_L2SPECTYPE_NONE,
-	L2TP_L2SPECTYPE_DEFAULT,
-};
-
-enum l2tp_encap_type {
-	L2TP_ENCAPTYPE_UDP,
-	L2TP_ENCAPTYPE_IP,
-};
-
-enum l2tp_seqmode {
-	L2TP_SEQ_NONE = 0,
-	L2TP_SEQ_IP = 1,
-	L2TP_SEQ_ALL = 2,
-};
-
-/**
- * enum l2tp_debug_flags - debug message categories for L2TP tunnels/sessions
- *
- * @L2TP_MSG_DEBUG: verbose debug (if compiled in)
- * @L2TP_MSG_CONTROL: userspace - kernel interface
- * @L2TP_MSG_SEQ: sequence numbers
- * @L2TP_MSG_DATA: data packets
- */
-enum l2tp_debug_flags {
-	L2TP_MSG_DEBUG		= (1 << 0),
-	L2TP_MSG_CONTROL	= (1 << 1),
-	L2TP_MSG_SEQ		= (1 << 2),
-	L2TP_MSG_DATA		= (1 << 3),
-};
-
-/*
- * NETLINK_GENERIC related info
- */
-#define L2TP_GENL_NAME		"l2tp"
-#define L2TP_GENL_VERSION	0x1
-#define L2TP_GENL_MCGROUP       "l2tp"
-
-#endif /* _LINUX_L2TP_H_ */
diff --git a/include/linux/libc-compat.h b/include/linux/libc-compat.h
deleted file mode 100644
index f38571d..0000000
--- a/include/linux/libc-compat.h
+++ /dev/null
@@ -1,213 +0,0 @@
-/*
- * Compatibility interface for userspace libc header coordination:
- *
- * Define compatibility macros that are used to control the inclusion or
- * exclusion of UAPI structures and definitions in coordination with another
- * userspace C library.
- *
- * This header is intended to solve the problem of UAPI definitions that
- * conflict with userspace definitions. If a UAPI header has such conflicting
- * definitions then the solution is as follows:
- *
- * * Synchronize the UAPI header and the libc headers so either one can be
- *   used and such that the ABI is preserved. If this is not possible then
- *   no simple compatibility interface exists (you need to write translating
- *   wrappers and rename things) and you can't use this interface.
- *
- * Then follow this process:
- *
- * (a) Include libc-compat.h in the UAPI header.
- *      e.g. #include <linux/libc-compat.h>
- *     This include must be as early as possible.
- *
- * (b) In libc-compat.h add enough code to detect that the comflicting
- *     userspace libc header has been included first.
- *
- * (c) If the userspace libc header has been included first define a set of
- *     guard macros of the form __UAPI_DEF_FOO and set their values to 1, else
- *     set their values to 0.
- *
- * (d) Back in the UAPI header with the conflicting definitions, guard the
- *     definitions with:
- *     #if __UAPI_DEF_FOO
- *       ...
- *     #endif
- *
- * This fixes the situation where the linux headers are included *after* the
- * libc headers. To fix the problem with the inclusion in the other order the
- * userspace libc headers must be fixed like this:
- *
- * * For all definitions that conflict with kernel definitions wrap those
- *   defines in the following:
- *   #if !__UAPI_DEF_FOO
- *     ...
- *   #endif
- *
- * This prevents the redefinition of a construct already defined by the kernel.
- */
-#ifndef _LIBC_COMPAT_H
-#define _LIBC_COMPAT_H
-
-/* We have included glibc headers... */
-#if defined(__GLIBC__)
-
-/* Coordinate with glibc net/if.h header. */
-#if defined(_NET_IF_H) && defined(__USE_MISC)
-
-/* GLIBC headers included first so don't define anything
- * that would already be defined. */
-
-#define __UAPI_DEF_IF_IFCONF 0
-#define __UAPI_DEF_IF_IFMAP 0
-#define __UAPI_DEF_IF_IFNAMSIZ 0
-#define __UAPI_DEF_IF_IFREQ 0
-/* Everything up to IFF_DYNAMIC, matches net/if.h until glibc 2.23 */
-#define __UAPI_DEF_IF_NET_DEVICE_FLAGS 0
-/* For the future if glibc adds IFF_LOWER_UP, IFF_DORMANT and IFF_ECHO */
-#ifndef __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO
-#define __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO 1
-#endif /* __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO */
-
-#else /* _NET_IF_H */
-
-/* Linux headers included first, and we must define everything
- * we need. The expectation is that glibc will check the
- * __UAPI_DEF_* defines and adjust appropriately. */
-
-#define __UAPI_DEF_IF_IFCONF 1
-#define __UAPI_DEF_IF_IFMAP 1
-#define __UAPI_DEF_IF_IFNAMSIZ 1
-#define __UAPI_DEF_IF_IFREQ 1
-/* Everything up to IFF_DYNAMIC, matches net/if.h until glibc 2.23 */
-#define __UAPI_DEF_IF_NET_DEVICE_FLAGS 1
-/* For the future if glibc adds IFF_LOWER_UP, IFF_DORMANT and IFF_ECHO */
-#define __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO 1
-
-#endif /* _NET_IF_H */
-
-/* Coordinate with glibc netinet/in.h header. */
-#if defined(_NETINET_IN_H)
-
-/* GLIBC headers included first so don't define anything
- * that would already be defined. */
-#define __UAPI_DEF_IN_ADDR		0
-#define __UAPI_DEF_IN_IPPROTO		0
-#define __UAPI_DEF_IN_PKTINFO		0
-#define __UAPI_DEF_IP_MREQ		0
-#define __UAPI_DEF_SOCKADDR_IN		0
-#define __UAPI_DEF_IN_CLASS		0
-
-#define __UAPI_DEF_IN6_ADDR		0
-/* The exception is the in6_addr macros which must be defined
- * if the glibc code didn't define them. This guard matches
- * the guard in glibc/inet/netinet/in.h which defines the
- * additional in6_addr macros e.g. s6_addr16, and s6_addr32. */
-#if defined(__USE_MISC) || defined (__USE_GNU)
-#define __UAPI_DEF_IN6_ADDR_ALT		0
-#else
-#define __UAPI_DEF_IN6_ADDR_ALT		1
-#endif
-#define __UAPI_DEF_SOCKADDR_IN6		0
-#define __UAPI_DEF_IPV6_MREQ		0
-#define __UAPI_DEF_IPPROTO_V6		0
-#define __UAPI_DEF_IPV6_OPTIONS		0
-#define __UAPI_DEF_IN6_PKTINFO		0
-#define __UAPI_DEF_IP6_MTUINFO		0
-
-#else
-
-/* Linux headers included first, and we must define everything
- * we need. The expectation is that glibc will check the
- * __UAPI_DEF_* defines and adjust appropriately. */
-#define __UAPI_DEF_IN_ADDR		1
-#define __UAPI_DEF_IN_IPPROTO		1
-#define __UAPI_DEF_IN_PKTINFO		1
-#define __UAPI_DEF_IP_MREQ		1
-#define __UAPI_DEF_SOCKADDR_IN		1
-#define __UAPI_DEF_IN_CLASS		1
-
-#define __UAPI_DEF_IN6_ADDR		1
-/* We unconditionally define the in6_addr macros and glibc must
- * coordinate. */
-#define __UAPI_DEF_IN6_ADDR_ALT		1
-#define __UAPI_DEF_SOCKADDR_IN6		1
-#define __UAPI_DEF_IPV6_MREQ		1
-#define __UAPI_DEF_IPPROTO_V6		1
-#define __UAPI_DEF_IPV6_OPTIONS		1
-#define __UAPI_DEF_IN6_PKTINFO		1
-#define __UAPI_DEF_IP6_MTUINFO		1
-
-#endif /* _NETINET_IN_H */
-
-/* Coordinate with glibc netipx/ipx.h header. */
-#if defined(__NETIPX_IPX_H)
-
-#define __UAPI_DEF_SOCKADDR_IPX			0
-#define __UAPI_DEF_IPX_ROUTE_DEFINITION		0
-#define __UAPI_DEF_IPX_INTERFACE_DEFINITION	0
-#define __UAPI_DEF_IPX_CONFIG_DATA		0
-#define __UAPI_DEF_IPX_ROUTE_DEF		0
-
-#else /* defined(__NETIPX_IPX_H) */
-
-#define __UAPI_DEF_SOCKADDR_IPX			1
-#define __UAPI_DEF_IPX_ROUTE_DEFINITION		1
-#define __UAPI_DEF_IPX_INTERFACE_DEFINITION	1
-#define __UAPI_DEF_IPX_CONFIG_DATA		1
-#define __UAPI_DEF_IPX_ROUTE_DEF		1
-
-#endif /* defined(__NETIPX_IPX_H) */
-
-/* Definitions for xattr.h */
-#if defined(_SYS_XATTR_H)
-#define __UAPI_DEF_XATTR		0
-#else
-#define __UAPI_DEF_XATTR		1
-#endif
-
-/* If we did not see any headers from any supported C libraries,
- * or we are being included in the kernel, then define everything
- * that we need. */
-#else /* !defined(__GLIBC__) */
-
-/* Definitions for if.h */
-#define __UAPI_DEF_IF_IFCONF 1
-#define __UAPI_DEF_IF_IFMAP 1
-#define __UAPI_DEF_IF_IFNAMSIZ 1
-#define __UAPI_DEF_IF_IFREQ 1
-/* Everything up to IFF_DYNAMIC, matches net/if.h until glibc 2.23 */
-#define __UAPI_DEF_IF_NET_DEVICE_FLAGS 1
-/* For the future if glibc adds IFF_LOWER_UP, IFF_DORMANT and IFF_ECHO */
-#define __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO 1
-
-/* Definitions for in.h */
-#define __UAPI_DEF_IN_ADDR		1
-#define __UAPI_DEF_IN_IPPROTO		1
-#define __UAPI_DEF_IN_PKTINFO		1
-#define __UAPI_DEF_IP_MREQ		1
-#define __UAPI_DEF_SOCKADDR_IN		1
-#define __UAPI_DEF_IN_CLASS		1
-
-/* Definitions for in6.h */
-#define __UAPI_DEF_IN6_ADDR		1
-#define __UAPI_DEF_IN6_ADDR_ALT		1
-#define __UAPI_DEF_SOCKADDR_IN6		1
-#define __UAPI_DEF_IPV6_MREQ		1
-#define __UAPI_DEF_IPPROTO_V6		1
-#define __UAPI_DEF_IPV6_OPTIONS		1
-#define __UAPI_DEF_IN6_PKTINFO		1
-#define __UAPI_DEF_IP6_MTUINFO		1
-
-/* Definitions for ipx.h */
-#define __UAPI_DEF_SOCKADDR_IPX			1
-#define __UAPI_DEF_IPX_ROUTE_DEFINITION		1
-#define __UAPI_DEF_IPX_INTERFACE_DEFINITION	1
-#define __UAPI_DEF_IPX_CONFIG_DATA		1
-#define __UAPI_DEF_IPX_ROUTE_DEF		1
-
-/* Definitions for xattr.h */
-#define __UAPI_DEF_XATTR		1
-
-#endif /* __GLIBC__ */
-
-#endif /* _LIBC_COMPAT_H */
diff --git a/include/linux/limits.h b/include/linux/limits.h
deleted file mode 100644
index 2d0f941..0000000
--- a/include/linux/limits.h
+++ /dev/null
@@ -1,20 +0,0 @@
-#ifndef _LINUX_LIMITS_H
-#define _LINUX_LIMITS_H
-
-#define NR_OPEN	        1024
-
-#define NGROUPS_MAX    65536	/* supplemental group IDs are available */
-#define ARG_MAX       131072	/* # bytes of args + environ for exec() */
-#define LINK_MAX         127	/* # links a file may have */
-#define MAX_CANON        255	/* size of the canonical input queue */
-#define MAX_INPUT        255	/* size of the type-ahead buffer */
-#define NAME_MAX         255	/* # chars in a file name */
-#define PATH_MAX        4096	/* # chars in a path name including nul */
-#define PIPE_BUF        4096	/* # bytes in atomic write to a pipe */
-#define XATTR_NAME_MAX   255	/* # chars in an extended attribute name */
-#define XATTR_SIZE_MAX 65536	/* size of an extended attribute value (64k) */
-#define XATTR_LIST_MAX 65536	/* size of extended attribute namelist (64k) */
-
-#define RTSIG_MAX	  32
-
-#endif
diff --git a/include/linux/lwtunnel.h b/include/linux/lwtunnel.h
deleted file mode 100644
index 3298426..0000000
--- a/include/linux/lwtunnel.h
+++ /dev/null
@@ -1,70 +0,0 @@
-#ifndef _LWTUNNEL_H_
-#define _LWTUNNEL_H_
-
-#include <linux/types.h>
-
-enum lwtunnel_encap_types {
-	LWTUNNEL_ENCAP_NONE,
-	LWTUNNEL_ENCAP_MPLS,
-	LWTUNNEL_ENCAP_IP,
-	LWTUNNEL_ENCAP_ILA,
-	LWTUNNEL_ENCAP_IP6,
-	LWTUNNEL_ENCAP_SEG6,
-	LWTUNNEL_ENCAP_BPF,
-	LWTUNNEL_ENCAP_SEG6_LOCAL,
-	__LWTUNNEL_ENCAP_MAX,
-};
-
-#define LWTUNNEL_ENCAP_MAX (__LWTUNNEL_ENCAP_MAX - 1)
-
-enum lwtunnel_ip_t {
-	LWTUNNEL_IP_UNSPEC,
-	LWTUNNEL_IP_ID,
-	LWTUNNEL_IP_DST,
-	LWTUNNEL_IP_SRC,
-	LWTUNNEL_IP_TTL,
-	LWTUNNEL_IP_TOS,
-	LWTUNNEL_IP_FLAGS,
-	LWTUNNEL_IP_PAD,
-	__LWTUNNEL_IP_MAX,
-};
-
-#define LWTUNNEL_IP_MAX (__LWTUNNEL_IP_MAX - 1)
-
-enum lwtunnel_ip6_t {
-	LWTUNNEL_IP6_UNSPEC,
-	LWTUNNEL_IP6_ID,
-	LWTUNNEL_IP6_DST,
-	LWTUNNEL_IP6_SRC,
-	LWTUNNEL_IP6_HOPLIMIT,
-	LWTUNNEL_IP6_TC,
-	LWTUNNEL_IP6_FLAGS,
-	LWTUNNEL_IP6_PAD,
-	__LWTUNNEL_IP6_MAX,
-};
-
-#define LWTUNNEL_IP6_MAX (__LWTUNNEL_IP6_MAX - 1)
-
-enum {
-	LWT_BPF_PROG_UNSPEC,
-	LWT_BPF_PROG_FD,
-	LWT_BPF_PROG_NAME,
-	__LWT_BPF_PROG_MAX,
-};
-
-#define LWT_BPF_PROG_MAX (__LWT_BPF_PROG_MAX - 1)
-
-enum {
-	LWT_BPF_UNSPEC,
-	LWT_BPF_IN,
-	LWT_BPF_OUT,
-	LWT_BPF_XMIT,
-	LWT_BPF_XMIT_HEADROOM,
-	__LWT_BPF_MAX,
-};
-
-#define LWT_BPF_MAX (__LWT_BPF_MAX - 1)
-
-#define LWT_BPF_MAX_HEADROOM 256
-
-#endif /* _LWTUNNEL_H_ */
diff --git a/include/linux/magic.h b/include/linux/magic.h
deleted file mode 100644
index e439565..0000000
--- a/include/linux/magic.h
+++ /dev/null
@@ -1,91 +0,0 @@
-#ifndef __LINUX_MAGIC_H__
-#define __LINUX_MAGIC_H__
-
-#define ADFS_SUPER_MAGIC	0xadf5
-#define AFFS_SUPER_MAGIC	0xadff
-#define AFS_SUPER_MAGIC                0x5346414F
-#define AUTOFS_SUPER_MAGIC	0x0187
-#define CODA_SUPER_MAGIC	0x73757245
-#define CRAMFS_MAGIC		0x28cd3d45	/* some random number */
-#define CRAMFS_MAGIC_WEND	0x453dcd28	/* magic number with the wrong endianess */
-#define DEBUGFS_MAGIC          0x64626720
-#define SECURITYFS_MAGIC	0x73636673
-#define SELINUX_MAGIC		0xf97cff8c
-#define SMACK_MAGIC		0x43415d53	/* "SMAC" */
-#define RAMFS_MAGIC		0x858458f6	/* some random number */
-#define TMPFS_MAGIC		0x01021994
-#define HUGETLBFS_MAGIC 	0x958458f6	/* some random number */
-#define SQUASHFS_MAGIC		0x73717368
-#define ECRYPTFS_SUPER_MAGIC	0xf15f
-#define EFS_SUPER_MAGIC		0x414A53
-#define EXT2_SUPER_MAGIC	0xEF53
-#define EXT3_SUPER_MAGIC	0xEF53
-#define XENFS_SUPER_MAGIC	0xabba1974
-#define EXT4_SUPER_MAGIC	0xEF53
-#define BTRFS_SUPER_MAGIC	0x9123683E
-#define NILFS_SUPER_MAGIC	0x3434
-#define F2FS_SUPER_MAGIC	0xF2F52010
-#define HPFS_SUPER_MAGIC	0xf995e849
-#define ISOFS_SUPER_MAGIC	0x9660
-#define JFFS2_SUPER_MAGIC	0x72b6
-#define PSTOREFS_MAGIC		0x6165676C
-#define EFIVARFS_MAGIC		0xde5e81e4
-#define HOSTFS_SUPER_MAGIC	0x00c0ffee
-#define OVERLAYFS_SUPER_MAGIC	0x794c7630
-
-#define MINIX_SUPER_MAGIC	0x137F		/* minix v1 fs, 14 char names */
-#define MINIX_SUPER_MAGIC2	0x138F		/* minix v1 fs, 30 char names */
-#define MINIX2_SUPER_MAGIC	0x2468		/* minix v2 fs, 14 char names */
-#define MINIX2_SUPER_MAGIC2	0x2478		/* minix v2 fs, 30 char names */
-#define MINIX3_SUPER_MAGIC	0x4d5a		/* minix v3 fs, 60 char names */
-
-#define MSDOS_SUPER_MAGIC	0x4d44		/* MD */
-#define NCP_SUPER_MAGIC		0x564c		/* Guess, what 0x564c is :-) */
-#define NFS_SUPER_MAGIC		0x6969
-#define OCFS2_SUPER_MAGIC	0x7461636f
-#define OPENPROM_SUPER_MAGIC	0x9fa1
-#define QNX4_SUPER_MAGIC	0x002f		/* qnx4 fs detection */
-#define QNX6_SUPER_MAGIC	0x68191122	/* qnx6 fs detection */
-
-#define REISERFS_SUPER_MAGIC	0x52654973	/* used by gcc */
-					/* used by file system utilities that
-	                                   look at the superblock, etc.  */
-#define REISERFS_SUPER_MAGIC_STRING	"ReIsErFs"
-#define REISER2FS_SUPER_MAGIC_STRING	"ReIsEr2Fs"
-#define REISER2FS_JR_SUPER_MAGIC_STRING	"ReIsEr3Fs"
-
-#define SMB_SUPER_MAGIC		0x517B
-#define CGROUP_SUPER_MAGIC	0x27e0eb
-#define CGROUP2_SUPER_MAGIC	0x63677270
-
-#define RDTGROUP_SUPER_MAGIC	0x7655821
-
-#define STACK_END_MAGIC		0x57AC6E9D
-
-#define TRACEFS_MAGIC          0x74726163
-
-#define V9FS_MAGIC		0x01021997
-
-#define BDEVFS_MAGIC            0x62646576
-#define DAXFS_MAGIC             0x64646178
-#define BINFMTFS_MAGIC          0x42494e4d
-#define DEVPTS_SUPER_MAGIC	0x1cd1
-#define FUTEXFS_SUPER_MAGIC	0xBAD1DEA
-#define PIPEFS_MAGIC            0x50495045
-#define PROC_SUPER_MAGIC	0x9fa0
-#define SOCKFS_MAGIC		0x534F434B
-#define SYSFS_MAGIC		0x62656572
-#define USBDEVICE_SUPER_MAGIC	0x9fa2
-#define MTD_INODE_FS_MAGIC      0x11307854
-#define ANON_INODE_FS_MAGIC	0x09041934
-#define BTRFS_TEST_MAGIC	0x73727279
-#define NSFS_MAGIC		0x6e736673
-#define BPF_FS_MAGIC		0xcafe4a11
-#define AAFS_MAGIC		0x5a3c69f0
-
-/* Since UDF 2.01 is ISO 13346 based... */
-#define UDF_SUPER_MAGIC		0x15013346
-#define BALLOON_KVM_MAGIC	0x13661366
-#define ZSMALLOC_MAGIC		0x58295829
-
-#endif /* __LINUX_MAGIC_H__ */
diff --git a/include/linux/mpls.h b/include/linux/mpls.h
deleted file mode 100644
index bf5b625..0000000
--- a/include/linux/mpls.h
+++ /dev/null
@@ -1,76 +0,0 @@
-#ifndef _MPLS_H
-#define _MPLS_H
-
-#include <linux/types.h>
-#include <asm/byteorder.h>
-
-/* Reference: RFC 5462, RFC 3032
- *
- *  0                   1                   2                   3
- *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
- * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
- * |                Label                  | TC  |S|       TTL     |
- * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
- *
- *	Label:  Label Value, 20 bits
- *	TC:     Traffic Class field, 3 bits
- *	S:      Bottom of Stack, 1 bit
- *	TTL:    Time to Live, 8 bits
- */
-
-struct mpls_label {
-	__be32 entry;
-};
-
-#define MPLS_LS_LABEL_MASK      0xFFFFF000
-#define MPLS_LS_LABEL_SHIFT     12
-#define MPLS_LS_TC_MASK         0x00000E00
-#define MPLS_LS_TC_SHIFT        9
-#define MPLS_LS_S_MASK          0x00000100
-#define MPLS_LS_S_SHIFT         8
-#define MPLS_LS_TTL_MASK        0x000000FF
-#define MPLS_LS_TTL_SHIFT       0
-
-/* Reserved labels */
-#define MPLS_LABEL_IPV4NULL		0 /* RFC3032 */
-#define MPLS_LABEL_RTALERT		1 /* RFC3032 */
-#define MPLS_LABEL_IPV6NULL		2 /* RFC3032 */
-#define MPLS_LABEL_IMPLNULL		3 /* RFC3032 */
-#define MPLS_LABEL_ENTROPY		7 /* RFC6790 */
-#define MPLS_LABEL_GAL			13 /* RFC5586 */
-#define MPLS_LABEL_OAMALERT		14 /* RFC3429 */
-#define MPLS_LABEL_EXTENSION		15 /* RFC7274 */
-
-#define MPLS_LABEL_FIRST_UNRESERVED	16 /* RFC3032 */
-
-/* These are embedded into IFLA_STATS_AF_SPEC:
- * [IFLA_STATS_AF_SPEC]
- * -> [AF_MPLS]
- *    -> [MPLS_STATS_xxx]
- *
- * Attributes:
- * [MPLS_STATS_LINK] = {
- *     struct mpls_link_stats
- * }
- */
-enum {
-	MPLS_STATS_UNSPEC, /* also used as 64bit pad attribute */
-	MPLS_STATS_LINK,
-	__MPLS_STATS_MAX,
-};
-
-#define MPLS_STATS_MAX (__MPLS_STATS_MAX - 1)
-
-struct mpls_link_stats {
-	__u64	rx_packets;		/* total packets received	*/
-	__u64	tx_packets;		/* total packets transmitted	*/
-	__u64	rx_bytes;		/* total bytes received		*/
-	__u64	tx_bytes;		/* total bytes transmitted	*/
-	__u64	rx_errors;		/* bad packets received		*/
-	__u64	tx_errors;		/* packet transmit problems	*/
-	__u64	rx_dropped;		/* packet dropped on receive	*/
-	__u64	tx_dropped;		/* packet dropped on transmit	*/
-	__u64	rx_noroute;		/* no route for packet dest	*/
-};
-
-#endif /* _MPLS_H */
diff --git a/include/linux/mpls_iptunnel.h b/include/linux/mpls_iptunnel.h
deleted file mode 100644
index 1a0e57b..0000000
--- a/include/linux/mpls_iptunnel.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- *	mpls tunnel api
- *
- *	Authors:
- *		Roopa Prabhu <roopa@cumulusnetworks.com>
- *
- *	This program is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU General Public License
- *	as published by the Free Software Foundation; either version
- *	2 of the License, or (at your option) any later version.
- */
-
-#ifndef _LINUX_MPLS_IPTUNNEL_H
-#define _LINUX_MPLS_IPTUNNEL_H
-
-/* MPLS tunnel attributes
- * [RTA_ENCAP] = {
- *     [MPLS_IPTUNNEL_DST]
- *     [MPLS_IPTUNNEL_TTL]
- * }
- */
-enum {
-	MPLS_IPTUNNEL_UNSPEC,
-	MPLS_IPTUNNEL_DST,
-	MPLS_IPTUNNEL_TTL,
-	__MPLS_IPTUNNEL_MAX,
-};
-#define MPLS_IPTUNNEL_MAX (__MPLS_IPTUNNEL_MAX - 1)
-
-#endif /* _LINUX_MPLS_IPTUNNEL_H */
diff --git a/include/linux/neighbour.h b/include/linux/neighbour.h
deleted file mode 100644
index 3199d28..0000000
--- a/include/linux/neighbour.h
+++ /dev/null
@@ -1,171 +0,0 @@
-#ifndef __LINUX_NEIGHBOUR_H
-#define __LINUX_NEIGHBOUR_H
-
-#include <linux/types.h>
-#include <linux/netlink.h>
-
-struct ndmsg {
-	__u8		ndm_family;
-	__u8		ndm_pad1;
-	__u16		ndm_pad2;
-	__s32		ndm_ifindex;
-	__u16		ndm_state;
-	__u8		ndm_flags;
-	__u8		ndm_type;
-};
-
-enum {
-	NDA_UNSPEC,
-	NDA_DST,
-	NDA_LLADDR,
-	NDA_CACHEINFO,
-	NDA_PROBES,
-	NDA_VLAN,
-	NDA_PORT,
-	NDA_VNI,
-	NDA_IFINDEX,
-	NDA_MASTER,
-	NDA_LINK_NETNSID,
-	NDA_SRC_VNI,
-	__NDA_MAX
-};
-
-#define NDA_MAX (__NDA_MAX - 1)
-
-/*
- *	Neighbor Cache Entry Flags
- */
-
-#define NTF_USE		0x01
-#define NTF_SELF	0x02
-#define NTF_MASTER	0x04
-#define NTF_PROXY	0x08	/* == ATF_PUBL */
-#define NTF_EXT_LEARNED	0x10
-#define NTF_OFFLOADED   0x20
-#define NTF_ROUTER	0x80
-
-/*
- *	Neighbor Cache Entry States.
- */
-
-#define NUD_INCOMPLETE	0x01
-#define NUD_REACHABLE	0x02
-#define NUD_STALE	0x04
-#define NUD_DELAY	0x08
-#define NUD_PROBE	0x10
-#define NUD_FAILED	0x20
-
-/* Dummy states */
-#define NUD_NOARP	0x40
-#define NUD_PERMANENT	0x80
-#define NUD_NONE	0x00
-
-/* NUD_NOARP & NUD_PERMANENT are pseudostates, they never change
-   and make no address resolution or NUD.
-   NUD_PERMANENT also cannot be deleted by garbage collectors.
- */
-
-struct nda_cacheinfo {
-	__u32		ndm_confirmed;
-	__u32		ndm_used;
-	__u32		ndm_updated;
-	__u32		ndm_refcnt;
-};
-
-/*****************************************************************
- *		Neighbour tables specific messages.
- *
- * To retrieve the neighbour tables send RTM_GETNEIGHTBL with the
- * NLM_F_DUMP flag set. Every neighbour table configuration is
- * spread over multiple messages to avoid running into message
- * size limits on systems with many interfaces. The first message
- * in the sequence transports all not device specific data such as
- * statistics, configuration, and the default parameter set.
- * This message is followed by 0..n messages carrying device
- * specific parameter sets.
- * Although the ordering should be sufficient, NDTA_NAME can be
- * used to identify sequences. The initial message can be identified
- * by checking for NDTA_CONFIG. The device specific messages do
- * not contain this TLV but have NDTPA_IFINDEX set to the
- * corresponding interface index.
- *
- * To change neighbour table attributes, send RTM_SETNEIGHTBL
- * with NDTA_NAME set. Changeable attribute include NDTA_THRESH[1-3],
- * NDTA_GC_INTERVAL, and all TLVs in NDTA_PARMS unless marked
- * otherwise. Device specific parameter sets can be changed by
- * setting NDTPA_IFINDEX to the interface index of the corresponding
- * device.
- ****/
-
-struct ndt_stats {
-	__u64		ndts_allocs;
-	__u64		ndts_destroys;
-	__u64		ndts_hash_grows;
-	__u64		ndts_res_failed;
-	__u64		ndts_lookups;
-	__u64		ndts_hits;
-	__u64		ndts_rcv_probes_mcast;
-	__u64		ndts_rcv_probes_ucast;
-	__u64		ndts_periodic_gc_runs;
-	__u64		ndts_forced_gc_runs;
-	__u64		ndts_table_fulls;
-};
-
-enum {
-	NDTPA_UNSPEC,
-	NDTPA_IFINDEX,			/* u32, unchangeable */
-	NDTPA_REFCNT,			/* u32, read-only */
-	NDTPA_REACHABLE_TIME,		/* u64, read-only, msecs */
-	NDTPA_BASE_REACHABLE_TIME,	/* u64, msecs */
-	NDTPA_RETRANS_TIME,		/* u64, msecs */
-	NDTPA_GC_STALETIME,		/* u64, msecs */
-	NDTPA_DELAY_PROBE_TIME,		/* u64, msecs */
-	NDTPA_QUEUE_LEN,		/* u32 */
-	NDTPA_APP_PROBES,		/* u32 */
-	NDTPA_UCAST_PROBES,		/* u32 */
-	NDTPA_MCAST_PROBES,		/* u32 */
-	NDTPA_ANYCAST_DELAY,		/* u64, msecs */
-	NDTPA_PROXY_DELAY,		/* u64, msecs */
-	NDTPA_PROXY_QLEN,		/* u32 */
-	NDTPA_LOCKTIME,			/* u64, msecs */
-	NDTPA_QUEUE_LENBYTES,		/* u32 */
-	NDTPA_MCAST_REPROBES,		/* u32 */
-	NDTPA_PAD,
-	__NDTPA_MAX
-};
-#define NDTPA_MAX (__NDTPA_MAX - 1)
-
-struct ndtmsg {
-	__u8		ndtm_family;
-	__u8		ndtm_pad1;
-	__u16		ndtm_pad2;
-};
-
-struct ndt_config {
-	__u16		ndtc_key_len;
-	__u16		ndtc_entry_size;
-	__u32		ndtc_entries;
-	__u32		ndtc_last_flush;	/* delta to now in msecs */
-	__u32		ndtc_last_rand;		/* delta to now in msecs */
-	__u32		ndtc_hash_rnd;
-	__u32		ndtc_hash_mask;
-	__u32		ndtc_hash_chain_gc;
-	__u32		ndtc_proxy_qlen;
-};
-
-enum {
-	NDTA_UNSPEC,
-	NDTA_NAME,			/* char *, unchangeable */
-	NDTA_THRESH1,			/* u32 */
-	NDTA_THRESH2,			/* u32 */
-	NDTA_THRESH3,			/* u32 */
-	NDTA_CONFIG,			/* struct ndt_config, read-only */
-	NDTA_PARMS,			/* nested TLV NDTPA_* */
-	NDTA_STATS,			/* struct ndt_stats, read-only */
-	NDTA_GC_INTERVAL,		/* u64, msecs */
-	NDTA_PAD,
-	__NDTA_MAX
-};
-#define NDTA_MAX (__NDTA_MAX - 1)
-
-#endif
diff --git a/include/linux/net_namespace.h b/include/linux/net_namespace.h
deleted file mode 100644
index 9a92b7e..0000000
--- a/include/linux/net_namespace.h
+++ /dev/null
@@ -1,23 +0,0 @@
-/* Copyright (c) 2015 6WIND S.A.
- * Author: Nicolas Dichtel <nicolas.dichtel@6wind.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- */
-#ifndef _LINUX_NET_NAMESPACE_H_
-#define _LINUX_NET_NAMESPACE_H_
-
-/* Attributes of RTM_NEWNSID/RTM_GETNSID messages */
-enum {
-	NETNSA_NONE,
-#define NETNSA_NSID_NOT_ASSIGNED -1
-	NETNSA_NSID,
-	NETNSA_PID,
-	NETNSA_FD,
-	__NETNSA_MAX,
-};
-
-#define NETNSA_MAX		(__NETNSA_MAX - 1)
-
-#endif /* _LINUX_NET_NAMESPACE_H_ */
diff --git a/include/linux/netconf.h b/include/linux/netconf.h
deleted file mode 100644
index 4afbd7d..0000000
--- a/include/linux/netconf.h
+++ /dev/null
@@ -1,28 +0,0 @@
-#ifndef _LINUX_NETCONF_H_
-#define _LINUX_NETCONF_H_
-
-#include <linux/types.h>
-#include <linux/netlink.h>
-
-struct netconfmsg {
-	__u8	ncm_family;
-};
-
-enum {
-	NETCONFA_UNSPEC,
-	NETCONFA_IFINDEX,
-	NETCONFA_FORWARDING,
-	NETCONFA_RP_FILTER,
-	NETCONFA_MC_FORWARDING,
-	NETCONFA_PROXY_NEIGH,
-	NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN,
-	NETCONFA_INPUT,
-	__NETCONFA_MAX
-};
-#define NETCONFA_MAX	(__NETCONFA_MAX - 1)
-#define NETCONFA_ALL	-1
-
-#define NETCONFA_IFINDEX_ALL		-1
-#define NETCONFA_IFINDEX_DEFAULT	-2
-
-#endif /* _LINUX_NETCONF_H_ */
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
deleted file mode 100644
index 66fceb4..0000000
--- a/include/linux/netdevice.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * INET		An implementation of the TCP/IP protocol suite for the LINUX
- *		operating system.  INET is implemented using the  BSD Socket
- *		interface as the means of communication with the user level.
- *
- *		Definitions for the Interfaces handler.
- *
- * Version:	@(#)dev.h	1.0.10	08/12/93
- *
- * Authors:	Ross Biro
- *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
- *		Corey Minyard <wf-rch!minyard@relay.EU.net>
- *		Donald J. Becker, <becker@cesdis.gsfc.nasa.gov>
- *		Alan Cox, <alan@lxorguk.ukuu.org.uk>
- *		Bjorn Ekwall. <bj0rn@blox.se>
- *              Pekka Riikonen <priikone@poseidon.pspt.fi>
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
- *
- *		Moved to /usr/include/linux for NET3
- */
-#ifndef _LINUX_NETDEVICE_H
-#define _LINUX_NETDEVICE_H
-
-#include <linux/if.h>
-#include <linux/if_ether.h>
-#include <linux/if_packet.h>
-#include <linux/if_link.h>
-
-
-#define MAX_ADDR_LEN	32		/* Largest hardware address length */
-
-/* Initial net device group. All devices belong to group 0 by default. */
-#define INIT_NETDEV_GROUP	0
-
-
-/* interface name assignment types (sysfs name_assign_type attribute) */
-#define NET_NAME_UNKNOWN	0	/* unknown origin (not exposed to userspace) */
-#define NET_NAME_ENUM		1	/* enumerated by kernel */
-#define NET_NAME_PREDICTABLE	2	/* predictably named by the kernel */
-#define NET_NAME_USER		3	/* provided by user-space */
-#define NET_NAME_RENAMED	4	/* renamed by user-space */
-
-/* Media selection options. */
-enum {
-        IF_PORT_UNKNOWN = 0,
-        IF_PORT_10BASE2,
-        IF_PORT_10BASET,
-        IF_PORT_AUI,
-        IF_PORT_100BASET,
-        IF_PORT_100BASETX,
-        IF_PORT_100BASEFX
-};
-
-/* hardware address assignment types */
-#define NET_ADDR_PERM		0	/* address is permanent (default) */
-#define NET_ADDR_RANDOM		1	/* address is generated randomly */
-#define NET_ADDR_STOLEN		2	/* address is stolen from other device */
-#define NET_ADDR_SET		3	/* address is set using
-					 * dev_set_mac_address() */
-
-#endif /* _LINUX_NETDEVICE_H */
diff --git a/include/linux/netfilter.h b/include/linux/netfilter.h
deleted file mode 100644
index ff4a4a5..0000000
--- a/include/linux/netfilter.h
+++ /dev/null
@@ -1,77 +0,0 @@
-#ifndef __LINUX_NETFILTER_H
-#define __LINUX_NETFILTER_H
-
-#include <linux/types.h>
-
-#include <linux/in.h>
-#include <linux/in6.h>
-
-/* Responses from hook functions. */
-#define NF_DROP 0
-#define NF_ACCEPT 1
-#define NF_STOLEN 2
-#define NF_QUEUE 3
-#define NF_REPEAT 4
-#define NF_STOP 5	/* Deprecated, for userspace nf_queue compatibility. */
-#define NF_MAX_VERDICT NF_STOP
-
-/* we overload the higher bits for encoding auxiliary data such as the queue
- * number or errno values. Not nice, but better than additional function
- * arguments. */
-#define NF_VERDICT_MASK 0x000000ff
-
-/* extra verdict flags have mask 0x0000ff00 */
-#define NF_VERDICT_FLAG_QUEUE_BYPASS	0x00008000
-
-/* queue number (NF_QUEUE) or errno (NF_DROP) */
-#define NF_VERDICT_QMASK 0xffff0000
-#define NF_VERDICT_QBITS 16
-
-#define NF_QUEUE_NR(x) ((((x) << 16) & NF_VERDICT_QMASK) | NF_QUEUE)
-
-#define NF_DROP_ERR(x) (((-x) << 16) | NF_DROP)
-
-/* only for userspace compatibility */
-/* Generic cache responses from hook functions.
-   <= 0x2000 is used for protocol-flags. */
-#define NFC_UNKNOWN 0x4000
-#define NFC_ALTERED 0x8000
-
-/* NF_VERDICT_BITS should be 8 now, but userspace might break if this changes */
-#define NF_VERDICT_BITS 16
-
-enum nf_inet_hooks {
-	NF_INET_PRE_ROUTING,
-	NF_INET_LOCAL_IN,
-	NF_INET_FORWARD,
-	NF_INET_LOCAL_OUT,
-	NF_INET_POST_ROUTING,
-	NF_INET_NUMHOOKS
-};
-
-enum nf_dev_hooks {
-	NF_NETDEV_INGRESS,
-	NF_NETDEV_NUMHOOKS
-};
-
-enum {
-	NFPROTO_UNSPEC =  0,
-	NFPROTO_INET   =  1,
-	NFPROTO_IPV4   =  2,
-	NFPROTO_ARP    =  3,
-	NFPROTO_NETDEV =  5,
-	NFPROTO_BRIDGE =  7,
-	NFPROTO_IPV6   = 10,
-	NFPROTO_DECNET = 12,
-	NFPROTO_NUMPROTO,
-};
-
-union nf_inet_addr {
-	__u32		all[4];
-	__be32		ip;
-	__be32		ip6[4];
-	struct in_addr	in;
-	struct in6_addr	in6;
-};
-
-#endif /* __LINUX_NETFILTER_H */
diff --git a/include/linux/netfilter/ipset/ip_set.h b/include/linux/netfilter/ipset/ip_set.h
deleted file mode 100644
index a6c96b0..0000000
--- a/include/linux/netfilter/ipset/ip_set.h
+++ /dev/null
@@ -1,304 +0,0 @@
-/* Copyright (C) 2000-2002 Joakim Axelsson <gozem@linux.nu>
- *                         Patrick Schaaf <bof@bof.de>
- *                         Martin Josefsson <gandalf@wlug.westbo.se>
- * Copyright (C) 2003-2011 Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#ifndef _IP_SET_H
-#define _IP_SET_H
-
-#include <linux/types.h>
-
-/* The protocol version */
-#define IPSET_PROTOCOL		6
-
-/* The max length of strings including NUL: set and type identifiers */
-#define IPSET_MAXNAMELEN	32
-
-/* The maximum permissible comment length we will accept over netlink */
-#define IPSET_MAX_COMMENT_SIZE	255
-
-/* Message types and commands */
-enum ipset_cmd {
-	IPSET_CMD_NONE,
-	IPSET_CMD_PROTOCOL,	/* 1: Return protocol version */
-	IPSET_CMD_CREATE,	/* 2: Create a new (empty) set */
-	IPSET_CMD_DESTROY,	/* 3: Destroy a (empty) set */
-	IPSET_CMD_FLUSH,	/* 4: Remove all elements from a set */
-	IPSET_CMD_RENAME,	/* 5: Rename a set */
-	IPSET_CMD_SWAP,		/* 6: Swap two sets */
-	IPSET_CMD_LIST,		/* 7: List sets */
-	IPSET_CMD_SAVE,		/* 8: Save sets */
-	IPSET_CMD_ADD,		/* 9: Add an element to a set */
-	IPSET_CMD_DEL,		/* 10: Delete an element from a set */
-	IPSET_CMD_TEST,		/* 11: Test an element in a set */
-	IPSET_CMD_HEADER,	/* 12: Get set header data only */
-	IPSET_CMD_TYPE,		/* 13: Get set type */
-	IPSET_MSG_MAX,		/* Netlink message commands */
-
-	/* Commands in userspace: */
-	IPSET_CMD_RESTORE = IPSET_MSG_MAX, /* 14: Enter restore mode */
-	IPSET_CMD_HELP,		/* 15: Get help */
-	IPSET_CMD_VERSION,	/* 16: Get program version */
-	IPSET_CMD_QUIT,		/* 17: Quit from interactive mode */
-
-	IPSET_CMD_MAX,
-
-	IPSET_CMD_COMMIT = IPSET_CMD_MAX, /* 18: Commit buffered commands */
-};
-
-/* Attributes at command level */
-enum {
-	IPSET_ATTR_UNSPEC,
-	IPSET_ATTR_PROTOCOL,	/* 1: Protocol version */
-	IPSET_ATTR_SETNAME,	/* 2: Name of the set */
-	IPSET_ATTR_TYPENAME,	/* 3: Typename */
-	IPSET_ATTR_SETNAME2 = IPSET_ATTR_TYPENAME, /* Setname at rename/swap */
-	IPSET_ATTR_REVISION,	/* 4: Settype revision */
-	IPSET_ATTR_FAMILY,	/* 5: Settype family */
-	IPSET_ATTR_FLAGS,	/* 6: Flags at command level */
-	IPSET_ATTR_DATA,	/* 7: Nested attributes */
-	IPSET_ATTR_ADT,		/* 8: Multiple data containers */
-	IPSET_ATTR_LINENO,	/* 9: Restore lineno */
-	IPSET_ATTR_PROTOCOL_MIN, /* 10: Minimal supported version number */
-	IPSET_ATTR_REVISION_MIN	= IPSET_ATTR_PROTOCOL_MIN, /* type rev min */
-	__IPSET_ATTR_CMD_MAX,
-};
-#define IPSET_ATTR_CMD_MAX	(__IPSET_ATTR_CMD_MAX - 1)
-
-/* CADT specific attributes */
-enum {
-	IPSET_ATTR_IP = IPSET_ATTR_UNSPEC + 1,
-	IPSET_ATTR_IP_FROM = IPSET_ATTR_IP,
-	IPSET_ATTR_IP_TO,	/* 2 */
-	IPSET_ATTR_CIDR,	/* 3 */
-	IPSET_ATTR_PORT,	/* 4 */
-	IPSET_ATTR_PORT_FROM = IPSET_ATTR_PORT,
-	IPSET_ATTR_PORT_TO,	/* 5 */
-	IPSET_ATTR_TIMEOUT,	/* 6 */
-	IPSET_ATTR_PROTO,	/* 7 */
-	IPSET_ATTR_CADT_FLAGS,	/* 8 */
-	IPSET_ATTR_CADT_LINENO = IPSET_ATTR_LINENO,	/* 9 */
-	IPSET_ATTR_MARK,	/* 10 */
-	IPSET_ATTR_MARKMASK,	/* 11 */
-	/* Reserve empty slots */
-	IPSET_ATTR_CADT_MAX = 16,
-	/* Create-only specific attributes */
-	IPSET_ATTR_GC,
-	IPSET_ATTR_HASHSIZE,
-	IPSET_ATTR_MAXELEM,
-	IPSET_ATTR_NETMASK,
-	IPSET_ATTR_PROBES,
-	IPSET_ATTR_RESIZE,
-	IPSET_ATTR_SIZE,
-	/* Kernel-only */
-	IPSET_ATTR_ELEMENTS,
-	IPSET_ATTR_REFERENCES,
-	IPSET_ATTR_MEMSIZE,
-
-	__IPSET_ATTR_CREATE_MAX,
-};
-#define IPSET_ATTR_CREATE_MAX	(__IPSET_ATTR_CREATE_MAX - 1)
-
-/* ADT specific attributes */
-enum {
-	IPSET_ATTR_ETHER = IPSET_ATTR_CADT_MAX + 1,
-	IPSET_ATTR_NAME,
-	IPSET_ATTR_NAMEREF,
-	IPSET_ATTR_IP2,
-	IPSET_ATTR_CIDR2,
-	IPSET_ATTR_IP2_TO,
-	IPSET_ATTR_IFACE,
-	IPSET_ATTR_BYTES,
-	IPSET_ATTR_PACKETS,
-	IPSET_ATTR_COMMENT,
-	IPSET_ATTR_SKBMARK,
-	IPSET_ATTR_SKBPRIO,
-	IPSET_ATTR_SKBQUEUE,
-	IPSET_ATTR_PAD,
-	__IPSET_ATTR_ADT_MAX,
-};
-#define IPSET_ATTR_ADT_MAX	(__IPSET_ATTR_ADT_MAX - 1)
-
-/* IP specific attributes */
-enum {
-	IPSET_ATTR_IPADDR_IPV4 = IPSET_ATTR_UNSPEC + 1,
-	IPSET_ATTR_IPADDR_IPV6,
-	__IPSET_ATTR_IPADDR_MAX,
-};
-#define IPSET_ATTR_IPADDR_MAX	(__IPSET_ATTR_IPADDR_MAX - 1)
-
-/* Error codes */
-enum ipset_errno {
-	IPSET_ERR_PRIVATE = 4096,
-	IPSET_ERR_PROTOCOL,
-	IPSET_ERR_FIND_TYPE,
-	IPSET_ERR_MAX_SETS,
-	IPSET_ERR_BUSY,
-	IPSET_ERR_EXIST_SETNAME2,
-	IPSET_ERR_TYPE_MISMATCH,
-	IPSET_ERR_EXIST,
-	IPSET_ERR_INVALID_CIDR,
-	IPSET_ERR_INVALID_NETMASK,
-	IPSET_ERR_INVALID_FAMILY,
-	IPSET_ERR_TIMEOUT,
-	IPSET_ERR_REFERENCED,
-	IPSET_ERR_IPADDR_IPV4,
-	IPSET_ERR_IPADDR_IPV6,
-	IPSET_ERR_COUNTER,
-	IPSET_ERR_COMMENT,
-	IPSET_ERR_INVALID_MARKMASK,
-	IPSET_ERR_SKBINFO,
-
-	/* Type specific error codes */
-	IPSET_ERR_TYPE_SPECIFIC = 4352,
-};
-
-/* Flags at command level or match/target flags, lower half of cmdattrs*/
-enum ipset_cmd_flags {
-	IPSET_FLAG_BIT_EXIST	= 0,
-	IPSET_FLAG_EXIST	= (1 << IPSET_FLAG_BIT_EXIST),
-	IPSET_FLAG_BIT_LIST_SETNAME = 1,
-	IPSET_FLAG_LIST_SETNAME	= (1 << IPSET_FLAG_BIT_LIST_SETNAME),
-	IPSET_FLAG_BIT_LIST_HEADER = 2,
-	IPSET_FLAG_LIST_HEADER	= (1 << IPSET_FLAG_BIT_LIST_HEADER),
-	IPSET_FLAG_BIT_SKIP_COUNTER_UPDATE = 3,
-	IPSET_FLAG_SKIP_COUNTER_UPDATE =
-		(1 << IPSET_FLAG_BIT_SKIP_COUNTER_UPDATE),
-	IPSET_FLAG_BIT_SKIP_SUBCOUNTER_UPDATE = 4,
-	IPSET_FLAG_SKIP_SUBCOUNTER_UPDATE =
-		(1 << IPSET_FLAG_BIT_SKIP_SUBCOUNTER_UPDATE),
-	IPSET_FLAG_BIT_MATCH_COUNTERS = 5,
-	IPSET_FLAG_MATCH_COUNTERS = (1 << IPSET_FLAG_BIT_MATCH_COUNTERS),
-	IPSET_FLAG_BIT_RETURN_NOMATCH = 7,
-	IPSET_FLAG_RETURN_NOMATCH = (1 << IPSET_FLAG_BIT_RETURN_NOMATCH),
-	IPSET_FLAG_BIT_MAP_SKBMARK = 8,
-	IPSET_FLAG_MAP_SKBMARK = (1 << IPSET_FLAG_BIT_MAP_SKBMARK),
-	IPSET_FLAG_BIT_MAP_SKBPRIO = 9,
-	IPSET_FLAG_MAP_SKBPRIO = (1 << IPSET_FLAG_BIT_MAP_SKBPRIO),
-	IPSET_FLAG_BIT_MAP_SKBQUEUE = 10,
-	IPSET_FLAG_MAP_SKBQUEUE = (1 << IPSET_FLAG_BIT_MAP_SKBQUEUE),
-	IPSET_FLAG_CMD_MAX = 15,
-};
-
-/* Flags at CADT attribute level, upper half of cmdattrs */
-enum ipset_cadt_flags {
-	IPSET_FLAG_BIT_BEFORE	= 0,
-	IPSET_FLAG_BEFORE	= (1 << IPSET_FLAG_BIT_BEFORE),
-	IPSET_FLAG_BIT_PHYSDEV	= 1,
-	IPSET_FLAG_PHYSDEV	= (1 << IPSET_FLAG_BIT_PHYSDEV),
-	IPSET_FLAG_BIT_NOMATCH	= 2,
-	IPSET_FLAG_NOMATCH	= (1 << IPSET_FLAG_BIT_NOMATCH),
-	IPSET_FLAG_BIT_WITH_COUNTERS = 3,
-	IPSET_FLAG_WITH_COUNTERS = (1 << IPSET_FLAG_BIT_WITH_COUNTERS),
-	IPSET_FLAG_BIT_WITH_COMMENT = 4,
-	IPSET_FLAG_WITH_COMMENT = (1 << IPSET_FLAG_BIT_WITH_COMMENT),
-	IPSET_FLAG_BIT_WITH_FORCEADD = 5,
-	IPSET_FLAG_WITH_FORCEADD = (1 << IPSET_FLAG_BIT_WITH_FORCEADD),
-	IPSET_FLAG_BIT_WITH_SKBINFO = 6,
-	IPSET_FLAG_WITH_SKBINFO = (1 << IPSET_FLAG_BIT_WITH_SKBINFO),
-	IPSET_FLAG_CADT_MAX	= 15,
-};
-
-/* The flag bits which correspond to the non-extension create flags */
-enum ipset_create_flags {
-	IPSET_CREATE_FLAG_BIT_FORCEADD = 0,
-	IPSET_CREATE_FLAG_FORCEADD = (1 << IPSET_CREATE_FLAG_BIT_FORCEADD),
-	IPSET_CREATE_FLAG_BIT_MAX = 7,
-};
-
-/* Commands with settype-specific attributes */
-enum ipset_adt {
-	IPSET_ADD,
-	IPSET_DEL,
-	IPSET_TEST,
-	IPSET_ADT_MAX,
-	IPSET_CREATE = IPSET_ADT_MAX,
-	IPSET_CADT_MAX,
-};
-
-/* Sets are identified by an index in kernel space. Tweak with ip_set_id_t
- * and IPSET_INVALID_ID if you want to increase the max number of sets.
- */
-typedef __u16 ip_set_id_t;
-
-#define IPSET_INVALID_ID		65535
-
-enum ip_set_dim {
-	IPSET_DIM_ZERO = 0,
-	IPSET_DIM_ONE,
-	IPSET_DIM_TWO,
-	IPSET_DIM_THREE,
-	/* Max dimension in elements.
-	 * If changed, new revision of iptables match/target is required.
-	 */
-	IPSET_DIM_MAX = 6,
-	/* Backward compatibility: set match revision 2 */
-	IPSET_BIT_RETURN_NOMATCH = 7,
-};
-
-/* Option flags for kernel operations */
-enum ip_set_kopt {
-	IPSET_INV_MATCH = (1 << IPSET_DIM_ZERO),
-	IPSET_DIM_ONE_SRC = (1 << IPSET_DIM_ONE),
-	IPSET_DIM_TWO_SRC = (1 << IPSET_DIM_TWO),
-	IPSET_DIM_THREE_SRC = (1 << IPSET_DIM_THREE),
-	IPSET_RETURN_NOMATCH = (1 << IPSET_BIT_RETURN_NOMATCH),
-};
-
-enum {
-	IPSET_COUNTER_NONE = 0,
-	IPSET_COUNTER_EQ,
-	IPSET_COUNTER_NE,
-	IPSET_COUNTER_LT,
-	IPSET_COUNTER_GT,
-};
-
-/* Backward compatibility for set match v3 */
-struct ip_set_counter_match0 {
-	__u8 op;
-	__u64 value;
-};
-
-struct ip_set_counter_match {
-	__aligned_u64 value;
-	__u8 op;
-};
-
-/* Interface to iptables/ip6tables */
-
-#define SO_IP_SET		83
-
-union ip_set_name_index {
-	char name[IPSET_MAXNAMELEN];
-	ip_set_id_t index;
-};
-
-#define IP_SET_OP_GET_BYNAME	0x00000006	/* Get set index by name */
-struct ip_set_req_get_set {
-	unsigned int op;
-	unsigned int version;
-	union ip_set_name_index set;
-};
-
-#define IP_SET_OP_GET_BYINDEX	0x00000007	/* Get set name by index */
-/* Uses ip_set_req_get_set */
-
-#define IP_SET_OP_GET_FNAME	0x00000008	/* Get set index and family */
-struct ip_set_req_get_set_family {
-	unsigned int op;
-	unsigned int version;
-	unsigned int family;
-	union ip_set_name_index set;
-};
-
-#define IP_SET_OP_VERSION	0x00000100	/* Ask kernel version */
-struct ip_set_req_version {
-	unsigned int op;
-	unsigned int version;
-};
-
-#endif /* _IP_SET_H */
diff --git a/include/linux/netfilter/x_tables.h b/include/linux/netfilter/x_tables.h
deleted file mode 100644
index 4120970..0000000
--- a/include/linux/netfilter/x_tables.h
+++ /dev/null
@@ -1,185 +0,0 @@
-#ifndef _X_TABLES_H
-#define _X_TABLES_H
-#include <linux/kernel.h>
-#include <linux/types.h>
-
-#define XT_FUNCTION_MAXNAMELEN 30
-#define XT_EXTENSION_MAXNAMELEN 29
-#define XT_TABLE_MAXNAMELEN 32
-
-struct xt_entry_match {
-	union {
-		struct {
-			__u16 match_size;
-
-			/* Used by userspace */
-			char name[XT_EXTENSION_MAXNAMELEN];
-			__u8 revision;
-		} user;
-		struct {
-			__u16 match_size;
-
-			/* Used inside the kernel */
-			struct xt_match *match;
-		} kernel;
-
-		/* Total length */
-		__u16 match_size;
-	} u;
-
-	unsigned char data[0];
-};
-
-struct xt_entry_target {
-	union {
-		struct {
-			__u16 target_size;
-
-			/* Used by userspace */
-			char name[XT_EXTENSION_MAXNAMELEN];
-			__u8 revision;
-		} user;
-		struct {
-			__u16 target_size;
-
-			/* Used inside the kernel */
-			struct xt_target *target;
-		} kernel;
-
-		/* Total length */
-		__u16 target_size;
-	} u;
-
-	unsigned char data[0];
-};
-
-#define XT_TARGET_INIT(__name, __size)					       \
-{									       \
-	.target.u.user = {						       \
-		.target_size	= XT_ALIGN(__size),			       \
-		.name		= __name,				       \
-	},								       \
-}
-
-struct xt_standard_target {
-	struct xt_entry_target target;
-	int verdict;
-};
-
-struct xt_error_target {
-	struct xt_entry_target target;
-	char errorname[XT_FUNCTION_MAXNAMELEN];
-};
-
-/* The argument to IPT_SO_GET_REVISION_*.  Returns highest revision
- * kernel supports, if >= revision. */
-struct xt_get_revision {
-	char name[XT_EXTENSION_MAXNAMELEN];
-	__u8 revision;
-};
-
-/* CONTINUE verdict for targets */
-#define XT_CONTINUE 0xFFFFFFFF
-
-/* For standard target */
-#define XT_RETURN (-NF_REPEAT - 1)
-
-/* this is a dummy structure to find out the alignment requirement for a struct
- * containing all the fundamental data types that are used in ipt_entry,
- * ip6t_entry and arpt_entry.  This sucks, and it is a hack.  It will be my
- * personal pleasure to remove it -HW
- */
-struct _xt_align {
-	__u8 u8;
-	__u16 u16;
-	__u32 u32;
-	__u64 u64;
-};
-
-#define XT_ALIGN(s) __ALIGN_KERNEL((s), __alignof__(struct _xt_align))
-
-/* Standard return verdict, or do jump. */
-#define XT_STANDARD_TARGET ""
-/* Error verdict. */
-#define XT_ERROR_TARGET "ERROR"
-
-#define SET_COUNTER(c,b,p) do { (c).bcnt = (b); (c).pcnt = (p); } while(0)
-#define ADD_COUNTER(c,b,p) do { (c).bcnt += (b); (c).pcnt += (p); } while(0)
-
-struct xt_counters {
-	__u64 pcnt, bcnt;			/* Packet and byte counters */
-};
-
-/* The argument to IPT_SO_ADD_COUNTERS. */
-struct xt_counters_info {
-	/* Which table. */
-	char name[XT_TABLE_MAXNAMELEN];
-
-	unsigned int num_counters;
-
-	/* The counters (actually `number' of these). */
-	struct xt_counters counters[0];
-};
-
-#define XT_INV_PROTO		0x40	/* Invert the sense of PROTO. */
-
-/* fn returns 0 to continue iteration */
-#define XT_MATCH_ITERATE(type, e, fn, args...)			\
-({								\
-	unsigned int __i;					\
-	int __ret = 0;						\
-	struct xt_entry_match *__m;				\
-								\
-	for (__i = sizeof(type);				\
-	     __i < (e)->target_offset;				\
-	     __i += __m->u.match_size) {			\
-		__m = (void *)e + __i;				\
-								\
-		__ret = fn(__m , ## args);			\
-		if (__ret != 0)					\
-			break;					\
-	}							\
-	__ret;							\
-})
-
-/* fn returns 0 to continue iteration */
-#define XT_ENTRY_ITERATE_CONTINUE(type, entries, size, n, fn, args...) \
-({								\
-	unsigned int __i, __n;					\
-	int __ret = 0;						\
-	type *__entry;						\
-								\
-	for (__i = 0, __n = 0; __i < (size);			\
-	     __i += __entry->next_offset, __n++) { 		\
-		__entry = (void *)(entries) + __i;		\
-		if (__n < n)					\
-			continue;				\
-								\
-		__ret = fn(__entry , ## args);			\
-		if (__ret != 0)					\
-			break;					\
-	}							\
-	__ret;							\
-})
-
-/* fn returns 0 to continue iteration */
-#define XT_ENTRY_ITERATE(type, entries, size, fn, args...) \
-	XT_ENTRY_ITERATE_CONTINUE(type, entries, size, 0, fn, args)
-
-
-/* pos is normally a struct ipt_entry/ip6t_entry/etc. */
-#define xt_entry_foreach(pos, ehead, esize) \
-	for ((pos) = (typeof(pos))(ehead); \
-	     (pos) < (typeof(pos))((char *)(ehead) + (esize)); \
-	     (pos) = (typeof(pos))((char *)(pos) + (pos)->next_offset))
-
-/* can only be xt_entry_match, so no use of typeof here */
-#define xt_ematch_foreach(pos, entry) \
-	for ((pos) = (struct xt_entry_match *)entry->elems; \
-	     (pos) < (struct xt_entry_match *)((char *)(entry) + \
-	             (entry)->target_offset); \
-	     (pos) = (struct xt_entry_match *)((char *)(pos) + \
-	             (pos)->u.match_size))
-
-
-#endif /* _X_TABLES_H */
diff --git a/include/linux/netfilter/xt_set.h b/include/linux/netfilter/xt_set.h
deleted file mode 100644
index d4e0234..0000000
--- a/include/linux/netfilter/xt_set.h
+++ /dev/null
@@ -1,93 +0,0 @@
-#ifndef _XT_SET_H
-#define _XT_SET_H
-
-#include <linux/types.h>
-#include <linux/netfilter/ipset/ip_set.h>
-
-/* Revision 0 interface: backward compatible with netfilter/iptables */
-
-/*
- * Option flags for kernel operations (xt_set_info_v0)
- */
-#define IPSET_SRC		0x01	/* Source match/add */
-#define IPSET_DST		0x02	/* Destination match/add */
-#define IPSET_MATCH_INV		0x04	/* Inverse matching */
-
-struct xt_set_info_v0 {
-	ip_set_id_t index;
-	union {
-		__u32 flags[IPSET_DIM_MAX + 1];
-		struct {
-			__u32 __flags[IPSET_DIM_MAX];
-			__u8 dim;
-			__u8 flags;
-		} compat;
-	} u;
-};
-
-/* match and target infos */
-struct xt_set_info_match_v0 {
-	struct xt_set_info_v0 match_set;
-};
-
-struct xt_set_info_target_v0 {
-	struct xt_set_info_v0 add_set;
-	struct xt_set_info_v0 del_set;
-};
-
-/* Revision 1  match and target */
-
-struct xt_set_info {
-	ip_set_id_t index;
-	__u8 dim;
-	__u8 flags;
-};
-
-/* match and target infos */
-struct xt_set_info_match_v1 {
-	struct xt_set_info match_set;
-};
-
-struct xt_set_info_target_v1 {
-	struct xt_set_info add_set;
-	struct xt_set_info del_set;
-};
-
-/* Revision 2 target */
-
-struct xt_set_info_target_v2 {
-	struct xt_set_info add_set;
-	struct xt_set_info del_set;
-	__u32 flags;
-	__u32 timeout;
-};
-
-/* Revision 3 match */
-
-struct xt_set_info_match_v3 {
-	struct xt_set_info match_set;
-	struct ip_set_counter_match0 packets;
-	struct ip_set_counter_match0 bytes;
-	__u32 flags;
-};
-
-/* Revision 3 target */
-
-struct xt_set_info_target_v3 {
-	struct xt_set_info add_set;
-	struct xt_set_info del_set;
-	struct xt_set_info map_set;
-	__u32 flags;
-	__u32 timeout;
-};
-
-/* Revision 4 match */
-
-struct xt_set_info_match_v4 {
-	struct xt_set_info match_set;
-	struct ip_set_counter_match packets;
-	struct ip_set_counter_match bytes;
-	__u32 flags;
-};
-
-#endif /*_XT_SET_H*/
diff --git a/include/linux/netfilter/xt_tcpudp.h b/include/linux/netfilter/xt_tcpudp.h
deleted file mode 100644
index 38aa7b3..0000000
--- a/include/linux/netfilter/xt_tcpudp.h
+++ /dev/null
@@ -1,36 +0,0 @@
-#ifndef _XT_TCPUDP_H
-#define _XT_TCPUDP_H
-
-#include <linux/types.h>
-
-/* TCP matching stuff */
-struct xt_tcp {
-	__u16 spts[2];			/* Source port range. */
-	__u16 dpts[2];			/* Destination port range. */
-	__u8 option;			/* TCP Option iff non-zero*/
-	__u8 flg_mask;			/* TCP flags mask byte */
-	__u8 flg_cmp;			/* TCP flags compare byte */
-	__u8 invflags;			/* Inverse flags */
-};
-
-/* Values for "inv" field in struct ipt_tcp. */
-#define XT_TCP_INV_SRCPT	0x01	/* Invert the sense of source ports. */
-#define XT_TCP_INV_DSTPT	0x02	/* Invert the sense of dest ports. */
-#define XT_TCP_INV_FLAGS	0x04	/* Invert the sense of TCP flags. */
-#define XT_TCP_INV_OPTION	0x08	/* Invert the sense of option test. */
-#define XT_TCP_INV_MASK		0x0F	/* All possible flags. */
-
-/* UDP matching stuff */
-struct xt_udp {
-	__u16 spts[2];			/* Source port range. */
-	__u16 dpts[2];			/* Destination port range. */
-	__u8 invflags;			/* Inverse flags */
-};
-
-/* Values for "invflags" field in struct ipt_udp. */
-#define XT_UDP_INV_SRCPT	0x01	/* Invert the sense of source ports. */
-#define XT_UDP_INV_DSTPT	0x02	/* Invert the sense of dest ports. */
-#define XT_UDP_INV_MASK	0x03	/* All possible flags. */
-
-
-#endif
diff --git a/include/linux/netfilter_ipv4.h b/include/linux/netfilter_ipv4.h
deleted file mode 100644
index a5f4dc7..0000000
--- a/include/linux/netfilter_ipv4.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/* IPv4-specific defines for netfilter. 
- * (C)1998 Rusty Russell -- This code is GPL.
- */
-#ifndef __LINUX_IP_NETFILTER_H
-#define __LINUX_IP_NETFILTER_H
-
-
-#include <linux/netfilter.h>
-
-/* only for userspace compatibility */
-
-#include <limits.h> /* for INT_MIN, INT_MAX */
-
-/* IP Cache bits. */
-/* Src IP address. */
-#define NFC_IP_SRC		0x0001
-/* Dest IP address. */
-#define NFC_IP_DST		0x0002
-/* Input device. */
-#define NFC_IP_IF_IN		0x0004
-/* Output device. */
-#define NFC_IP_IF_OUT		0x0008
-/* TOS. */
-#define NFC_IP_TOS		0x0010
-/* Protocol. */
-#define NFC_IP_PROTO		0x0020
-/* IP options. */
-#define NFC_IP_OPTIONS		0x0040
-/* Frag & flags. */
-#define NFC_IP_FRAG		0x0080
-
-/* Per-protocol information: only matters if proto match. */
-/* TCP flags. */
-#define NFC_IP_TCPFLAGS		0x0100
-/* Source port. */
-#define NFC_IP_SRC_PT		0x0200
-/* Dest port. */
-#define NFC_IP_DST_PT		0x0400
-/* Something else about the proto */
-#define NFC_IP_PROTO_UNKNOWN	0x2000
-
-/* IP Hooks */
-/* After promisc drops, checksum checks. */
-#define NF_IP_PRE_ROUTING	0
-/* If the packet is destined for this box. */
-#define NF_IP_LOCAL_IN		1
-/* If the packet is destined for another interface. */
-#define NF_IP_FORWARD		2
-/* Packets coming from a local process. */
-#define NF_IP_LOCAL_OUT		3
-/* Packets about to hit the wire. */
-#define NF_IP_POST_ROUTING	4
-#define NF_IP_NUMHOOKS		5
-
-enum nf_ip_hook_priorities {
-	NF_IP_PRI_FIRST = INT_MIN,
-	NF_IP_PRI_CONNTRACK_DEFRAG = -400,
-	NF_IP_PRI_RAW = -300,
-	NF_IP_PRI_SELINUX_FIRST = -225,
-	NF_IP_PRI_CONNTRACK = -200,
-	NF_IP_PRI_MANGLE = -150,
-	NF_IP_PRI_NAT_DST = -100,
-	NF_IP_PRI_FILTER = 0,
-	NF_IP_PRI_SECURITY = 50,
-	NF_IP_PRI_NAT_SRC = 100,
-	NF_IP_PRI_SELINUX_LAST = 225,
-	NF_IP_PRI_CONNTRACK_HELPER = 300,
-	NF_IP_PRI_CONNTRACK_CONFIRM = INT_MAX,
-	NF_IP_PRI_LAST = INT_MAX,
-};
-
-/* Arguments for setsockopt SOL_IP: */
-/* 2.0 firewalling went from 64 through 71 (and +256, +512, etc). */
-/* 2.2 firewalling (+ masq) went from 64 through 76 */
-/* 2.4 firewalling went 64 through 67. */
-#define SO_ORIGINAL_DST 80
-
-
-#endif /* __LINUX_IP_NETFILTER_H */
diff --git a/include/linux/netfilter_ipv4/ip_tables.h b/include/linux/netfilter_ipv4/ip_tables.h
deleted file mode 100644
index 456fb86..0000000
--- a/include/linux/netfilter_ipv4/ip_tables.h
+++ /dev/null
@@ -1,228 +0,0 @@
-/*
- * 25-Jul-1998 Major changes to allow for ip chain table
- *
- * 3-Jan-2000 Named tables to allow packet selection for different uses.
- */
-
-/*
- * 	Format of an IP firewall descriptor
- *
- * 	src, dst, src_mask, dst_mask are always stored in network byte order.
- * 	flags are stored in host byte order (of course).
- * 	Port numbers are stored in HOST byte order.
- */
-
-#ifndef _IPTABLES_H
-#define _IPTABLES_H
-
-#include <linux/types.h>
-
-#include <linux/if.h>
-#include <linux/netfilter_ipv4.h>
-
-#include <linux/netfilter/x_tables.h>
-
-#define IPT_FUNCTION_MAXNAMELEN XT_FUNCTION_MAXNAMELEN
-#define IPT_TABLE_MAXNAMELEN XT_TABLE_MAXNAMELEN
-#define ipt_match xt_match
-#define ipt_target xt_target
-#define ipt_table xt_table
-#define ipt_get_revision xt_get_revision
-#define ipt_entry_match xt_entry_match
-#define ipt_entry_target xt_entry_target
-#define ipt_standard_target xt_standard_target
-#define ipt_error_target xt_error_target
-#define ipt_counters xt_counters
-#define IPT_CONTINUE XT_CONTINUE
-#define IPT_RETURN XT_RETURN
-
-/* This group is older than old (iptables < v1.4.0-rc1~89) */
-#include <linux/netfilter/xt_tcpudp.h>
-#define ipt_udp xt_udp
-#define ipt_tcp xt_tcp
-#define IPT_TCP_INV_SRCPT	XT_TCP_INV_SRCPT
-#define IPT_TCP_INV_DSTPT	XT_TCP_INV_DSTPT
-#define IPT_TCP_INV_FLAGS	XT_TCP_INV_FLAGS
-#define IPT_TCP_INV_OPTION	XT_TCP_INV_OPTION
-#define IPT_TCP_INV_MASK	XT_TCP_INV_MASK
-#define IPT_UDP_INV_SRCPT	XT_UDP_INV_SRCPT
-#define IPT_UDP_INV_DSTPT	XT_UDP_INV_DSTPT
-#define IPT_UDP_INV_MASK	XT_UDP_INV_MASK
-
-/* The argument to IPT_SO_ADD_COUNTERS. */
-#define ipt_counters_info xt_counters_info
-/* Standard return verdict, or do jump. */
-#define IPT_STANDARD_TARGET XT_STANDARD_TARGET
-/* Error verdict. */
-#define IPT_ERROR_TARGET XT_ERROR_TARGET
-
-/* fn returns 0 to continue iteration */
-#define IPT_MATCH_ITERATE(e, fn, args...) \
-	XT_MATCH_ITERATE(struct ipt_entry, e, fn, ## args)
-
-/* fn returns 0 to continue iteration */
-#define IPT_ENTRY_ITERATE(entries, size, fn, args...) \
-	XT_ENTRY_ITERATE(struct ipt_entry, entries, size, fn, ## args)
-
-/* Yes, Virginia, you have to zero the padding. */
-struct ipt_ip {
-	/* Source and destination IP addr */
-	struct in_addr src, dst;
-	/* Mask for src and dest IP addr */
-	struct in_addr smsk, dmsk;
-	char iniface[IFNAMSIZ], outiface[IFNAMSIZ];
-	unsigned char iniface_mask[IFNAMSIZ], outiface_mask[IFNAMSIZ];
-
-	/* Protocol, 0 = ANY */
-	__u16 proto;
-
-	/* Flags word */
-	__u8 flags;
-	/* Inverse flags */
-	__u8 invflags;
-};
-
-/* Values for "flag" field in struct ipt_ip (general ip structure). */
-#define IPT_F_FRAG		0x01	/* Set if rule is a fragment rule */
-#define IPT_F_GOTO		0x02	/* Set if jump is a goto */
-#define IPT_F_MASK		0x03	/* All possible flag bits mask. */
-
-/* Values for "inv" field in struct ipt_ip. */
-#define IPT_INV_VIA_IN		0x01	/* Invert the sense of IN IFACE. */
-#define IPT_INV_VIA_OUT		0x02	/* Invert the sense of OUT IFACE */
-#define IPT_INV_TOS		0x04	/* Invert the sense of TOS. */
-#define IPT_INV_SRCIP		0x08	/* Invert the sense of SRC IP. */
-#define IPT_INV_DSTIP		0x10	/* Invert the sense of DST OP. */
-#define IPT_INV_FRAG		0x20	/* Invert the sense of FRAG. */
-#define IPT_INV_PROTO		XT_INV_PROTO
-#define IPT_INV_MASK		0x7F	/* All possible flag bits mask. */
-
-/* This structure defines each of the firewall rules.  Consists of 3
-   parts which are 1) general IP header stuff 2) match specific
-   stuff 3) the target to perform if the rule matches */
-struct ipt_entry {
-	struct ipt_ip ip;
-
-	/* Mark with fields that we care about. */
-	unsigned int nfcache;
-
-	/* Size of ipt_entry + matches */
-	__u16 target_offset;
-	/* Size of ipt_entry + matches + target */
-	__u16 next_offset;
-
-	/* Back pointer */
-	unsigned int comefrom;
-
-	/* Packet and byte counters. */
-	struct xt_counters counters;
-
-	/* The matches (if any), then the target. */
-	unsigned char elems[0];
-};
-
-/*
- * New IP firewall options for [gs]etsockopt at the RAW IP level.
- * Unlike BSD Linux inherits IP options so you don't have to use a raw
- * socket for this. Instead we check rights in the calls.
- *
- * ATTENTION: check linux/in.h before adding new number here.
- */
-#define IPT_BASE_CTL		64
-
-#define IPT_SO_SET_REPLACE	(IPT_BASE_CTL)
-#define IPT_SO_SET_ADD_COUNTERS	(IPT_BASE_CTL + 1)
-#define IPT_SO_SET_MAX		IPT_SO_SET_ADD_COUNTERS
-
-#define IPT_SO_GET_INFO			(IPT_BASE_CTL)
-#define IPT_SO_GET_ENTRIES		(IPT_BASE_CTL + 1)
-#define IPT_SO_GET_REVISION_MATCH	(IPT_BASE_CTL + 2)
-#define IPT_SO_GET_REVISION_TARGET	(IPT_BASE_CTL + 3)
-#define IPT_SO_GET_MAX			IPT_SO_GET_REVISION_TARGET
-
-/* ICMP matching stuff */
-struct ipt_icmp {
-	__u8 type;				/* type to match */
-	__u8 code[2];				/* range of code */
-	__u8 invflags;				/* Inverse flags */
-};
-
-/* Values for "inv" field for struct ipt_icmp. */
-#define IPT_ICMP_INV	0x01	/* Invert the sense of type/code test */
-
-/* The argument to IPT_SO_GET_INFO */
-struct ipt_getinfo {
-	/* Which table: caller fills this in. */
-	char name[XT_TABLE_MAXNAMELEN];
-
-	/* Kernel fills these in. */
-	/* Which hook entry points are valid: bitmask */
-	unsigned int valid_hooks;
-
-	/* Hook entry points: one per netfilter hook. */
-	unsigned int hook_entry[NF_INET_NUMHOOKS];
-
-	/* Underflow points. */
-	unsigned int underflow[NF_INET_NUMHOOKS];
-
-	/* Number of entries */
-	unsigned int num_entries;
-
-	/* Size of entries. */
-	unsigned int size;
-};
-
-/* The argument to IPT_SO_SET_REPLACE. */
-struct ipt_replace {
-	/* Which table. */
-	char name[XT_TABLE_MAXNAMELEN];
-
-	/* Which hook entry points are valid: bitmask.  You can't
-           change this. */
-	unsigned int valid_hooks;
-
-	/* Number of entries */
-	unsigned int num_entries;
-
-	/* Total size of new entries */
-	unsigned int size;
-
-	/* Hook entry points. */
-	unsigned int hook_entry[NF_INET_NUMHOOKS];
-
-	/* Underflow points. */
-	unsigned int underflow[NF_INET_NUMHOOKS];
-
-	/* Information about old entries: */
-	/* Number of counters (must be equal to current number of entries). */
-	unsigned int num_counters;
-	/* The old entries' counters. */
-	struct xt_counters *counters;
-
-	/* The entries (hang off end: not really an array). */
-	struct ipt_entry entries[0];
-};
-
-/* The argument to IPT_SO_GET_ENTRIES. */
-struct ipt_get_entries {
-	/* Which table: user fills this in. */
-	char name[XT_TABLE_MAXNAMELEN];
-
-	/* User fills this in: total entry size. */
-	unsigned int size;
-
-	/* The entries. */
-	struct ipt_entry entrytable[0];
-};
-
-/* Helper functions */
-static __inline__ struct xt_entry_target *
-ipt_get_target(struct ipt_entry *e)
-{
-	return (void *)e + e->target_offset;
-}
-
-/*
- *	Main firewall chains definitions and global var's definitions.
- */
-#endif /* _IPTABLES_H */
diff --git a/include/linux/netfilter_ipv6.h b/include/linux/netfilter_ipv6.h
deleted file mode 100644
index 8483d1d..0000000
--- a/include/linux/netfilter_ipv6.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/* IPv6-specific defines for netfilter. 
- * (C)1998 Rusty Russell -- This code is GPL.
- * (C)1999 David Jeffery
- *   this header was blatantly ripped from netfilter_ipv4.h 
- *   it's amazing what adding a bunch of 6s can do =8^)
- */
-#ifndef __LINUX_IP6_NETFILTER_H
-#define __LINUX_IP6_NETFILTER_H
-
-
-#include <linux/netfilter.h>
-
-/* only for userspace compatibility */
-
-#include <limits.h> /* for INT_MIN, INT_MAX */
-
-/* IP Cache bits. */
-/* Src IP address. */
-#define NFC_IP6_SRC              0x0001
-/* Dest IP address. */
-#define NFC_IP6_DST              0x0002
-/* Input device. */
-#define NFC_IP6_IF_IN            0x0004
-/* Output device. */
-#define NFC_IP6_IF_OUT           0x0008
-/* TOS. */
-#define NFC_IP6_TOS              0x0010
-/* Protocol. */
-#define NFC_IP6_PROTO            0x0020
-/* IP options. */
-#define NFC_IP6_OPTIONS          0x0040
-/* Frag & flags. */
-#define NFC_IP6_FRAG             0x0080
-
-
-/* Per-protocol information: only matters if proto match. */
-/* TCP flags. */
-#define NFC_IP6_TCPFLAGS         0x0100
-/* Source port. */
-#define NFC_IP6_SRC_PT           0x0200
-/* Dest port. */
-#define NFC_IP6_DST_PT           0x0400
-/* Something else about the proto */
-#define NFC_IP6_PROTO_UNKNOWN    0x2000
-
-/* IP6 Hooks */
-/* After promisc drops, checksum checks. */
-#define NF_IP6_PRE_ROUTING	0
-/* If the packet is destined for this box. */
-#define NF_IP6_LOCAL_IN		1
-/* If the packet is destined for another interface. */
-#define NF_IP6_FORWARD		2
-/* Packets coming from a local process. */
-#define NF_IP6_LOCAL_OUT		3
-/* Packets about to hit the wire. */
-#define NF_IP6_POST_ROUTING	4
-#define NF_IP6_NUMHOOKS		5
-
-
-enum nf_ip6_hook_priorities {
-	NF_IP6_PRI_FIRST = INT_MIN,
-	NF_IP6_PRI_CONNTRACK_DEFRAG = -400,
-	NF_IP6_PRI_RAW = -300,
-	NF_IP6_PRI_SELINUX_FIRST = -225,
-	NF_IP6_PRI_CONNTRACK = -200,
-	NF_IP6_PRI_MANGLE = -150,
-	NF_IP6_PRI_NAT_DST = -100,
-	NF_IP6_PRI_FILTER = 0,
-	NF_IP6_PRI_SECURITY = 50,
-	NF_IP6_PRI_NAT_SRC = 100,
-	NF_IP6_PRI_SELINUX_LAST = 225,
-	NF_IP6_PRI_CONNTRACK_HELPER = 300,
-	NF_IP6_PRI_LAST = INT_MAX,
-};
-
-
-#endif /* __LINUX_IP6_NETFILTER_H */
diff --git a/include/linux/netfilter_ipv6/ip6_tables.h b/include/linux/netfilter_ipv6/ip6_tables.h
deleted file mode 100644
index fcc8cca..0000000
--- a/include/linux/netfilter_ipv6/ip6_tables.h
+++ /dev/null
@@ -1,269 +0,0 @@
-/*
- * 25-Jul-1998 Major changes to allow for ip chain table
- *
- * 3-Jan-2000 Named tables to allow packet selection for different uses.
- */
-
-/*
- * 	Format of an IP6 firewall descriptor
- *
- * 	src, dst, src_mask, dst_mask are always stored in network byte order.
- * 	flags are stored in host byte order (of course).
- * 	Port numbers are stored in HOST byte order.
- */
-
-#ifndef _IP6_TABLES_H
-#define _IP6_TABLES_H
-
-#include <linux/types.h>
-
-#include <linux/if.h>
-#include <linux/netfilter_ipv6.h>
-
-#include <linux/netfilter/x_tables.h>
-
-#define IP6T_FUNCTION_MAXNAMELEN XT_FUNCTION_MAXNAMELEN
-#define IP6T_TABLE_MAXNAMELEN XT_TABLE_MAXNAMELEN
-#define ip6t_match xt_match
-#define ip6t_target xt_target
-#define ip6t_table xt_table
-#define ip6t_get_revision xt_get_revision
-#define ip6t_entry_match xt_entry_match
-#define ip6t_entry_target xt_entry_target
-#define ip6t_standard_target xt_standard_target
-#define ip6t_error_target xt_error_target
-#define ip6t_counters xt_counters
-#define IP6T_CONTINUE XT_CONTINUE
-#define IP6T_RETURN XT_RETURN
-
-/* Pre-iptables-1.4.0 */
-#include <linux/netfilter/xt_tcpudp.h>
-#define ip6t_tcp xt_tcp
-#define ip6t_udp xt_udp
-#define IP6T_TCP_INV_SRCPT	XT_TCP_INV_SRCPT
-#define IP6T_TCP_INV_DSTPT	XT_TCP_INV_DSTPT
-#define IP6T_TCP_INV_FLAGS	XT_TCP_INV_FLAGS
-#define IP6T_TCP_INV_OPTION	XT_TCP_INV_OPTION
-#define IP6T_TCP_INV_MASK	XT_TCP_INV_MASK
-#define IP6T_UDP_INV_SRCPT	XT_UDP_INV_SRCPT
-#define IP6T_UDP_INV_DSTPT	XT_UDP_INV_DSTPT
-#define IP6T_UDP_INV_MASK	XT_UDP_INV_MASK
-
-#define ip6t_counters_info xt_counters_info
-#define IP6T_STANDARD_TARGET XT_STANDARD_TARGET
-#define IP6T_ERROR_TARGET XT_ERROR_TARGET
-#define IP6T_MATCH_ITERATE(e, fn, args...) \
-	XT_MATCH_ITERATE(struct ip6t_entry, e, fn, ## args)
-#define IP6T_ENTRY_ITERATE(entries, size, fn, args...) \
-	XT_ENTRY_ITERATE(struct ip6t_entry, entries, size, fn, ## args)
-
-/* Yes, Virginia, you have to zero the padding. */
-struct ip6t_ip6 {
-	/* Source and destination IP6 addr */
-	struct in6_addr src, dst;		
-	/* Mask for src and dest IP6 addr */
-	struct in6_addr smsk, dmsk;
-	char iniface[IFNAMSIZ], outiface[IFNAMSIZ];
-	unsigned char iniface_mask[IFNAMSIZ], outiface_mask[IFNAMSIZ];
-
-	/* Upper protocol number
-	 * - The allowed value is 0 (any) or protocol number of last parsable
-	 *   header, which is 50 (ESP), 59 (No Next Header), 135 (MH), or
-	 *   the non IPv6 extension headers.
-	 * - The protocol numbers of IPv6 extension headers except of ESP and
-	 *   MH do not match any packets.
-	 * - You also need to set IP6T_FLAGS_PROTO to "flags" to check protocol.
-	 */
-	__u16 proto;
-	/* TOS to match iff flags & IP6T_F_TOS */
-	__u8 tos;
-
-	/* Flags word */
-	__u8 flags;
-	/* Inverse flags */
-	__u8 invflags;
-};
-
-/* Values for "flag" field in struct ip6t_ip6 (general ip6 structure). */
-#define IP6T_F_PROTO		0x01	/* Set if rule cares about upper 
-					   protocols */
-#define IP6T_F_TOS		0x02	/* Match the TOS. */
-#define IP6T_F_GOTO		0x04	/* Set if jump is a goto */
-#define IP6T_F_MASK		0x07	/* All possible flag bits mask. */
-
-/* Values for "inv" field in struct ip6t_ip6. */
-#define IP6T_INV_VIA_IN		0x01	/* Invert the sense of IN IFACE. */
-#define IP6T_INV_VIA_OUT		0x02	/* Invert the sense of OUT IFACE */
-#define IP6T_INV_TOS		0x04	/* Invert the sense of TOS. */
-#define IP6T_INV_SRCIP		0x08	/* Invert the sense of SRC IP. */
-#define IP6T_INV_DSTIP		0x10	/* Invert the sense of DST OP. */
-#define IP6T_INV_FRAG		0x20	/* Invert the sense of FRAG. */
-#define IP6T_INV_PROTO		XT_INV_PROTO
-#define IP6T_INV_MASK		0x7F	/* All possible flag bits mask. */
-
-/* This structure defines each of the firewall rules.  Consists of 3
-   parts which are 1) general IP header stuff 2) match specific
-   stuff 3) the target to perform if the rule matches */
-struct ip6t_entry {
-	struct ip6t_ip6 ipv6;
-
-	/* Mark with fields that we care about. */
-	unsigned int nfcache;
-
-	/* Size of ipt_entry + matches */
-	__u16 target_offset;
-	/* Size of ipt_entry + matches + target */
-	__u16 next_offset;
-
-	/* Back pointer */
-	unsigned int comefrom;
-
-	/* Packet and byte counters. */
-	struct xt_counters counters;
-
-	/* The matches (if any), then the target. */
-	unsigned char elems[0];
-};
-
-/* Standard entry */
-struct ip6t_standard {
-	struct ip6t_entry entry;
-	struct xt_standard_target target;
-};
-
-struct ip6t_error {
-	struct ip6t_entry entry;
-	struct xt_error_target target;
-};
-
-#define IP6T_ENTRY_INIT(__size)						       \
-{									       \
-	.target_offset	= sizeof(struct ip6t_entry),			       \
-	.next_offset	= (__size),					       \
-}
-
-#define IP6T_STANDARD_INIT(__verdict)					       \
-{									       \
-	.entry		= IP6T_ENTRY_INIT(sizeof(struct ip6t_standard)),       \
-	.target		= XT_TARGET_INIT(XT_STANDARD_TARGET,		       \
-					 sizeof(struct xt_standard_target)),   \
-	.target.verdict	= -(__verdict) - 1,				       \
-}
-
-#define IP6T_ERROR_INIT							       \
-{									       \
-	.entry		= IP6T_ENTRY_INIT(sizeof(struct ip6t_error)),	       \
-	.target		= XT_TARGET_INIT(XT_ERROR_TARGET,		       \
-					 sizeof(struct xt_error_target)),      \
-	.target.errorname = "ERROR",					       \
-}
-
-/*
- * New IP firewall options for [gs]etsockopt at the RAW IP level.
- * Unlike BSD Linux inherits IP options so you don't have to use
- * a raw socket for this. Instead we check rights in the calls.
- *
- * ATTENTION: check linux/in6.h before adding new number here.
- */
-#define IP6T_BASE_CTL			64
-
-#define IP6T_SO_SET_REPLACE		(IP6T_BASE_CTL)
-#define IP6T_SO_SET_ADD_COUNTERS	(IP6T_BASE_CTL + 1)
-#define IP6T_SO_SET_MAX			IP6T_SO_SET_ADD_COUNTERS
-
-#define IP6T_SO_GET_INFO		(IP6T_BASE_CTL)
-#define IP6T_SO_GET_ENTRIES		(IP6T_BASE_CTL + 1)
-#define IP6T_SO_GET_REVISION_MATCH	(IP6T_BASE_CTL + 4)
-#define IP6T_SO_GET_REVISION_TARGET	(IP6T_BASE_CTL + 5)
-#define IP6T_SO_GET_MAX			IP6T_SO_GET_REVISION_TARGET
-
-/* obtain original address if REDIRECT'd connection */
-#define IP6T_SO_ORIGINAL_DST            80
-
-/* ICMP matching stuff */
-struct ip6t_icmp {
-	__u8 type;				/* type to match */
-	__u8 code[2];				/* range of code */
-	__u8 invflags;				/* Inverse flags */
-};
-
-/* Values for "inv" field for struct ipt_icmp. */
-#define IP6T_ICMP_INV	0x01	/* Invert the sense of type/code test */
-
-/* The argument to IP6T_SO_GET_INFO */
-struct ip6t_getinfo {
-	/* Which table: caller fills this in. */
-	char name[XT_TABLE_MAXNAMELEN];
-
-	/* Kernel fills these in. */
-	/* Which hook entry points are valid: bitmask */
-	unsigned int valid_hooks;
-
-	/* Hook entry points: one per netfilter hook. */
-	unsigned int hook_entry[NF_INET_NUMHOOKS];
-
-	/* Underflow points. */
-	unsigned int underflow[NF_INET_NUMHOOKS];
-
-	/* Number of entries */
-	unsigned int num_entries;
-
-	/* Size of entries. */
-	unsigned int size;
-};
-
-/* The argument to IP6T_SO_SET_REPLACE. */
-struct ip6t_replace {
-	/* Which table. */
-	char name[XT_TABLE_MAXNAMELEN];
-
-	/* Which hook entry points are valid: bitmask.  You can't
-           change this. */
-	unsigned int valid_hooks;
-
-	/* Number of entries */
-	unsigned int num_entries;
-
-	/* Total size of new entries */
-	unsigned int size;
-
-	/* Hook entry points. */
-	unsigned int hook_entry[NF_INET_NUMHOOKS];
-
-	/* Underflow points. */
-	unsigned int underflow[NF_INET_NUMHOOKS];
-
-	/* Information about old entries: */
-	/* Number of counters (must be equal to current number of entries). */
-	unsigned int num_counters;
-	/* The old entries' counters. */
-	struct xt_counters *counters;
-
-	/* The entries (hang off end: not really an array). */
-	struct ip6t_entry entries[0];
-};
-
-/* The argument to IP6T_SO_GET_ENTRIES. */
-struct ip6t_get_entries {
-	/* Which table: user fills this in. */
-	char name[XT_TABLE_MAXNAMELEN];
-
-	/* User fills this in: total entry size. */
-	unsigned int size;
-
-	/* The entries. */
-	struct ip6t_entry entrytable[0];
-};
-
-/* Helper functions */
-static __inline__ struct xt_entry_target *
-ip6t_get_target(struct ip6t_entry *e)
-{
-	return (void *)e + e->target_offset;
-}
-
-/*
- *	Main firewall chains definitions and global var's definitions.
- */
-
-#endif /* _IP6_TABLES_H */
diff --git a/include/linux/netlink.h b/include/linux/netlink.h
deleted file mode 100644
index ec0690b..0000000
--- a/include/linux/netlink.h
+++ /dev/null
@@ -1,246 +0,0 @@
-#ifndef __LINUX_NETLINK_H
-#define __LINUX_NETLINK_H
-
-#include <linux/kernel.h>
-#include <linux/socket.h> /* for __kernel_sa_family_t */
-#include <linux/types.h>
-
-#define NETLINK_ROUTE		0	/* Routing/device hook				*/
-#define NETLINK_UNUSED		1	/* Unused number				*/
-#define NETLINK_USERSOCK	2	/* Reserved for user mode socket protocols 	*/
-#define NETLINK_FIREWALL	3	/* Unused number, formerly ip_queue		*/
-#define NETLINK_SOCK_DIAG	4	/* socket monitoring				*/
-#define NETLINK_NFLOG		5	/* netfilter/iptables ULOG */
-#define NETLINK_XFRM		6	/* ipsec */
-#define NETLINK_SELINUX		7	/* SELinux event notifications */
-#define NETLINK_ISCSI		8	/* Open-iSCSI */
-#define NETLINK_AUDIT		9	/* auditing */
-#define NETLINK_FIB_LOOKUP	10	
-#define NETLINK_CONNECTOR	11
-#define NETLINK_NETFILTER	12	/* netfilter subsystem */
-#define NETLINK_IP6_FW		13
-#define NETLINK_DNRTMSG		14	/* DECnet routing messages */
-#define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
-#define NETLINK_GENERIC		16
-/* leave room for NETLINK_DM (DM Events) */
-#define NETLINK_SCSITRANSPORT	18	/* SCSI Transports */
-#define NETLINK_ECRYPTFS	19
-#define NETLINK_RDMA		20
-#define NETLINK_CRYPTO		21	/* Crypto layer */
-#define NETLINK_SMC		22	/* SMC monitoring */
-
-#define NETLINK_INET_DIAG	NETLINK_SOCK_DIAG
-
-#define MAX_LINKS 32		
-
-struct sockaddr_nl {
-	__kernel_sa_family_t	nl_family;	/* AF_NETLINK	*/
-	unsigned short	nl_pad;		/* zero		*/
-	__u32		nl_pid;		/* port ID	*/
-       	__u32		nl_groups;	/* multicast groups mask */
-};
-
-struct nlmsghdr {
-	__u32		nlmsg_len;	/* Length of message including header */
-	__u16		nlmsg_type;	/* Message content */
-	__u16		nlmsg_flags;	/* Additional flags */
-	__u32		nlmsg_seq;	/* Sequence number */
-	__u32		nlmsg_pid;	/* Sending process port ID */
-};
-
-/* Flags values */
-
-#define NLM_F_REQUEST		0x01	/* It is request message. 	*/
-#define NLM_F_MULTI		0x02	/* Multipart message, terminated by NLMSG_DONE */
-#define NLM_F_ACK		0x04	/* Reply with ack, with zero or error code */
-#define NLM_F_ECHO		0x08	/* Echo this request 		*/
-#define NLM_F_DUMP_INTR		0x10	/* Dump was inconsistent due to sequence change */
-#define NLM_F_DUMP_FILTERED	0x20	/* Dump was filtered as requested */
-
-/* Modifiers to GET request */
-#define NLM_F_ROOT	0x100	/* specify tree	root	*/
-#define NLM_F_MATCH	0x200	/* return all matching	*/
-#define NLM_F_ATOMIC	0x400	/* atomic GET		*/
-#define NLM_F_DUMP	(NLM_F_ROOT|NLM_F_MATCH)
-
-/* Modifiers to NEW request */
-#define NLM_F_REPLACE	0x100	/* Override existing		*/
-#define NLM_F_EXCL	0x200	/* Do not touch, if it exists	*/
-#define NLM_F_CREATE	0x400	/* Create, if it does not exist	*/
-#define NLM_F_APPEND	0x800	/* Add to end of list		*/
-
-/* Modifiers to DELETE request */
-#define NLM_F_NONREC	0x100	/* Do not delete recursively	*/
-
-/* Flags for ACK message */
-#define NLM_F_CAPPED	0x100	/* request was capped */
-#define NLM_F_ACK_TLVS	0x200	/* extended ACK TVLs were included */
-
-/*
-   4.4BSD ADD		NLM_F_CREATE|NLM_F_EXCL
-   4.4BSD CHANGE	NLM_F_REPLACE
-
-   True CHANGE		NLM_F_CREATE|NLM_F_REPLACE
-   Append		NLM_F_CREATE
-   Check		NLM_F_EXCL
- */
-
-#define NLMSG_ALIGNTO	4U
-#define NLMSG_ALIGN(len) ( ((len)+NLMSG_ALIGNTO-1) & ~(NLMSG_ALIGNTO-1) )
-#define NLMSG_HDRLEN	 ((int) NLMSG_ALIGN(sizeof(struct nlmsghdr)))
-#define NLMSG_LENGTH(len) ((len) + NLMSG_HDRLEN)
-#define NLMSG_SPACE(len) NLMSG_ALIGN(NLMSG_LENGTH(len))
-#define NLMSG_DATA(nlh)  ((void*)(((char*)nlh) + NLMSG_LENGTH(0)))
-#define NLMSG_NEXT(nlh,len)	 ((len) -= NLMSG_ALIGN((nlh)->nlmsg_len), \
-				  (struct nlmsghdr*)(((char*)(nlh)) + NLMSG_ALIGN((nlh)->nlmsg_len)))
-#define NLMSG_OK(nlh,len) ((len) >= (int)sizeof(struct nlmsghdr) && \
-			   (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && \
-			   (nlh)->nlmsg_len <= (len))
-#define NLMSG_PAYLOAD(nlh,len) ((nlh)->nlmsg_len - NLMSG_SPACE((len)))
-
-#define NLMSG_NOOP		0x1	/* Nothing.		*/
-#define NLMSG_ERROR		0x2	/* Error		*/
-#define NLMSG_DONE		0x3	/* End of a dump	*/
-#define NLMSG_OVERRUN		0x4	/* Data lost		*/
-
-#define NLMSG_MIN_TYPE		0x10	/* < 0x10: reserved control messages */
-
-struct nlmsgerr {
-	int		error;
-	struct nlmsghdr msg;
-	/*
-	 * followed by the message contents unless NETLINK_CAP_ACK was set
-	 * or the ACK indicates success (error == 0)
-	 * message length is aligned with NLMSG_ALIGN()
-	 */
-	/*
-	 * followed by TLVs defined in enum nlmsgerr_attrs
-	 * if NETLINK_EXT_ACK was set
-	 */
-};
-
-/**
- * enum nlmsgerr_attrs - nlmsgerr attributes
- * @NLMSGERR_ATTR_UNUSED: unused
- * @NLMSGERR_ATTR_MSG: error message string (string)
- * @NLMSGERR_ATTR_OFFS: offset of the invalid attribute in the original
- *	 message, counting from the beginning of the header (u32)
- * @NLMSGERR_ATTR_COOKIE: arbitrary subsystem specific cookie to
- *	be used - in the success case - to identify a created
- *	object or operation or similar (binary)
- * @__NLMSGERR_ATTR_MAX: number of attributes
- * @NLMSGERR_ATTR_MAX: highest attribute number
- */
-enum nlmsgerr_attrs {
-	NLMSGERR_ATTR_UNUSED,
-	NLMSGERR_ATTR_MSG,
-	NLMSGERR_ATTR_OFFS,
-	NLMSGERR_ATTR_COOKIE,
-
-	__NLMSGERR_ATTR_MAX,
-	NLMSGERR_ATTR_MAX = __NLMSGERR_ATTR_MAX - 1
-};
-
-#define NETLINK_ADD_MEMBERSHIP		1
-#define NETLINK_DROP_MEMBERSHIP		2
-#define NETLINK_PKTINFO			3
-#define NETLINK_BROADCAST_ERROR		4
-#define NETLINK_NO_ENOBUFS		5
-#define NETLINK_RX_RING			6
-#define NETLINK_TX_RING			7
-#define NETLINK_LISTEN_ALL_NSID		8
-#define NETLINK_LIST_MEMBERSHIPS	9
-#define NETLINK_CAP_ACK			10
-#define NETLINK_EXT_ACK			11
-
-struct nl_pktinfo {
-	__u32	group;
-};
-
-struct nl_mmap_req {
-	unsigned int	nm_block_size;
-	unsigned int	nm_block_nr;
-	unsigned int	nm_frame_size;
-	unsigned int	nm_frame_nr;
-};
-
-struct nl_mmap_hdr {
-	unsigned int	nm_status;
-	unsigned int	nm_len;
-	__u32		nm_group;
-	/* credentials */
-	__u32		nm_pid;
-	__u32		nm_uid;
-	__u32		nm_gid;
-};
-
-enum nl_mmap_status {
-	NL_MMAP_STATUS_UNUSED,
-	NL_MMAP_STATUS_RESERVED,
-	NL_MMAP_STATUS_VALID,
-	NL_MMAP_STATUS_COPY,
-	NL_MMAP_STATUS_SKIP,
-};
-
-#define NL_MMAP_MSG_ALIGNMENT		NLMSG_ALIGNTO
-#define NL_MMAP_MSG_ALIGN(sz)		__ALIGN_KERNEL(sz, NL_MMAP_MSG_ALIGNMENT)
-#define NL_MMAP_HDRLEN			NL_MMAP_MSG_ALIGN(sizeof(struct nl_mmap_hdr))
-
-#define NET_MAJOR 36		/* Major 36 is reserved for networking 						*/
-
-enum {
-	NETLINK_UNCONNECTED = 0,
-	NETLINK_CONNECTED,
-};
-
-/*
- *  <------- NLA_HDRLEN ------> <-- NLA_ALIGN(payload)-->
- * +---------------------+- - -+- - - - - - - - - -+- - -+
- * |        Header       | Pad |     Payload       | Pad |
- * |   (struct nlattr)   | ing |                   | ing |
- * +---------------------+- - -+- - - - - - - - - -+- - -+
- *  <-------------- nlattr->nla_len -------------->
- */
-
-struct nlattr {
-	__u16           nla_len;
-	__u16           nla_type;
-};
-
-/*
- * nla_type (16 bits)
- * +---+---+-------------------------------+
- * | N | O | Attribute Type                |
- * +---+---+-------------------------------+
- * N := Carries nested attributes
- * O := Payload stored in network byte order
- *
- * Note: The N and O flag are mutually exclusive.
- */
-#define NLA_F_NESTED		(1 << 15)
-#define NLA_F_NET_BYTEORDER	(1 << 14)
-#define NLA_TYPE_MASK		~(NLA_F_NESTED | NLA_F_NET_BYTEORDER)
-
-#define NLA_ALIGNTO		4
-#define NLA_ALIGN(len)		(((len) + NLA_ALIGNTO - 1) & ~(NLA_ALIGNTO - 1))
-#define NLA_HDRLEN		((int) NLA_ALIGN(sizeof(struct nlattr)))
-
-/* Generic 32 bitflags attribute content sent to the kernel.
- *
- * The value is a bitmap that defines the values being set
- * The selector is a bitmask that defines which value is legit
- *
- * Examples:
- *  value = 0x0, and selector = 0x1
- *  implies we are selecting bit 1 and we want to set its value to 0.
- *
- *  value = 0x2, and selector = 0x2
- *  implies we are selecting bit 2 and we want to set its value to 1.
- *
- */
-struct nla_bitfield32 {
-	__u32 value;
-	__u32 selector;
-};
-
-#endif /* __LINUX_NETLINK_H */
diff --git a/include/linux/netlink_diag.h b/include/linux/netlink_diag.h
deleted file mode 100644
index c8c8c7d..0000000
--- a/include/linux/netlink_diag.h
+++ /dev/null
@@ -1,64 +0,0 @@
-#ifndef __NETLINK_DIAG_H__
-#define __NETLINK_DIAG_H__
-
-#include <linux/types.h>
-
-struct netlink_diag_req {
-	__u8	sdiag_family;
-	__u8	sdiag_protocol;
-	__u16	pad;
-	__u32	ndiag_ino;
-	__u32	ndiag_show;
-	__u32	ndiag_cookie[2];
-};
-
-struct netlink_diag_msg {
-	__u8	ndiag_family;
-	__u8	ndiag_type;
-	__u8	ndiag_protocol;
-	__u8	ndiag_state;
-
-	__u32	ndiag_portid;
-	__u32	ndiag_dst_portid;
-	__u32	ndiag_dst_group;
-	__u32	ndiag_ino;
-	__u32	ndiag_cookie[2];
-};
-
-struct netlink_diag_ring {
-	__u32	ndr_block_size;
-	__u32	ndr_block_nr;
-	__u32	ndr_frame_size;
-	__u32	ndr_frame_nr;
-};
-
-enum {
-	/* NETLINK_DIAG_NONE, standard nl API requires this attribute!  */
-	NETLINK_DIAG_MEMINFO,
-	NETLINK_DIAG_GROUPS,
-	NETLINK_DIAG_RX_RING,
-	NETLINK_DIAG_TX_RING,
-	NETLINK_DIAG_FLAGS,
-
-	__NETLINK_DIAG_MAX,
-};
-
-#define NETLINK_DIAG_MAX (__NETLINK_DIAG_MAX - 1)
-
-#define NDIAG_PROTO_ALL		((__u8) ~0)
-
-#define NDIAG_SHOW_MEMINFO	0x00000001 /* show memory info of a socket */
-#define NDIAG_SHOW_GROUPS	0x00000002 /* show groups of a netlink socket */
-/* deprecated since 4.6 */
-#define NDIAG_SHOW_RING_CFG	0x00000004 /* show ring configuration */
-#define NDIAG_SHOW_FLAGS	0x00000008 /* show flags of a netlink socket */
-
-/* flags */
-#define NDIAG_FLAG_CB_RUNNING		0x00000001
-#define NDIAG_FLAG_PKTINFO		0x00000002
-#define NDIAG_FLAG_BROADCAST_ERROR	0x00000004
-#define NDIAG_FLAG_NO_ENOBUFS		0x00000008
-#define NDIAG_FLAG_LISTEN_ALL_NSID	0x00000010
-#define NDIAG_FLAG_CAP_ACK		0x00000020
-
-#endif
diff --git a/include/linux/packet_diag.h b/include/linux/packet_diag.h
deleted file mode 100644
index 0c5d5dd..0000000
--- a/include/linux/packet_diag.h
+++ /dev/null
@@ -1,80 +0,0 @@
-#ifndef __PACKET_DIAG_H__
-#define __PACKET_DIAG_H__
-
-#include <linux/types.h>
-
-struct packet_diag_req {
-	__u8	sdiag_family;
-	__u8	sdiag_protocol;
-	__u16	pad;
-	__u32	pdiag_ino;
-	__u32	pdiag_show;
-	__u32	pdiag_cookie[2];
-};
-
-#define PACKET_SHOW_INFO	0x00000001 /* Basic packet_sk information */
-#define PACKET_SHOW_MCLIST	0x00000002 /* A set of packet_diag_mclist-s */
-#define PACKET_SHOW_RING_CFG	0x00000004 /* Rings configuration parameters */
-#define PACKET_SHOW_FANOUT	0x00000008
-#define PACKET_SHOW_MEMINFO	0x00000010
-#define PACKET_SHOW_FILTER	0x00000020
-
-struct packet_diag_msg {
-	__u8	pdiag_family;
-	__u8	pdiag_type;
-	__u16	pdiag_num;
-
-	__u32	pdiag_ino;
-	__u32	pdiag_cookie[2];
-};
-
-enum {
-	/* PACKET_DIAG_NONE, standard nl API requires this attribute!  */
-	PACKET_DIAG_INFO,
-	PACKET_DIAG_MCLIST,
-	PACKET_DIAG_RX_RING,
-	PACKET_DIAG_TX_RING,
-	PACKET_DIAG_FANOUT,
-	PACKET_DIAG_UID,
-	PACKET_DIAG_MEMINFO,
-	PACKET_DIAG_FILTER,
-
-	__PACKET_DIAG_MAX,
-};
-
-#define PACKET_DIAG_MAX (__PACKET_DIAG_MAX - 1)
-
-struct packet_diag_info {
-	__u32	pdi_index;
-	__u32	pdi_version;
-	__u32	pdi_reserve;
-	__u32	pdi_copy_thresh;
-	__u32	pdi_tstamp;
-	__u32	pdi_flags;
-
-#define PDI_RUNNING	0x1
-#define PDI_AUXDATA	0x2
-#define PDI_ORIGDEV	0x4
-#define PDI_VNETHDR	0x8
-#define PDI_LOSS	0x10
-};
-
-struct packet_diag_mclist {
-	__u32	pdmc_index;
-	__u32	pdmc_count;
-	__u16	pdmc_type;
-	__u16	pdmc_alen;
-	__u8	pdmc_addr[32]; /* MAX_ADDR_LEN */
-};
-
-struct packet_diag_ring {
-	__u32	pdr_block_size;
-	__u32	pdr_block_nr;
-	__u32	pdr_frame_size;
-	__u32	pdr_frame_nr;
-	__u32	pdr_retire_tmo;
-	__u32	pdr_sizeof_priv;
-	__u32	pdr_features;
-};
-
-#endif
diff --git a/include/linux/param.h b/include/linux/param.h
deleted file mode 100644
index 092e92f..0000000
--- a/include/linux/param.h
+++ /dev/null
@@ -1,6 +0,0 @@
-#ifndef _LINUX_PARAM_H
-#define _LINUX_PARAM_H
-
-#include <asm/param.h>
-
-#endif
diff --git a/include/linux/pfkeyv2.h b/include/linux/pfkeyv2.h
deleted file mode 100644
index ada7f01..0000000
--- a/include/linux/pfkeyv2.h
+++ /dev/null
@@ -1,383 +0,0 @@
-/* PF_KEY user interface, this is defined by rfc2367 so
- * do not make arbitrary modifications or else this header
- * file will not be compliant.
- */
-
-#ifndef _LINUX_PFKEY2_H
-#define _LINUX_PFKEY2_H
-
-#include <linux/types.h>
-
-#define PF_KEY_V2		2
-#define PFKEYV2_REVISION	199806L
-
-struct sadb_msg {
-	__u8		sadb_msg_version;
-	__u8		sadb_msg_type;
-	__u8		sadb_msg_errno;
-	__u8		sadb_msg_satype;
-	__u16	sadb_msg_len;
-	__u16	sadb_msg_reserved;
-	__u32	sadb_msg_seq;
-	__u32	sadb_msg_pid;
-} __attribute__((packed));
-/* sizeof(struct sadb_msg) == 16 */
-
-struct sadb_ext {
-	__u16	sadb_ext_len;
-	__u16	sadb_ext_type;
-} __attribute__((packed));
-/* sizeof(struct sadb_ext) == 4 */
-
-struct sadb_sa {
-	__u16	sadb_sa_len;
-	__u16	sadb_sa_exttype;
-	__be32		sadb_sa_spi;
-	__u8		sadb_sa_replay;
-	__u8		sadb_sa_state;
-	__u8		sadb_sa_auth;
-	__u8		sadb_sa_encrypt;
-	__u32	sadb_sa_flags;
-} __attribute__((packed));
-/* sizeof(struct sadb_sa) == 16 */
-
-struct sadb_lifetime {
-	__u16	sadb_lifetime_len;
-	__u16	sadb_lifetime_exttype;
-	__u32	sadb_lifetime_allocations;
-	__u64	sadb_lifetime_bytes;
-	__u64	sadb_lifetime_addtime;
-	__u64	sadb_lifetime_usetime;
-} __attribute__((packed));
-/* sizeof(struct sadb_lifetime) == 32 */
-
-struct sadb_address {
-	__u16	sadb_address_len;
-	__u16	sadb_address_exttype;
-	__u8		sadb_address_proto;
-	__u8		sadb_address_prefixlen;
-	__u16	sadb_address_reserved;
-} __attribute__((packed));
-/* sizeof(struct sadb_address) == 8 */
-
-struct sadb_key {
-	__u16	sadb_key_len;
-	__u16	sadb_key_exttype;
-	__u16	sadb_key_bits;
-	__u16	sadb_key_reserved;
-} __attribute__((packed));
-/* sizeof(struct sadb_key) == 8 */
-
-struct sadb_ident {
-	__u16	sadb_ident_len;
-	__u16	sadb_ident_exttype;
-	__u16	sadb_ident_type;
-	__u16	sadb_ident_reserved;
-	__u64	sadb_ident_id;
-} __attribute__((packed));
-/* sizeof(struct sadb_ident) == 16 */
-
-struct sadb_sens {
-	__u16	sadb_sens_len;
-	__u16	sadb_sens_exttype;
-	__u32	sadb_sens_dpd;
-	__u8		sadb_sens_sens_level;
-	__u8		sadb_sens_sens_len;
-	__u8		sadb_sens_integ_level;
-	__u8		sadb_sens_integ_len;
-	__u32	sadb_sens_reserved;
-} __attribute__((packed));
-/* sizeof(struct sadb_sens) == 16 */
-
-/* followed by:
-	__u64	sadb_sens_bitmap[sens_len];
-	__u64	sadb_integ_bitmap[integ_len];  */
-
-struct sadb_prop {
-	__u16	sadb_prop_len;
-	__u16	sadb_prop_exttype;
-	__u8		sadb_prop_replay;
-	__u8		sadb_prop_reserved[3];
-} __attribute__((packed));
-/* sizeof(struct sadb_prop) == 8 */
-
-/* followed by:
-	struct sadb_comb sadb_combs[(sadb_prop_len +
-		sizeof(__u64) - sizeof(struct sadb_prop)) /
-		sizeof(struct sadb_comb)]; */
-
-struct sadb_comb {
-	__u8		sadb_comb_auth;
-	__u8		sadb_comb_encrypt;
-	__u16	sadb_comb_flags;
-	__u16	sadb_comb_auth_minbits;
-	__u16	sadb_comb_auth_maxbits;
-	__u16	sadb_comb_encrypt_minbits;
-	__u16	sadb_comb_encrypt_maxbits;
-	__u32	sadb_comb_reserved;
-	__u32	sadb_comb_soft_allocations;
-	__u32	sadb_comb_hard_allocations;
-	__u64	sadb_comb_soft_bytes;
-	__u64	sadb_comb_hard_bytes;
-	__u64	sadb_comb_soft_addtime;
-	__u64	sadb_comb_hard_addtime;
-	__u64	sadb_comb_soft_usetime;
-	__u64	sadb_comb_hard_usetime;
-} __attribute__((packed));
-/* sizeof(struct sadb_comb) == 72 */
-
-struct sadb_supported {
-	__u16	sadb_supported_len;
-	__u16	sadb_supported_exttype;
-	__u32	sadb_supported_reserved;
-} __attribute__((packed));
-/* sizeof(struct sadb_supported) == 8 */
-
-/* followed by:
-	struct sadb_alg sadb_algs[(sadb_supported_len +
-		sizeof(__u64) - sizeof(struct sadb_supported)) /
-		sizeof(struct sadb_alg)]; */
-
-struct sadb_alg {
-	__u8		sadb_alg_id;
-	__u8		sadb_alg_ivlen;
-	__u16	sadb_alg_minbits;
-	__u16	sadb_alg_maxbits;
-	__u16	sadb_alg_reserved;
-} __attribute__((packed));
-/* sizeof(struct sadb_alg) == 8 */
-
-struct sadb_spirange {
-	__u16	sadb_spirange_len;
-	__u16	sadb_spirange_exttype;
-	__u32	sadb_spirange_min;
-	__u32	sadb_spirange_max;
-	__u32	sadb_spirange_reserved;
-} __attribute__((packed));
-/* sizeof(struct sadb_spirange) == 16 */
-
-struct sadb_x_kmprivate {
-	__u16	sadb_x_kmprivate_len;
-	__u16	sadb_x_kmprivate_exttype;
-	__u32	sadb_x_kmprivate_reserved;
-} __attribute__((packed));
-/* sizeof(struct sadb_x_kmprivate) == 8 */
-
-struct sadb_x_sa2 {
-	__u16	sadb_x_sa2_len;
-	__u16	sadb_x_sa2_exttype;
-	__u8		sadb_x_sa2_mode;
-	__u8		sadb_x_sa2_reserved1;
-	__u16	sadb_x_sa2_reserved2;
-	__u32	sadb_x_sa2_sequence;
-	__u32	sadb_x_sa2_reqid;
-} __attribute__((packed));
-/* sizeof(struct sadb_x_sa2) == 16 */
-
-struct sadb_x_policy {
-	__u16	sadb_x_policy_len;
-	__u16	sadb_x_policy_exttype;
-	__u16	sadb_x_policy_type;
-	__u8		sadb_x_policy_dir;
-	__u8		sadb_x_policy_reserved;
-	__u32	sadb_x_policy_id;
-	__u32	sadb_x_policy_priority;
-} __attribute__((packed));
-/* sizeof(struct sadb_x_policy) == 16 */
-
-struct sadb_x_ipsecrequest {
-	__u16	sadb_x_ipsecrequest_len;
-	__u16	sadb_x_ipsecrequest_proto;
-	__u8		sadb_x_ipsecrequest_mode;
-	__u8		sadb_x_ipsecrequest_level;
-	__u16	sadb_x_ipsecrequest_reserved1;
-	__u32	sadb_x_ipsecrequest_reqid;
-	__u32	sadb_x_ipsecrequest_reserved2;
-} __attribute__((packed));
-/* sizeof(struct sadb_x_ipsecrequest) == 16 */
-
-/* This defines the TYPE of Nat Traversal in use.  Currently only one
- * type of NAT-T is supported, draft-ietf-ipsec-udp-encaps-06
- */
-struct sadb_x_nat_t_type {
-	__u16	sadb_x_nat_t_type_len;
-	__u16	sadb_x_nat_t_type_exttype;
-	__u8		sadb_x_nat_t_type_type;
-	__u8		sadb_x_nat_t_type_reserved[3];
-} __attribute__((packed));
-/* sizeof(struct sadb_x_nat_t_type) == 8 */
-
-/* Pass a NAT Traversal port (Source or Dest port) */
-struct sadb_x_nat_t_port {
-	__u16	sadb_x_nat_t_port_len;
-	__u16	sadb_x_nat_t_port_exttype;
-	__be16		sadb_x_nat_t_port_port;
-	__u16	sadb_x_nat_t_port_reserved;
-} __attribute__((packed));
-/* sizeof(struct sadb_x_nat_t_port) == 8 */
-
-/* Generic LSM security context */
-struct sadb_x_sec_ctx {
-	__u16	sadb_x_sec_len;
-	__u16	sadb_x_sec_exttype;
-	__u8		sadb_x_ctx_alg;  /* LSMs: e.g., selinux == 1 */
-	__u8		sadb_x_ctx_doi;
-	__u16	sadb_x_ctx_len;
-} __attribute__((packed));
-/* sizeof(struct sadb_sec_ctx) = 8 */
-
-/* Used by MIGRATE to pass addresses IKE will use to perform
- * negotiation with the peer */
-struct sadb_x_kmaddress {
-	__u16	sadb_x_kmaddress_len;
-	__u16	sadb_x_kmaddress_exttype;
-	__u32	sadb_x_kmaddress_reserved;
-} __attribute__((packed));
-/* sizeof(struct sadb_x_kmaddress) == 8 */
-
-/* To specify the SA dump filter */
-struct sadb_x_filter {
-	__u16	sadb_x_filter_len;
-	__u16	sadb_x_filter_exttype;
-	__u32	sadb_x_filter_saddr[4];
-	__u32	sadb_x_filter_daddr[4];
-	__u16	sadb_x_filter_family;
-	__u8	sadb_x_filter_splen;
-	__u8	sadb_x_filter_dplen;
-} __attribute__((packed));
-/* sizeof(struct sadb_x_filter) == 40 */
-
-/* Message types */
-#define SADB_RESERVED		0
-#define SADB_GETSPI		1
-#define SADB_UPDATE		2
-#define SADB_ADD		3
-#define SADB_DELETE		4
-#define SADB_GET		5
-#define SADB_ACQUIRE		6
-#define SADB_REGISTER		7
-#define SADB_EXPIRE		8
-#define SADB_FLUSH		9
-#define SADB_DUMP		10
-#define SADB_X_PROMISC		11
-#define SADB_X_PCHANGE		12
-#define SADB_X_SPDUPDATE	13
-#define SADB_X_SPDADD		14
-#define SADB_X_SPDDELETE	15
-#define SADB_X_SPDGET		16
-#define SADB_X_SPDACQUIRE	17
-#define SADB_X_SPDDUMP		18
-#define SADB_X_SPDFLUSH		19
-#define SADB_X_SPDSETIDX	20
-#define SADB_X_SPDEXPIRE	21
-#define SADB_X_SPDDELETE2	22
-#define SADB_X_NAT_T_NEW_MAPPING	23
-#define SADB_X_MIGRATE		24
-#define SADB_MAX		24
-
-/* Security Association flags */
-#define SADB_SAFLAGS_PFS	1
-#define SADB_SAFLAGS_NOPMTUDISC	0x20000000
-#define SADB_SAFLAGS_DECAP_DSCP	0x40000000
-#define SADB_SAFLAGS_NOECN	0x80000000
-
-/* Security Association states */
-#define SADB_SASTATE_LARVAL	0
-#define SADB_SASTATE_MATURE	1
-#define SADB_SASTATE_DYING	2
-#define SADB_SASTATE_DEAD	3
-#define SADB_SASTATE_MAX	3
-
-/* Security Association types */
-#define SADB_SATYPE_UNSPEC	0
-#define SADB_SATYPE_AH		2
-#define SADB_SATYPE_ESP		3
-#define SADB_SATYPE_RSVP	5
-#define SADB_SATYPE_OSPFV2	6
-#define SADB_SATYPE_RIPV2	7
-#define SADB_SATYPE_MIP		8
-#define SADB_X_SATYPE_IPCOMP	9
-#define SADB_SATYPE_MAX		9
-
-/* Authentication algorithms */
-#define SADB_AALG_NONE			0
-#define SADB_AALG_MD5HMAC		2
-#define SADB_AALG_SHA1HMAC		3
-#define SADB_X_AALG_SHA2_256HMAC	5
-#define SADB_X_AALG_SHA2_384HMAC	6
-#define SADB_X_AALG_SHA2_512HMAC	7
-#define SADB_X_AALG_RIPEMD160HMAC	8
-#define SADB_X_AALG_AES_XCBC_MAC	9
-#define SADB_X_AALG_NULL		251	/* kame */
-#define SADB_AALG_MAX			251
-
-/* Encryption algorithms */
-#define SADB_EALG_NONE			0
-#define SADB_EALG_DESCBC		2
-#define SADB_EALG_3DESCBC		3
-#define SADB_X_EALG_CASTCBC		6
-#define SADB_X_EALG_BLOWFISHCBC		7
-#define SADB_EALG_NULL			11
-#define SADB_X_EALG_AESCBC		12
-#define SADB_X_EALG_AESCTR		13
-#define SADB_X_EALG_AES_CCM_ICV8	14
-#define SADB_X_EALG_AES_CCM_ICV12	15
-#define SADB_X_EALG_AES_CCM_ICV16	16
-#define SADB_X_EALG_AES_GCM_ICV8	18
-#define SADB_X_EALG_AES_GCM_ICV12	19
-#define SADB_X_EALG_AES_GCM_ICV16	20
-#define SADB_X_EALG_CAMELLIACBC		22
-#define SADB_X_EALG_NULL_AES_GMAC	23
-#define SADB_EALG_MAX                   253 /* last EALG */
-/* private allocations should use 249-255 (RFC2407) */
-#define SADB_X_EALG_SERPENTCBC  252     /* draft-ietf-ipsec-ciph-aes-cbc-00 */
-#define SADB_X_EALG_TWOFISHCBC  253     /* draft-ietf-ipsec-ciph-aes-cbc-00 */
-
-/* Compression algorithms */
-#define SADB_X_CALG_NONE		0
-#define SADB_X_CALG_OUI			1
-#define SADB_X_CALG_DEFLATE		2
-#define SADB_X_CALG_LZS			3
-#define SADB_X_CALG_LZJH		4
-#define SADB_X_CALG_MAX			4
-
-/* Extension Header values */
-#define SADB_EXT_RESERVED		0
-#define SADB_EXT_SA			1
-#define SADB_EXT_LIFETIME_CURRENT	2
-#define SADB_EXT_LIFETIME_HARD		3
-#define SADB_EXT_LIFETIME_SOFT		4
-#define SADB_EXT_ADDRESS_SRC		5
-#define SADB_EXT_ADDRESS_DST		6
-#define SADB_EXT_ADDRESS_PROXY		7
-#define SADB_EXT_KEY_AUTH		8
-#define SADB_EXT_KEY_ENCRYPT		9
-#define SADB_EXT_IDENTITY_SRC		10
-#define SADB_EXT_IDENTITY_DST		11
-#define SADB_EXT_SENSITIVITY		12
-#define SADB_EXT_PROPOSAL		13
-#define SADB_EXT_SUPPORTED_AUTH		14
-#define SADB_EXT_SUPPORTED_ENCRYPT	15
-#define SADB_EXT_SPIRANGE		16
-#define SADB_X_EXT_KMPRIVATE		17
-#define SADB_X_EXT_POLICY		18
-#define SADB_X_EXT_SA2			19
-/* The next four entries are for setting up NAT Traversal */
-#define SADB_X_EXT_NAT_T_TYPE		20
-#define SADB_X_EXT_NAT_T_SPORT		21
-#define SADB_X_EXT_NAT_T_DPORT		22
-#define SADB_X_EXT_NAT_T_OA		23
-#define SADB_X_EXT_SEC_CTX		24
-/* Used with MIGRATE to pass @ to IKE for negotiation */
-#define SADB_X_EXT_KMADDRESS		25
-#define SADB_X_EXT_FILTER		26
-#define SADB_EXT_MAX			26
-
-/* Identity Extension values */
-#define SADB_IDENTTYPE_RESERVED	0
-#define SADB_IDENTTYPE_PREFIX	1
-#define SADB_IDENTTYPE_FQDN	2
-#define SADB_IDENTTYPE_USERFQDN	3
-#define SADB_IDENTTYPE_MAX	3
-
-#endif /* !(_LINUX_PFKEY2_H) */
diff --git a/include/linux/pkt_cls.h b/include/linux/pkt_cls.h
deleted file mode 100644
index d5e2bf6..0000000
--- a/include/linux/pkt_cls.h
+++ /dev/null
@@ -1,569 +0,0 @@
-#ifndef __LINUX_PKT_CLS_H
-#define __LINUX_PKT_CLS_H
-
-#include <linux/types.h>
-#include <linux/pkt_sched.h>
-
-#define TC_COOKIE_MAX_SIZE 16
-
-/* Action attributes */
-enum {
-	TCA_ACT_UNSPEC,
-	TCA_ACT_KIND,
-	TCA_ACT_OPTIONS,
-	TCA_ACT_INDEX,
-	TCA_ACT_STATS,
-	TCA_ACT_PAD,
-	TCA_ACT_COOKIE,
-	__TCA_ACT_MAX
-};
-
-#define TCA_ACT_MAX __TCA_ACT_MAX
-#define TCA_OLD_COMPAT (TCA_ACT_MAX+1)
-#define TCA_ACT_MAX_PRIO 32
-#define TCA_ACT_BIND	1
-#define TCA_ACT_NOBIND	0
-#define TCA_ACT_UNBIND	1
-#define TCA_ACT_NOUNBIND	0
-#define TCA_ACT_REPLACE		1
-#define TCA_ACT_NOREPLACE	0
-
-#define TC_ACT_UNSPEC	(-1)
-#define TC_ACT_OK		0
-#define TC_ACT_RECLASSIFY	1
-#define TC_ACT_SHOT		2
-#define TC_ACT_PIPE		3
-#define TC_ACT_STOLEN		4
-#define TC_ACT_QUEUED		5
-#define TC_ACT_REPEAT		6
-#define TC_ACT_REDIRECT		7
-#define TC_ACT_TRAP		8 /* For hw path, this means "trap to cpu"
-				   * and don't further process the frame
-				   * in hardware. For sw path, this is
-				   * equivalent of TC_ACT_STOLEN - drop
-				   * the skb and act like everything
-				   * is alright.
-				   */
-
-/* There is a special kind of actions called "extended actions",
- * which need a value parameter. These have a local opcode located in
- * the highest nibble, starting from 1. The rest of the bits
- * are used to carry the value. These two parts together make
- * a combined opcode.
- */
-#define __TC_ACT_EXT_SHIFT 28
-#define __TC_ACT_EXT(local) ((local) << __TC_ACT_EXT_SHIFT)
-#define TC_ACT_EXT_VAL_MASK ((1 << __TC_ACT_EXT_SHIFT) - 1)
-#define TC_ACT_EXT_CMP(combined, opcode) \
-	(((combined) & (~TC_ACT_EXT_VAL_MASK)) == opcode)
-
-#define TC_ACT_JUMP __TC_ACT_EXT(1)
-#define TC_ACT_GOTO_CHAIN __TC_ACT_EXT(2)
-
-/* Action type identifiers*/
-enum {
-	TCA_ID_UNSPEC=0,
-	TCA_ID_POLICE=1,
-	/* other actions go here */
-	__TCA_ID_MAX=255
-};
-
-#define TCA_ID_MAX __TCA_ID_MAX
-
-struct tc_police {
-	__u32			index;
-	int			action;
-#define TC_POLICE_UNSPEC	TC_ACT_UNSPEC
-#define TC_POLICE_OK		TC_ACT_OK
-#define TC_POLICE_RECLASSIFY	TC_ACT_RECLASSIFY
-#define TC_POLICE_SHOT		TC_ACT_SHOT
-#define TC_POLICE_PIPE		TC_ACT_PIPE
-
-	__u32			limit;
-	__u32			burst;
-	__u32			mtu;
-	struct tc_ratespec	rate;
-	struct tc_ratespec	peakrate;
-	int			refcnt;
-	int			bindcnt;
-	__u32			capab;
-};
-
-struct tcf_t {
-	__u64   install;
-	__u64   lastuse;
-	__u64   expires;
-	__u64   firstuse;
-};
-
-struct tc_cnt {
-	int                   refcnt;
-	int                   bindcnt;
-};
-
-#define tc_gen \
-	__u32                 index; \
-	__u32                 capab; \
-	int                   action; \
-	int                   refcnt; \
-	int                   bindcnt
-
-enum {
-	TCA_POLICE_UNSPEC,
-	TCA_POLICE_TBF,
-	TCA_POLICE_RATE,
-	TCA_POLICE_PEAKRATE,
-	TCA_POLICE_AVRATE,
-	TCA_POLICE_RESULT,
-	TCA_POLICE_TM,
-	TCA_POLICE_PAD,
-	__TCA_POLICE_MAX
-#define TCA_POLICE_RESULT TCA_POLICE_RESULT
-};
-
-#define TCA_POLICE_MAX (__TCA_POLICE_MAX - 1)
-
-/* tca flags definitions */
-#define TCA_CLS_FLAGS_SKIP_HW	(1 << 0) /* don't offload filter to HW */
-#define TCA_CLS_FLAGS_SKIP_SW	(1 << 1) /* don't use filter in SW */
-#define TCA_CLS_FLAGS_IN_HW	(1 << 2) /* filter is offloaded to HW */
-#define TCA_CLS_FLAGS_NOT_IN_HW (1 << 3) /* filter isn't offloaded to HW */
-
-/* U32 filters */
-
-#define TC_U32_HTID(h) ((h)&0xFFF00000)
-#define TC_U32_USERHTID(h) (TC_U32_HTID(h)>>20)
-#define TC_U32_HASH(h) (((h)>>12)&0xFF)
-#define TC_U32_NODE(h) ((h)&0xFFF)
-#define TC_U32_KEY(h) ((h)&0xFFFFF)
-#define TC_U32_UNSPEC	0
-#define TC_U32_ROOT	(0xFFF00000)
-
-enum {
-	TCA_U32_UNSPEC,
-	TCA_U32_CLASSID,
-	TCA_U32_HASH,
-	TCA_U32_LINK,
-	TCA_U32_DIVISOR,
-	TCA_U32_SEL,
-	TCA_U32_POLICE,
-	TCA_U32_ACT,
-	TCA_U32_INDEV,
-	TCA_U32_PCNT,
-	TCA_U32_MARK,
-	TCA_U32_FLAGS,
-	TCA_U32_PAD,
-	__TCA_U32_MAX
-};
-
-#define TCA_U32_MAX (__TCA_U32_MAX - 1)
-
-struct tc_u32_key {
-	__be32		mask;
-	__be32		val;
-	int		off;
-	int		offmask;
-};
-
-struct tc_u32_sel {
-	unsigned char		flags;
-	unsigned char		offshift;
-	unsigned char		nkeys;
-
-	__be16			offmask;
-	__u16			off;
-	short			offoff;
-
-	short			hoff;
-	__be32			hmask;
-	struct tc_u32_key	keys[0];
-};
-
-struct tc_u32_mark {
-	__u32		val;
-	__u32		mask;
-	__u32		success;
-};
-
-struct tc_u32_pcnt {
-	__u64 rcnt;
-	__u64 rhit;
-	__u64 kcnts[0];
-};
-
-/* Flags */
-
-#define TC_U32_TERMINAL		1
-#define TC_U32_OFFSET		2
-#define TC_U32_VAROFFSET	4
-#define TC_U32_EAT		8
-
-#define TC_U32_MAXDEPTH 8
-
-
-/* RSVP filter */
-
-enum {
-	TCA_RSVP_UNSPEC,
-	TCA_RSVP_CLASSID,
-	TCA_RSVP_DST,
-	TCA_RSVP_SRC,
-	TCA_RSVP_PINFO,
-	TCA_RSVP_POLICE,
-	TCA_RSVP_ACT,
-	__TCA_RSVP_MAX
-};
-
-#define TCA_RSVP_MAX (__TCA_RSVP_MAX - 1 )
-
-struct tc_rsvp_gpi {
-	__u32	key;
-	__u32	mask;
-	int	offset;
-};
-
-struct tc_rsvp_pinfo {
-	struct tc_rsvp_gpi dpi;
-	struct tc_rsvp_gpi spi;
-	__u8	protocol;
-	__u8	tunnelid;
-	__u8	tunnelhdr;
-	__u8	pad;
-};
-
-/* ROUTE filter */
-
-enum {
-	TCA_ROUTE4_UNSPEC,
-	TCA_ROUTE4_CLASSID,
-	TCA_ROUTE4_TO,
-	TCA_ROUTE4_FROM,
-	TCA_ROUTE4_IIF,
-	TCA_ROUTE4_POLICE,
-	TCA_ROUTE4_ACT,
-	__TCA_ROUTE4_MAX
-};
-
-#define TCA_ROUTE4_MAX (__TCA_ROUTE4_MAX - 1)
-
-
-/* FW filter */
-
-enum {
-	TCA_FW_UNSPEC,
-	TCA_FW_CLASSID,
-	TCA_FW_POLICE,
-	TCA_FW_INDEV, /*  used by CONFIG_NET_CLS_IND */
-	TCA_FW_ACT, /* used by CONFIG_NET_CLS_ACT */
-	TCA_FW_MASK,
-	__TCA_FW_MAX
-};
-
-#define TCA_FW_MAX (__TCA_FW_MAX - 1)
-
-/* TC index filter */
-
-enum {
-	TCA_TCINDEX_UNSPEC,
-	TCA_TCINDEX_HASH,
-	TCA_TCINDEX_MASK,
-	TCA_TCINDEX_SHIFT,
-	TCA_TCINDEX_FALL_THROUGH,
-	TCA_TCINDEX_CLASSID,
-	TCA_TCINDEX_POLICE,
-	TCA_TCINDEX_ACT,
-	__TCA_TCINDEX_MAX
-};
-
-#define TCA_TCINDEX_MAX     (__TCA_TCINDEX_MAX - 1)
-
-/* Flow filter */
-
-enum {
-	FLOW_KEY_SRC,
-	FLOW_KEY_DST,
-	FLOW_KEY_PROTO,
-	FLOW_KEY_PROTO_SRC,
-	FLOW_KEY_PROTO_DST,
-	FLOW_KEY_IIF,
-	FLOW_KEY_PRIORITY,
-	FLOW_KEY_MARK,
-	FLOW_KEY_NFCT,
-	FLOW_KEY_NFCT_SRC,
-	FLOW_KEY_NFCT_DST,
-	FLOW_KEY_NFCT_PROTO_SRC,
-	FLOW_KEY_NFCT_PROTO_DST,
-	FLOW_KEY_RTCLASSID,
-	FLOW_KEY_SKUID,
-	FLOW_KEY_SKGID,
-	FLOW_KEY_VLAN_TAG,
-	FLOW_KEY_RXHASH,
-	__FLOW_KEY_MAX,
-};
-
-#define FLOW_KEY_MAX	(__FLOW_KEY_MAX - 1)
-
-enum {
-	FLOW_MODE_MAP,
-	FLOW_MODE_HASH,
-};
-
-enum {
-	TCA_FLOW_UNSPEC,
-	TCA_FLOW_KEYS,
-	TCA_FLOW_MODE,
-	TCA_FLOW_BASECLASS,
-	TCA_FLOW_RSHIFT,
-	TCA_FLOW_ADDEND,
-	TCA_FLOW_MASK,
-	TCA_FLOW_XOR,
-	TCA_FLOW_DIVISOR,
-	TCA_FLOW_ACT,
-	TCA_FLOW_POLICE,
-	TCA_FLOW_EMATCHES,
-	TCA_FLOW_PERTURB,
-	__TCA_FLOW_MAX
-};
-
-#define TCA_FLOW_MAX	(__TCA_FLOW_MAX - 1)
-
-/* Basic filter */
-
-enum {
-	TCA_BASIC_UNSPEC,
-	TCA_BASIC_CLASSID,
-	TCA_BASIC_EMATCHES,
-	TCA_BASIC_ACT,
-	TCA_BASIC_POLICE,
-	__TCA_BASIC_MAX
-};
-
-#define TCA_BASIC_MAX (__TCA_BASIC_MAX - 1)
-
-
-/* Cgroup classifier */
-
-enum {
-	TCA_CGROUP_UNSPEC,
-	TCA_CGROUP_ACT,
-	TCA_CGROUP_POLICE,
-	TCA_CGROUP_EMATCHES,
-	__TCA_CGROUP_MAX,
-};
-
-#define TCA_CGROUP_MAX (__TCA_CGROUP_MAX - 1)
-
-/* BPF classifier */
-
-#define TCA_BPF_FLAG_ACT_DIRECT		(1 << 0)
-
-enum {
-	TCA_BPF_UNSPEC,
-	TCA_BPF_ACT,
-	TCA_BPF_POLICE,
-	TCA_BPF_CLASSID,
-	TCA_BPF_OPS_LEN,
-	TCA_BPF_OPS,
-	TCA_BPF_FD,
-	TCA_BPF_NAME,
-	TCA_BPF_FLAGS,
-	TCA_BPF_FLAGS_GEN,
-	TCA_BPF_TAG,
-	TCA_BPF_ID,
-	__TCA_BPF_MAX,
-};
-
-#define TCA_BPF_MAX (__TCA_BPF_MAX - 1)
-
-/* Flower classifier */
-
-enum {
-	TCA_FLOWER_UNSPEC,
-	TCA_FLOWER_CLASSID,
-	TCA_FLOWER_INDEV,
-	TCA_FLOWER_ACT,
-	TCA_FLOWER_KEY_ETH_DST,		/* ETH_ALEN */
-	TCA_FLOWER_KEY_ETH_DST_MASK,	/* ETH_ALEN */
-	TCA_FLOWER_KEY_ETH_SRC,		/* ETH_ALEN */
-	TCA_FLOWER_KEY_ETH_SRC_MASK,	/* ETH_ALEN */
-	TCA_FLOWER_KEY_ETH_TYPE,	/* be16 */
-	TCA_FLOWER_KEY_IP_PROTO,	/* u8 */
-	TCA_FLOWER_KEY_IPV4_SRC,	/* be32 */
-	TCA_FLOWER_KEY_IPV4_SRC_MASK,	/* be32 */
-	TCA_FLOWER_KEY_IPV4_DST,	/* be32 */
-	TCA_FLOWER_KEY_IPV4_DST_MASK,	/* be32 */
-	TCA_FLOWER_KEY_IPV6_SRC,	/* struct in6_addr */
-	TCA_FLOWER_KEY_IPV6_SRC_MASK,	/* struct in6_addr */
-	TCA_FLOWER_KEY_IPV6_DST,	/* struct in6_addr */
-	TCA_FLOWER_KEY_IPV6_DST_MASK,	/* struct in6_addr */
-	TCA_FLOWER_KEY_TCP_SRC,		/* be16 */
-	TCA_FLOWER_KEY_TCP_DST,		/* be16 */
-	TCA_FLOWER_KEY_UDP_SRC,		/* be16 */
-	TCA_FLOWER_KEY_UDP_DST,		/* be16 */
-
-	TCA_FLOWER_FLAGS,
-	TCA_FLOWER_KEY_VLAN_ID,		/* be16 */
-	TCA_FLOWER_KEY_VLAN_PRIO,	/* u8   */
-	TCA_FLOWER_KEY_VLAN_ETH_TYPE,	/* be16 */
-
-	TCA_FLOWER_KEY_ENC_KEY_ID,	/* be32 */
-	TCA_FLOWER_KEY_ENC_IPV4_SRC,	/* be32 */
-	TCA_FLOWER_KEY_ENC_IPV4_SRC_MASK,/* be32 */
-	TCA_FLOWER_KEY_ENC_IPV4_DST,	/* be32 */
-	TCA_FLOWER_KEY_ENC_IPV4_DST_MASK,/* be32 */
-	TCA_FLOWER_KEY_ENC_IPV6_SRC,	/* struct in6_addr */
-	TCA_FLOWER_KEY_ENC_IPV6_SRC_MASK,/* struct in6_addr */
-	TCA_FLOWER_KEY_ENC_IPV6_DST,	/* struct in6_addr */
-	TCA_FLOWER_KEY_ENC_IPV6_DST_MASK,/* struct in6_addr */
-
-	TCA_FLOWER_KEY_TCP_SRC_MASK,	/* be16 */
-	TCA_FLOWER_KEY_TCP_DST_MASK,	/* be16 */
-	TCA_FLOWER_KEY_UDP_SRC_MASK,	/* be16 */
-	TCA_FLOWER_KEY_UDP_DST_MASK,	/* be16 */
-	TCA_FLOWER_KEY_SCTP_SRC_MASK,	/* be16 */
-	TCA_FLOWER_KEY_SCTP_DST_MASK,	/* be16 */
-
-	TCA_FLOWER_KEY_SCTP_SRC,	/* be16 */
-	TCA_FLOWER_KEY_SCTP_DST,	/* be16 */
-
-	TCA_FLOWER_KEY_ENC_UDP_SRC_PORT,	/* be16 */
-	TCA_FLOWER_KEY_ENC_UDP_SRC_PORT_MASK,	/* be16 */
-	TCA_FLOWER_KEY_ENC_UDP_DST_PORT,	/* be16 */
-	TCA_FLOWER_KEY_ENC_UDP_DST_PORT_MASK,	/* be16 */
-
-	TCA_FLOWER_KEY_FLAGS,		/* be32 */
-	TCA_FLOWER_KEY_FLAGS_MASK,	/* be32 */
-
-	TCA_FLOWER_KEY_ICMPV4_CODE,	/* u8 */
-	TCA_FLOWER_KEY_ICMPV4_CODE_MASK,/* u8 */
-	TCA_FLOWER_KEY_ICMPV4_TYPE,	/* u8 */
-	TCA_FLOWER_KEY_ICMPV4_TYPE_MASK,/* u8 */
-	TCA_FLOWER_KEY_ICMPV6_CODE,	/* u8 */
-	TCA_FLOWER_KEY_ICMPV6_CODE_MASK,/* u8 */
-	TCA_FLOWER_KEY_ICMPV6_TYPE,	/* u8 */
-	TCA_FLOWER_KEY_ICMPV6_TYPE_MASK,/* u8 */
-
-	TCA_FLOWER_KEY_ARP_SIP,		/* be32 */
-	TCA_FLOWER_KEY_ARP_SIP_MASK,	/* be32 */
-	TCA_FLOWER_KEY_ARP_TIP,		/* be32 */
-	TCA_FLOWER_KEY_ARP_TIP_MASK,	/* be32 */
-	TCA_FLOWER_KEY_ARP_OP,		/* u8 */
-	TCA_FLOWER_KEY_ARP_OP_MASK,	/* u8 */
-	TCA_FLOWER_KEY_ARP_SHA,		/* ETH_ALEN */
-	TCA_FLOWER_KEY_ARP_SHA_MASK,	/* ETH_ALEN */
-	TCA_FLOWER_KEY_ARP_THA,		/* ETH_ALEN */
-	TCA_FLOWER_KEY_ARP_THA_MASK,	/* ETH_ALEN */
-
-	TCA_FLOWER_KEY_MPLS_TTL,	/* u8 - 8 bits */
-	TCA_FLOWER_KEY_MPLS_BOS,	/* u8 - 1 bit */
-	TCA_FLOWER_KEY_MPLS_TC,		/* u8 - 3 bits */
-	TCA_FLOWER_KEY_MPLS_LABEL,	/* be32 - 20 bits */
-
-	TCA_FLOWER_KEY_TCP_FLAGS,	/* be16 */
-	TCA_FLOWER_KEY_TCP_FLAGS_MASK,	/* be16 */
-
-	TCA_FLOWER_KEY_IP_TOS,		/* u8 */
-	TCA_FLOWER_KEY_IP_TOS_MASK,	/* u8 */
-	TCA_FLOWER_KEY_IP_TTL,		/* u8 */
-	TCA_FLOWER_KEY_IP_TTL_MASK,	/* u8 */
-
-	__TCA_FLOWER_MAX,
-};
-
-#define TCA_FLOWER_MAX (__TCA_FLOWER_MAX - 1)
-
-enum {
-	TCA_FLOWER_KEY_FLAGS_IS_FRAGMENT = (1 << 0),
-};
-
-/* Match-all classifier */
-
-enum {
-	TCA_MATCHALL_UNSPEC,
-	TCA_MATCHALL_CLASSID,
-	TCA_MATCHALL_ACT,
-	TCA_MATCHALL_FLAGS,
-	__TCA_MATCHALL_MAX,
-};
-
-#define TCA_MATCHALL_MAX (__TCA_MATCHALL_MAX - 1)
-
-/* Extended Matches */
-
-struct tcf_ematch_tree_hdr {
-	__u16		nmatches;
-	__u16		progid;
-};
-
-enum {
-	TCA_EMATCH_TREE_UNSPEC,
-	TCA_EMATCH_TREE_HDR,
-	TCA_EMATCH_TREE_LIST,
-	__TCA_EMATCH_TREE_MAX
-};
-#define TCA_EMATCH_TREE_MAX (__TCA_EMATCH_TREE_MAX - 1)
-
-struct tcf_ematch_hdr {
-	__u16		matchid;
-	__u16		kind;
-	__u16		flags;
-	__u16		pad; /* currently unused */
-};
-
-/*  0                   1
- *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 
- * +-----------------------+-+-+---+
- * |         Unused        |S|I| R |
- * +-----------------------+-+-+---+
- *
- * R(2) ::= relation to next ematch
- *          where: 0 0 END (last ematch)
- *                 0 1 AND
- *                 1 0 OR
- *                 1 1 Unused (invalid)
- * I(1) ::= invert result
- * S(1) ::= simple payload
- */
-#define TCF_EM_REL_END	0
-#define TCF_EM_REL_AND	(1<<0)
-#define TCF_EM_REL_OR	(1<<1)
-#define TCF_EM_INVERT	(1<<2)
-#define TCF_EM_SIMPLE	(1<<3)
-
-#define TCF_EM_REL_MASK	3
-#define TCF_EM_REL_VALID(v) (((v) & TCF_EM_REL_MASK) != TCF_EM_REL_MASK)
-
-enum {
-	TCF_LAYER_LINK,
-	TCF_LAYER_NETWORK,
-	TCF_LAYER_TRANSPORT,
-	__TCF_LAYER_MAX
-};
-#define TCF_LAYER_MAX (__TCF_LAYER_MAX - 1)
-
-/* Ematch type assignments
- *   1..32767		Reserved for ematches inside kernel tree
- *   32768..65535	Free to use, not reliable
- */
-#define	TCF_EM_CONTAINER	0
-#define	TCF_EM_CMP		1
-#define	TCF_EM_NBYTE		2
-#define	TCF_EM_U32		3
-#define	TCF_EM_META		4
-#define	TCF_EM_TEXT		5
-#define	TCF_EM_VLAN		6
-#define	TCF_EM_CANID		7
-#define	TCF_EM_IPSET		8
-#define	TCF_EM_MAX		8
-
-enum {
-	TCF_EM_PROG_TC
-};
-
-enum {
-	TCF_EM_OPND_EQ,
-	TCF_EM_OPND_GT,
-	TCF_EM_OPND_LT
-};
-
-#endif
diff --git a/include/linux/pkt_sched.h b/include/linux/pkt_sched.h
deleted file mode 100644
index 099bf55..0000000
--- a/include/linux/pkt_sched.h
+++ /dev/null
@@ -1,874 +0,0 @@
-#ifndef __LINUX_PKT_SCHED_H
-#define __LINUX_PKT_SCHED_H
-
-#include <linux/types.h>
-
-/* Logical priority bands not depending on specific packet scheduler.
-   Every scheduler will map them to real traffic classes, if it has
-   no more precise mechanism to classify packets.
-
-   These numbers have no special meaning, though their coincidence
-   with obsolete IPv6 values is not occasional :-). New IPv6 drafts
-   preferred full anarchy inspired by diffserv group.
-
-   Note: TC_PRIO_BESTEFFORT does not mean that it is the most unhappy
-   class, actually, as rule it will be handled with more care than
-   filler or even bulk.
- */
-
-#define TC_PRIO_BESTEFFORT		0
-#define TC_PRIO_FILLER			1
-#define TC_PRIO_BULK			2
-#define TC_PRIO_INTERACTIVE_BULK	4
-#define TC_PRIO_INTERACTIVE		6
-#define TC_PRIO_CONTROL			7
-
-#define TC_PRIO_MAX			15
-
-/* Generic queue statistics, available for all the elements.
-   Particular schedulers may have also their private records.
- */
-
-struct tc_stats {
-	__u64	bytes;			/* Number of enqueued bytes */
-	__u32	packets;		/* Number of enqueued packets	*/
-	__u32	drops;			/* Packets dropped because of lack of resources */
-	__u32	overlimits;		/* Number of throttle events when this
-					 * flow goes out of allocated bandwidth */
-	__u32	bps;			/* Current flow byte rate */
-	__u32	pps;			/* Current flow packet rate */
-	__u32	qlen;
-	__u32	backlog;
-};
-
-struct tc_estimator {
-	signed char	interval;
-	unsigned char	ewma_log;
-};
-
-/* "Handles"
-   ---------
-
-    All the traffic control objects have 32bit identifiers, or "handles".
-
-    They can be considered as opaque numbers from user API viewpoint,
-    but actually they always consist of two fields: major and
-    minor numbers, which are interpreted by kernel specially,
-    that may be used by applications, though not recommended.
-
-    F.e. qdisc handles always have minor number equal to zero,
-    classes (or flows) have major equal to parent qdisc major, and
-    minor uniquely identifying class inside qdisc.
-
-    Macros to manipulate handles:
- */
-
-#define TC_H_MAJ_MASK (0xFFFF0000U)
-#define TC_H_MIN_MASK (0x0000FFFFU)
-#define TC_H_MAJ(h) ((h)&TC_H_MAJ_MASK)
-#define TC_H_MIN(h) ((h)&TC_H_MIN_MASK)
-#define TC_H_MAKE(maj,min) (((maj)&TC_H_MAJ_MASK)|((min)&TC_H_MIN_MASK))
-
-#define TC_H_UNSPEC	(0U)
-#define TC_H_ROOT	(0xFFFFFFFFU)
-#define TC_H_INGRESS    (0xFFFFFFF1U)
-#define TC_H_CLSACT	TC_H_INGRESS
-
-#define TC_H_MIN_INGRESS	0xFFF2U
-#define TC_H_MIN_EGRESS		0xFFF3U
-
-/* Need to corrospond to iproute2 tc/tc_core.h "enum link_layer" */
-enum tc_link_layer {
-	TC_LINKLAYER_UNAWARE, /* Indicate unaware old iproute2 util */
-	TC_LINKLAYER_ETHERNET,
-	TC_LINKLAYER_ATM,
-};
-#define TC_LINKLAYER_MASK 0x0F /* limit use to lower 4 bits */
-
-struct tc_ratespec {
-	unsigned char	cell_log;
-	__u8		linklayer; /* lower 4 bits */
-	unsigned short	overhead;
-	short		cell_align;
-	unsigned short	mpu;
-	__u32		rate;
-};
-
-#define TC_RTAB_SIZE	1024
-
-struct tc_sizespec {
-	unsigned char	cell_log;
-	unsigned char	size_log;
-	short		cell_align;
-	int		overhead;
-	unsigned int	linklayer;
-	unsigned int	mpu;
-	unsigned int	mtu;
-	unsigned int	tsize;
-};
-
-enum {
-	TCA_STAB_UNSPEC,
-	TCA_STAB_BASE,
-	TCA_STAB_DATA,
-	__TCA_STAB_MAX
-};
-
-#define TCA_STAB_MAX (__TCA_STAB_MAX - 1)
-
-/* FIFO section */
-
-struct tc_fifo_qopt {
-	__u32	limit;	/* Queue length: bytes for bfifo, packets for pfifo */
-};
-
-/* PRIO section */
-
-#define TCQ_PRIO_BANDS	16
-#define TCQ_MIN_PRIO_BANDS 2
-
-struct tc_prio_qopt {
-	int	bands;			/* Number of bands */
-	__u8	priomap[TC_PRIO_MAX+1];	/* Map: logical priority -> PRIO band */
-};
-
-/* MULTIQ section */
-
-struct tc_multiq_qopt {
-	__u16	bands;			/* Number of bands */
-	__u16	max_bands;		/* Maximum number of queues */
-};
-
-/* PLUG section */
-
-#define TCQ_PLUG_BUFFER                0
-#define TCQ_PLUG_RELEASE_ONE           1
-#define TCQ_PLUG_RELEASE_INDEFINITE    2
-#define TCQ_PLUG_LIMIT                 3
-
-struct tc_plug_qopt {
-	/* TCQ_PLUG_BUFFER: Inset a plug into the queue and
-	 *  buffer any incoming packets
-	 * TCQ_PLUG_RELEASE_ONE: Dequeue packets from queue head
-	 *   to beginning of the next plug.
-	 * TCQ_PLUG_RELEASE_INDEFINITE: Dequeue all packets from queue.
-	 *   Stop buffering packets until the next TCQ_PLUG_BUFFER
-	 *   command is received (just act as a pass-thru queue).
-	 * TCQ_PLUG_LIMIT: Increase/decrease queue size
-	 */
-	int             action;
-	__u32           limit;
-};
-
-/* TBF section */
-
-struct tc_tbf_qopt {
-	struct tc_ratespec rate;
-	struct tc_ratespec peakrate;
-	__u32		limit;
-	__u32		buffer;
-	__u32		mtu;
-};
-
-enum {
-	TCA_TBF_UNSPEC,
-	TCA_TBF_PARMS,
-	TCA_TBF_RTAB,
-	TCA_TBF_PTAB,
-	TCA_TBF_RATE64,
-	TCA_TBF_PRATE64,
-	TCA_TBF_BURST,
-	TCA_TBF_PBURST,
-	TCA_TBF_PAD,
-	__TCA_TBF_MAX,
-};
-
-#define TCA_TBF_MAX (__TCA_TBF_MAX - 1)
-
-
-/* TEQL section */
-
-/* TEQL does not require any parameters */
-
-/* SFQ section */
-
-struct tc_sfq_qopt {
-	unsigned	quantum;	/* Bytes per round allocated to flow */
-	int		perturb_period;	/* Period of hash perturbation */
-	__u32		limit;		/* Maximal packets in queue */
-	unsigned	divisor;	/* Hash divisor  */
-	unsigned	flows;		/* Maximal number of flows  */
-};
-
-struct tc_sfqred_stats {
-	__u32           prob_drop;      /* Early drops, below max threshold */
-	__u32           forced_drop;	/* Early drops, after max threshold */
-	__u32           prob_mark;      /* Marked packets, below max threshold */
-	__u32           forced_mark;    /* Marked packets, after max threshold */
-	__u32           prob_mark_head; /* Marked packets, below max threshold */
-	__u32           forced_mark_head;/* Marked packets, after max threshold */
-};
-
-struct tc_sfq_qopt_v1 {
-	struct tc_sfq_qopt v0;
-	unsigned int	depth;		/* max number of packets per flow */
-	unsigned int	headdrop;
-/* SFQRED parameters */
-	__u32		limit;		/* HARD maximal flow queue length (bytes) */
-	__u32		qth_min;	/* Min average length threshold (bytes) */
-	__u32		qth_max;	/* Max average length threshold (bytes) */
-	unsigned char   Wlog;		/* log(W)		*/
-	unsigned char   Plog;		/* log(P_max/(qth_max-qth_min))	*/
-	unsigned char   Scell_log;	/* cell size for idle damping */
-	unsigned char	flags;
-	__u32		max_P;		/* probability, high resolution */
-/* SFQRED stats */
-	struct tc_sfqred_stats stats;
-};
-
-
-struct tc_sfq_xstats {
-	__s32		allot;
-};
-
-/* RED section */
-
-enum {
-	TCA_RED_UNSPEC,
-	TCA_RED_PARMS,
-	TCA_RED_STAB,
-	TCA_RED_MAX_P,
-	__TCA_RED_MAX,
-};
-
-#define TCA_RED_MAX (__TCA_RED_MAX - 1)
-
-struct tc_red_qopt {
-	__u32		limit;		/* HARD maximal queue length (bytes)	*/
-	__u32		qth_min;	/* Min average length threshold (bytes) */
-	__u32		qth_max;	/* Max average length threshold (bytes) */
-	unsigned char   Wlog;		/* log(W)		*/
-	unsigned char   Plog;		/* log(P_max/(qth_max-qth_min))	*/
-	unsigned char   Scell_log;	/* cell size for idle damping */
-	unsigned char	flags;
-#define TC_RED_ECN		1
-#define TC_RED_HARDDROP		2
-#define TC_RED_ADAPTATIVE	4
-};
-
-struct tc_red_xstats {
-	__u32           early;          /* Early drops */
-	__u32           pdrop;          /* Drops due to queue limits */
-	__u32           other;          /* Drops due to drop() calls */
-	__u32           marked;         /* Marked packets */
-};
-
-/* GRED section */
-
-#define MAX_DPs 16
-
-enum {
-       TCA_GRED_UNSPEC,
-       TCA_GRED_PARMS,
-       TCA_GRED_STAB,
-       TCA_GRED_DPS,
-       TCA_GRED_MAX_P,
-       TCA_GRED_LIMIT,
-       __TCA_GRED_MAX,
-};
-
-#define TCA_GRED_MAX (__TCA_GRED_MAX - 1)
-
-struct tc_gred_qopt {
-	__u32		limit;        /* HARD maximal queue length (bytes)    */
-	__u32		qth_min;      /* Min average length threshold (bytes) */
-	__u32		qth_max;      /* Max average length threshold (bytes) */
-	__u32		DP;           /* up to 2^32 DPs */
-	__u32		backlog;
-	__u32		qave;
-	__u32		forced;
-	__u32		early;
-	__u32		other;
-	__u32		pdrop;
-	__u8		Wlog;         /* log(W)               */
-	__u8		Plog;         /* log(P_max/(qth_max-qth_min)) */
-	__u8		Scell_log;    /* cell size for idle damping */
-	__u8		prio;         /* prio of this VQ */
-	__u32		packets;
-	__u32		bytesin;
-};
-
-/* gred setup */
-struct tc_gred_sopt {
-	__u32		DPs;
-	__u32		def_DP;
-	__u8		grio;
-	__u8		flags;
-	__u16		pad1;
-};
-
-/* CHOKe section */
-
-enum {
-	TCA_CHOKE_UNSPEC,
-	TCA_CHOKE_PARMS,
-	TCA_CHOKE_STAB,
-	TCA_CHOKE_MAX_P,
-	__TCA_CHOKE_MAX,
-};
-
-#define TCA_CHOKE_MAX (__TCA_CHOKE_MAX - 1)
-
-struct tc_choke_qopt {
-	__u32		limit;		/* Hard queue length (packets)	*/
-	__u32		qth_min;	/* Min average threshold (packets) */
-	__u32		qth_max;	/* Max average threshold (packets) */
-	unsigned char   Wlog;		/* log(W)		*/
-	unsigned char   Plog;		/* log(P_max/(qth_max-qth_min))	*/
-	unsigned char   Scell_log;	/* cell size for idle damping */
-	unsigned char	flags;		/* see RED flags */
-};
-
-struct tc_choke_xstats {
-	__u32		early;          /* Early drops */
-	__u32		pdrop;          /* Drops due to queue limits */
-	__u32		other;          /* Drops due to drop() calls */
-	__u32		marked;         /* Marked packets */
-	__u32		matched;	/* Drops due to flow match */
-};
-
-/* HTB section */
-#define TC_HTB_NUMPRIO		8
-#define TC_HTB_MAXDEPTH		8
-#define TC_HTB_PROTOVER		3 /* the same as HTB and TC's major */
-
-struct tc_htb_opt {
-	struct tc_ratespec 	rate;
-	struct tc_ratespec 	ceil;
-	__u32	buffer;
-	__u32	cbuffer;
-	__u32	quantum;
-	__u32	level;		/* out only */
-	__u32	prio;
-};
-struct tc_htb_glob {
-	__u32 version;		/* to match HTB/TC */
-    	__u32 rate2quantum;	/* bps->quantum divisor */
-    	__u32 defcls;		/* default class number */
-	__u32 debug;		/* debug flags */
-
-	/* stats */
-	__u32 direct_pkts; /* count of non shaped packets */
-};
-enum {
-	TCA_HTB_UNSPEC,
-	TCA_HTB_PARMS,
-	TCA_HTB_INIT,
-	TCA_HTB_CTAB,
-	TCA_HTB_RTAB,
-	TCA_HTB_DIRECT_QLEN,
-	TCA_HTB_RATE64,
-	TCA_HTB_CEIL64,
-	TCA_HTB_PAD,
-	__TCA_HTB_MAX,
-};
-
-#define TCA_HTB_MAX (__TCA_HTB_MAX - 1)
-
-struct tc_htb_xstats {
-	__u32 lends;
-	__u32 borrows;
-	__u32 giants;	/* too big packets (rate will not be accurate) */
-	__u32 tokens;
-	__u32 ctokens;
-};
-
-/* HFSC section */
-
-struct tc_hfsc_qopt {
-	__u16	defcls;		/* default class */
-};
-
-struct tc_service_curve {
-	__u32	m1;		/* slope of the first segment in bps */
-	__u32	d;		/* x-projection of the first segment in us */
-	__u32	m2;		/* slope of the second segment in bps */
-};
-
-struct tc_hfsc_stats {
-	__u64	work;		/* total work done */
-	__u64	rtwork;		/* work done by real-time criteria */
-	__u32	period;		/* current period */
-	__u32	level;		/* class level in hierarchy */
-};
-
-enum {
-	TCA_HFSC_UNSPEC,
-	TCA_HFSC_RSC,
-	TCA_HFSC_FSC,
-	TCA_HFSC_USC,
-	__TCA_HFSC_MAX,
-};
-
-#define TCA_HFSC_MAX (__TCA_HFSC_MAX - 1)
-
-
-/* CBQ section */
-
-#define TC_CBQ_MAXPRIO		8
-#define TC_CBQ_MAXLEVEL		8
-#define TC_CBQ_DEF_EWMA		5
-
-struct tc_cbq_lssopt {
-	unsigned char	change;
-	unsigned char	flags;
-#define TCF_CBQ_LSS_BOUNDED	1
-#define TCF_CBQ_LSS_ISOLATED	2
-	unsigned char  	ewma_log;
-	unsigned char  	level;
-#define TCF_CBQ_LSS_FLAGS	1
-#define TCF_CBQ_LSS_EWMA	2
-#define TCF_CBQ_LSS_MAXIDLE	4
-#define TCF_CBQ_LSS_MINIDLE	8
-#define TCF_CBQ_LSS_OFFTIME	0x10
-#define TCF_CBQ_LSS_AVPKT	0x20
-	__u32		maxidle;
-	__u32		minidle;
-	__u32		offtime;
-	__u32		avpkt;
-};
-
-struct tc_cbq_wrropt {
-	unsigned char	flags;
-	unsigned char	priority;
-	unsigned char	cpriority;
-	unsigned char	__reserved;
-	__u32		allot;
-	__u32		weight;
-};
-
-struct tc_cbq_ovl {
-	unsigned char	strategy;
-#define	TC_CBQ_OVL_CLASSIC	0
-#define	TC_CBQ_OVL_DELAY	1
-#define	TC_CBQ_OVL_LOWPRIO	2
-#define	TC_CBQ_OVL_DROP		3
-#define	TC_CBQ_OVL_RCLASSIC	4
-	unsigned char	priority2;
-	__u16		pad;
-	__u32		penalty;
-};
-
-struct tc_cbq_police {
-	unsigned char	police;
-	unsigned char	__res1;
-	unsigned short	__res2;
-};
-
-struct tc_cbq_fopt {
-	__u32		split;
-	__u32		defmap;
-	__u32		defchange;
-};
-
-struct tc_cbq_xstats {
-	__u32		borrows;
-	__u32		overactions;
-	__s32		avgidle;
-	__s32		undertime;
-};
-
-enum {
-	TCA_CBQ_UNSPEC,
-	TCA_CBQ_LSSOPT,
-	TCA_CBQ_WRROPT,
-	TCA_CBQ_FOPT,
-	TCA_CBQ_OVL_STRATEGY,
-	TCA_CBQ_RATE,
-	TCA_CBQ_RTAB,
-	TCA_CBQ_POLICE,
-	__TCA_CBQ_MAX,
-};
-
-#define TCA_CBQ_MAX	(__TCA_CBQ_MAX - 1)
-
-/* dsmark section */
-
-enum {
-	TCA_DSMARK_UNSPEC,
-	TCA_DSMARK_INDICES,
-	TCA_DSMARK_DEFAULT_INDEX,
-	TCA_DSMARK_SET_TC_INDEX,
-	TCA_DSMARK_MASK,
-	TCA_DSMARK_VALUE,
-	__TCA_DSMARK_MAX,
-};
-
-#define TCA_DSMARK_MAX (__TCA_DSMARK_MAX - 1)
-
-/* ATM  section */
-
-enum {
-	TCA_ATM_UNSPEC,
-	TCA_ATM_FD,		/* file/socket descriptor */
-	TCA_ATM_PTR,		/* pointer to descriptor - later */
-	TCA_ATM_HDR,		/* LL header */
-	TCA_ATM_EXCESS,		/* excess traffic class (0 for CLP)  */
-	TCA_ATM_ADDR,		/* PVC address (for output only) */
-	TCA_ATM_STATE,		/* VC state (ATM_VS_*; for output only) */
-	__TCA_ATM_MAX,
-};
-
-#define TCA_ATM_MAX	(__TCA_ATM_MAX - 1)
-
-/* Network emulator */
-
-enum {
-	TCA_NETEM_UNSPEC,
-	TCA_NETEM_CORR,
-	TCA_NETEM_DELAY_DIST,
-	TCA_NETEM_REORDER,
-	TCA_NETEM_CORRUPT,
-	TCA_NETEM_LOSS,
-	TCA_NETEM_RATE,
-	TCA_NETEM_ECN,
-	TCA_NETEM_RATE64,
-	TCA_NETEM_PAD,
-	__TCA_NETEM_MAX,
-};
-
-#define TCA_NETEM_MAX (__TCA_NETEM_MAX - 1)
-
-struct tc_netem_qopt {
-	__u32	latency;	/* added delay (us) */
-	__u32   limit;		/* fifo limit (packets) */
-	__u32	loss;		/* random packet loss (0=none ~0=100%) */
-	__u32	gap;		/* re-ordering gap (0 for none) */
-	__u32   duplicate;	/* random packet dup  (0=none ~0=100%) */
-	__u32	jitter;		/* random jitter in latency (us) */
-};
-
-struct tc_netem_corr {
-	__u32	delay_corr;	/* delay correlation */
-	__u32	loss_corr;	/* packet loss correlation */
-	__u32	dup_corr;	/* duplicate correlation  */
-};
-
-struct tc_netem_reorder {
-	__u32	probability;
-	__u32	correlation;
-};
-
-struct tc_netem_corrupt {
-	__u32	probability;
-	__u32	correlation;
-};
-
-struct tc_netem_rate {
-	__u32	rate;	/* byte/s */
-	__s32	packet_overhead;
-	__u32	cell_size;
-	__s32	cell_overhead;
-};
-
-enum {
-	NETEM_LOSS_UNSPEC,
-	NETEM_LOSS_GI,		/* General Intuitive - 4 state model */
-	NETEM_LOSS_GE,		/* Gilbert Elliot models */
-	__NETEM_LOSS_MAX
-};
-#define NETEM_LOSS_MAX (__NETEM_LOSS_MAX - 1)
-
-/* State transition probabilities for 4 state model */
-struct tc_netem_gimodel {
-	__u32	p13;
-	__u32	p31;
-	__u32	p32;
-	__u32	p14;
-	__u32	p23;
-};
-
-/* Gilbert-Elliot models */
-struct tc_netem_gemodel {
-	__u32 p;
-	__u32 r;
-	__u32 h;
-	__u32 k1;
-};
-
-#define NETEM_DIST_SCALE	8192
-#define NETEM_DIST_MAX		16384
-
-/* DRR */
-
-enum {
-	TCA_DRR_UNSPEC,
-	TCA_DRR_QUANTUM,
-	__TCA_DRR_MAX
-};
-
-#define TCA_DRR_MAX	(__TCA_DRR_MAX - 1)
-
-struct tc_drr_stats {
-	__u32	deficit;
-};
-
-/* MQPRIO */
-#define TC_QOPT_BITMASK 15
-#define TC_QOPT_MAX_QUEUE 16
-
-enum {
-	TC_MQPRIO_HW_OFFLOAD_NONE,	/* no offload requested */
-	TC_MQPRIO_HW_OFFLOAD_TCS,	/* offload TCs, no queue counts */
-	__TC_MQPRIO_HW_OFFLOAD_MAX
-};
-
-#define TC_MQPRIO_HW_OFFLOAD_MAX (__TC_MQPRIO_HW_OFFLOAD_MAX - 1)
-
-struct tc_mqprio_qopt {
-	__u8	num_tc;
-	__u8	prio_tc_map[TC_QOPT_BITMASK + 1];
-	__u8	hw;
-	__u16	count[TC_QOPT_MAX_QUEUE];
-	__u16	offset[TC_QOPT_MAX_QUEUE];
-};
-
-/* SFB */
-
-enum {
-	TCA_SFB_UNSPEC,
-	TCA_SFB_PARMS,
-	__TCA_SFB_MAX,
-};
-
-#define TCA_SFB_MAX (__TCA_SFB_MAX - 1)
-
-/*
- * Note: increment, decrement are Q0.16 fixed-point values.
- */
-struct tc_sfb_qopt {
-	__u32 rehash_interval;	/* delay between hash move, in ms */
-	__u32 warmup_time;	/* double buffering warmup time in ms (warmup_time < rehash_interval) */
-	__u32 max;		/* max len of qlen_min */
-	__u32 bin_size;		/* maximum queue length per bin */
-	__u32 increment;	/* probability increment, (d1 in Blue) */
-	__u32 decrement;	/* probability decrement, (d2 in Blue) */
-	__u32 limit;		/* max SFB queue length */
-	__u32 penalty_rate;	/* inelastic flows are rate limited to 'rate' pps */
-	__u32 penalty_burst;
-};
-
-struct tc_sfb_xstats {
-	__u32 earlydrop;
-	__u32 penaltydrop;
-	__u32 bucketdrop;
-	__u32 queuedrop;
-	__u32 childdrop; /* drops in child qdisc */
-	__u32 marked;
-	__u32 maxqlen;
-	__u32 maxprob;
-	__u32 avgprob;
-};
-
-#define SFB_MAX_PROB 0xFFFF
-
-/* QFQ */
-enum {
-	TCA_QFQ_UNSPEC,
-	TCA_QFQ_WEIGHT,
-	TCA_QFQ_LMAX,
-	__TCA_QFQ_MAX
-};
-
-#define TCA_QFQ_MAX	(__TCA_QFQ_MAX - 1)
-
-struct tc_qfq_stats {
-	__u32 weight;
-	__u32 lmax;
-};
-
-/* CODEL */
-
-enum {
-	TCA_CODEL_UNSPEC,
-	TCA_CODEL_TARGET,
-	TCA_CODEL_LIMIT,
-	TCA_CODEL_INTERVAL,
-	TCA_CODEL_ECN,
-	TCA_CODEL_CE_THRESHOLD,
-	__TCA_CODEL_MAX
-};
-
-#define TCA_CODEL_MAX	(__TCA_CODEL_MAX - 1)
-
-struct tc_codel_xstats {
-	__u32	maxpacket; /* largest packet we've seen so far */
-	__u32	count;	   /* how many drops we've done since the last time we
-			    * entered dropping state
-			    */
-	__u32	lastcount; /* count at entry to dropping state */
-	__u32	ldelay;    /* in-queue delay seen by most recently dequeued packet */
-	__s32	drop_next; /* time to drop next packet */
-	__u32	drop_overlimit; /* number of time max qdisc packet limit was hit */
-	__u32	ecn_mark;  /* number of packets we ECN marked instead of dropped */
-	__u32	dropping;  /* are we in dropping state ? */
-	__u32	ce_mark;   /* number of CE marked packets because of ce_threshold */
-};
-
-/* FQ_CODEL */
-
-enum {
-	TCA_FQ_CODEL_UNSPEC,
-	TCA_FQ_CODEL_TARGET,
-	TCA_FQ_CODEL_LIMIT,
-	TCA_FQ_CODEL_INTERVAL,
-	TCA_FQ_CODEL_ECN,
-	TCA_FQ_CODEL_FLOWS,
-	TCA_FQ_CODEL_QUANTUM,
-	TCA_FQ_CODEL_CE_THRESHOLD,
-	TCA_FQ_CODEL_DROP_BATCH_SIZE,
-	TCA_FQ_CODEL_MEMORY_LIMIT,
-	__TCA_FQ_CODEL_MAX
-};
-
-#define TCA_FQ_CODEL_MAX	(__TCA_FQ_CODEL_MAX - 1)
-
-enum {
-	TCA_FQ_CODEL_XSTATS_QDISC,
-	TCA_FQ_CODEL_XSTATS_CLASS,
-};
-
-struct tc_fq_codel_qd_stats {
-	__u32	maxpacket;	/* largest packet we've seen so far */
-	__u32	drop_overlimit; /* number of time max qdisc
-				 * packet limit was hit
-				 */
-	__u32	ecn_mark;	/* number of packets we ECN marked
-				 * instead of being dropped
-				 */
-	__u32	new_flow_count; /* number of time packets
-				 * created a 'new flow'
-				 */
-	__u32	new_flows_len;	/* count of flows in new list */
-	__u32	old_flows_len;	/* count of flows in old list */
-	__u32	ce_mark;	/* packets above ce_threshold */
-	__u32	memory_usage;	/* in bytes */
-	__u32	drop_overmemory;
-};
-
-struct tc_fq_codel_cl_stats {
-	__s32	deficit;
-	__u32	ldelay;		/* in-queue delay seen by most recently
-				 * dequeued packet
-				 */
-	__u32	count;
-	__u32	lastcount;
-	__u32	dropping;
-	__s32	drop_next;
-};
-
-struct tc_fq_codel_xstats {
-	__u32	type;
-	union {
-		struct tc_fq_codel_qd_stats qdisc_stats;
-		struct tc_fq_codel_cl_stats class_stats;
-	};
-};
-
-/* FQ */
-
-enum {
-	TCA_FQ_UNSPEC,
-
-	TCA_FQ_PLIMIT,		/* limit of total number of packets in queue */
-
-	TCA_FQ_FLOW_PLIMIT,	/* limit of packets per flow */
-
-	TCA_FQ_QUANTUM,		/* RR quantum */
-
-	TCA_FQ_INITIAL_QUANTUM,		/* RR quantum for new flow */
-
-	TCA_FQ_RATE_ENABLE,	/* enable/disable rate limiting */
-
-	TCA_FQ_FLOW_DEFAULT_RATE,/* obsolete, do not use */
-
-	TCA_FQ_FLOW_MAX_RATE,	/* per flow max rate */
-
-	TCA_FQ_BUCKETS_LOG,	/* log2(number of buckets) */
-
-	TCA_FQ_FLOW_REFILL_DELAY,	/* flow credit refill delay in usec */
-
-	TCA_FQ_ORPHAN_MASK,	/* mask applied to orphaned skb hashes */
-
-	TCA_FQ_LOW_RATE_THRESHOLD, /* per packet delay under this rate */
-
-	__TCA_FQ_MAX
-};
-
-#define TCA_FQ_MAX	(__TCA_FQ_MAX - 1)
-
-struct tc_fq_qd_stats {
-	__u64	gc_flows;
-	__u64	highprio_packets;
-	__u64	tcp_retrans;
-	__u64	throttled;
-	__u64	flows_plimit;
-	__u64	pkts_too_long;
-	__u64	allocation_errors;
-	__s64	time_next_delayed_flow;
-	__u32	flows;
-	__u32	inactive_flows;
-	__u32	throttled_flows;
-	__u32	unthrottle_latency_ns;
-};
-
-/* Heavy-Hitter Filter */
-
-enum {
-	TCA_HHF_UNSPEC,
-	TCA_HHF_BACKLOG_LIMIT,
-	TCA_HHF_QUANTUM,
-	TCA_HHF_HH_FLOWS_LIMIT,
-	TCA_HHF_RESET_TIMEOUT,
-	TCA_HHF_ADMIT_BYTES,
-	TCA_HHF_EVICT_TIMEOUT,
-	TCA_HHF_NON_HH_WEIGHT,
-	__TCA_HHF_MAX
-};
-
-#define TCA_HHF_MAX	(__TCA_HHF_MAX - 1)
-
-struct tc_hhf_xstats {
-	__u32	drop_overlimit; /* number of times max qdisc packet limit
-				 * was hit
-				 */
-	__u32	hh_overlimit;   /* number of times max heavy-hitters was hit */
-	__u32	hh_tot_count;   /* number of captured heavy-hitters so far */
-	__u32	hh_cur_count;   /* number of current heavy-hitters */
-};
-
-/* PIE */
-enum {
-	TCA_PIE_UNSPEC,
-	TCA_PIE_TARGET,
-	TCA_PIE_LIMIT,
-	TCA_PIE_TUPDATE,
-	TCA_PIE_ALPHA,
-	TCA_PIE_BETA,
-	TCA_PIE_ECN,
-	TCA_PIE_BYTEMODE,
-	__TCA_PIE_MAX
-};
-#define TCA_PIE_MAX   (__TCA_PIE_MAX - 1)
-
-struct tc_pie_xstats {
-	__u32 prob;             /* current probability */
-	__u32 delay;            /* current delay in ms */
-	__u32 avg_dq_rate;      /* current average dq_rate in bits/pie_time */
-	__u32 packets_in;       /* total number of packets enqueued */
-	__u32 dropped;          /* packets dropped due to pie_action */
-	__u32 overlimit;        /* dropped due to lack of space in queue */
-	__u32 maxq;             /* maximum queue size */
-	__u32 ecn_mark;         /* packets marked with ecn*/
-};
-#endif
diff --git a/include/linux/posix_types.h b/include/linux/posix_types.h
deleted file mode 100644
index 988f76e..0000000
--- a/include/linux/posix_types.h
+++ /dev/null
@@ -1,37 +0,0 @@
-#ifndef _LINUX_POSIX_TYPES_H
-#define _LINUX_POSIX_TYPES_H
-
-#include <linux/stddef.h>
-
-/*
- * This allows for 1024 file descriptors: if NR_OPEN is ever grown
- * beyond that you'll have to change this too. But 1024 fd's seem to be
- * enough even for such "real" unices like OSF/1, so hopefully this is
- * one limit that doesn't have to be changed [again].
- *
- * Note that POSIX wants the FD_CLEAR(fd,fdsetp) defines to be in
- * <sys/time.h> (and thus <linux/time.h>) - but this is a more logical
- * place for them. Solved by having dummy defines in <sys/time.h>.
- */
-
-/*
- * This macro may have been defined in <gnu/types.h>. But we always
- * use the one here.
- */
-#undef __FD_SETSIZE
-#define __FD_SETSIZE	1024
-
-typedef struct {
-	unsigned long fds_bits[__FD_SETSIZE / (8 * sizeof(long))];
-} __kernel_fd_set;
-
-/* Type of a signal handler.  */
-typedef void (*__kernel_sighandler_t)(int);
-
-/* Type of a SYSV IPC key.  */
-typedef int __kernel_key_t;
-typedef int __kernel_mqd_t;
-
-#include <asm/posix_types.h>
-
-#endif /* _LINUX_POSIX_TYPES_H */
diff --git a/include/linux/rtnetlink.h b/include/linux/rtnetlink.h
deleted file mode 100644
index 813e9e0..0000000
--- a/include/linux/rtnetlink.h
+++ /dev/null
@@ -1,718 +0,0 @@
-#ifndef __LINUX_RTNETLINK_H
-#define __LINUX_RTNETLINK_H
-
-#include <linux/types.h>
-#include <linux/netlink.h>
-#include <linux/if_link.h>
-#include <linux/if_addr.h>
-#include <linux/neighbour.h>
-
-/* rtnetlink families. Values up to 127 are reserved for real address
- * families, values above 128 may be used arbitrarily.
- */
-#define RTNL_FAMILY_IPMR		128
-#define RTNL_FAMILY_IP6MR		129
-#define RTNL_FAMILY_MAX			129
-
-/****
- *		Routing/neighbour discovery messages.
- ****/
-
-/* Types of messages */
-
-enum {
-	RTM_BASE	= 16,
-#define RTM_BASE	RTM_BASE
-
-	RTM_NEWLINK	= 16,
-#define RTM_NEWLINK	RTM_NEWLINK
-	RTM_DELLINK,
-#define RTM_DELLINK	RTM_DELLINK
-	RTM_GETLINK,
-#define RTM_GETLINK	RTM_GETLINK
-	RTM_SETLINK,
-#define RTM_SETLINK	RTM_SETLINK
-
-	RTM_NEWADDR	= 20,
-#define RTM_NEWADDR	RTM_NEWADDR
-	RTM_DELADDR,
-#define RTM_DELADDR	RTM_DELADDR
-	RTM_GETADDR,
-#define RTM_GETADDR	RTM_GETADDR
-
-	RTM_NEWROUTE	= 24,
-#define RTM_NEWROUTE	RTM_NEWROUTE
-	RTM_DELROUTE,
-#define RTM_DELROUTE	RTM_DELROUTE
-	RTM_GETROUTE,
-#define RTM_GETROUTE	RTM_GETROUTE
-
-	RTM_NEWNEIGH	= 28,
-#define RTM_NEWNEIGH	RTM_NEWNEIGH
-	RTM_DELNEIGH,
-#define RTM_DELNEIGH	RTM_DELNEIGH
-	RTM_GETNEIGH,
-#define RTM_GETNEIGH	RTM_GETNEIGH
-
-	RTM_NEWRULE	= 32,
-#define RTM_NEWRULE	RTM_NEWRULE
-	RTM_DELRULE,
-#define RTM_DELRULE	RTM_DELRULE
-	RTM_GETRULE,
-#define RTM_GETRULE	RTM_GETRULE
-
-	RTM_NEWQDISC	= 36,
-#define RTM_NEWQDISC	RTM_NEWQDISC
-	RTM_DELQDISC,
-#define RTM_DELQDISC	RTM_DELQDISC
-	RTM_GETQDISC,
-#define RTM_GETQDISC	RTM_GETQDISC
-
-	RTM_NEWTCLASS	= 40,
-#define RTM_NEWTCLASS	RTM_NEWTCLASS
-	RTM_DELTCLASS,
-#define RTM_DELTCLASS	RTM_DELTCLASS
-	RTM_GETTCLASS,
-#define RTM_GETTCLASS	RTM_GETTCLASS
-
-	RTM_NEWTFILTER	= 44,
-#define RTM_NEWTFILTER	RTM_NEWTFILTER
-	RTM_DELTFILTER,
-#define RTM_DELTFILTER	RTM_DELTFILTER
-	RTM_GETTFILTER,
-#define RTM_GETTFILTER	RTM_GETTFILTER
-
-	RTM_NEWACTION	= 48,
-#define RTM_NEWACTION   RTM_NEWACTION
-	RTM_DELACTION,
-#define RTM_DELACTION   RTM_DELACTION
-	RTM_GETACTION,
-#define RTM_GETACTION   RTM_GETACTION
-
-	RTM_NEWPREFIX	= 52,
-#define RTM_NEWPREFIX	RTM_NEWPREFIX
-
-	RTM_GETMULTICAST = 58,
-#define RTM_GETMULTICAST RTM_GETMULTICAST
-
-	RTM_GETANYCAST	= 62,
-#define RTM_GETANYCAST	RTM_GETANYCAST
-
-	RTM_NEWNEIGHTBL	= 64,
-#define RTM_NEWNEIGHTBL	RTM_NEWNEIGHTBL
-	RTM_GETNEIGHTBL	= 66,
-#define RTM_GETNEIGHTBL	RTM_GETNEIGHTBL
-	RTM_SETNEIGHTBL,
-#define RTM_SETNEIGHTBL	RTM_SETNEIGHTBL
-
-	RTM_NEWNDUSEROPT = 68,
-#define RTM_NEWNDUSEROPT RTM_NEWNDUSEROPT
-
-	RTM_NEWADDRLABEL = 72,
-#define RTM_NEWADDRLABEL RTM_NEWADDRLABEL
-	RTM_DELADDRLABEL,
-#define RTM_DELADDRLABEL RTM_DELADDRLABEL
-	RTM_GETADDRLABEL,
-#define RTM_GETADDRLABEL RTM_GETADDRLABEL
-
-	RTM_GETDCB = 78,
-#define RTM_GETDCB RTM_GETDCB
-	RTM_SETDCB,
-#define RTM_SETDCB RTM_SETDCB
-
-	RTM_NEWNETCONF = 80,
-#define RTM_NEWNETCONF RTM_NEWNETCONF
-	RTM_DELNETCONF,
-#define RTM_DELNETCONF RTM_DELNETCONF
-	RTM_GETNETCONF = 82,
-#define RTM_GETNETCONF RTM_GETNETCONF
-
-	RTM_NEWMDB = 84,
-#define RTM_NEWMDB RTM_NEWMDB
-	RTM_DELMDB = 85,
-#define RTM_DELMDB RTM_DELMDB
-	RTM_GETMDB = 86,
-#define RTM_GETMDB RTM_GETMDB
-
-	RTM_NEWNSID = 88,
-#define RTM_NEWNSID RTM_NEWNSID
-	RTM_DELNSID = 89,
-#define RTM_DELNSID RTM_DELNSID
-	RTM_GETNSID = 90,
-#define RTM_GETNSID RTM_GETNSID
-
-	RTM_NEWSTATS = 92,
-#define RTM_NEWSTATS RTM_NEWSTATS
-	RTM_GETSTATS = 94,
-#define RTM_GETSTATS RTM_GETSTATS
-
-	RTM_NEWCACHEREPORT = 96,
-#define RTM_NEWCACHEREPORT RTM_NEWCACHEREPORT
-
-	__RTM_MAX,
-#define RTM_MAX		(((__RTM_MAX + 3) & ~3) - 1)
-};
-
-#define RTM_NR_MSGTYPES	(RTM_MAX + 1 - RTM_BASE)
-#define RTM_NR_FAMILIES	(RTM_NR_MSGTYPES >> 2)
-#define RTM_FAM(cmd)	(((cmd) - RTM_BASE) >> 2)
-
-/* 
-   Generic structure for encapsulation of optional route information.
-   It is reminiscent of sockaddr, but with sa_family replaced
-   with attribute type.
- */
-
-struct rtattr {
-	unsigned short	rta_len;
-	unsigned short	rta_type;
-};
-
-/* Macros to handle rtattributes */
-
-#define RTA_ALIGNTO	4U
-#define RTA_ALIGN(len) ( ((len)+RTA_ALIGNTO-1) & ~(RTA_ALIGNTO-1) )
-#define RTA_OK(rta,len) ((len) >= (int)sizeof(struct rtattr) && \
-			 (rta)->rta_len >= sizeof(struct rtattr) && \
-			 (rta)->rta_len <= (len))
-#define RTA_NEXT(rta,attrlen)	((attrlen) -= RTA_ALIGN((rta)->rta_len), \
-				 (struct rtattr*)(((char*)(rta)) + RTA_ALIGN((rta)->rta_len)))
-#define RTA_LENGTH(len)	(RTA_ALIGN(sizeof(struct rtattr)) + (len))
-#define RTA_SPACE(len)	RTA_ALIGN(RTA_LENGTH(len))
-#define RTA_DATA(rta)   ((void*)(((char*)(rta)) + RTA_LENGTH(0)))
-#define RTA_PAYLOAD(rta) ((int)((rta)->rta_len) - RTA_LENGTH(0))
-
-
-
-
-/******************************************************************************
- *		Definitions used in routing table administration.
- ****/
-
-struct rtmsg {
-	unsigned char		rtm_family;
-	unsigned char		rtm_dst_len;
-	unsigned char		rtm_src_len;
-	unsigned char		rtm_tos;
-
-	unsigned char		rtm_table;	/* Routing table id */
-	unsigned char		rtm_protocol;	/* Routing protocol; see below	*/
-	unsigned char		rtm_scope;	/* See below */	
-	unsigned char		rtm_type;	/* See below	*/
-
-	unsigned		rtm_flags;
-};
-
-/* rtm_type */
-
-enum {
-	RTN_UNSPEC,
-	RTN_UNICAST,		/* Gateway or direct route	*/
-	RTN_LOCAL,		/* Accept locally		*/
-	RTN_BROADCAST,		/* Accept locally as broadcast,
-				   send as broadcast */
-	RTN_ANYCAST,		/* Accept locally as broadcast,
-				   but send as unicast */
-	RTN_MULTICAST,		/* Multicast route		*/
-	RTN_BLACKHOLE,		/* Drop				*/
-	RTN_UNREACHABLE,	/* Destination is unreachable   */
-	RTN_PROHIBIT,		/* Administratively prohibited	*/
-	RTN_THROW,		/* Not in this table		*/
-	RTN_NAT,		/* Translate this address	*/
-	RTN_XRESOLVE,		/* Use external resolver	*/
-	__RTN_MAX
-};
-
-#define RTN_MAX (__RTN_MAX - 1)
-
-
-/* rtm_protocol */
-
-#define RTPROT_UNSPEC	0
-#define RTPROT_REDIRECT	1	/* Route installed by ICMP redirects;
-				   not used by current IPv4 */
-#define RTPROT_KERNEL	2	/* Route installed by kernel		*/
-#define RTPROT_BOOT	3	/* Route installed during boot		*/
-#define RTPROT_STATIC	4	/* Route installed by administrator	*/
-
-/* Values of protocol >= RTPROT_STATIC are not interpreted by kernel;
-   they are just passed from user and back as is.
-   It will be used by hypothetical multiple routing daemons.
-   Note that protocol values should be standardized in order to
-   avoid conflicts.
- */
-
-#define RTPROT_GATED	8	/* Apparently, GateD */
-#define RTPROT_RA	9	/* RDISC/ND router advertisements */
-#define RTPROT_MRT	10	/* Merit MRT */
-#define RTPROT_ZEBRA	11	/* Zebra */
-#define RTPROT_BIRD	12	/* BIRD */
-#define RTPROT_DNROUTED	13	/* DECnet routing daemon */
-#define RTPROT_XORP	14	/* XORP */
-#define RTPROT_NTK	15	/* Netsukuku */
-#define RTPROT_DHCP	16      /* DHCP client */
-#define RTPROT_MROUTED	17      /* Multicast daemon */
-#define RTPROT_BABEL	42      /* Babel daemon */
-
-/* rtm_scope
-
-   Really it is not scope, but sort of distance to the destination.
-   NOWHERE are reserved for not existing destinations, HOST is our
-   local addresses, LINK are destinations, located on directly attached
-   link and UNIVERSE is everywhere in the Universe.
-
-   Intermediate values are also possible f.e. interior routes
-   could be assigned a value between UNIVERSE and LINK.
-*/
-
-enum rt_scope_t {
-	RT_SCOPE_UNIVERSE=0,
-/* User defined values  */
-	RT_SCOPE_SITE=200,
-	RT_SCOPE_LINK=253,
-	RT_SCOPE_HOST=254,
-	RT_SCOPE_NOWHERE=255
-};
-
-/* rtm_flags */
-
-#define RTM_F_NOTIFY		0x100	/* Notify user of route change	*/
-#define RTM_F_CLONED		0x200	/* This route is cloned		*/
-#define RTM_F_EQUALIZE		0x400	/* Multipath equalizer: NI	*/
-#define RTM_F_PREFIX		0x800	/* Prefix addresses		*/
-#define RTM_F_LOOKUP_TABLE	0x1000	/* set rtm_table to FIB lookup result */
-#define RTM_F_FIB_MATCH	        0x2000	/* return full fib lookup match */
-
-/* Reserved table identifiers */
-
-enum rt_class_t {
-	RT_TABLE_UNSPEC=0,
-/* User defined values */
-	RT_TABLE_COMPAT=252,
-	RT_TABLE_DEFAULT=253,
-	RT_TABLE_MAIN=254,
-	RT_TABLE_LOCAL=255,
-	RT_TABLE_MAX=0xFFFFFFFF
-};
-
-
-/* Routing message attributes */
-
-enum rtattr_type_t {
-	RTA_UNSPEC,
-	RTA_DST,
-	RTA_SRC,
-	RTA_IIF,
-	RTA_OIF,
-	RTA_GATEWAY,
-	RTA_PRIORITY,
-	RTA_PREFSRC,
-	RTA_METRICS,
-	RTA_MULTIPATH,
-	RTA_PROTOINFO, /* no longer used */
-	RTA_FLOW,
-	RTA_CACHEINFO,
-	RTA_SESSION, /* no longer used */
-	RTA_MP_ALGO, /* no longer used */
-	RTA_TABLE,
-	RTA_MARK,
-	RTA_MFC_STATS,
-	RTA_VIA,
-	RTA_NEWDST,
-	RTA_PREF,
-	RTA_ENCAP_TYPE,
-	RTA_ENCAP,
-	RTA_EXPIRES,
-	RTA_PAD,
-	RTA_UID,
-	RTA_TTL_PROPAGATE,
-	__RTA_MAX
-};
-
-#define RTA_MAX (__RTA_MAX - 1)
-
-#define RTM_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct rtmsg))))
-#define RTM_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct rtmsg))
-
-/* RTM_MULTIPATH --- array of struct rtnexthop.
- *
- * "struct rtnexthop" describes all necessary nexthop information,
- * i.e. parameters of path to a destination via this nexthop.
- *
- * At the moment it is impossible to set different prefsrc, mtu, window
- * and rtt for different paths from multipath.
- */
-
-struct rtnexthop {
-	unsigned short		rtnh_len;
-	unsigned char		rtnh_flags;
-	unsigned char		rtnh_hops;
-	int			rtnh_ifindex;
-};
-
-/* rtnh_flags */
-
-#define RTNH_F_DEAD		1	/* Nexthop is dead (used by multipath)	*/
-#define RTNH_F_PERVASIVE	2	/* Do recursive gateway lookup	*/
-#define RTNH_F_ONLINK		4	/* Gateway is forced on link	*/
-#define RTNH_F_OFFLOAD		8	/* offloaded route */
-#define RTNH_F_LINKDOWN		16	/* carrier-down on nexthop */
-#define RTNH_F_UNRESOLVED	32	/* The entry is unresolved (ipmr) */
-
-#define RTNH_COMPARE_MASK	(RTNH_F_DEAD | RTNH_F_LINKDOWN | RTNH_F_OFFLOAD)
-
-/* Macros to handle hexthops */
-
-#define RTNH_ALIGNTO	4
-#define RTNH_ALIGN(len) ( ((len)+RTNH_ALIGNTO-1) & ~(RTNH_ALIGNTO-1) )
-#define RTNH_OK(rtnh,len) ((rtnh)->rtnh_len >= sizeof(struct rtnexthop) && \
-			   ((int)(rtnh)->rtnh_len) <= (len))
-#define RTNH_NEXT(rtnh)	((struct rtnexthop*)(((char*)(rtnh)) + RTNH_ALIGN((rtnh)->rtnh_len)))
-#define RTNH_LENGTH(len) (RTNH_ALIGN(sizeof(struct rtnexthop)) + (len))
-#define RTNH_SPACE(len)	RTNH_ALIGN(RTNH_LENGTH(len))
-#define RTNH_DATA(rtnh)   ((struct rtattr*)(((char*)(rtnh)) + RTNH_LENGTH(0)))
-
-/* RTA_VIA */
-struct rtvia {
-	__kernel_sa_family_t	rtvia_family;
-	__u8			rtvia_addr[0];
-};
-
-/* RTM_CACHEINFO */
-
-struct rta_cacheinfo {
-	__u32	rta_clntref;
-	__u32	rta_lastuse;
-	__s32	rta_expires;
-	__u32	rta_error;
-	__u32	rta_used;
-
-#define RTNETLINK_HAVE_PEERINFO 1
-	__u32	rta_id;
-	__u32	rta_ts;
-	__u32	rta_tsage;
-};
-
-/* RTM_METRICS --- array of struct rtattr with types of RTAX_* */
-
-enum {
-	RTAX_UNSPEC,
-#define RTAX_UNSPEC RTAX_UNSPEC
-	RTAX_LOCK,
-#define RTAX_LOCK RTAX_LOCK
-	RTAX_MTU,
-#define RTAX_MTU RTAX_MTU
-	RTAX_WINDOW,
-#define RTAX_WINDOW RTAX_WINDOW
-	RTAX_RTT,
-#define RTAX_RTT RTAX_RTT
-	RTAX_RTTVAR,
-#define RTAX_RTTVAR RTAX_RTTVAR
-	RTAX_SSTHRESH,
-#define RTAX_SSTHRESH RTAX_SSTHRESH
-	RTAX_CWND,
-#define RTAX_CWND RTAX_CWND
-	RTAX_ADVMSS,
-#define RTAX_ADVMSS RTAX_ADVMSS
-	RTAX_REORDERING,
-#define RTAX_REORDERING RTAX_REORDERING
-	RTAX_HOPLIMIT,
-#define RTAX_HOPLIMIT RTAX_HOPLIMIT
-	RTAX_INITCWND,
-#define RTAX_INITCWND RTAX_INITCWND
-	RTAX_FEATURES,
-#define RTAX_FEATURES RTAX_FEATURES
-	RTAX_RTO_MIN,
-#define RTAX_RTO_MIN RTAX_RTO_MIN
-	RTAX_INITRWND,
-#define RTAX_INITRWND RTAX_INITRWND
-	RTAX_QUICKACK,
-#define RTAX_QUICKACK RTAX_QUICKACK
-	RTAX_CC_ALGO,
-#define RTAX_CC_ALGO RTAX_CC_ALGO
-	__RTAX_MAX
-};
-
-#define RTAX_MAX (__RTAX_MAX - 1)
-
-#define RTAX_FEATURE_ECN	(1 << 0)
-#define RTAX_FEATURE_SACK	(1 << 1)
-#define RTAX_FEATURE_TIMESTAMP	(1 << 2)
-#define RTAX_FEATURE_ALLFRAG	(1 << 3)
-
-#define RTAX_FEATURE_MASK	(RTAX_FEATURE_ECN | RTAX_FEATURE_SACK | \
-				 RTAX_FEATURE_TIMESTAMP | RTAX_FEATURE_ALLFRAG)
-
-struct rta_session {
-	__u8	proto;
-	__u8	pad1;
-	__u16	pad2;
-
-	union {
-		struct {
-			__u16	sport;
-			__u16	dport;
-		} ports;
-
-		struct {
-			__u8	type;
-			__u8	code;
-			__u16	ident;
-		} icmpt;
-
-		__u32		spi;
-	} u;
-};
-
-struct rta_mfc_stats {
-	__u64	mfcs_packets;
-	__u64	mfcs_bytes;
-	__u64	mfcs_wrong_if;
-};
-
-/****
- *		General form of address family dependent message.
- ****/
-
-struct rtgenmsg {
-	unsigned char		rtgen_family;
-};
-
-/*****************************************************************
- *		Link layer specific messages.
- ****/
-
-/* struct ifinfomsg
- * passes link level specific information, not dependent
- * on network protocol.
- */
-
-struct ifinfomsg {
-	unsigned char	ifi_family;
-	unsigned char	__ifi_pad;
-	unsigned short	ifi_type;		/* ARPHRD_* */
-	int		ifi_index;		/* Link index	*/
-	unsigned	ifi_flags;		/* IFF_* flags	*/
-	unsigned	ifi_change;		/* IFF_* change mask */
-};
-
-/********************************************************************
- *		prefix information 
- ****/
-
-struct prefixmsg {
-	unsigned char	prefix_family;
-	unsigned char	prefix_pad1;
-	unsigned short	prefix_pad2;
-	int		prefix_ifindex;
-	unsigned char	prefix_type;
-	unsigned char	prefix_len;
-	unsigned char	prefix_flags;
-	unsigned char	prefix_pad3;
-};
-
-enum 
-{
-	PREFIX_UNSPEC,
-	PREFIX_ADDRESS,
-	PREFIX_CACHEINFO,
-	__PREFIX_MAX
-};
-
-#define PREFIX_MAX	(__PREFIX_MAX - 1)
-
-struct prefix_cacheinfo {
-	__u32	preferred_time;
-	__u32	valid_time;
-};
-
-
-/*****************************************************************
- *		Traffic control messages.
- ****/
-
-struct tcmsg {
-	unsigned char	tcm_family;
-	unsigned char	tcm__pad1;
-	unsigned short	tcm__pad2;
-	int		tcm_ifindex;
-	__u32		tcm_handle;
-	__u32		tcm_parent;
-	__u32		tcm_info;
-};
-
-enum {
-	TCA_UNSPEC,
-	TCA_KIND,
-	TCA_OPTIONS,
-	TCA_STATS,
-	TCA_XSTATS,
-	TCA_RATE,
-	TCA_FCNT,
-	TCA_STATS2,
-	TCA_STAB,
-	TCA_PAD,
-	TCA_DUMP_INVISIBLE,
-	TCA_CHAIN,
-	__TCA_MAX
-};
-
-#define TCA_MAX (__TCA_MAX - 1)
-
-#define TCA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct tcmsg))))
-#define TCA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct tcmsg))
-
-/********************************************************************
- *		Neighbor Discovery userland options
- ****/
-
-struct nduseroptmsg {
-	unsigned char	nduseropt_family;
-	unsigned char	nduseropt_pad1;
-	unsigned short	nduseropt_opts_len;	/* Total length of options */
-	int		nduseropt_ifindex;
-	__u8		nduseropt_icmp_type;
-	__u8		nduseropt_icmp_code;
-	unsigned short	nduseropt_pad2;
-	unsigned int	nduseropt_pad3;
-	/* Followed by one or more ND options */
-};
-
-enum {
-	NDUSEROPT_UNSPEC,
-	NDUSEROPT_SRCADDR,
-	__NDUSEROPT_MAX
-};
-
-#define NDUSEROPT_MAX	(__NDUSEROPT_MAX - 1)
-
-/* RTnetlink multicast groups - backwards compatibility for userspace */
-#define RTMGRP_LINK		1
-#define RTMGRP_NOTIFY		2
-#define RTMGRP_NEIGH		4
-#define RTMGRP_TC		8
-
-#define RTMGRP_IPV4_IFADDR	0x10
-#define RTMGRP_IPV4_MROUTE	0x20
-#define RTMGRP_IPV4_ROUTE	0x40
-#define RTMGRP_IPV4_RULE	0x80
-
-#define RTMGRP_IPV6_IFADDR	0x100
-#define RTMGRP_IPV6_MROUTE	0x200
-#define RTMGRP_IPV6_ROUTE	0x400
-#define RTMGRP_IPV6_IFINFO	0x800
-
-#define RTMGRP_DECnet_IFADDR    0x1000
-#define RTMGRP_DECnet_ROUTE     0x4000
-
-#define RTMGRP_IPV6_PREFIX	0x20000
-
-/* RTnetlink multicast groups */
-enum rtnetlink_groups {
-	RTNLGRP_NONE,
-#define RTNLGRP_NONE		RTNLGRP_NONE
-	RTNLGRP_LINK,
-#define RTNLGRP_LINK		RTNLGRP_LINK
-	RTNLGRP_NOTIFY,
-#define RTNLGRP_NOTIFY		RTNLGRP_NOTIFY
-	RTNLGRP_NEIGH,
-#define RTNLGRP_NEIGH		RTNLGRP_NEIGH
-	RTNLGRP_TC,
-#define RTNLGRP_TC		RTNLGRP_TC
-	RTNLGRP_IPV4_IFADDR,
-#define RTNLGRP_IPV4_IFADDR	RTNLGRP_IPV4_IFADDR
-	RTNLGRP_IPV4_MROUTE,
-#define	RTNLGRP_IPV4_MROUTE	RTNLGRP_IPV4_MROUTE
-	RTNLGRP_IPV4_ROUTE,
-#define RTNLGRP_IPV4_ROUTE	RTNLGRP_IPV4_ROUTE
-	RTNLGRP_IPV4_RULE,
-#define RTNLGRP_IPV4_RULE	RTNLGRP_IPV4_RULE
-	RTNLGRP_IPV6_IFADDR,
-#define RTNLGRP_IPV6_IFADDR	RTNLGRP_IPV6_IFADDR
-	RTNLGRP_IPV6_MROUTE,
-#define RTNLGRP_IPV6_MROUTE	RTNLGRP_IPV6_MROUTE
-	RTNLGRP_IPV6_ROUTE,
-#define RTNLGRP_IPV6_ROUTE	RTNLGRP_IPV6_ROUTE
-	RTNLGRP_IPV6_IFINFO,
-#define RTNLGRP_IPV6_IFINFO	RTNLGRP_IPV6_IFINFO
-	RTNLGRP_DECnet_IFADDR,
-#define RTNLGRP_DECnet_IFADDR	RTNLGRP_DECnet_IFADDR
-	RTNLGRP_NOP2,
-	RTNLGRP_DECnet_ROUTE,
-#define RTNLGRP_DECnet_ROUTE	RTNLGRP_DECnet_ROUTE
-	RTNLGRP_DECnet_RULE,
-#define RTNLGRP_DECnet_RULE	RTNLGRP_DECnet_RULE
-	RTNLGRP_NOP4,
-	RTNLGRP_IPV6_PREFIX,
-#define RTNLGRP_IPV6_PREFIX	RTNLGRP_IPV6_PREFIX
-	RTNLGRP_IPV6_RULE,
-#define RTNLGRP_IPV6_RULE	RTNLGRP_IPV6_RULE
-	RTNLGRP_ND_USEROPT,
-#define RTNLGRP_ND_USEROPT	RTNLGRP_ND_USEROPT
-	RTNLGRP_PHONET_IFADDR,
-#define RTNLGRP_PHONET_IFADDR	RTNLGRP_PHONET_IFADDR
-	RTNLGRP_PHONET_ROUTE,
-#define RTNLGRP_PHONET_ROUTE	RTNLGRP_PHONET_ROUTE
-	RTNLGRP_DCB,
-#define RTNLGRP_DCB		RTNLGRP_DCB
-	RTNLGRP_IPV4_NETCONF,
-#define RTNLGRP_IPV4_NETCONF	RTNLGRP_IPV4_NETCONF
-	RTNLGRP_IPV6_NETCONF,
-#define RTNLGRP_IPV6_NETCONF	RTNLGRP_IPV6_NETCONF
-	RTNLGRP_MDB,
-#define RTNLGRP_MDB		RTNLGRP_MDB
-	RTNLGRP_MPLS_ROUTE,
-#define RTNLGRP_MPLS_ROUTE	RTNLGRP_MPLS_ROUTE
-	RTNLGRP_NSID,
-#define RTNLGRP_NSID		RTNLGRP_NSID
-	RTNLGRP_MPLS_NETCONF,
-#define RTNLGRP_MPLS_NETCONF	RTNLGRP_MPLS_NETCONF
-	RTNLGRP_IPV4_MROUTE_R,
-#define RTNLGRP_IPV4_MROUTE_R	RTNLGRP_IPV4_MROUTE_R
-	RTNLGRP_IPV6_MROUTE_R,
-#define RTNLGRP_IPV6_MROUTE_R	RTNLGRP_IPV6_MROUTE_R
-	__RTNLGRP_MAX
-};
-#define RTNLGRP_MAX	(__RTNLGRP_MAX - 1)
-
-/* TC action piece */
-struct tcamsg {
-	unsigned char	tca_family;
-	unsigned char	tca__pad1;
-	unsigned short	tca__pad2;
-};
-
-enum {
-	TCA_ROOT_UNSPEC,
-	TCA_ROOT_TAB,
-#define TCA_ACT_TAB TCA_ROOT_TAB
-#define TCAA_MAX TCA_ROOT_TAB
-	TCA_ROOT_FLAGS,
-	TCA_ROOT_COUNT,
-	TCA_ROOT_TIME_DELTA, /* in msecs */
-	__TCA_ROOT_MAX,
-#define	TCA_ROOT_MAX (__TCA_ROOT_MAX - 1)
-};
-
-#define TA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct tcamsg))))
-#define TA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct tcamsg))
-/* tcamsg flags stored in attribute TCA_ROOT_FLAGS
- *
- * TCA_FLAG_LARGE_DUMP_ON user->kernel to request for larger than TCA_ACT_MAX_PRIO
- * actions in a dump. All dump responses will contain the number of actions
- * being dumped stored in for user app's consumption in TCA_ROOT_COUNT
- *
- */
-#define TCA_FLAG_LARGE_DUMP_ON		(1 << 0)
-
-/* New extended info filters for IFLA_EXT_MASK */
-#define RTEXT_FILTER_VF		(1 << 0)
-#define RTEXT_FILTER_BRVLAN	(1 << 1)
-#define RTEXT_FILTER_BRVLAN_COMPRESSED	(1 << 2)
-#define	RTEXT_FILTER_SKIP_STATS	(1 << 3)
-
-/* End of information exported to user level */
-
-
-
-#endif /* __LINUX_RTNETLINK_H */
diff --git a/include/linux/sctp.h b/include/linux/sctp.h
deleted file mode 100644
index fec24c4..0000000
--- a/include/linux/sctp.h
+++ /dev/null
@@ -1,1085 +0,0 @@
-/* SCTP kernel implementation
- * (C) Copyright IBM Corp. 2001, 2004
- * Copyright (c) 1999-2000 Cisco, Inc.
- * Copyright (c) 1999-2001 Motorola, Inc.
- * Copyright (c) 2002 Intel Corp.
- *
- * This file is part of the SCTP kernel implementation
- *
- * This header represents the structures and constants needed to support
- * the SCTP Extension to the Sockets API.
- *
- * This SCTP implementation is free software;
- * you can redistribute it and/or modify it under the terms of
- * the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This SCTP implementation is distributed in the hope that it
- * will be useful, but WITHOUT ANY WARRANTY; without even the implied
- *                 ************************
- * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See the GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with GNU CC; see the file COPYING.  If not, see
- * <http://www.gnu.org/licenses/>.
- *
- * Please send any bug reports or fixes you make to the
- * email address(es):
- *    lksctp developers <linux-sctp@vger.kernel.org>
- *
- * Or submit a bug report through the following website:
- *    http://www.sf.net/projects/lksctp
- *
- * Written or modified by:
- *    La Monte H.P. Yarroll    <piggy@acm.org>
- *    R. Stewart               <randall@sctp.chicago.il.us>
- *    K. Morneau               <kmorneau@cisco.com>
- *    Q. Xie                   <qxie1@email.mot.com>
- *    Karl Knutson             <karl@athena.chicago.il.us>
- *    Jon Grimm                <jgrimm@us.ibm.com>
- *    Daisy Chang              <daisyc@us.ibm.com>
- *    Ryan Layer               <rmlayer@us.ibm.com>
- *    Ardelle Fan              <ardelle.fan@intel.com>
- *    Sridhar Samudrala        <sri@us.ibm.com>
- *    Inaky Perez-Gonzalez     <inaky.gonzalez@intel.com>
- *    Vlad Yasevich            <vladislav.yasevich@hp.com>
- *
- * Any bugs reported given to us we will try to fix... any fixes shared will
- * be incorporated into the next SCTP release.
- */
-
-#ifndef _SCTP_H
-#define _SCTP_H
-
-#include <linux/types.h>
-#include <linux/socket.h>
-
-typedef __s32 sctp_assoc_t;
-
-/* The following symbols come from the Sockets API Extensions for
- * SCTP <draft-ietf-tsvwg-sctpsocket-07.txt>.
- */
-#define SCTP_RTOINFO	0
-#define SCTP_ASSOCINFO  1
-#define SCTP_INITMSG	2
-#define SCTP_NODELAY	3		/* Get/set nodelay option. */
-#define SCTP_AUTOCLOSE	4
-#define SCTP_SET_PEER_PRIMARY_ADDR 5
-#define SCTP_PRIMARY_ADDR	6
-#define SCTP_ADAPTATION_LAYER	7
-#define SCTP_DISABLE_FRAGMENTS	8
-#define SCTP_PEER_ADDR_PARAMS	9
-#define SCTP_DEFAULT_SEND_PARAM	10
-#define SCTP_EVENTS	11
-#define SCTP_I_WANT_MAPPED_V4_ADDR 12	/* Turn on/off mapped v4 addresses  */
-#define SCTP_MAXSEG	13		/* Get/set maximum fragment. */
-#define SCTP_STATUS	14
-#define SCTP_GET_PEER_ADDR_INFO	15
-#define SCTP_DELAYED_ACK_TIME	16
-#define SCTP_DELAYED_ACK SCTP_DELAYED_ACK_TIME
-#define SCTP_DELAYED_SACK SCTP_DELAYED_ACK_TIME
-#define SCTP_CONTEXT	17
-#define SCTP_FRAGMENT_INTERLEAVE	18
-#define SCTP_PARTIAL_DELIVERY_POINT	19 /* Set/Get partial delivery point */
-#define SCTP_MAX_BURST	20		/* Set/Get max burst */
-#define SCTP_AUTH_CHUNK	21	/* Set only: add a chunk type to authenticate */
-#define SCTP_HMAC_IDENT	22
-#define SCTP_AUTH_KEY	23
-#define SCTP_AUTH_ACTIVE_KEY	24
-#define SCTP_AUTH_DELETE_KEY	25
-#define SCTP_PEER_AUTH_CHUNKS	26	/* Read only */
-#define SCTP_LOCAL_AUTH_CHUNKS	27	/* Read only */
-#define SCTP_GET_ASSOC_NUMBER	28	/* Read only */
-#define SCTP_GET_ASSOC_ID_LIST	29	/* Read only */
-#define SCTP_AUTO_ASCONF       30
-#define SCTP_PEER_ADDR_THLDS	31
-#define SCTP_RECVRCVINFO	32
-#define SCTP_RECVNXTINFO	33
-#define SCTP_DEFAULT_SNDINFO	34
-
-/* Internal Socket Options. Some of the sctp library functions are
- * implemented using these socket options.
- */
-#define SCTP_SOCKOPT_BINDX_ADD	100	/* BINDX requests for adding addrs */
-#define SCTP_SOCKOPT_BINDX_REM	101	/* BINDX requests for removing addrs. */
-#define SCTP_SOCKOPT_PEELOFF	102	/* peel off association. */
-/* Options 104-106 are deprecated and removed. Do not use this space */
-#define SCTP_SOCKOPT_CONNECTX_OLD	107	/* CONNECTX old requests. */
-#define SCTP_GET_PEER_ADDRS	108		/* Get all peer address. */
-#define SCTP_GET_LOCAL_ADDRS	109		/* Get all local address. */
-#define SCTP_SOCKOPT_CONNECTX	110		/* CONNECTX requests. */
-#define SCTP_SOCKOPT_CONNECTX3	111	/* CONNECTX requests (updated) */
-#define SCTP_GET_ASSOC_STATS	112	/* Read only */
-#define SCTP_PR_SUPPORTED	113
-#define SCTP_DEFAULT_PRINFO	114
-#define SCTP_PR_ASSOC_STATUS	115
-#define SCTP_PR_STREAM_STATUS	116
-#define SCTP_RECONFIG_SUPPORTED	117
-#define SCTP_ENABLE_STREAM_RESET	118
-#define SCTP_RESET_STREAMS	119
-#define SCTP_RESET_ASSOC	120
-#define SCTP_ADD_STREAMS	121
-#define SCTP_SOCKOPT_PEELOFF_FLAGS 122
-
-/* PR-SCTP policies */
-#define SCTP_PR_SCTP_NONE	0x0000
-#define SCTP_PR_SCTP_TTL	0x0010
-#define SCTP_PR_SCTP_RTX	0x0020
-#define SCTP_PR_SCTP_PRIO	0x0030
-#define SCTP_PR_SCTP_MAX	SCTP_PR_SCTP_PRIO
-#define SCTP_PR_SCTP_MASK	0x0030
-
-#define __SCTP_PR_INDEX(x)	((x >> 4) - 1)
-#define SCTP_PR_INDEX(x)	__SCTP_PR_INDEX(SCTP_PR_SCTP_ ## x)
-
-#define SCTP_PR_POLICY(x)	((x) & SCTP_PR_SCTP_MASK)
-#define SCTP_PR_SET_POLICY(flags, x)	\
-	do {				\
-		flags &= ~SCTP_PR_SCTP_MASK;	\
-		flags |= x;		\
-	} while (0)
-
-#define SCTP_PR_TTL_ENABLED(x)	(SCTP_PR_POLICY(x) == SCTP_PR_SCTP_TTL)
-#define SCTP_PR_RTX_ENABLED(x)	(SCTP_PR_POLICY(x) == SCTP_PR_SCTP_RTX)
-#define SCTP_PR_PRIO_ENABLED(x)	(SCTP_PR_POLICY(x) == SCTP_PR_SCTP_PRIO)
-
-/* For enable stream reset */
-#define SCTP_ENABLE_RESET_STREAM_REQ	0x01
-#define SCTP_ENABLE_RESET_ASSOC_REQ	0x02
-#define SCTP_ENABLE_CHANGE_ASSOC_REQ	0x04
-#define SCTP_ENABLE_STRRESET_MASK	0x07
-
-#define SCTP_STREAM_RESET_INCOMING	0x01
-#define SCTP_STREAM_RESET_OUTGOING	0x02
-
-/* These are bit fields for msghdr->msg_flags.  See section 5.1.  */
-/* On user space Linux, these live in <bits/socket.h> as an enum.  */
-enum sctp_msg_flags {
-	MSG_NOTIFICATION = 0x8000,
-#define MSG_NOTIFICATION MSG_NOTIFICATION
-};
-
-/* 5.3.1 SCTP Initiation Structure (SCTP_INIT)
- *
- *   This cmsghdr structure provides information for initializing new
- *   SCTP associations with sendmsg().  The SCTP_INITMSG socket option
- *   uses this same data structure.  This structure is not used for
- *   recvmsg().
- *
- *   cmsg_level    cmsg_type      cmsg_data[]
- *   ------------  ------------   ----------------------
- *   IPPROTO_SCTP  SCTP_INIT      struct sctp_initmsg
- */
-struct sctp_initmsg {
-	__u16 sinit_num_ostreams;
-	__u16 sinit_max_instreams;
-	__u16 sinit_max_attempts;
-	__u16 sinit_max_init_timeo;
-};
-
-/* 5.3.2 SCTP Header Information Structure (SCTP_SNDRCV)
- *
- *   This cmsghdr structure specifies SCTP options for sendmsg() and
- *   describes SCTP header information about a received message through
- *   recvmsg().
- *
- *   cmsg_level    cmsg_type      cmsg_data[]
- *   ------------  ------------   ----------------------
- *   IPPROTO_SCTP  SCTP_SNDRCV    struct sctp_sndrcvinfo
- */
-struct sctp_sndrcvinfo {
-	__u16 sinfo_stream;
-	__u16 sinfo_ssn;
-	__u16 sinfo_flags;
-	__u32 sinfo_ppid;
-	__u32 sinfo_context;
-	__u32 sinfo_timetolive;
-	__u32 sinfo_tsn;
-	__u32 sinfo_cumtsn;
-	sctp_assoc_t sinfo_assoc_id;
-};
-
-/* 5.3.4 SCTP Send Information Structure (SCTP_SNDINFO)
- *
- *   This cmsghdr structure specifies SCTP options for sendmsg().
- *
- *   cmsg_level    cmsg_type      cmsg_data[]
- *   ------------  ------------   -------------------
- *   IPPROTO_SCTP  SCTP_SNDINFO   struct sctp_sndinfo
- */
-struct sctp_sndinfo {
-	__u16 snd_sid;
-	__u16 snd_flags;
-	__u32 snd_ppid;
-	__u32 snd_context;
-	sctp_assoc_t snd_assoc_id;
-};
-
-/* 5.3.5 SCTP Receive Information Structure (SCTP_RCVINFO)
- *
- *   This cmsghdr structure describes SCTP receive information
- *   about a received message through recvmsg().
- *
- *   cmsg_level    cmsg_type      cmsg_data[]
- *   ------------  ------------   -------------------
- *   IPPROTO_SCTP  SCTP_RCVINFO   struct sctp_rcvinfo
- */
-struct sctp_rcvinfo {
-	__u16 rcv_sid;
-	__u16 rcv_ssn;
-	__u16 rcv_flags;
-	__u32 rcv_ppid;
-	__u32 rcv_tsn;
-	__u32 rcv_cumtsn;
-	__u32 rcv_context;
-	sctp_assoc_t rcv_assoc_id;
-};
-
-/* 5.3.6 SCTP Next Receive Information Structure (SCTP_NXTINFO)
- *
- *   This cmsghdr structure describes SCTP receive information
- *   of the next message that will be delivered through recvmsg()
- *   if this information is already available when delivering
- *   the current message.
- *
- *   cmsg_level    cmsg_type      cmsg_data[]
- *   ------------  ------------   -------------------
- *   IPPROTO_SCTP  SCTP_NXTINFO   struct sctp_nxtinfo
- */
-struct sctp_nxtinfo {
-	__u16 nxt_sid;
-	__u16 nxt_flags;
-	__u32 nxt_ppid;
-	__u32 nxt_length;
-	sctp_assoc_t nxt_assoc_id;
-};
-
-/*
- *  sinfo_flags: 16 bits (unsigned integer)
- *
- *   This field may contain any of the following flags and is composed of
- *   a bitwise OR of these values.
- */
-enum sctp_sinfo_flags {
-	SCTP_UNORDERED		= (1 << 0), /* Send/receive message unordered. */
-	SCTP_ADDR_OVER		= (1 << 1), /* Override the primary destination. */
-	SCTP_ABORT		= (1 << 2), /* Send an ABORT message to the peer. */
-	SCTP_SACK_IMMEDIATELY	= (1 << 3), /* SACK should be sent without delay. */
-	SCTP_NOTIFICATION	= MSG_NOTIFICATION, /* Next message is not user msg but notification. */
-	SCTP_EOF		= MSG_FIN,  /* Initiate graceful shutdown process. */
-};
-
-typedef union {
-	__u8   			raw;
-	struct sctp_initmsg	init;
-	struct sctp_sndrcvinfo	sndrcv;
-} sctp_cmsg_data_t;
-
-/* These are cmsg_types.  */
-typedef enum sctp_cmsg_type {
-	SCTP_INIT,		/* 5.2.1 SCTP Initiation Structure */
-#define SCTP_INIT	SCTP_INIT
-	SCTP_SNDRCV,		/* 5.2.2 SCTP Header Information Structure */
-#define SCTP_SNDRCV	SCTP_SNDRCV
-	SCTP_SNDINFO,		/* 5.3.4 SCTP Send Information Structure */
-#define SCTP_SNDINFO	SCTP_SNDINFO
-	SCTP_RCVINFO,		/* 5.3.5 SCTP Receive Information Structure */
-#define SCTP_RCVINFO	SCTP_RCVINFO
-	SCTP_NXTINFO,		/* 5.3.6 SCTP Next Receive Information Structure */
-#define SCTP_NXTINFO	SCTP_NXTINFO
-} sctp_cmsg_t;
-
-/*
- * 5.3.1.1 SCTP_ASSOC_CHANGE
- *
- *   Communication notifications inform the ULP that an SCTP association
- *   has either begun or ended. The identifier for a new association is
- *   provided by this notificaion. The notification information has the
- *   following format:
- *
- */
-struct sctp_assoc_change {
-	__u16 sac_type;
-	__u16 sac_flags;
-	__u32 sac_length;
-	__u16 sac_state;
-	__u16 sac_error;
-	__u16 sac_outbound_streams;
-	__u16 sac_inbound_streams;
-	sctp_assoc_t sac_assoc_id;
-	__u8 sac_info[0];
-};
-
-/*
- *   sac_state: 32 bits (signed integer)
- *
- *   This field holds one of a number of values that communicate the
- *   event that happened to the association.  They include:
- *
- *   Note:  The following state names deviate from the API draft as
- *   the names clash too easily with other kernel symbols.
- */
-enum sctp_sac_state {
-	SCTP_COMM_UP,
-	SCTP_COMM_LOST,
-	SCTP_RESTART,
-	SCTP_SHUTDOWN_COMP,
-	SCTP_CANT_STR_ASSOC,
-};
-
-/*
- * 5.3.1.2 SCTP_PEER_ADDR_CHANGE
- *
- *   When a destination address on a multi-homed peer encounters a change
- *   an interface details event is sent.  The information has the
- *   following structure:
- */
-struct sctp_paddr_change {
-	__u16 spc_type;
-	__u16 spc_flags;
-	__u32 spc_length;
-	struct sockaddr_storage spc_aaddr;
-	int spc_state;
-	int spc_error;
-	sctp_assoc_t spc_assoc_id;
-} __attribute__((packed, aligned(4)));
-
-/*
- *    spc_state:  32 bits (signed integer)
- *
- *   This field holds one of a number of values that communicate the
- *   event that happened to the address.  They include:
- */
-enum sctp_spc_state {
-	SCTP_ADDR_AVAILABLE,
-	SCTP_ADDR_UNREACHABLE,
-	SCTP_ADDR_REMOVED,
-	SCTP_ADDR_ADDED,
-	SCTP_ADDR_MADE_PRIM,
-	SCTP_ADDR_CONFIRMED,
-};
-
-
-/*
- * 5.3.1.3 SCTP_REMOTE_ERROR
- *
- *   A remote peer may send an Operational Error message to its peer.
- *   This message indicates a variety of error conditions on an
- *   association. The entire error TLV as it appears on the wire is
- *   included in a SCTP_REMOTE_ERROR event.  Please refer to the SCTP
- *   specification [SCTP] and any extensions for a list of possible
- *   error formats. SCTP error TLVs have the format:
- */
-struct sctp_remote_error {
-	__u16 sre_type;
-	__u16 sre_flags;
-	__u32 sre_length;
-	__u16 sre_error;
-	sctp_assoc_t sre_assoc_id;
-	__u8 sre_data[0];
-};
-
-
-/*
- * 5.3.1.4 SCTP_SEND_FAILED
- *
- *   If SCTP cannot deliver a message it may return the message as a
- *   notification.
- */
-struct sctp_send_failed {
-	__u16 ssf_type;
-	__u16 ssf_flags;
-	__u32 ssf_length;
-	__u32 ssf_error;
-	struct sctp_sndrcvinfo ssf_info;
-	sctp_assoc_t ssf_assoc_id;
-	__u8 ssf_data[0];
-};
-
-/*
- *   ssf_flags: 16 bits (unsigned integer)
- *
- *   The flag value will take one of the following values
- *
- *   SCTP_DATA_UNSENT  - Indicates that the data was never put on
- *                       the wire.
- *
- *   SCTP_DATA_SENT    - Indicates that the data was put on the wire.
- *                       Note that this does not necessarily mean that the
- *                       data was (or was not) successfully delivered.
- */
-enum sctp_ssf_flags {
-	SCTP_DATA_UNSENT,
-	SCTP_DATA_SENT,
-};
-
-/*
- * 5.3.1.5 SCTP_SHUTDOWN_EVENT
- *
- *   When a peer sends a SHUTDOWN, SCTP delivers this notification to
- *   inform the application that it should cease sending data.
- */
-struct sctp_shutdown_event {
-	__u16 sse_type;
-	__u16 sse_flags;
-	__u32 sse_length;
-	sctp_assoc_t sse_assoc_id;
-};
-
-/*
- * 5.3.1.6 SCTP_ADAPTATION_INDICATION
- *
- *   When a peer sends a Adaptation Layer Indication parameter , SCTP
- *   delivers this notification to inform the application
- *   that of the peers requested adaptation layer.
- */
-struct sctp_adaptation_event {
-	__u16 sai_type;
-	__u16 sai_flags;
-	__u32 sai_length;
-	__u32 sai_adaptation_ind;
-	sctp_assoc_t sai_assoc_id;
-};
-
-/*
- * 5.3.1.7 SCTP_PARTIAL_DELIVERY_EVENT
- *
- *   When a receiver is engaged in a partial delivery of a
- *   message this notification will be used to indicate
- *   various events.
- */
-struct sctp_pdapi_event {
-	__u16 pdapi_type;
-	__u16 pdapi_flags;
-	__u32 pdapi_length;
-	__u32 pdapi_indication;
-	sctp_assoc_t pdapi_assoc_id;
-};
-
-enum { SCTP_PARTIAL_DELIVERY_ABORTED=0, };
-
-/*
- * 5.3.1.8.  SCTP_AUTHENTICATION_EVENT
- *
- *  When a receiver is using authentication this message will provide
- *  notifications regarding new keys being made active as well as errors.
- */
-struct sctp_authkey_event {
-	__u16 auth_type;
-	__u16 auth_flags;
-	__u32 auth_length;
-	__u16 auth_keynumber;
-	__u16 auth_altkeynumber;
-	__u32 auth_indication;
-	sctp_assoc_t auth_assoc_id;
-};
-
-enum { SCTP_AUTH_NEWKEY = 0, };
-
-/*
- * 6.1.9. SCTP_SENDER_DRY_EVENT
- *
- * When the SCTP stack has no more user data to send or retransmit, this
- * notification is given to the user. Also, at the time when a user app
- * subscribes to this event, if there is no data to be sent or
- * retransmit, the stack will immediately send up this notification.
- */
-struct sctp_sender_dry_event {
-	__u16 sender_dry_type;
-	__u16 sender_dry_flags;
-	__u32 sender_dry_length;
-	sctp_assoc_t sender_dry_assoc_id;
-};
-
-#define SCTP_STREAM_RESET_INCOMING_SSN	0x0001
-#define SCTP_STREAM_RESET_OUTGOING_SSN	0x0002
-#define SCTP_STREAM_RESET_DENIED	0x0004
-#define SCTP_STREAM_RESET_FAILED	0x0008
-struct sctp_stream_reset_event {
-	__u16 strreset_type;
-	__u16 strreset_flags;
-	__u32 strreset_length;
-	sctp_assoc_t strreset_assoc_id;
-	__u16 strreset_stream_list[];
-};
-
-#define SCTP_ASSOC_RESET_DENIED		0x0004
-#define SCTP_ASSOC_RESET_FAILED		0x0008
-struct sctp_assoc_reset_event {
-	__u16 assocreset_type;
-	__u16 assocreset_flags;
-	__u32 assocreset_length;
-	sctp_assoc_t assocreset_assoc_id;
-	__u32 assocreset_local_tsn;
-	__u32 assocreset_remote_tsn;
-};
-
-#define SCTP_ASSOC_CHANGE_DENIED	0x0004
-#define SCTP_ASSOC_CHANGE_FAILED	0x0008
-struct sctp_stream_change_event {
-	__u16 strchange_type;
-	__u16 strchange_flags;
-	__u32 strchange_length;
-	sctp_assoc_t strchange_assoc_id;
-	__u16 strchange_instrms;
-	__u16 strchange_outstrms;
-};
-
-/*
- * Described in Section 7.3
- *   Ancillary Data and Notification Interest Options
- */
-struct sctp_event_subscribe {
-	__u8 sctp_data_io_event;
-	__u8 sctp_association_event;
-	__u8 sctp_address_event;
-	__u8 sctp_send_failure_event;
-	__u8 sctp_peer_error_event;
-	__u8 sctp_shutdown_event;
-	__u8 sctp_partial_delivery_event;
-	__u8 sctp_adaptation_layer_event;
-	__u8 sctp_authentication_event;
-	__u8 sctp_sender_dry_event;
-	__u8 sctp_stream_reset_event;
-	__u8 sctp_assoc_reset_event;
-	__u8 sctp_stream_change_event;
-};
-
-/*
- * 5.3.1 SCTP Notification Structure
- *
- *   The notification structure is defined as the union of all
- *   notification types.
- *
- */
-union sctp_notification {
-	struct {
-		__u16 sn_type;             /* Notification type. */
-		__u16 sn_flags;
-		__u32 sn_length;
-	} sn_header;
-	struct sctp_assoc_change sn_assoc_change;
-	struct sctp_paddr_change sn_paddr_change;
-	struct sctp_remote_error sn_remote_error;
-	struct sctp_send_failed sn_send_failed;
-	struct sctp_shutdown_event sn_shutdown_event;
-	struct sctp_adaptation_event sn_adaptation_event;
-	struct sctp_pdapi_event sn_pdapi_event;
-	struct sctp_authkey_event sn_authkey_event;
-	struct sctp_sender_dry_event sn_sender_dry_event;
-	struct sctp_stream_reset_event sn_strreset_event;
-	struct sctp_assoc_reset_event sn_assocreset_event;
-	struct sctp_stream_change_event sn_strchange_event;
-};
-
-/* Section 5.3.1
- * All standard values for sn_type flags are greater than 2^15.
- * Values from 2^15 and down are reserved.
- */
-
-enum sctp_sn_type {
-	SCTP_SN_TYPE_BASE     = (1<<15),
-	SCTP_ASSOC_CHANGE,
-#define SCTP_ASSOC_CHANGE		SCTP_ASSOC_CHANGE
-	SCTP_PEER_ADDR_CHANGE,
-#define SCTP_PEER_ADDR_CHANGE		SCTP_PEER_ADDR_CHANGE
-	SCTP_SEND_FAILED,
-#define SCTP_SEND_FAILED		SCTP_SEND_FAILED
-	SCTP_REMOTE_ERROR,
-#define SCTP_REMOTE_ERROR		SCTP_REMOTE_ERROR
-	SCTP_SHUTDOWN_EVENT,
-#define SCTP_SHUTDOWN_EVENT		SCTP_SHUTDOWN_EVENT
-	SCTP_PARTIAL_DELIVERY_EVENT,
-#define SCTP_PARTIAL_DELIVERY_EVENT	SCTP_PARTIAL_DELIVERY_EVENT
-	SCTP_ADAPTATION_INDICATION,
-#define SCTP_ADAPTATION_INDICATION	SCTP_ADAPTATION_INDICATION
-	SCTP_AUTHENTICATION_EVENT,
-#define SCTP_AUTHENTICATION_INDICATION	SCTP_AUTHENTICATION_EVENT
-	SCTP_SENDER_DRY_EVENT,
-#define SCTP_SENDER_DRY_EVENT		SCTP_SENDER_DRY_EVENT
-	SCTP_STREAM_RESET_EVENT,
-#define SCTP_STREAM_RESET_EVENT		SCTP_STREAM_RESET_EVENT
-	SCTP_ASSOC_RESET_EVENT,
-#define SCTP_ASSOC_RESET_EVENT		SCTP_ASSOC_RESET_EVENT
-	SCTP_STREAM_CHANGE_EVENT,
-#define SCTP_STREAM_CHANGE_EVENT	SCTP_STREAM_CHANGE_EVENT
-};
-
-/* Notification error codes used to fill up the error fields in some
- * notifications.
- * SCTP_PEER_ADDRESS_CHAGE 	: spc_error
- * SCTP_ASSOC_CHANGE		: sac_error
- * These names should be potentially included in the draft 04 of the SCTP
- * sockets API specification.
- */
-typedef enum sctp_sn_error {
-	SCTP_FAILED_THRESHOLD,
-	SCTP_RECEIVED_SACK,
-	SCTP_HEARTBEAT_SUCCESS,
-	SCTP_RESPONSE_TO_USER_REQ,
-	SCTP_INTERNAL_ERROR,
-	SCTP_SHUTDOWN_GUARD_EXPIRES,
-	SCTP_PEER_FAULTY,
-} sctp_sn_error_t;
-
-/*
- * 7.1.1 Retransmission Timeout Parameters (SCTP_RTOINFO)
- *
- *   The protocol parameters used to initialize and bound retransmission
- *   timeout (RTO) are tunable.  See [SCTP] for more information on how
- *   these parameters are used in RTO calculation.
- */
-struct sctp_rtoinfo {
-	sctp_assoc_t	srto_assoc_id;
-	__u32		srto_initial;
-	__u32		srto_max;
-	__u32		srto_min;
-};
-
-/*
- * 7.1.2 Association Parameters (SCTP_ASSOCINFO)
- *
- *   This option is used to both examine and set various association and
- *   endpoint parameters.
- */
-struct sctp_assocparams {
-	sctp_assoc_t	sasoc_assoc_id;
-	__u16		sasoc_asocmaxrxt;
-	__u16		sasoc_number_peer_destinations;
-	__u32		sasoc_peer_rwnd;
-	__u32		sasoc_local_rwnd;
-	__u32		sasoc_cookie_life;
-};
-
-/*
- * 7.1.9 Set Peer Primary Address (SCTP_SET_PEER_PRIMARY_ADDR)
- *
- *  Requests that the peer mark the enclosed address as the association
- *  primary. The enclosed address must be one of the association's
- *  locally bound addresses. The following structure is used to make a
- *   set primary request:
- */
-struct sctp_setpeerprim {
-	sctp_assoc_t            sspp_assoc_id;
-	struct sockaddr_storage sspp_addr;
-} __attribute__((packed, aligned(4)));
-
-/*
- * 7.1.10 Set Primary Address (SCTP_PRIMARY_ADDR)
- *
- *  Requests that the local SCTP stack use the enclosed peer address as
- *  the association primary. The enclosed address must be one of the
- *  association peer's addresses. The following structure is used to
- *  make a set peer primary request:
- */
-struct sctp_prim {
-	sctp_assoc_t            ssp_assoc_id;
-	struct sockaddr_storage ssp_addr;
-} __attribute__((packed, aligned(4)));
-
-/* For backward compatibility use, define the old name too */
-#define sctp_setprim	sctp_prim
-
-/*
- * 7.1.11 Set Adaptation Layer Indicator (SCTP_ADAPTATION_LAYER)
- *
- * Requests that the local endpoint set the specified Adaptation Layer
- * Indication parameter for all future INIT and INIT-ACK exchanges.
- */
-struct sctp_setadaptation {
-	__u32	ssb_adaptation_ind;
-};
-
-/*
- * 7.1.13 Peer Address Parameters  (SCTP_PEER_ADDR_PARAMS)
- *
- *   Applications can enable or disable heartbeats for any peer address
- *   of an association, modify an address's heartbeat interval, force a
- *   heartbeat to be sent immediately, and adjust the address's maximum
- *   number of retransmissions sent before an address is considered
- *   unreachable. The following structure is used to access and modify an
- *   address's parameters:
- */
-enum  sctp_spp_flags {
-	SPP_HB_ENABLE = 1<<0,		/*Enable heartbeats*/
-	SPP_HB_DISABLE = 1<<1,		/*Disable heartbeats*/
-	SPP_HB = SPP_HB_ENABLE | SPP_HB_DISABLE,
-	SPP_HB_DEMAND = 1<<2,		/*Send heartbeat immediately*/
-	SPP_PMTUD_ENABLE = 1<<3,	/*Enable PMTU discovery*/
-	SPP_PMTUD_DISABLE = 1<<4,	/*Disable PMTU discovery*/
-	SPP_PMTUD = SPP_PMTUD_ENABLE | SPP_PMTUD_DISABLE,
-	SPP_SACKDELAY_ENABLE = 1<<5,	/*Enable SACK*/
-	SPP_SACKDELAY_DISABLE = 1<<6,	/*Disable SACK*/
-	SPP_SACKDELAY = SPP_SACKDELAY_ENABLE | SPP_SACKDELAY_DISABLE,
-	SPP_HB_TIME_IS_ZERO = 1<<7,	/* Set HB delay to 0 */
-};
-
-struct sctp_paddrparams {
-	sctp_assoc_t		spp_assoc_id;
-	struct sockaddr_storage	spp_address;
-	__u32			spp_hbinterval;
-	__u16			spp_pathmaxrxt;
-	__u32			spp_pathmtu;
-	__u32			spp_sackdelay;
-	__u32			spp_flags;
-} __attribute__((packed, aligned(4)));
-
-/*
- * 7.1.18.  Add a chunk that must be authenticated (SCTP_AUTH_CHUNK)
- *
- * This set option adds a chunk type that the user is requesting to be
- * received only in an authenticated way.  Changes to the list of chunks
- * will only effect future associations on the socket.
- */
-struct sctp_authchunk {
-	__u8		sauth_chunk;
-};
-
-/*
- * 7.1.19.  Get or set the list of supported HMAC Identifiers (SCTP_HMAC_IDENT)
- *
- * This option gets or sets the list of HMAC algorithms that the local
- * endpoint requires the peer to use.
- */
-/* This here is only used by user space as is. It might not be a good idea
- * to export/reveal the whole structure with reserved fields etc.
- */
-enum {
-	SCTP_AUTH_HMAC_ID_SHA1 = 1,
-	SCTP_AUTH_HMAC_ID_SHA256 = 3,
-};
-
-struct sctp_hmacalgo {
-	__u32		shmac_num_idents;
-	__u16		shmac_idents[];
-};
-
-/* Sadly, user and kernel space have different names for
- * this structure member, so this is to not break anything.
- */
-#define shmac_number_of_idents	shmac_num_idents
-
-/*
- * 7.1.20.  Set a shared key (SCTP_AUTH_KEY)
- *
- * This option will set a shared secret key which is used to build an
- * association shared key.
- */
-struct sctp_authkey {
-	sctp_assoc_t	sca_assoc_id;
-	__u16		sca_keynumber;
-	__u16		sca_keylength;
-	__u8		sca_key[];
-};
-
-/*
- * 7.1.21.  Get or set the active shared key (SCTP_AUTH_ACTIVE_KEY)
- *
- * This option will get or set the active shared key to be used to build
- * the association shared key.
- */
-
-struct sctp_authkeyid {
-	sctp_assoc_t	scact_assoc_id;
-	__u16		scact_keynumber;
-};
-
-
-/*
- * 7.1.23.  Get or set delayed ack timer (SCTP_DELAYED_SACK)
- *
- * This option will effect the way delayed acks are performed.  This
- * option allows you to get or set the delayed ack time, in
- * milliseconds.  It also allows changing the delayed ack frequency.
- * Changing the frequency to 1 disables the delayed sack algorithm.  If
- * the assoc_id is 0, then this sets or gets the endpoints default
- * values.  If the assoc_id field is non-zero, then the set or get
- * effects the specified association for the one to many model (the
- * assoc_id field is ignored by the one to one model).  Note that if
- * sack_delay or sack_freq are 0 when setting this option, then the
- * current values will remain unchanged.
- */
-struct sctp_sack_info {
-	sctp_assoc_t	sack_assoc_id;
-	uint32_t	sack_delay;
-	uint32_t	sack_freq;
-};
-
-struct sctp_assoc_value {
-    sctp_assoc_t            assoc_id;
-    uint32_t                assoc_value;
-};
-
-/*
- * 7.2.2 Peer Address Information
- *
- *   Applications can retrieve information about a specific peer address
- *   of an association, including its reachability state, congestion
- *   window, and retransmission timer values.  This information is
- *   read-only. The following structure is used to access this
- *   information:
- */
-struct sctp_paddrinfo {
-	sctp_assoc_t		spinfo_assoc_id;
-	struct sockaddr_storage	spinfo_address;
-	__s32			spinfo_state;
-	__u32			spinfo_cwnd;
-	__u32			spinfo_srtt;
-	__u32			spinfo_rto;
-	__u32			spinfo_mtu;
-} __attribute__((packed, aligned(4)));
-
-/* Peer addresses's state. */
-/* UNKNOWN: Peer address passed by the upper layer in sendmsg or connect[x]
- * calls.
- * UNCONFIRMED: Peer address received in INIT/INIT-ACK address parameters.
- *              Not yet confirmed by a heartbeat and not available for data
- *		transfers.
- * ACTIVE : Peer address confirmed, active and available for data transfers.
- * INACTIVE: Peer address inactive and not available for data transfers.
- */
-enum sctp_spinfo_state {
-	SCTP_INACTIVE,
-	SCTP_PF,
-	SCTP_ACTIVE,
-	SCTP_UNCONFIRMED,
-	SCTP_UNKNOWN = 0xffff  /* Value used for transport state unknown */
-};
-
-/*
- * 7.2.1 Association Status (SCTP_STATUS)
- *
- *   Applications can retrieve current status information about an
- *   association, including association state, peer receiver window size,
- *   number of unacked data chunks, and number of data chunks pending
- *   receipt.  This information is read-only.  The following structure is
- *   used to access this information:
- */
-struct sctp_status {
-	sctp_assoc_t		sstat_assoc_id;
-	__s32			sstat_state;
-	__u32			sstat_rwnd;
-	__u16			sstat_unackdata;
-	__u16			sstat_penddata;
-	__u16			sstat_instrms;
-	__u16			sstat_outstrms;
-	__u32			sstat_fragmentation_point;
-	struct sctp_paddrinfo	sstat_primary;
-};
-
-/*
- * 7.2.3.  Get the list of chunks the peer requires to be authenticated
- *         (SCTP_PEER_AUTH_CHUNKS)
- *
- * This option gets a list of chunks for a specified association that
- * the peer requires to be received authenticated only.
- */
-struct sctp_authchunks {
-	sctp_assoc_t	gauth_assoc_id;
-	__u32		gauth_number_of_chunks;
-	uint8_t		gauth_chunks[];
-};
-
-/* The broken spelling has been released already in lksctp-tools header,
- * so don't break anyone, now that it's fixed.
- */
-#define guth_number_of_chunks	gauth_number_of_chunks
-
-/* Association states.  */
-enum sctp_sstat_state {
-	SCTP_EMPTY                = 0,
-	SCTP_CLOSED               = 1,
-	SCTP_COOKIE_WAIT          = 2,
-	SCTP_COOKIE_ECHOED        = 3,
-	SCTP_ESTABLISHED          = 4,
-	SCTP_SHUTDOWN_PENDING     = 5,
-	SCTP_SHUTDOWN_SENT        = 6,
-	SCTP_SHUTDOWN_RECEIVED    = 7,
-	SCTP_SHUTDOWN_ACK_SENT    = 8,
-};
-
-/*
- * 8.2.6. Get the Current Identifiers of Associations
- *        (SCTP_GET_ASSOC_ID_LIST)
- *
- * This option gets the current list of SCTP association identifiers of
- * the SCTP associations handled by a one-to-many style socket.
- */
-struct sctp_assoc_ids {
-	__u32		gaids_number_of_ids;
-	sctp_assoc_t	gaids_assoc_id[];
-};
-
-/*
- * 8.3, 8.5 get all peer/local addresses in an association.
- * This parameter struct is used by SCTP_GET_PEER_ADDRS and
- * SCTP_GET_LOCAL_ADDRS socket options used internally to implement
- * sctp_getpaddrs() and sctp_getladdrs() API.
- */
-struct sctp_getaddrs_old {
-	sctp_assoc_t            assoc_id;
-	int			addr_num;
-	struct sockaddr		*addrs;
-};
-
-struct sctp_getaddrs {
-	sctp_assoc_t		assoc_id; /*input*/
-	__u32			addr_num; /*output*/
-	__u8			addrs[0]; /*output, variable size*/
-};
-
-/* A socket user request obtained via SCTP_GET_ASSOC_STATS that retrieves
- * association stats. All stats are counts except sas_maxrto and
- * sas_obs_rto_ipaddr. maxrto is the max observed rto + transport since
- * the last call. Will return 0 when RTO was not update since last call
- */
-struct sctp_assoc_stats {
-	sctp_assoc_t	sas_assoc_id;    /* Input */
-					 /* Transport of observed max RTO */
-	struct sockaddr_storage sas_obs_rto_ipaddr;
-	__u64		sas_maxrto;      /* Maximum Observed RTO for period */
-	__u64		sas_isacks;	 /* SACKs received */
-	__u64		sas_osacks;	 /* SACKs sent */
-	__u64		sas_opackets;	 /* Packets sent */
-	__u64		sas_ipackets;	 /* Packets received */
-	__u64		sas_rtxchunks;   /* Retransmitted Chunks */
-	__u64		sas_outofseqtsns;/* TSN received > next expected */
-	__u64		sas_idupchunks;  /* Dups received (ordered+unordered) */
-	__u64		sas_gapcnt;      /* Gap Acknowledgements Received */
-	__u64		sas_ouodchunks;  /* Unordered data chunks sent */
-	__u64		sas_iuodchunks;  /* Unordered data chunks received */
-	__u64		sas_oodchunks;	 /* Ordered data chunks sent */
-	__u64		sas_iodchunks;	 /* Ordered data chunks received */
-	__u64		sas_octrlchunks; /* Control chunks sent */
-	__u64		sas_ictrlchunks; /* Control chunks received */
-};
-
-/*
- * 8.1 sctp_bindx()
- *
- * The flags parameter is formed from the bitwise OR of zero or more of the
- * following currently defined flags:
- */
-#define SCTP_BINDX_ADD_ADDR 0x01
-#define SCTP_BINDX_REM_ADDR 0x02
-
-/* This is the structure that is passed as an argument(optval) to
- * getsockopt(SCTP_SOCKOPT_PEELOFF).
- */
-typedef struct {
-	sctp_assoc_t associd;
-	int sd;
-} sctp_peeloff_arg_t;
-
-typedef struct {
-	sctp_peeloff_arg_t p_arg;
-	unsigned flags;
-} sctp_peeloff_flags_arg_t;
-
-/*
- *  Peer Address Thresholds socket option
- */
-struct sctp_paddrthlds {
-	sctp_assoc_t spt_assoc_id;
-	struct sockaddr_storage spt_address;
-	__u16 spt_pathmaxrxt;
-	__u16 spt_pathpfthld;
-};
-
-/*
- * Socket Option for Getting the Association/Stream-Specific PR-SCTP Status
- */
-struct sctp_prstatus {
-	sctp_assoc_t sprstat_assoc_id;
-	__u16 sprstat_sid;
-	__u16 sprstat_policy;
-	__u64 sprstat_abandoned_unsent;
-	__u64 sprstat_abandoned_sent;
-};
-
-struct sctp_default_prinfo {
-	sctp_assoc_t pr_assoc_id;
-	__u32 pr_value;
-	__u16 pr_policy;
-};
-
-struct sctp_info {
-	__u32	sctpi_tag;
-	__u32	sctpi_state;
-	__u32	sctpi_rwnd;
-	__u16	sctpi_unackdata;
-	__u16	sctpi_penddata;
-	__u16	sctpi_instrms;
-	__u16	sctpi_outstrms;
-	__u32	sctpi_fragmentation_point;
-	__u32	sctpi_inqueue;
-	__u32	sctpi_outqueue;
-	__u32	sctpi_overall_error;
-	__u32	sctpi_max_burst;
-	__u32	sctpi_maxseg;
-	__u32	sctpi_peer_rwnd;
-	__u32	sctpi_peer_tag;
-	__u8	sctpi_peer_capable;
-	__u8	sctpi_peer_sack;
-	__u16	__reserved1;
-
-	/* assoc status info */
-	__u64	sctpi_isacks;
-	__u64	sctpi_osacks;
-	__u64	sctpi_opackets;
-	__u64	sctpi_ipackets;
-	__u64	sctpi_rtxchunks;
-	__u64	sctpi_outofseqtsns;
-	__u64	sctpi_idupchunks;
-	__u64	sctpi_gapcnt;
-	__u64	sctpi_ouodchunks;
-	__u64	sctpi_iuodchunks;
-	__u64	sctpi_oodchunks;
-	__u64	sctpi_iodchunks;
-	__u64	sctpi_octrlchunks;
-	__u64	sctpi_ictrlchunks;
-
-	/* primary transport info */
-	struct sockaddr_storage	sctpi_p_address;
-	__s32	sctpi_p_state;
-	__u32	sctpi_p_cwnd;
-	__u32	sctpi_p_srtt;
-	__u32	sctpi_p_rto;
-	__u32	sctpi_p_hbinterval;
-	__u32	sctpi_p_pathmaxrxt;
-	__u32	sctpi_p_sackdelay;
-	__u32	sctpi_p_sackfreq;
-	__u32	sctpi_p_ssthresh;
-	__u32	sctpi_p_partial_bytes_acked;
-	__u32	sctpi_p_flight_size;
-	__u16	sctpi_p_error;
-	__u16	__reserved2;
-
-	/* sctp sock info */
-	__u32	sctpi_s_autoclose;
-	__u32	sctpi_s_adaptation_ind;
-	__u32	sctpi_s_pd_point;
-	__u8	sctpi_s_nodelay;
-	__u8	sctpi_s_disable_fragments;
-	__u8	sctpi_s_v4mapped;
-	__u8	sctpi_s_frag_interleave;
-	__u32	sctpi_s_type;
-	__u32	__reserved3;
-};
-
-struct sctp_reset_streams {
-	sctp_assoc_t srs_assoc_id;
-	uint16_t srs_flags;
-	uint16_t srs_number_streams;	/* 0 == ALL */
-	uint16_t srs_stream_list[];	/* list if srs_num_streams is not 0 */
-};
-
-struct sctp_add_streams {
-	sctp_assoc_t sas_assoc_id;
-	uint16_t sas_instrms;
-	uint16_t sas_outstrms;
-};
-
-#endif /* _SCTP_H */
diff --git a/include/linux/seg6.h b/include/linux/seg6.h
deleted file mode 100644
index 0715279..0000000
--- a/include/linux/seg6.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- *  SR-IPv6 implementation
- *
- *  Author:
- *  David Lebrun <david.lebrun@uclouvain.be>
- *
- *
- *  This program is free software; you can redistribute it and/or
- *      modify it under the terms of the GNU General Public License
- *      as published by the Free Software Foundation; either version
- *      2 of the License, or (at your option) any later version.
- */
-
-#ifndef _LINUX_SEG6_H
-#define _LINUX_SEG6_H
-
-#include <linux/types.h>
-#include <linux/in6.h>		/* For struct in6_addr. */
-
-/*
- * SRH
- */
-struct ipv6_sr_hdr {
-	__u8	nexthdr;
-	__u8	hdrlen;
-	__u8	type;
-	__u8	segments_left;
-	__u8	first_segment;
-	__u8	flags;
-	__u16	reserved;
-
-	struct in6_addr segments[0];
-};
-
-#define SR6_FLAG1_PROTECTED	(1 << 6)
-#define SR6_FLAG1_OAM		(1 << 5)
-#define SR6_FLAG1_ALERT		(1 << 4)
-#define SR6_FLAG1_HMAC		(1 << 3)
-
-#define SR6_TLV_INGRESS		1
-#define SR6_TLV_EGRESS		2
-#define SR6_TLV_OPAQUE		3
-#define SR6_TLV_PADDING		4
-#define SR6_TLV_HMAC		5
-
-#define sr_has_hmac(srh) ((srh)->flags & SR6_FLAG1_HMAC)
-
-struct sr6_tlv {
-	__u8 type;
-	__u8 len;
-	__u8 data[0];
-};
-
-#endif
diff --git a/include/linux/seg6_genl.h b/include/linux/seg6_genl.h
deleted file mode 100644
index 99382f9..0000000
--- a/include/linux/seg6_genl.h
+++ /dev/null
@@ -1,32 +0,0 @@
-#ifndef _LINUX_SEG6_GENL_H
-#define _LINUX_SEG6_GENL_H
-
-#define SEG6_GENL_NAME		"SEG6"
-#define SEG6_GENL_VERSION	0x1
-
-enum {
-	SEG6_ATTR_UNSPEC,
-	SEG6_ATTR_DST,
-	SEG6_ATTR_DSTLEN,
-	SEG6_ATTR_HMACKEYID,
-	SEG6_ATTR_SECRET,
-	SEG6_ATTR_SECRETLEN,
-	SEG6_ATTR_ALGID,
-	SEG6_ATTR_HMACINFO,
-	__SEG6_ATTR_MAX,
-};
-
-#define SEG6_ATTR_MAX (__SEG6_ATTR_MAX - 1)
-
-enum {
-	SEG6_CMD_UNSPEC,
-	SEG6_CMD_SETHMAC,
-	SEG6_CMD_DUMPHMAC,
-	SEG6_CMD_SET_TUNSRC,
-	SEG6_CMD_GET_TUNSRC,
-	__SEG6_CMD_MAX,
-};
-
-#define SEG6_CMD_MAX (__SEG6_CMD_MAX - 1)
-
-#endif
diff --git a/include/linux/seg6_hmac.h b/include/linux/seg6_hmac.h
deleted file mode 100644
index 704f93e..0000000
--- a/include/linux/seg6_hmac.h
+++ /dev/null
@@ -1,22 +0,0 @@
-#ifndef _LINUX_SEG6_HMAC_H
-#define _LINUX_SEG6_HMAC_H
-
-#include <linux/types.h>
-#include <linux/seg6.h>
-
-#define SEG6_HMAC_SECRET_LEN	64
-#define SEG6_HMAC_FIELD_LEN	32
-
-struct sr6_tlv_hmac {
-	struct sr6_tlv tlvhdr;
-	__u16 reserved;
-	__be32 hmackeyid;
-	__u8 hmac[SEG6_HMAC_FIELD_LEN];
-};
-
-enum {
-	SEG6_HMAC_ALGO_SHA1 = 1,
-	SEG6_HMAC_ALGO_SHA256 = 2,
-};
-
-#endif
diff --git a/include/linux/seg6_iptunnel.h b/include/linux/seg6_iptunnel.h
deleted file mode 100644
index a5dc05a..0000000
--- a/include/linux/seg6_iptunnel.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- *  SR-IPv6 implementation
- *
- *  Author:
- *  David Lebrun <david.lebrun@uclouvain.be>
- *
- *
- *  This program is free software; you can redistribute it and/or
- *      modify it under the terms of the GNU General Public License
- *      as published by the Free Software Foundation; either version
- *      2 of the License, or (at your option) any later version.
- */
-
-#ifndef _LINUX_SEG6_IPTUNNEL_H
-#define _LINUX_SEG6_IPTUNNEL_H
-
-#include <linux/seg6.h>		/* For struct ipv6_sr_hdr. */
-
-enum {
-	SEG6_IPTUNNEL_UNSPEC,
-	SEG6_IPTUNNEL_SRH,
-	__SEG6_IPTUNNEL_MAX,
-};
-#define SEG6_IPTUNNEL_MAX (__SEG6_IPTUNNEL_MAX - 1)
-
-struct seg6_iptunnel_encap {
-	int mode;
-	struct ipv6_sr_hdr srh[0];
-};
-
-#define SEG6_IPTUN_ENCAP_SIZE(x) ((sizeof(*x)) + (((x)->srh->hdrlen + 1) << 3))
-
-enum {
-	SEG6_IPTUN_MODE_INLINE,
-	SEG6_IPTUN_MODE_ENCAP,
-	SEG6_IPTUN_MODE_L2ENCAP,
-};
-
-
-#endif
diff --git a/include/linux/seg6_local.h b/include/linux/seg6_local.h
deleted file mode 100644
index 76b90d6..0000000
--- a/include/linux/seg6_local.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- *  SR-IPv6 implementation
- *
- *  Author:
- *  David Lebrun <david.lebrun@uclouvain.be>
- *
- *
- *  This program is free software; you can redistribute it and/or
- *      modify it under the terms of the GNU General Public License
- *      as published by the Free Software Foundation; either version
- *      2 of the License, or (at your option) any later version.
- */
-
-#ifndef _LINUX_SEG6_LOCAL_H
-#define _LINUX_SEG6_LOCAL_H
-
-#include <linux/seg6.h>
-
-enum {
-	SEG6_LOCAL_UNSPEC,
-	SEG6_LOCAL_ACTION,
-	SEG6_LOCAL_SRH,
-	SEG6_LOCAL_TABLE,
-	SEG6_LOCAL_NH4,
-	SEG6_LOCAL_NH6,
-	SEG6_LOCAL_IIF,
-	SEG6_LOCAL_OIF,
-	__SEG6_LOCAL_MAX,
-};
-#define SEG6_LOCAL_MAX (__SEG6_LOCAL_MAX - 1)
-
-enum {
-	SEG6_LOCAL_ACTION_UNSPEC	= 0,
-	/* node segment */
-	SEG6_LOCAL_ACTION_END		= 1,
-	/* adjacency segment (IPv6 cross-connect) */
-	SEG6_LOCAL_ACTION_END_X		= 2,
-	/* lookup of next seg NH in table */
-	SEG6_LOCAL_ACTION_END_T		= 3,
-	/* decap and L2 cross-connect */
-	SEG6_LOCAL_ACTION_END_DX2	= 4,
-	/* decap and IPv6 cross-connect */
-	SEG6_LOCAL_ACTION_END_DX6	= 5,
-	/* decap and IPv4 cross-connect */
-	SEG6_LOCAL_ACTION_END_DX4	= 6,
-	/* decap and lookup of DA in v6 table */
-	SEG6_LOCAL_ACTION_END_DT6	= 7,
-	/* decap and lookup of DA in v4 table */
-	SEG6_LOCAL_ACTION_END_DT4	= 8,
-	/* binding segment with insertion */
-	SEG6_LOCAL_ACTION_END_B6	= 9,
-	/* binding segment with encapsulation */
-	SEG6_LOCAL_ACTION_END_B6_ENCAP	= 10,
-	/* binding segment with MPLS encap */
-	SEG6_LOCAL_ACTION_END_BM	= 11,
-	/* lookup last seg in table */
-	SEG6_LOCAL_ACTION_END_S		= 12,
-	/* forward to SR-unaware VNF with static proxy */
-	SEG6_LOCAL_ACTION_END_AS	= 13,
-	/* forward to SR-unaware VNF with masquerading */
-	SEG6_LOCAL_ACTION_END_AM	= 14,
-
-	__SEG6_LOCAL_ACTION_MAX,
-};
-
-#define SEG6_LOCAL_ACTION_MAX (__SEG6_LOCAL_ACTION_MAX - 1)
-
-#endif
diff --git a/include/linux/sock_diag.h b/include/linux/sock_diag.h
deleted file mode 100644
index 901231e..0000000
--- a/include/linux/sock_diag.h
+++ /dev/null
@@ -1,38 +0,0 @@
-#ifndef __SOCK_DIAG_H__
-#define __SOCK_DIAG_H__
-
-#include <linux/types.h>
-
-#define SOCK_DIAG_BY_FAMILY 20
-#define SOCK_DESTROY 21
-
-struct sock_diag_req {
-	__u8	sdiag_family;
-	__u8	sdiag_protocol;
-};
-
-enum {
-	SK_MEMINFO_RMEM_ALLOC,
-	SK_MEMINFO_RCVBUF,
-	SK_MEMINFO_WMEM_ALLOC,
-	SK_MEMINFO_SNDBUF,
-	SK_MEMINFO_FWD_ALLOC,
-	SK_MEMINFO_WMEM_QUEUED,
-	SK_MEMINFO_OPTMEM,
-	SK_MEMINFO_BACKLOG,
-	SK_MEMINFO_DROPS,
-
-	SK_MEMINFO_VARS,
-};
-
-enum sknetlink_groups {
-	SKNLGRP_NONE,
-	SKNLGRP_INET_TCP_DESTROY,
-	SKNLGRP_INET_UDP_DESTROY,
-	SKNLGRP_INET6_TCP_DESTROY,
-	SKNLGRP_INET6_UDP_DESTROY,
-	__SKNLGRP_MAX,
-};
-#define SKNLGRP_MAX	(__SKNLGRP_MAX - 1)
-
-#endif /* __SOCK_DIAG_H__ */
diff --git a/include/linux/socket.h b/include/linux/socket.h
deleted file mode 100644
index 8c1e501..0000000
--- a/include/linux/socket.h
+++ /dev/null
@@ -1,21 +0,0 @@
-#ifndef _LINUX_SOCKET_H
-#define _LINUX_SOCKET_H
-
-/*
- * Desired design of maximum size and alignment (see RFC2553)
- */
-#define _K_SS_MAXSIZE	128	/* Implementation specific max size */
-#define _K_SS_ALIGNSIZE	(__alignof__ (struct sockaddr *))
-				/* Implementation specific desired alignment */
-
-typedef unsigned short __kernel_sa_family_t;
-
-struct __kernel_sockaddr_storage {
-	__kernel_sa_family_t	ss_family;		/* address family */
-	/* Following field(s) are implementation specific */
-	char		__data[_K_SS_MAXSIZE - sizeof(unsigned short)];
-				/* space to achieve desired size, */
-				/* _SS_MAXSIZE value minus size of ss_family */
-} __attribute__ ((aligned(_K_SS_ALIGNSIZE)));	/* force desired alignment */
-
-#endif /* _LINUX_SOCKET_H */
diff --git a/include/linux/sockios.h b/include/linux/sockios.h
deleted file mode 100644
index 79d029d..0000000
--- a/include/linux/sockios.h
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * INET		An implementation of the TCP/IP protocol suite for the LINUX
- *		operating system.  INET is implemented using the  BSD Socket
- *		interface as the means of communication with the user level.
- *
- *		Definitions of the socket-level I/O control calls.
- *
- * Version:	@(#)sockios.h	1.0.2	03/09/93
- *
- * Authors:	Ross Biro
- *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
- */
-#ifndef _LINUX_SOCKIOS_H
-#define _LINUX_SOCKIOS_H
-
-#include <asm/sockios.h>
-
-/* Linux-specific socket ioctls */
-#define SIOCINQ		FIONREAD
-#define SIOCOUTQ	TIOCOUTQ        /* output queue size (not sent + not acked) */
-
-#define SOCK_IOC_TYPE	0x89
-
-/* Routing table calls. */
-#define SIOCADDRT	0x890B		/* add routing table entry	*/
-#define SIOCDELRT	0x890C		/* delete routing table entry	*/
-#define SIOCRTMSG	0x890D		/* unused			*/
-
-/* Socket configuration controls. */
-#define SIOCGIFNAME	0x8910		/* get iface name		*/
-#define SIOCSIFLINK	0x8911		/* set iface channel		*/
-#define SIOCGIFCONF	0x8912		/* get iface list		*/
-#define SIOCGIFFLAGS	0x8913		/* get flags			*/
-#define SIOCSIFFLAGS	0x8914		/* set flags			*/
-#define SIOCGIFADDR	0x8915		/* get PA address		*/
-#define SIOCSIFADDR	0x8916		/* set PA address		*/
-#define SIOCGIFDSTADDR	0x8917		/* get remote PA address	*/
-#define SIOCSIFDSTADDR	0x8918		/* set remote PA address	*/
-#define SIOCGIFBRDADDR	0x8919		/* get broadcast PA address	*/
-#define SIOCSIFBRDADDR	0x891a		/* set broadcast PA address	*/
-#define SIOCGIFNETMASK	0x891b		/* get network PA mask		*/
-#define SIOCSIFNETMASK	0x891c		/* set network PA mask		*/
-#define SIOCGIFMETRIC	0x891d		/* get metric			*/
-#define SIOCSIFMETRIC	0x891e		/* set metric			*/
-#define SIOCGIFMEM	0x891f		/* get memory address (BSD)	*/
-#define SIOCSIFMEM	0x8920		/* set memory address (BSD)	*/
-#define SIOCGIFMTU	0x8921		/* get MTU size			*/
-#define SIOCSIFMTU	0x8922		/* set MTU size			*/
-#define SIOCSIFNAME	0x8923		/* set interface name */
-#define	SIOCSIFHWADDR	0x8924		/* set hardware address 	*/
-#define SIOCGIFENCAP	0x8925		/* get/set encapsulations       */
-#define SIOCSIFENCAP	0x8926		
-#define SIOCGIFHWADDR	0x8927		/* Get hardware address		*/
-#define SIOCGIFSLAVE	0x8929		/* Driver slaving support	*/
-#define SIOCSIFSLAVE	0x8930
-#define SIOCADDMULTI	0x8931		/* Multicast address lists	*/
-#define SIOCDELMULTI	0x8932
-#define SIOCGIFINDEX	0x8933		/* name -> if_index mapping	*/
-#define SIOGIFINDEX	SIOCGIFINDEX	/* misprint compatibility :-)	*/
-#define SIOCSIFPFLAGS	0x8934		/* set/get extended flags set	*/
-#define SIOCGIFPFLAGS	0x8935
-#define SIOCDIFADDR	0x8936		/* delete PA address		*/
-#define	SIOCSIFHWBROADCAST	0x8937	/* set hardware broadcast addr	*/
-#define SIOCGIFCOUNT	0x8938		/* get number of devices */
-
-#define SIOCGIFBR	0x8940		/* Bridging support		*/
-#define SIOCSIFBR	0x8941		/* Set bridging options 	*/
-
-#define SIOCGIFTXQLEN	0x8942		/* Get the tx queue length	*/
-#define SIOCSIFTXQLEN	0x8943		/* Set the tx queue length 	*/
-
-/* SIOCGIFDIVERT was:	0x8944		Frame diversion support */
-/* SIOCSIFDIVERT was:	0x8945		Set frame diversion options */
-
-#define SIOCETHTOOL	0x8946		/* Ethtool interface		*/
-
-#define SIOCGMIIPHY	0x8947		/* Get address of MII PHY in use. */
-#define SIOCGMIIREG	0x8948		/* Read MII PHY register.	*/
-#define SIOCSMIIREG	0x8949		/* Write MII PHY register.	*/
-
-#define SIOCWANDEV	0x894A		/* get/set netdev parameters	*/
-
-#define SIOCOUTQNSD	0x894B		/* output queue size (not sent only) */
-#define SIOCGSKNS	0x894C		/* get socket network namespace */
-
-/* ARP cache control calls. */
-		    /*  0x8950 - 0x8952  * obsolete calls, don't re-use */
-#define SIOCDARP	0x8953		/* delete ARP table entry	*/
-#define SIOCGARP	0x8954		/* get ARP table entry		*/
-#define SIOCSARP	0x8955		/* set ARP table entry		*/
-
-/* RARP cache control calls. */
-#define SIOCDRARP	0x8960		/* delete RARP table entry	*/
-#define SIOCGRARP	0x8961		/* get RARP table entry		*/
-#define SIOCSRARP	0x8962		/* set RARP table entry		*/
-
-/* Driver configuration calls */
-
-#define SIOCGIFMAP	0x8970		/* Get device parameters	*/
-#define SIOCSIFMAP	0x8971		/* Set device parameters	*/
-
-/* DLCI configuration calls */
-
-#define SIOCADDDLCI	0x8980		/* Create new DLCI device	*/
-#define SIOCDELDLCI	0x8981		/* Delete DLCI device		*/
-
-#define SIOCGIFVLAN	0x8982		/* 802.1Q VLAN support		*/
-#define SIOCSIFVLAN	0x8983		/* Set 802.1Q VLAN options 	*/
-
-/* bonding calls */
-
-#define SIOCBONDENSLAVE	0x8990		/* enslave a device to the bond */
-#define SIOCBONDRELEASE 0x8991		/* release a slave from the bond*/
-#define SIOCBONDSETHWADDR      0x8992	/* set the hw addr of the bond  */
-#define SIOCBONDSLAVEINFOQUERY 0x8993   /* rtn info about slave state   */
-#define SIOCBONDINFOQUERY      0x8994	/* rtn info about bond state    */
-#define SIOCBONDCHANGEACTIVE   0x8995   /* update to a new active slave */
-			
-/* bridge calls */
-#define SIOCBRADDBR     0x89a0		/* create new bridge device     */
-#define SIOCBRDELBR     0x89a1		/* remove bridge device         */
-#define SIOCBRADDIF	0x89a2		/* add interface to bridge      */
-#define SIOCBRDELIF	0x89a3		/* remove interface from bridge */
-
-/* hardware time stamping: parameters in linux/net_tstamp.h */
-#define SIOCSHWTSTAMP	0x89b0		/* set and get config		*/
-#define SIOCGHWTSTAMP	0x89b1		/* get config			*/
-
-/* Device private ioctl calls */
-
-/*
- *	These 16 ioctls are available to devices via the do_ioctl() device
- *	vector. Each device should include this file and redefine these names
- *	as their own. Because these are device dependent it is a good idea
- *	_NOT_ to issue them to random objects and hope.
- *
- *	THESE IOCTLS ARE _DEPRECATED_ AND WILL DISAPPEAR IN 2.5.X -DaveM
- */
- 
-#define SIOCDEVPRIVATE	0x89F0	/* to 89FF */
-
-/*
- *	These 16 ioctl calls are protocol private
- */
- 
-#define SIOCPROTOPRIVATE 0x89E0 /* to 89EF */
-#endif	/* _LINUX_SOCKIOS_H */
diff --git a/include/linux/stddef.h b/include/linux/stddef.h
deleted file mode 100644
index 4bb69de..0000000
--- a/include/linux/stddef.h
+++ /dev/null
@@ -1,5 +0,0 @@
-
-
-#ifndef __always_inline
-#define __always_inline __inline__
-#endif
diff --git a/include/linux/sysinfo.h b/include/linux/sysinfo.h
deleted file mode 100644
index 934335a..0000000
--- a/include/linux/sysinfo.h
+++ /dev/null
@@ -1,24 +0,0 @@
-#ifndef _LINUX_SYSINFO_H
-#define _LINUX_SYSINFO_H
-
-#include <linux/types.h>
-
-#define SI_LOAD_SHIFT	16
-struct sysinfo {
-	__kernel_long_t uptime;		/* Seconds since boot */
-	__kernel_ulong_t loads[3];	/* 1, 5, and 15 minute load averages */
-	__kernel_ulong_t totalram;	/* Total usable main memory size */
-	__kernel_ulong_t freeram;	/* Available memory size */
-	__kernel_ulong_t sharedram;	/* Amount of shared memory */
-	__kernel_ulong_t bufferram;	/* Memory used by buffers */
-	__kernel_ulong_t totalswap;	/* Total swap space size */
-	__kernel_ulong_t freeswap;	/* swap space still available */
-	__u16 procs;		   	/* Number of current processes */
-	__u16 pad;		   	/* Explicit padding for m68k */
-	__kernel_ulong_t totalhigh;	/* Total high memory size */
-	__kernel_ulong_t freehigh;	/* Available high memory size */
-	__u32 mem_unit;			/* Memory unit size in bytes */
-	char _f[20-2*sizeof(__kernel_ulong_t)-sizeof(__u32)];	/* Padding: libc5 uses this.. */
-};
-
-#endif /* _LINUX_SYSINFO_H */
diff --git a/include/linux/tc_act/tc_bpf.h b/include/linux/tc_act/tc_bpf.h
deleted file mode 100644
index 8dc2ac0..0000000
--- a/include/linux/tc_act/tc_bpf.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (c) 2015 Jiri Pirko <jiri@resnulli.us>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#ifndef __LINUX_TC_BPF_H
-#define __LINUX_TC_BPF_H
-
-#include <linux/pkt_cls.h>
-
-#define TCA_ACT_BPF 13
-
-struct tc_act_bpf {
-	tc_gen;
-};
-
-enum {
-	TCA_ACT_BPF_UNSPEC,
-	TCA_ACT_BPF_TM,
-	TCA_ACT_BPF_PARMS,
-	TCA_ACT_BPF_OPS_LEN,
-	TCA_ACT_BPF_OPS,
-	TCA_ACT_BPF_FD,
-	TCA_ACT_BPF_NAME,
-	TCA_ACT_BPF_PAD,
-	TCA_ACT_BPF_TAG,
-	TCA_ACT_BPF_ID,
-	__TCA_ACT_BPF_MAX,
-};
-#define TCA_ACT_BPF_MAX (__TCA_ACT_BPF_MAX - 1)
-
-#endif
diff --git a/include/linux/tc_act/tc_connmark.h b/include/linux/tc_act/tc_connmark.h
deleted file mode 100644
index 62a5e94..0000000
--- a/include/linux/tc_act/tc_connmark.h
+++ /dev/null
@@ -1,23 +0,0 @@
-#ifndef __UAPI_TC_CONNMARK_H
-#define __UAPI_TC_CONNMARK_H
-
-#include <linux/types.h>
-#include <linux/pkt_cls.h>
-
-#define TCA_ACT_CONNMARK 14
-
-struct tc_connmark {
-	tc_gen;
-	__u16 zone;
-};
-
-enum {
-	TCA_CONNMARK_UNSPEC,
-	TCA_CONNMARK_PARMS,
-	TCA_CONNMARK_TM,
-	TCA_CONNMARK_PAD,
-	__TCA_CONNMARK_MAX
-};
-#define TCA_CONNMARK_MAX (__TCA_CONNMARK_MAX - 1)
-
-#endif
diff --git a/include/linux/tc_act/tc_csum.h b/include/linux/tc_act/tc_csum.h
deleted file mode 100644
index a11bb35..0000000
--- a/include/linux/tc_act/tc_csum.h
+++ /dev/null
@@ -1,34 +0,0 @@
-#ifndef __LINUX_TC_CSUM_H
-#define __LINUX_TC_CSUM_H
-
-#include <linux/types.h>
-#include <linux/pkt_cls.h>
-
-#define TCA_ACT_CSUM 16
-
-enum {
-	TCA_CSUM_UNSPEC,
-	TCA_CSUM_PARMS,
-	TCA_CSUM_TM,
-	TCA_CSUM_PAD,
-	__TCA_CSUM_MAX
-};
-#define TCA_CSUM_MAX (__TCA_CSUM_MAX - 1)
-
-enum {
-	TCA_CSUM_UPDATE_FLAG_IPV4HDR = 1,
-	TCA_CSUM_UPDATE_FLAG_ICMP    = 2,
-	TCA_CSUM_UPDATE_FLAG_IGMP    = 4,
-	TCA_CSUM_UPDATE_FLAG_TCP     = 8,
-	TCA_CSUM_UPDATE_FLAG_UDP     = 16,
-	TCA_CSUM_UPDATE_FLAG_UDPLITE = 32,
-	TCA_CSUM_UPDATE_FLAG_SCTP    = 64,
-};
-
-struct tc_csum {
-	tc_gen;
-
-	__u32 update_flags;
-};
-
-#endif /* __LINUX_TC_CSUM_H */
diff --git a/include/linux/tc_act/tc_defact.h b/include/linux/tc_act/tc_defact.h
deleted file mode 100644
index d2a3abb..0000000
--- a/include/linux/tc_act/tc_defact.h
+++ /dev/null
@@ -1,20 +0,0 @@
-#ifndef __LINUX_TC_DEF_H
-#define __LINUX_TC_DEF_H
-
-#include <linux/pkt_cls.h>
-
-struct tc_defact {
-	tc_gen;
-};
-
-enum {
-	TCA_DEF_UNSPEC,
-	TCA_DEF_TM,
-	TCA_DEF_PARMS,
-	TCA_DEF_DATA,
-	TCA_DEF_PAD,
-	__TCA_DEF_MAX
-};
-#define TCA_DEF_MAX (__TCA_DEF_MAX - 1)
-
-#endif
diff --git a/include/linux/tc_act/tc_gact.h b/include/linux/tc_act/tc_gact.h
deleted file mode 100644
index 70b536a..0000000
--- a/include/linux/tc_act/tc_gact.h
+++ /dev/null
@@ -1,33 +0,0 @@
-#ifndef __LINUX_TC_GACT_H
-#define __LINUX_TC_GACT_H
-
-#include <linux/types.h>
-#include <linux/pkt_cls.h>
-
-#define TCA_ACT_GACT 5
-struct tc_gact {
-	tc_gen;
-
-};
-
-struct tc_gact_p {
-#define PGACT_NONE              0
-#define PGACT_NETRAND           1
-#define PGACT_DETERM            2
-#define MAX_RAND                (PGACT_DETERM + 1 )
-	__u16                 ptype;
-	__u16                 pval;
-	int                   paction;
-};
- 
-enum {
-	TCA_GACT_UNSPEC,
-	TCA_GACT_TM,
-	TCA_GACT_PARMS,
-	TCA_GACT_PROB,
-	TCA_GACT_PAD,
-	__TCA_GACT_MAX
-};
-#define TCA_GACT_MAX (__TCA_GACT_MAX - 1)
- 
-#endif
diff --git a/include/linux/tc_act/tc_ife.h b/include/linux/tc_act/tc_ife.h
deleted file mode 100644
index 7c28178..0000000
--- a/include/linux/tc_act/tc_ife.h
+++ /dev/null
@@ -1,32 +0,0 @@
-#ifndef __UAPI_TC_IFE_H
-#define __UAPI_TC_IFE_H
-
-#include <linux/types.h>
-#include <linux/pkt_cls.h>
-#include <linux/ife.h>
-
-#define TCA_ACT_IFE 25
-/* Flag bits for now just encoding/decoding; mutually exclusive */
-#define IFE_ENCODE 1
-#define IFE_DECODE 0
-
-struct tc_ife {
-	tc_gen;
-	__u16 flags;
-};
-
-/*XXX: We need to encode the total number of bytes consumed */
-enum {
-	TCA_IFE_UNSPEC,
-	TCA_IFE_PARMS,
-	TCA_IFE_TM,
-	TCA_IFE_DMAC,
-	TCA_IFE_SMAC,
-	TCA_IFE_TYPE,
-	TCA_IFE_METALST,
-	TCA_IFE_PAD,
-	__TCA_IFE_MAX
-};
-#define TCA_IFE_MAX (__TCA_IFE_MAX - 1)
-
-#endif
diff --git a/include/linux/tc_act/tc_ipt.h b/include/linux/tc_act/tc_ipt.h
deleted file mode 100644
index 7c6e155..0000000
--- a/include/linux/tc_act/tc_ipt.h
+++ /dev/null
@@ -1,22 +0,0 @@
-#ifndef __LINUX_TC_IPT_H
-#define __LINUX_TC_IPT_H
-
-#include <linux/pkt_cls.h>
-
-#define TCA_ACT_IPT 6
-#define TCA_ACT_XT 10
-
-enum {
-	TCA_IPT_UNSPEC,
-	TCA_IPT_TABLE,
-	TCA_IPT_HOOK,
-	TCA_IPT_INDEX,
-	TCA_IPT_CNT,
-	TCA_IPT_TM,
-	TCA_IPT_TARG,
-	TCA_IPT_PAD,
-	__TCA_IPT_MAX
-};
-#define TCA_IPT_MAX (__TCA_IPT_MAX - 1)
-                                                                                
-#endif
diff --git a/include/linux/tc_act/tc_mirred.h b/include/linux/tc_act/tc_mirred.h
deleted file mode 100644
index 3d7a2b3..0000000
--- a/include/linux/tc_act/tc_mirred.h
+++ /dev/null
@@ -1,28 +0,0 @@
-#ifndef __LINUX_TC_MIR_H
-#define __LINUX_TC_MIR_H
-
-#include <linux/types.h>
-#include <linux/pkt_cls.h>
-
-#define TCA_ACT_MIRRED 8
-#define TCA_EGRESS_REDIR 1  /* packet redirect to EGRESS*/
-#define TCA_EGRESS_MIRROR 2 /* mirror packet to EGRESS */
-#define TCA_INGRESS_REDIR 3  /* packet redirect to INGRESS*/
-#define TCA_INGRESS_MIRROR 4 /* mirror packet to INGRESS */
-                                                                                
-struct tc_mirred {
-	tc_gen;
-	int                     eaction;   /* one of IN/EGRESS_MIRROR/REDIR */
-	__u32                   ifindex;  /* ifindex of egress port */
-};
-                                                                                
-enum {
-	TCA_MIRRED_UNSPEC,
-	TCA_MIRRED_TM,
-	TCA_MIRRED_PARMS,
-	TCA_MIRRED_PAD,
-	__TCA_MIRRED_MAX
-};
-#define TCA_MIRRED_MAX (__TCA_MIRRED_MAX - 1)
-                                                                                
-#endif
diff --git a/include/linux/tc_act/tc_nat.h b/include/linux/tc_act/tc_nat.h
deleted file mode 100644
index 923457c..0000000
--- a/include/linux/tc_act/tc_nat.h
+++ /dev/null
@@ -1,28 +0,0 @@
-#ifndef __LINUX_TC_NAT_H
-#define __LINUX_TC_NAT_H
-
-#include <linux/pkt_cls.h>
-#include <linux/types.h>
-
-#define TCA_ACT_NAT 9
-
-enum {
-	TCA_NAT_UNSPEC,
-	TCA_NAT_PARMS,
-	TCA_NAT_TM,
-	TCA_NAT_PAD,
-	__TCA_NAT_MAX
-};
-#define TCA_NAT_MAX (__TCA_NAT_MAX - 1)
-
-#define TCA_NAT_FLAG_EGRESS 1
-
-struct tc_nat {
-	tc_gen;
-	__be32 old_addr;
-	__be32 new_addr;
-	__be32 mask;
-	__u32 flags;
-};
-
-#endif
diff --git a/include/linux/tc_act/tc_pedit.h b/include/linux/tc_act/tc_pedit.h
deleted file mode 100644
index 143d2b3..0000000
--- a/include/linux/tc_act/tc_pedit.h
+++ /dev/null
@@ -1,66 +0,0 @@
-#ifndef __LINUX_TC_PED_H
-#define __LINUX_TC_PED_H
-
-#include <linux/types.h>
-#include <linux/pkt_cls.h>
-
-#define TCA_ACT_PEDIT 7
-
-enum {
-	TCA_PEDIT_UNSPEC,
-	TCA_PEDIT_TM,
-	TCA_PEDIT_PARMS,
-	TCA_PEDIT_PAD,
-	TCA_PEDIT_PARMS_EX,
-	TCA_PEDIT_KEYS_EX,
-	TCA_PEDIT_KEY_EX,
-	__TCA_PEDIT_MAX
-};
-#define TCA_PEDIT_MAX (__TCA_PEDIT_MAX - 1)
-                                                                                
-enum {
-	TCA_PEDIT_KEY_EX_HTYPE = 1,
-	TCA_PEDIT_KEY_EX_CMD = 2,
-	__TCA_PEDIT_KEY_EX_MAX
-};
-#define TCA_PEDIT_KEY_EX_MAX (__TCA_PEDIT_KEY_EX_MAX - 1)
-
- /* TCA_PEDIT_KEY_EX_HDR_TYPE_NETWROK is a special case for legacy users. It
-  * means no specific header type - offset is relative to the network layer
-  */
-enum pedit_header_type {
-	TCA_PEDIT_KEY_EX_HDR_TYPE_NETWORK = 0,
-	TCA_PEDIT_KEY_EX_HDR_TYPE_ETH = 1,
-	TCA_PEDIT_KEY_EX_HDR_TYPE_IP4 = 2,
-	TCA_PEDIT_KEY_EX_HDR_TYPE_IP6 = 3,
-	TCA_PEDIT_KEY_EX_HDR_TYPE_TCP = 4,
-	TCA_PEDIT_KEY_EX_HDR_TYPE_UDP = 5,
-	__PEDIT_HDR_TYPE_MAX,
-};
-#define TCA_PEDIT_HDR_TYPE_MAX (__PEDIT_HDR_TYPE_MAX - 1)
-
-enum pedit_cmd {
-	TCA_PEDIT_KEY_EX_CMD_SET = 0,
-	TCA_PEDIT_KEY_EX_CMD_ADD = 1,
-	__PEDIT_CMD_MAX,
-};
-#define TCA_PEDIT_CMD_MAX (__PEDIT_CMD_MAX - 1)
-
-struct tc_pedit_key {
-	__u32           mask;  /* AND */
-	__u32           val;   /*XOR */
-	__u32           off;  /*offset */
-	__u32           at;
-	__u32           offmask;
-	__u32           shift;
-};
-                                                                                
-struct tc_pedit_sel {
-	tc_gen;
-	unsigned char           nkeys;
-	unsigned char           flags;
-	struct tc_pedit_key     keys[0];
-};
-#define tc_pedit tc_pedit_sel
-
-#endif
diff --git a/include/linux/tc_act/tc_sample.h b/include/linux/tc_act/tc_sample.h
deleted file mode 100644
index edc9058..0000000
--- a/include/linux/tc_act/tc_sample.h
+++ /dev/null
@@ -1,26 +0,0 @@
-#ifndef __LINUX_TC_SAMPLE_H
-#define __LINUX_TC_SAMPLE_H
-
-#include <linux/types.h>
-#include <linux/pkt_cls.h>
-#include <linux/if_ether.h>
-
-#define TCA_ACT_SAMPLE 26
-
-struct tc_sample {
-	tc_gen;
-};
-
-enum {
-	TCA_SAMPLE_UNSPEC,
-	TCA_SAMPLE_TM,
-	TCA_SAMPLE_PARMS,
-	TCA_SAMPLE_RATE,
-	TCA_SAMPLE_TRUNC_SIZE,
-	TCA_SAMPLE_PSAMPLE_GROUP,
-	TCA_SAMPLE_PAD,
-	__TCA_SAMPLE_MAX
-};
-#define TCA_SAMPLE_MAX (__TCA_SAMPLE_MAX - 1)
-
-#endif
diff --git a/include/linux/tc_act/tc_skbedit.h b/include/linux/tc_act/tc_skbedit.h
deleted file mode 100644
index 2884425..0000000
--- a/include/linux/tc_act/tc_skbedit.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (c) 2008, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
- * Place - Suite 330, Boston, MA 02111-1307 USA.
- *
- * Author: Alexander Duyck <alexander.h.duyck@intel.com>
- */
-
-#ifndef __LINUX_TC_SKBEDIT_H
-#define __LINUX_TC_SKBEDIT_H
-
-#include <linux/pkt_cls.h>
-
-#define TCA_ACT_SKBEDIT 11
-
-#define SKBEDIT_F_PRIORITY		0x1
-#define SKBEDIT_F_QUEUE_MAPPING		0x2
-#define SKBEDIT_F_MARK			0x4
-#define SKBEDIT_F_PTYPE			0x8
-#define SKBEDIT_F_MASK			0x10
-
-struct tc_skbedit {
-	tc_gen;
-};
-
-enum {
-	TCA_SKBEDIT_UNSPEC,
-	TCA_SKBEDIT_TM,
-	TCA_SKBEDIT_PARMS,
-	TCA_SKBEDIT_PRIORITY,
-	TCA_SKBEDIT_QUEUE_MAPPING,
-	TCA_SKBEDIT_MARK,
-	TCA_SKBEDIT_PAD,
-	TCA_SKBEDIT_PTYPE,
-	TCA_SKBEDIT_MASK,
-	__TCA_SKBEDIT_MAX
-};
-#define TCA_SKBEDIT_MAX (__TCA_SKBEDIT_MAX - 1)
-
-#endif
diff --git a/include/linux/tc_act/tc_skbmod.h b/include/linux/tc_act/tc_skbmod.h
deleted file mode 100644
index 10fc07d..0000000
--- a/include/linux/tc_act/tc_skbmod.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (c) 2016, Jamal Hadi Salim
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
-*/
-
-#ifndef __LINUX_TC_SKBMOD_H
-#define __LINUX_TC_SKBMOD_H
-
-#include <linux/pkt_cls.h>
-
-#define TCA_ACT_SKBMOD 15
-
-#define SKBMOD_F_DMAC	0x1
-#define SKBMOD_F_SMAC	0x2
-#define SKBMOD_F_ETYPE	0x4
-#define SKBMOD_F_SWAPMAC 0x8
-
-struct tc_skbmod {
-	tc_gen;
-	__u64 flags;
-};
-
-enum {
-	TCA_SKBMOD_UNSPEC,
-	TCA_SKBMOD_TM,
-	TCA_SKBMOD_PARMS,
-	TCA_SKBMOD_DMAC,
-	TCA_SKBMOD_SMAC,
-	TCA_SKBMOD_ETYPE,
-	TCA_SKBMOD_PAD,
-	__TCA_SKBMOD_MAX
-};
-#define TCA_SKBMOD_MAX (__TCA_SKBMOD_MAX - 1)
-
-#endif
diff --git a/include/linux/tc_act/tc_tunnel_key.h b/include/linux/tc_act/tc_tunnel_key.h
deleted file mode 100644
index afcd4be..0000000
--- a/include/linux/tc_act/tc_tunnel_key.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (c) 2016, Amir Vadai <amir@vadai.me>
- * Copyright (c) 2016, Mellanox Technologies. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#ifndef __LINUX_TC_TUNNEL_KEY_H
-#define __LINUX_TC_TUNNEL_KEY_H
-
-#include <linux/pkt_cls.h>
-
-#define TCA_ACT_TUNNEL_KEY 17
-
-#define TCA_TUNNEL_KEY_ACT_SET	    1
-#define TCA_TUNNEL_KEY_ACT_RELEASE  2
-
-struct tc_tunnel_key {
-	tc_gen;
-	int t_action;
-};
-
-enum {
-	TCA_TUNNEL_KEY_UNSPEC,
-	TCA_TUNNEL_KEY_TM,
-	TCA_TUNNEL_KEY_PARMS,
-	TCA_TUNNEL_KEY_ENC_IPV4_SRC,	/* be32 */
-	TCA_TUNNEL_KEY_ENC_IPV4_DST,	/* be32 */
-	TCA_TUNNEL_KEY_ENC_IPV6_SRC,	/* struct in6_addr */
-	TCA_TUNNEL_KEY_ENC_IPV6_DST,	/* struct in6_addr */
-	TCA_TUNNEL_KEY_ENC_KEY_ID,	/* be64 */
-	TCA_TUNNEL_KEY_PAD,
-	TCA_TUNNEL_KEY_ENC_DST_PORT,	/* be16 */
-	TCA_TUNNEL_KEY_NO_CSUM,		/* u8 */
-	__TCA_TUNNEL_KEY_MAX,
-};
-
-#define TCA_TUNNEL_KEY_MAX (__TCA_TUNNEL_KEY_MAX - 1)
-
-#endif
diff --git a/include/linux/tc_act/tc_vlan.h b/include/linux/tc_act/tc_vlan.h
deleted file mode 100644
index bddb272..0000000
--- a/include/linux/tc_act/tc_vlan.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (c) 2014 Jiri Pirko <jiri@resnulli.us>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#ifndef __LINUX_TC_VLAN_H
-#define __LINUX_TC_VLAN_H
-
-#include <linux/pkt_cls.h>
-
-#define TCA_ACT_VLAN 12
-
-#define TCA_VLAN_ACT_POP	1
-#define TCA_VLAN_ACT_PUSH	2
-#define TCA_VLAN_ACT_MODIFY	3
-
-struct tc_vlan {
-	tc_gen;
-	int v_action;
-};
-
-enum {
-	TCA_VLAN_UNSPEC,
-	TCA_VLAN_TM,
-	TCA_VLAN_PARMS,
-	TCA_VLAN_PUSH_VLAN_ID,
-	TCA_VLAN_PUSH_VLAN_PROTOCOL,
-	TCA_VLAN_PAD,
-	TCA_VLAN_PUSH_VLAN_PRIORITY,
-	__TCA_VLAN_MAX,
-};
-#define TCA_VLAN_MAX (__TCA_VLAN_MAX - 1)
-
-#endif
diff --git a/include/linux/tc_ematch/tc_em_cmp.h b/include/linux/tc_ematch/tc_em_cmp.h
deleted file mode 100644
index f34bb1b..0000000
--- a/include/linux/tc_ematch/tc_em_cmp.h
+++ /dev/null
@@ -1,25 +0,0 @@
-#ifndef __LINUX_TC_EM_CMP_H
-#define __LINUX_TC_EM_CMP_H
-
-#include <linux/types.h>
-#include <linux/pkt_cls.h>
-
-struct tcf_em_cmp {
-	__u32		val;
-	__u32		mask;
-	__u16		off;
-	__u8		align:4;
-	__u8		flags:4;
-	__u8		layer:4;
-	__u8		opnd:4;
-};
-
-enum {
-	TCF_EM_ALIGN_U8  = 1,
-	TCF_EM_ALIGN_U16 = 2,
-	TCF_EM_ALIGN_U32 = 4
-};
-
-#define TCF_EM_CMP_TRANS	1
-
-#endif
diff --git a/include/linux/tc_ematch/tc_em_meta.h b/include/linux/tc_ematch/tc_em_meta.h
deleted file mode 100644
index b11f8ce..0000000
--- a/include/linux/tc_ematch/tc_em_meta.h
+++ /dev/null
@@ -1,92 +0,0 @@
-#ifndef __LINUX_TC_EM_META_H
-#define __LINUX_TC_EM_META_H
-
-#include <linux/types.h>
-#include <linux/pkt_cls.h>
-
-enum {
-	TCA_EM_META_UNSPEC,
-	TCA_EM_META_HDR,
-	TCA_EM_META_LVALUE,
-	TCA_EM_META_RVALUE,
-	__TCA_EM_META_MAX
-};
-#define TCA_EM_META_MAX (__TCA_EM_META_MAX - 1)
-
-struct tcf_meta_val {
-	__u16			kind;
-	__u8			shift;
-	__u8			op;
-};
-
-#define TCF_META_TYPE_MASK	(0xf << 12)
-#define TCF_META_TYPE(kind)	(((kind) & TCF_META_TYPE_MASK) >> 12)
-#define TCF_META_ID_MASK	0x7ff
-#define TCF_META_ID(kind)	((kind) & TCF_META_ID_MASK)
-
-enum {
-	TCF_META_TYPE_VAR,
-	TCF_META_TYPE_INT,
-	__TCF_META_TYPE_MAX
-};
-#define TCF_META_TYPE_MAX (__TCF_META_TYPE_MAX - 1)
-
-enum {
-	TCF_META_ID_VALUE,
-	TCF_META_ID_RANDOM,
-	TCF_META_ID_LOADAVG_0,
-	TCF_META_ID_LOADAVG_1,
-	TCF_META_ID_LOADAVG_2,
-	TCF_META_ID_DEV,
-	TCF_META_ID_PRIORITY,
-	TCF_META_ID_PROTOCOL,
-	TCF_META_ID_PKTTYPE,
-	TCF_META_ID_PKTLEN,
-	TCF_META_ID_DATALEN,
-	TCF_META_ID_MACLEN,
-	TCF_META_ID_NFMARK,
-	TCF_META_ID_TCINDEX,
-	TCF_META_ID_RTCLASSID,
-	TCF_META_ID_RTIIF,
-	TCF_META_ID_SK_FAMILY,
-	TCF_META_ID_SK_STATE,
-	TCF_META_ID_SK_REUSE,
-	TCF_META_ID_SK_BOUND_IF,
-	TCF_META_ID_SK_REFCNT,
-	TCF_META_ID_SK_SHUTDOWN,
-	TCF_META_ID_SK_PROTO,
-	TCF_META_ID_SK_TYPE,
-	TCF_META_ID_SK_RCVBUF,
-	TCF_META_ID_SK_RMEM_ALLOC,
-	TCF_META_ID_SK_WMEM_ALLOC,
-	TCF_META_ID_SK_OMEM_ALLOC,
-	TCF_META_ID_SK_WMEM_QUEUED,
-	TCF_META_ID_SK_RCV_QLEN,
-	TCF_META_ID_SK_SND_QLEN,
- 	TCF_META_ID_SK_ERR_QLEN,
-	TCF_META_ID_SK_FORWARD_ALLOCS,
-	TCF_META_ID_SK_SNDBUF,
- 	TCF_META_ID_SK_ALLOCS,
-	__TCF_META_ID_SK_ROUTE_CAPS,	/* unimplemented but in ABI already */
- 	TCF_META_ID_SK_HASH,
- 	TCF_META_ID_SK_LINGERTIME,
- 	TCF_META_ID_SK_ACK_BACKLOG,
- 	TCF_META_ID_SK_MAX_ACK_BACKLOG,
- 	TCF_META_ID_SK_PRIO,
- 	TCF_META_ID_SK_RCVLOWAT,
- 	TCF_META_ID_SK_RCVTIMEO,
- 	TCF_META_ID_SK_SNDTIMEO,
- 	TCF_META_ID_SK_SENDMSG_OFF,
- 	TCF_META_ID_SK_WRITE_PENDING,
-	TCF_META_ID_VLAN_TAG,
-	TCF_META_ID_RXHASH,
-	__TCF_META_ID_MAX
-};
-#define TCF_META_ID_MAX (__TCF_META_ID_MAX - 1)
-
-struct tcf_meta_hdr {
-	struct tcf_meta_val	left;
-	struct tcf_meta_val	right;
-};
-
-#endif
diff --git a/include/linux/tc_ematch/tc_em_nbyte.h b/include/linux/tc_ematch/tc_em_nbyte.h
deleted file mode 100644
index 7172cfb..0000000
--- a/include/linux/tc_ematch/tc_em_nbyte.h
+++ /dev/null
@@ -1,13 +0,0 @@
-#ifndef __LINUX_TC_EM_NBYTE_H
-#define __LINUX_TC_EM_NBYTE_H
-
-#include <linux/types.h>
-#include <linux/pkt_cls.h>
-
-struct tcf_em_nbyte {
-	__u16		off;
-	__u16		len:12;
-	__u8		layer:4;
-};
-
-#endif
diff --git a/include/linux/tcp.h b/include/linux/tcp.h
deleted file mode 100644
index 8edad3f..0000000
--- a/include/linux/tcp.h
+++ /dev/null
@@ -1,268 +0,0 @@
-/*
- * INET		An implementation of the TCP/IP protocol suite for the LINUX
- *		operating system.  INET is implemented using the  BSD Socket
- *		interface as the means of communication with the user level.
- *
- *		Definitions for the TCP protocol.
- *
- * Version:	@(#)tcp.h	1.0.2	04/28/93
- *
- * Author:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
- */
-#ifndef _LINUX_TCP_H
-#define _LINUX_TCP_H
-
-#include <linux/types.h>
-#include <asm/byteorder.h>
-#include <linux/socket.h>
-
-struct tcphdr {
-	__be16	source;
-	__be16	dest;
-	__be32	seq;
-	__be32	ack_seq;
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-	__u16	res1:4,
-		doff:4,
-		fin:1,
-		syn:1,
-		rst:1,
-		psh:1,
-		ack:1,
-		urg:1,
-		ece:1,
-		cwr:1;
-#elif defined(__BIG_ENDIAN_BITFIELD)
-	__u16	doff:4,
-		res1:4,
-		cwr:1,
-		ece:1,
-		urg:1,
-		ack:1,
-		psh:1,
-		rst:1,
-		syn:1,
-		fin:1;
-#else
-#error	"Adjust your <asm/byteorder.h> defines"
-#endif	
-	__be16	window;
-	__sum16	check;
-	__be16	urg_ptr;
-};
-
-/*
- *	The union cast uses a gcc extension to avoid aliasing problems
- *  (union is compatible to any of its members)
- *  This means this part of the code is -fstrict-aliasing safe now.
- */
-union tcp_word_hdr { 
-	struct tcphdr hdr;
-	__be32 		  words[5];
-}; 
-
-#define tcp_flag_word(tp) ( ((union tcp_word_hdr *)(tp))->words [3]) 
-
-enum { 
-	TCP_FLAG_CWR = __constant_cpu_to_be32(0x00800000),
-	TCP_FLAG_ECE = __constant_cpu_to_be32(0x00400000),
-	TCP_FLAG_URG = __constant_cpu_to_be32(0x00200000),
-	TCP_FLAG_ACK = __constant_cpu_to_be32(0x00100000),
-	TCP_FLAG_PSH = __constant_cpu_to_be32(0x00080000),
-	TCP_FLAG_RST = __constant_cpu_to_be32(0x00040000),
-	TCP_FLAG_SYN = __constant_cpu_to_be32(0x00020000),
-	TCP_FLAG_FIN = __constant_cpu_to_be32(0x00010000),
-	TCP_RESERVED_BITS = __constant_cpu_to_be32(0x0F000000),
-	TCP_DATA_OFFSET = __constant_cpu_to_be32(0xF0000000)
-}; 
-
-/*
- * TCP general constants
- */
-#define TCP_MSS_DEFAULT		 536U	/* IPv4 (RFC1122, RFC2581) */
-#define TCP_MSS_DESIRED		1220U	/* IPv6 (tunneled), EDNS0 (RFC3226) */
-
-/* TCP socket options */
-#define TCP_NODELAY		1	/* Turn off Nagle's algorithm. */
-#define TCP_MAXSEG		2	/* Limit MSS */
-#define TCP_CORK		3	/* Never send partially complete segments */
-#define TCP_KEEPIDLE		4	/* Start keeplives after this period */
-#define TCP_KEEPINTVL		5	/* Interval between keepalives */
-#define TCP_KEEPCNT		6	/* Number of keepalives before death */
-#define TCP_SYNCNT		7	/* Number of SYN retransmits */
-#define TCP_LINGER2		8	/* Life time of orphaned FIN-WAIT-2 state */
-#define TCP_DEFER_ACCEPT	9	/* Wake up listener only when data arrive */
-#define TCP_WINDOW_CLAMP	10	/* Bound advertised window */
-#define TCP_INFO		11	/* Information about this connection. */
-#define TCP_QUICKACK		12	/* Block/reenable quick acks */
-#define TCP_CONGESTION		13	/* Congestion control algorithm */
-#define TCP_MD5SIG		14	/* TCP MD5 Signature (RFC2385) */
-#define TCP_THIN_LINEAR_TIMEOUTS 16      /* Use linear timeouts for thin streams*/
-#define TCP_THIN_DUPACK         17      /* Fast retrans. after 1 dupack */
-#define TCP_USER_TIMEOUT	18	/* How long for loss retry before timeout */
-#define TCP_REPAIR		19	/* TCP sock is under repair right now */
-#define TCP_REPAIR_QUEUE	20
-#define TCP_QUEUE_SEQ		21
-#define TCP_REPAIR_OPTIONS	22
-#define TCP_FASTOPEN		23	/* Enable FastOpen on listeners */
-#define TCP_TIMESTAMP		24
-#define TCP_NOTSENT_LOWAT	25	/* limit number of unsent bytes in write queue */
-#define TCP_CC_INFO		26	/* Get Congestion Control (optional) info */
-#define TCP_SAVE_SYN		27	/* Record SYN headers for new connections */
-#define TCP_SAVED_SYN		28	/* Get SYN headers recorded for connection */
-#define TCP_REPAIR_WINDOW	29	/* Get/set window parameters */
-#define TCP_FASTOPEN_CONNECT	30	/* Attempt FastOpen with connect */
-#define TCP_ULP			31	/* Attach a ULP to a TCP connection */
-#define TCP_MD5SIG_EXT		32	/* TCP MD5 Signature with extensions */
-
-struct tcp_repair_opt {
-	__u32	opt_code;
-	__u32	opt_val;
-};
-
-struct tcp_repair_window {
-	__u32	snd_wl1;
-	__u32	snd_wnd;
-	__u32	max_window;
-
-	__u32	rcv_wnd;
-	__u32	rcv_wup;
-};
-
-enum {
-	TCP_NO_QUEUE,
-	TCP_RECV_QUEUE,
-	TCP_SEND_QUEUE,
-	TCP_QUEUES_NR,
-};
-
-/* for TCP_INFO socket option */
-#define TCPI_OPT_TIMESTAMPS	1
-#define TCPI_OPT_SACK		2
-#define TCPI_OPT_WSCALE		4
-#define TCPI_OPT_ECN		8 /* ECN was negociated at TCP session init */
-#define TCPI_OPT_ECN_SEEN	16 /* we received at least one packet with ECT */
-#define TCPI_OPT_SYN_DATA	32 /* SYN-ACK acked data in SYN sent or rcvd */
-
-enum tcp_ca_state {
-	TCP_CA_Open = 0,
-#define TCPF_CA_Open	(1<<TCP_CA_Open)
-	TCP_CA_Disorder = 1,
-#define TCPF_CA_Disorder (1<<TCP_CA_Disorder)
-	TCP_CA_CWR = 2,
-#define TCPF_CA_CWR	(1<<TCP_CA_CWR)
-	TCP_CA_Recovery = 3,
-#define TCPF_CA_Recovery (1<<TCP_CA_Recovery)
-	TCP_CA_Loss = 4
-#define TCPF_CA_Loss	(1<<TCP_CA_Loss)
-};
-
-struct tcp_info {
-	__u8	tcpi_state;
-	__u8	tcpi_ca_state;
-	__u8	tcpi_retransmits;
-	__u8	tcpi_probes;
-	__u8	tcpi_backoff;
-	__u8	tcpi_options;
-	__u8	tcpi_snd_wscale : 4, tcpi_rcv_wscale : 4;
-	__u8	tcpi_delivery_rate_app_limited:1;
-
-	__u32	tcpi_rto;
-	__u32	tcpi_ato;
-	__u32	tcpi_snd_mss;
-	__u32	tcpi_rcv_mss;
-
-	__u32	tcpi_unacked;
-	__u32	tcpi_sacked;
-	__u32	tcpi_lost;
-	__u32	tcpi_retrans;
-	__u32	tcpi_fackets;
-
-	/* Times. */
-	__u32	tcpi_last_data_sent;
-	__u32	tcpi_last_ack_sent;     /* Not remembered, sorry. */
-	__u32	tcpi_last_data_recv;
-	__u32	tcpi_last_ack_recv;
-
-	/* Metrics. */
-	__u32	tcpi_pmtu;
-	__u32	tcpi_rcv_ssthresh;
-	__u32	tcpi_rtt;
-	__u32	tcpi_rttvar;
-	__u32	tcpi_snd_ssthresh;
-	__u32	tcpi_snd_cwnd;
-	__u32	tcpi_advmss;
-	__u32	tcpi_reordering;
-
-	__u32	tcpi_rcv_rtt;
-	__u32	tcpi_rcv_space;
-
-	__u32	tcpi_total_retrans;
-
-	__u64	tcpi_pacing_rate;
-	__u64	tcpi_max_pacing_rate;
-	__u64	tcpi_bytes_acked;    /* RFC4898 tcpEStatsAppHCThruOctetsAcked */
-	__u64	tcpi_bytes_received; /* RFC4898 tcpEStatsAppHCThruOctetsReceived */
-	__u32	tcpi_segs_out;	     /* RFC4898 tcpEStatsPerfSegsOut */
-	__u32	tcpi_segs_in;	     /* RFC4898 tcpEStatsPerfSegsIn */
-
-	__u32	tcpi_notsent_bytes;
-	__u32	tcpi_min_rtt;
-	__u32	tcpi_data_segs_in;	/* RFC4898 tcpEStatsDataSegsIn */
-	__u32	tcpi_data_segs_out;	/* RFC4898 tcpEStatsDataSegsOut */
-
-	__u64   tcpi_delivery_rate;
-
-	__u64	tcpi_busy_time;      /* Time (usec) busy sending data */
-	__u64	tcpi_rwnd_limited;   /* Time (usec) limited by receive window */
-	__u64	tcpi_sndbuf_limited; /* Time (usec) limited by send buffer */
-};
-
-/* netlink attributes types for SCM_TIMESTAMPING_OPT_STATS */
-enum {
-	TCP_NLA_PAD,
-	TCP_NLA_BUSY,		/* Time (usec) busy sending data */
-	TCP_NLA_RWND_LIMITED,	/* Time (usec) limited by receive window */
-	TCP_NLA_SNDBUF_LIMITED,	/* Time (usec) limited by send buffer */
-	TCP_NLA_DATA_SEGS_OUT,	/* Data pkts sent including retransmission */
-	TCP_NLA_TOTAL_RETRANS,	/* Data pkts retransmitted */
-	TCP_NLA_PACING_RATE,    /* Pacing rate in bytes per second */
-	TCP_NLA_DELIVERY_RATE,  /* Delivery rate in bytes per second */
-	TCP_NLA_SND_CWND,       /* Sending congestion window */
-	TCP_NLA_REORDERING,     /* Reordering metric */
-	TCP_NLA_MIN_RTT,        /* minimum RTT */
-	TCP_NLA_RECUR_RETRANS,  /* Recurring retransmits for the current pkt */
-	TCP_NLA_DELIVERY_RATE_APP_LMT, /* delivery rate application limited ? */
-
-};
-
-/* for TCP_MD5SIG socket option */
-#define TCP_MD5SIG_MAXKEYLEN	80
-
-/* tcp_md5sig extension flags for TCP_MD5SIG_EXT */
-#define TCP_MD5SIG_FLAG_PREFIX		1	/* address prefix length */
-
-struct tcp_md5sig {
-	struct __kernel_sockaddr_storage tcpm_addr;	/* address associated */
-	__u8	tcpm_flags;				/* extension flags */
-	__u8	tcpm_prefixlen;				/* address prefix */
-	__u16	tcpm_keylen;				/* key length */
-	__u32	__tcpm_pad;				/* zero */
-	__u8	tcpm_key[TCP_MD5SIG_MAXKEYLEN];		/* key (binary) */
-};
-
-/* INET_DIAG_MD5SIG */
-struct tcp_diag_md5sig {
-	__u8	tcpm_family;
-	__u8	tcpm_prefixlen;
-	__u16	tcpm_keylen;
-	__be32	tcpm_addr[4];
-	__u8	tcpm_key[TCP_MD5SIG_MAXKEYLEN];
-};
-
-#endif /* _LINUX_TCP_H */
diff --git a/include/linux/tcp_metrics.h b/include/linux/tcp_metrics.h
deleted file mode 100644
index 80ad90d..0000000
--- a/include/linux/tcp_metrics.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/* tcp_metrics.h - TCP Metrics Interface */
-
-#ifndef _LINUX_TCP_METRICS_H
-#define _LINUX_TCP_METRICS_H
-
-#include <linux/types.h>
-
-/* NETLINK_GENERIC related info
- */
-#define TCP_METRICS_GENL_NAME		"tcp_metrics"
-#define TCP_METRICS_GENL_VERSION	0x1
-
-enum tcp_metric_index {
-	TCP_METRIC_RTT,		/* in ms units */
-	TCP_METRIC_RTTVAR,	/* in ms units */
-	TCP_METRIC_SSTHRESH,
-	TCP_METRIC_CWND,
-	TCP_METRIC_REORDERING,
-
-	TCP_METRIC_RTT_US,	/* in usec units */
-	TCP_METRIC_RTTVAR_US,	/* in usec units */
-
-	/* Always last.  */
-	__TCP_METRIC_MAX,
-};
-
-#define TCP_METRIC_MAX	(__TCP_METRIC_MAX - 1)
-
-enum {
-	TCP_METRICS_ATTR_UNSPEC,
-	TCP_METRICS_ATTR_ADDR_IPV4,		/* u32 */
-	TCP_METRICS_ATTR_ADDR_IPV6,		/* binary */
-	TCP_METRICS_ATTR_AGE,			/* msecs */
-	TCP_METRICS_ATTR_TW_TSVAL,		/* u32, raw, rcv tsval */
-	TCP_METRICS_ATTR_TW_TS_STAMP,		/* s32, sec age */
-	TCP_METRICS_ATTR_VALS,			/* nested +1, u32 */
-	TCP_METRICS_ATTR_FOPEN_MSS,		/* u16 */
-	TCP_METRICS_ATTR_FOPEN_SYN_DROPS,	/* u16, count of drops */
-	TCP_METRICS_ATTR_FOPEN_SYN_DROP_TS,	/* msecs age */
-	TCP_METRICS_ATTR_FOPEN_COOKIE,		/* binary */
-	TCP_METRICS_ATTR_SADDR_IPV4,		/* u32 */
-	TCP_METRICS_ATTR_SADDR_IPV6,		/* binary */
-	TCP_METRICS_ATTR_PAD,
-
-	__TCP_METRICS_ATTR_MAX,
-};
-
-#define TCP_METRICS_ATTR_MAX	(__TCP_METRICS_ATTR_MAX - 1)
-
-enum {
-	TCP_METRICS_CMD_UNSPEC,
-	TCP_METRICS_CMD_GET,
-	TCP_METRICS_CMD_DEL,
-
-	__TCP_METRICS_CMD_MAX,
-};
-
-#define TCP_METRICS_CMD_MAX	(__TCP_METRICS_CMD_MAX - 1)
-
-#endif /* _LINUX_TCP_METRICS_H */
diff --git a/include/linux/tipc.h b/include/linux/tipc.h
deleted file mode 100644
index 924fb5c..0000000
--- a/include/linux/tipc.h
+++ /dev/null
@@ -1,256 +0,0 @@
-/*
- * include/uapi/linux/tipc.h: Header for TIPC socket interface
- *
- * Copyright (c) 2003-2006, 2015-2016 Ericsson AB
- * Copyright (c) 2005, 2010-2011, Wind River Systems
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the names of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _LINUX_TIPC_H_
-#define _LINUX_TIPC_H_
-
-#include <linux/types.h>
-#include <linux/sockios.h>
-
-/*
- * TIPC addressing primitives
- */
-
-struct tipc_portid {
-	__u32 ref;
-	__u32 node;
-};
-
-struct tipc_name {
-	__u32 type;
-	__u32 instance;
-};
-
-struct tipc_name_seq {
-	__u32 type;
-	__u32 lower;
-	__u32 upper;
-};
-
-/* TIPC Address Size, Offset, Mask specification for Z.C.N
- */
-#define TIPC_NODE_BITS          12
-#define TIPC_CLUSTER_BITS       12
-#define TIPC_ZONE_BITS          8
-
-#define TIPC_NODE_OFFSET        0
-#define TIPC_CLUSTER_OFFSET     TIPC_NODE_BITS
-#define TIPC_ZONE_OFFSET        (TIPC_CLUSTER_OFFSET + TIPC_CLUSTER_BITS)
-
-#define TIPC_NODE_SIZE          ((1UL << TIPC_NODE_BITS) - 1)
-#define TIPC_CLUSTER_SIZE       ((1UL << TIPC_CLUSTER_BITS) - 1)
-#define TIPC_ZONE_SIZE          ((1UL << TIPC_ZONE_BITS) - 1)
-
-#define TIPC_NODE_MASK		(TIPC_NODE_SIZE << TIPC_NODE_OFFSET)
-#define TIPC_CLUSTER_MASK	(TIPC_CLUSTER_SIZE << TIPC_CLUSTER_OFFSET)
-#define TIPC_ZONE_MASK		(TIPC_ZONE_SIZE << TIPC_ZONE_OFFSET)
-
-#define TIPC_ZONE_CLUSTER_MASK (TIPC_ZONE_MASK | TIPC_CLUSTER_MASK)
-
-static __inline__ __u32 tipc_addr(unsigned int zone,
-			      unsigned int cluster,
-			      unsigned int node)
-{
-	return (zone << TIPC_ZONE_OFFSET) |
-		(cluster << TIPC_CLUSTER_OFFSET) |
-		node;
-}
-
-static __inline__ unsigned int tipc_zone(__u32 addr)
-{
-	return addr >> TIPC_ZONE_OFFSET;
-}
-
-static __inline__ unsigned int tipc_cluster(__u32 addr)
-{
-	return (addr & TIPC_CLUSTER_MASK) >> TIPC_CLUSTER_OFFSET;
-}
-
-static __inline__ unsigned int tipc_node(__u32 addr)
-{
-	return addr & TIPC_NODE_MASK;
-}
-
-/*
- * Application-accessible port name types
- */
-
-#define TIPC_CFG_SRV		0	/* configuration service name type */
-#define TIPC_TOP_SRV		1	/* topology service name type */
-#define TIPC_LINK_STATE		2	/* link state name type */
-#define TIPC_RESERVED_TYPES	64	/* lowest user-publishable name type */
-
-/*
- * Publication scopes when binding port names and port name sequences
- */
-
-#define TIPC_ZONE_SCOPE		1
-#define TIPC_CLUSTER_SCOPE	2
-#define TIPC_NODE_SCOPE		3
-
-/*
- * Limiting values for messages
- */
-
-#define TIPC_MAX_USER_MSG_SIZE	66000U
-
-/*
- * Message importance levels
- */
-
-#define TIPC_LOW_IMPORTANCE		0
-#define TIPC_MEDIUM_IMPORTANCE		1
-#define TIPC_HIGH_IMPORTANCE		2
-#define TIPC_CRITICAL_IMPORTANCE	3
-
-/*
- * Msg rejection/connection shutdown reasons
- */
-
-#define TIPC_OK			0
-#define TIPC_ERR_NO_NAME	1
-#define TIPC_ERR_NO_PORT	2
-#define TIPC_ERR_NO_NODE	3
-#define TIPC_ERR_OVERLOAD	4
-#define TIPC_CONN_SHUTDOWN	5
-
-/*
- * TIPC topology subscription service definitions
- */
-
-#define TIPC_SUB_PORTS		0x01	/* filter for port availability */
-#define TIPC_SUB_SERVICE	0x02	/* filter for service availability */
-#define TIPC_SUB_CANCEL		0x04	/* cancel a subscription */
-
-#define TIPC_WAIT_FOREVER	(~0)	/* timeout for permanent subscription */
-
-struct tipc_subscr {
-	struct tipc_name_seq seq;	/* name sequence of interest */
-	__u32 timeout;			/* subscription duration (in ms) */
-	__u32 filter;			/* bitmask of filter options */
-	char usr_handle[8];		/* available for subscriber use */
-};
-
-#define TIPC_PUBLISHED		1	/* publication event */
-#define TIPC_WITHDRAWN		2	/* withdraw event */
-#define TIPC_SUBSCR_TIMEOUT	3	/* subscription timeout event */
-
-struct tipc_event {
-	__u32 event;			/* event type */
-	__u32 found_lower;		/* matching name seq instances */
-	__u32 found_upper;		/*    "      "    "     "      */
-	struct tipc_portid port;	/* associated port */
-	struct tipc_subscr s;		/* associated subscription */
-};
-
-/*
- * Socket API
- */
-
-#ifndef AF_TIPC
-#define AF_TIPC		30
-#endif
-
-#ifndef PF_TIPC
-#define PF_TIPC		AF_TIPC
-#endif
-
-#ifndef SOL_TIPC
-#define SOL_TIPC	271
-#endif
-
-#define TIPC_ADDR_NAMESEQ	1
-#define TIPC_ADDR_MCAST		1
-#define TIPC_ADDR_NAME		2
-#define TIPC_ADDR_ID		3
-
-struct sockaddr_tipc {
-	unsigned short family;
-	unsigned char  addrtype;
-	signed   char  scope;
-	union {
-		struct tipc_portid id;
-		struct tipc_name_seq nameseq;
-		struct {
-			struct tipc_name name;
-			__u32 domain;
-		} name;
-	} addr;
-};
-
-/*
- * Ancillary data objects supported by recvmsg()
- */
-
-#define TIPC_ERRINFO	1	/* error info */
-#define TIPC_RETDATA	2	/* returned data */
-#define TIPC_DESTNAME	3	/* destination name */
-
-/*
- * TIPC-specific socket option names
- */
-
-#define TIPC_IMPORTANCE		127	/* Default: TIPC_LOW_IMPORTANCE */
-#define TIPC_SRC_DROPPABLE	128	/* Default: based on socket type */
-#define TIPC_DEST_DROPPABLE	129	/* Default: based on socket type */
-#define TIPC_CONN_TIMEOUT	130	/* Default: 8000 (ms)  */
-#define TIPC_NODE_RECVQ_DEPTH	131	/* Default: none (read only) */
-#define TIPC_SOCK_RECVQ_DEPTH	132	/* Default: none (read only) */
-#define TIPC_MCAST_BROADCAST    133     /* Default: TIPC selects. No arg */
-#define TIPC_MCAST_REPLICAST    134     /* Default: TIPC selects. No arg */
-
-/*
- * Maximum sizes of TIPC bearer-related names (including terminating NULL)
- * The string formatting for each name element is:
- * media: media
- * interface: media:interface name
- * link: Z.C.N:interface-Z.C.N:interface
- *
- */
-
-#define TIPC_MAX_MEDIA_NAME	16
-#define TIPC_MAX_IF_NAME	16
-#define TIPC_MAX_BEARER_NAME	32
-#define TIPC_MAX_LINK_NAME	60
-
-#define SIOCGETLINKNAME		SIOCPROTOPRIVATE
-
-struct tipc_sioc_ln_req {
-	__u32 peer;
-	__u32 bearer_id;
-	char linkname[TIPC_MAX_LINK_NAME];
-};
-#endif
diff --git a/include/linux/tipc_netlink.h b/include/linux/tipc_netlink.h
deleted file mode 100644
index f9edd20..0000000
--- a/include/linux/tipc_netlink.h
+++ /dev/null
@@ -1,294 +0,0 @@
-/*
- * Copyright (c) 2014, Ericsson AB
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the names of the copyright holders nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _LINUX_TIPC_NETLINK_H_
-#define _LINUX_TIPC_NETLINK_H_
-
-#define TIPC_GENL_V2_NAME      "TIPCv2"
-#define TIPC_GENL_V2_VERSION   0x1
-
-/* Netlink commands */
-enum {
-	TIPC_NL_UNSPEC,
-	TIPC_NL_LEGACY,
-	TIPC_NL_BEARER_DISABLE,
-	TIPC_NL_BEARER_ENABLE,
-	TIPC_NL_BEARER_GET,
-	TIPC_NL_BEARER_SET,
-	TIPC_NL_SOCK_GET,
-	TIPC_NL_PUBL_GET,
-	TIPC_NL_LINK_GET,
-	TIPC_NL_LINK_SET,
-	TIPC_NL_LINK_RESET_STATS,
-	TIPC_NL_MEDIA_GET,
-	TIPC_NL_MEDIA_SET,
-	TIPC_NL_NODE_GET,
-	TIPC_NL_NET_GET,
-	TIPC_NL_NET_SET,
-	TIPC_NL_NAME_TABLE_GET,
-	TIPC_NL_MON_SET,
-	TIPC_NL_MON_GET,
-	TIPC_NL_MON_PEER_GET,
-	TIPC_NL_PEER_REMOVE,
-	TIPC_NL_BEARER_ADD,
-	TIPC_NL_UDP_GET_REMOTEIP,
-
-	__TIPC_NL_CMD_MAX,
-	TIPC_NL_CMD_MAX = __TIPC_NL_CMD_MAX - 1
-};
-
-/* Top level netlink attributes */
-enum {
-	TIPC_NLA_UNSPEC,
-	TIPC_NLA_BEARER,		/* nest */
-	TIPC_NLA_SOCK,			/* nest */
-	TIPC_NLA_PUBL,			/* nest */
-	TIPC_NLA_LINK,			/* nest */
-	TIPC_NLA_MEDIA,			/* nest */
-	TIPC_NLA_NODE,			/* nest */
-	TIPC_NLA_NET,			/* nest */
-	TIPC_NLA_NAME_TABLE,		/* nest */
-	TIPC_NLA_MON,			/* nest */
-	TIPC_NLA_MON_PEER,		/* nest */
-
-	__TIPC_NLA_MAX,
-	TIPC_NLA_MAX = __TIPC_NLA_MAX - 1
-};
-
-/* Bearer info */
-enum {
-	TIPC_NLA_BEARER_UNSPEC,
-	TIPC_NLA_BEARER_NAME,		/* string */
-	TIPC_NLA_BEARER_PROP,		/* nest */
-	TIPC_NLA_BEARER_DOMAIN,		/* u32 */
-	TIPC_NLA_BEARER_UDP_OPTS,	/* nest */
-
-	__TIPC_NLA_BEARER_MAX,
-	TIPC_NLA_BEARER_MAX = __TIPC_NLA_BEARER_MAX - 1
-};
-
-enum {
-	TIPC_NLA_UDP_UNSPEC,
-	TIPC_NLA_UDP_LOCAL,		/* sockaddr_storage */
-	TIPC_NLA_UDP_REMOTE,		/* sockaddr_storage */
-	TIPC_NLA_UDP_MULTI_REMOTEIP,	/* flag */
-
-	__TIPC_NLA_UDP_MAX,
-	TIPC_NLA_UDP_MAX = __TIPC_NLA_UDP_MAX - 1
-};
-/* Socket info */
-enum {
-	TIPC_NLA_SOCK_UNSPEC,
-	TIPC_NLA_SOCK_ADDR,		/* u32 */
-	TIPC_NLA_SOCK_REF,		/* u32 */
-	TIPC_NLA_SOCK_CON,		/* nest */
-	TIPC_NLA_SOCK_HAS_PUBL,		/* flag */
-
-	__TIPC_NLA_SOCK_MAX,
-	TIPC_NLA_SOCK_MAX = __TIPC_NLA_SOCK_MAX - 1
-};
-
-/* Link info */
-enum {
-	TIPC_NLA_LINK_UNSPEC,
-	TIPC_NLA_LINK_NAME,		/* string */
-	TIPC_NLA_LINK_DEST,		/* u32 */
-	TIPC_NLA_LINK_MTU,		/* u32 */
-	TIPC_NLA_LINK_BROADCAST,	/* flag */
-	TIPC_NLA_LINK_UP,		/* flag */
-	TIPC_NLA_LINK_ACTIVE,		/* flag */
-	TIPC_NLA_LINK_PROP,		/* nest */
-	TIPC_NLA_LINK_STATS,		/* nest */
-	TIPC_NLA_LINK_RX,		/* u32 */
-	TIPC_NLA_LINK_TX,		/* u32 */
-
-	__TIPC_NLA_LINK_MAX,
-	TIPC_NLA_LINK_MAX = __TIPC_NLA_LINK_MAX - 1
-};
-
-/* Media info */
-enum {
-	TIPC_NLA_MEDIA_UNSPEC,
-	TIPC_NLA_MEDIA_NAME,		/* string */
-	TIPC_NLA_MEDIA_PROP,		/* nest */
-
-	__TIPC_NLA_MEDIA_MAX,
-	TIPC_NLA_MEDIA_MAX = __TIPC_NLA_MEDIA_MAX - 1
-};
-
-/* Node info */
-enum {
-	TIPC_NLA_NODE_UNSPEC,
-	TIPC_NLA_NODE_ADDR,		/* u32 */
-	TIPC_NLA_NODE_UP,		/* flag */
-
-	__TIPC_NLA_NODE_MAX,
-	TIPC_NLA_NODE_MAX = __TIPC_NLA_NODE_MAX - 1
-};
-
-/* Net info */
-enum {
-	TIPC_NLA_NET_UNSPEC,
-	TIPC_NLA_NET_ID,		/* u32 */
-	TIPC_NLA_NET_ADDR,		/* u32 */
-
-	__TIPC_NLA_NET_MAX,
-	TIPC_NLA_NET_MAX = __TIPC_NLA_NET_MAX - 1
-};
-
-/* Name table info */
-enum {
-	TIPC_NLA_NAME_TABLE_UNSPEC,
-	TIPC_NLA_NAME_TABLE_PUBL,	/* nest */
-
-	__TIPC_NLA_NAME_TABLE_MAX,
-	TIPC_NLA_NAME_TABLE_MAX = __TIPC_NLA_NAME_TABLE_MAX - 1
-};
-
-/* Monitor info */
-enum {
-	TIPC_NLA_MON_UNSPEC,
-	TIPC_NLA_MON_ACTIVATION_THRESHOLD,	/* u32 */
-	TIPC_NLA_MON_REF,			/* u32 */
-	TIPC_NLA_MON_ACTIVE,			/* flag */
-	TIPC_NLA_MON_BEARER_NAME,		/* string */
-	TIPC_NLA_MON_PEERCNT,			/* u32 */
-	TIPC_NLA_MON_LISTGEN,			/* u32 */
-
-	__TIPC_NLA_MON_MAX,
-	TIPC_NLA_MON_MAX = __TIPC_NLA_MON_MAX - 1
-};
-
-/* Publication info */
-enum {
-	TIPC_NLA_PUBL_UNSPEC,
-
-	TIPC_NLA_PUBL_TYPE,		/* u32 */
-	TIPC_NLA_PUBL_LOWER,		/* u32 */
-	TIPC_NLA_PUBL_UPPER,		/* u32 */
-	TIPC_NLA_PUBL_SCOPE,		/* u32 */
-	TIPC_NLA_PUBL_NODE,		/* u32 */
-	TIPC_NLA_PUBL_REF,		/* u32 */
-	TIPC_NLA_PUBL_KEY,		/* u32 */
-
-	__TIPC_NLA_PUBL_MAX,
-	TIPC_NLA_PUBL_MAX = __TIPC_NLA_PUBL_MAX - 1
-};
-
-/* Monitor peer info */
-enum {
-	TIPC_NLA_MON_PEER_UNSPEC,
-
-	TIPC_NLA_MON_PEER_ADDR,			/* u32 */
-	TIPC_NLA_MON_PEER_DOMGEN,		/* u32 */
-	TIPC_NLA_MON_PEER_APPLIED,		/* u32 */
-	TIPC_NLA_MON_PEER_UPMAP,		/* u64 */
-	TIPC_NLA_MON_PEER_MEMBERS,		/* tlv */
-	TIPC_NLA_MON_PEER_UP,			/* flag */
-	TIPC_NLA_MON_PEER_HEAD,			/* flag */
-	TIPC_NLA_MON_PEER_LOCAL,		/* flag */
-	TIPC_NLA_MON_PEER_PAD,			/* flag */
-
-	__TIPC_NLA_MON_PEER_MAX,
-	TIPC_NLA_MON_PEER_MAX = __TIPC_NLA_MON_PEER_MAX - 1
-};
-
-/* Nest, connection info */
-enum {
-	TIPC_NLA_CON_UNSPEC,
-
-	TIPC_NLA_CON_FLAG,		/* flag */
-	TIPC_NLA_CON_NODE,		/* u32 */
-	TIPC_NLA_CON_SOCK,		/* u32 */
-	TIPC_NLA_CON_TYPE,		/* u32 */
-	TIPC_NLA_CON_INST,		/* u32 */
-
-	__TIPC_NLA_CON_MAX,
-	TIPC_NLA_CON_MAX = __TIPC_NLA_CON_MAX - 1
-};
-
-/* Nest, link propreties. Valid for link, media and bearer */
-enum {
-	TIPC_NLA_PROP_UNSPEC,
-
-	TIPC_NLA_PROP_PRIO,		/* u32 */
-	TIPC_NLA_PROP_TOL,		/* u32 */
-	TIPC_NLA_PROP_WIN,		/* u32 */
-
-	__TIPC_NLA_PROP_MAX,
-	TIPC_NLA_PROP_MAX = __TIPC_NLA_PROP_MAX - 1
-};
-
-/* Nest, statistics info */
-enum {
-	TIPC_NLA_STATS_UNSPEC,
-
-	TIPC_NLA_STATS_RX_INFO,		/* u32 */
-	TIPC_NLA_STATS_RX_FRAGMENTS,	/* u32 */
-	TIPC_NLA_STATS_RX_FRAGMENTED,	/* u32 */
-	TIPC_NLA_STATS_RX_BUNDLES,	/* u32 */
-	TIPC_NLA_STATS_RX_BUNDLED,	/* u32 */
-	TIPC_NLA_STATS_TX_INFO,		/* u32 */
-	TIPC_NLA_STATS_TX_FRAGMENTS,	/* u32 */
-	TIPC_NLA_STATS_TX_FRAGMENTED,	/* u32 */
-	TIPC_NLA_STATS_TX_BUNDLES,	/* u32 */
-	TIPC_NLA_STATS_TX_BUNDLED,	/* u32 */
-	TIPC_NLA_STATS_MSG_PROF_TOT,	/* u32 */
-	TIPC_NLA_STATS_MSG_LEN_CNT,	/* u32 */
-	TIPC_NLA_STATS_MSG_LEN_TOT,	/* u32 */
-	TIPC_NLA_STATS_MSG_LEN_P0,	/* u32 */
-	TIPC_NLA_STATS_MSG_LEN_P1,	/* u32 */
-	TIPC_NLA_STATS_MSG_LEN_P2,	/* u32 */
-	TIPC_NLA_STATS_MSG_LEN_P3,	/* u32 */
-	TIPC_NLA_STATS_MSG_LEN_P4,	/* u32 */
-	TIPC_NLA_STATS_MSG_LEN_P5,	/* u32 */
-	TIPC_NLA_STATS_MSG_LEN_P6,	/* u32 */
-	TIPC_NLA_STATS_RX_STATES,	/* u32 */
-	TIPC_NLA_STATS_RX_PROBES,	/* u32 */
-	TIPC_NLA_STATS_RX_NACKS,	/* u32 */
-	TIPC_NLA_STATS_RX_DEFERRED,	/* u32 */
-	TIPC_NLA_STATS_TX_STATES,	/* u32 */
-	TIPC_NLA_STATS_TX_PROBES,	/* u32 */
-	TIPC_NLA_STATS_TX_NACKS,	/* u32 */
-	TIPC_NLA_STATS_TX_ACKS,		/* u32 */
-	TIPC_NLA_STATS_RETRANSMITTED,	/* u32 */
-	TIPC_NLA_STATS_DUPLICATES,	/* u32 */
-	TIPC_NLA_STATS_LINK_CONGS,	/* u32 */
-	TIPC_NLA_STATS_MAX_QUEUE,	/* u32 */
-	TIPC_NLA_STATS_AVG_QUEUE,	/* u32 */
-
-	__TIPC_NLA_STATS_MAX,
-	TIPC_NLA_STATS_MAX = __TIPC_NLA_STATS_MAX - 1
-};
-
-#endif
diff --git a/include/linux/types.h b/include/linux/types.h
deleted file mode 100644
index c640657..0000000
--- a/include/linux/types.h
+++ /dev/null
@@ -1,47 +0,0 @@
-#ifndef _LINUX_TYPES_H
-#define _LINUX_TYPES_H
-
-#include <asm/types.h>
-
-#ifndef __ASSEMBLY__
-
-#include <linux/posix_types.h>
-
-
-/*
- * Below are truly Linux-specific types that should never collide with
- * any application/library that wants linux/types.h.
- */
-
-#ifdef __CHECKER__
-#define __bitwise__ __attribute__((bitwise))
-#else
-#define __bitwise__
-#endif
-#define __bitwise __bitwise__
-
-typedef __u16 __bitwise __le16;
-typedef __u16 __bitwise __be16;
-typedef __u32 __bitwise __le32;
-typedef __u32 __bitwise __be32;
-typedef __u64 __bitwise __le64;
-typedef __u64 __bitwise __be64;
-
-typedef __u16 __bitwise __sum16;
-typedef __u32 __bitwise __wsum;
-
-/*
- * aligned_u64 should be used in defining kernel<->userspace ABIs to avoid
- * common 32/64-bit compat problems.
- * 64-bit values align to 4-byte boundaries on x86_32 (and possibly other
- * architectures) and to 8-byte boundaries on 64-bit architectures.  The new
- * aligned_64 type enforces 8-byte alignment so that structs containing
- * aligned_64 values have the same alignment on 32-bit and 64-bit architectures.
- * No conversions are necessary between 32-bit user-space and a 64-bit kernel.
- */
-#define __aligned_u64 __u64 __attribute__((aligned(8)))
-#define __aligned_be64 __be64 __attribute__((aligned(8)))
-#define __aligned_le64 __le64 __attribute__((aligned(8)))
-
-#endif /*  __ASSEMBLY__ */
-#endif /* _LINUX_TYPES_H */
diff --git a/include/linux/unix_diag.h b/include/linux/unix_diag.h
deleted file mode 100644
index 1eb0b8d..0000000
--- a/include/linux/unix_diag.h
+++ /dev/null
@@ -1,58 +0,0 @@
-#ifndef __UNIX_DIAG_H__
-#define __UNIX_DIAG_H__
-
-#include <linux/types.h>
-
-struct unix_diag_req {
-	__u8	sdiag_family;
-	__u8	sdiag_protocol;
-	__u16	pad;
-	__u32	udiag_states;
-	__u32	udiag_ino;
-	__u32	udiag_show;
-	__u32	udiag_cookie[2];
-};
-
-#define UDIAG_SHOW_NAME		0x00000001	/* show name (not path) */
-#define UDIAG_SHOW_VFS		0x00000002	/* show VFS inode info */
-#define UDIAG_SHOW_PEER		0x00000004	/* show peer socket info */
-#define UDIAG_SHOW_ICONS	0x00000008	/* show pending connections */
-#define UDIAG_SHOW_RQLEN	0x00000010	/* show skb receive queue len */
-#define UDIAG_SHOW_MEMINFO	0x00000020	/* show memory info of a socket */
-
-struct unix_diag_msg {
-	__u8	udiag_family;
-	__u8	udiag_type;
-	__u8	udiag_state;
-	__u8	pad;
-
-	__u32	udiag_ino;
-	__u32	udiag_cookie[2];
-};
-
-enum {
-	/* UNIX_DIAG_NONE, standard nl API requires this attribute!  */
-	UNIX_DIAG_NAME,
-	UNIX_DIAG_VFS,
-	UNIX_DIAG_PEER,
-	UNIX_DIAG_ICONS,
-	UNIX_DIAG_RQLEN,
-	UNIX_DIAG_MEMINFO,
-	UNIX_DIAG_SHUTDOWN,
-
-	__UNIX_DIAG_MAX,
-};
-
-#define UNIX_DIAG_MAX (__UNIX_DIAG_MAX - 1)
-
-struct unix_diag_vfs {
-	__u32	udiag_vfs_ino;
-	__u32	udiag_vfs_dev;
-};
-
-struct unix_diag_rqlen {
-	__u32	udiag_rqueue;
-	__u32	udiag_wqueue;
-};
-
-#endif
diff --git a/include/linux/veth.h b/include/linux/veth.h
deleted file mode 100644
index 3354c1e..0000000
--- a/include/linux/veth.h
+++ /dev/null
@@ -1,12 +0,0 @@
-#ifndef __NET_VETH_H_
-#define __NET_VETH_H_
-
-enum {
-	VETH_INFO_UNSPEC,
-	VETH_INFO_PEER,
-
-	__VETH_INFO_MAX
-#define VETH_INFO_MAX	(__VETH_INFO_MAX - 1)
-};
-
-#endif
diff --git a/include/linux/xfrm.h b/include/linux/xfrm.h
deleted file mode 100644
index 5790293..0000000
--- a/include/linux/xfrm.h
+++ /dev/null
@@ -1,536 +0,0 @@
-#ifndef _LINUX_XFRM_H
-#define _LINUX_XFRM_H
-
-#include <linux/in6.h>
-#include <linux/types.h>
-
-/* All of the structures in this file may not change size as they are
- * passed into the kernel from userspace via netlink sockets.
- */
-
-/* Structure to encapsulate addresses. I do not want to use
- * "standard" structure. My apologies.
- */
-typedef union {
-	__be32		a4;
-	__be32		a6[4];
-	struct in6_addr	in6;
-} xfrm_address_t;
-
-/* Ident of a specific xfrm_state. It is used on input to lookup
- * the state by (spi,daddr,ah/esp) or to store information about
- * spi, protocol and tunnel address on output.
- */
-struct xfrm_id {
-	xfrm_address_t	daddr;
-	__be32		spi;
-	__u8		proto;
-};
-
-struct xfrm_sec_ctx {
-	__u8	ctx_doi;
-	__u8	ctx_alg;
-	__u16	ctx_len;
-	__u32	ctx_sid;
-	char	ctx_str[0];
-};
-
-/* Security Context Domains of Interpretation */
-#define XFRM_SC_DOI_RESERVED 0
-#define XFRM_SC_DOI_LSM 1
-
-/* Security Context Algorithms */
-#define XFRM_SC_ALG_RESERVED 0
-#define XFRM_SC_ALG_SELINUX 1
-
-/* Selector, used as selector both on policy rules (SPD) and SAs. */
-
-struct xfrm_selector {
-	xfrm_address_t	daddr;
-	xfrm_address_t	saddr;
-	__be16	dport;
-	__be16	dport_mask;
-	__be16	sport;
-	__be16	sport_mask;
-	__u16	family;
-	__u8	prefixlen_d;
-	__u8	prefixlen_s;
-	__u8	proto;
-	int	ifindex;
-	__kernel_uid32_t	user;
-};
-
-#define XFRM_INF (~(__u64)0)
-
-struct xfrm_lifetime_cfg {
-	__u64	soft_byte_limit;
-	__u64	hard_byte_limit;
-	__u64	soft_packet_limit;
-	__u64	hard_packet_limit;
-	__u64	soft_add_expires_seconds;
-	__u64	hard_add_expires_seconds;
-	__u64	soft_use_expires_seconds;
-	__u64	hard_use_expires_seconds;
-};
-
-struct xfrm_lifetime_cur {
-	__u64	bytes;
-	__u64	packets;
-	__u64	add_time;
-	__u64	use_time;
-};
-
-struct xfrm_replay_state {
-	__u32	oseq;
-	__u32	seq;
-	__u32	bitmap;
-};
-
-#define XFRMA_REPLAY_ESN_MAX	4096
-
-struct xfrm_replay_state_esn {
-	unsigned int	bmp_len;
-	__u32		oseq;
-	__u32		seq;
-	__u32		oseq_hi;
-	__u32		seq_hi;
-	__u32		replay_window;
-	__u32		bmp[0];
-};
-
-struct xfrm_algo {
-	char		alg_name[64];
-	unsigned int	alg_key_len;    /* in bits */
-	char		alg_key[0];
-};
-
-struct xfrm_algo_auth {
-	char		alg_name[64];
-	unsigned int	alg_key_len;    /* in bits */
-	unsigned int	alg_trunc_len;  /* in bits */
-	char		alg_key[0];
-};
-
-struct xfrm_algo_aead {
-	char		alg_name[64];
-	unsigned int	alg_key_len;	/* in bits */
-	unsigned int	alg_icv_len;	/* in bits */
-	char		alg_key[0];
-};
-
-struct xfrm_stats {
-	__u32	replay_window;
-	__u32	replay;
-	__u32	integrity_failed;
-};
-
-enum {
-	XFRM_POLICY_TYPE_MAIN	= 0,
-	XFRM_POLICY_TYPE_SUB	= 1,
-	XFRM_POLICY_TYPE_MAX	= 2,
-	XFRM_POLICY_TYPE_ANY	= 255
-};
-
-enum {
-	XFRM_POLICY_IN	= 0,
-	XFRM_POLICY_OUT	= 1,
-	XFRM_POLICY_FWD	= 2,
-	XFRM_POLICY_MASK = 3,
-	XFRM_POLICY_MAX	= 3
-};
-
-enum {
-	XFRM_SHARE_ANY,		/* No limitations */
-	XFRM_SHARE_SESSION,	/* For this session only */
-	XFRM_SHARE_USER,	/* For this user only */
-	XFRM_SHARE_UNIQUE	/* Use once */
-};
-
-#define XFRM_MODE_TRANSPORT 0
-#define XFRM_MODE_TUNNEL 1
-#define XFRM_MODE_ROUTEOPTIMIZATION 2
-#define XFRM_MODE_IN_TRIGGER 3
-#define XFRM_MODE_BEET 4
-#define XFRM_MODE_MAX 5
-
-/* Netlink configuration messages.  */
-enum {
-	XFRM_MSG_BASE = 0x10,
-
-	XFRM_MSG_NEWSA = 0x10,
-#define XFRM_MSG_NEWSA XFRM_MSG_NEWSA
-	XFRM_MSG_DELSA,
-#define XFRM_MSG_DELSA XFRM_MSG_DELSA
-	XFRM_MSG_GETSA,
-#define XFRM_MSG_GETSA XFRM_MSG_GETSA
-
-	XFRM_MSG_NEWPOLICY,
-#define XFRM_MSG_NEWPOLICY XFRM_MSG_NEWPOLICY
-	XFRM_MSG_DELPOLICY,
-#define XFRM_MSG_DELPOLICY XFRM_MSG_DELPOLICY
-	XFRM_MSG_GETPOLICY,
-#define XFRM_MSG_GETPOLICY XFRM_MSG_GETPOLICY
-
-	XFRM_MSG_ALLOCSPI,
-#define XFRM_MSG_ALLOCSPI XFRM_MSG_ALLOCSPI
-	XFRM_MSG_ACQUIRE,
-#define XFRM_MSG_ACQUIRE XFRM_MSG_ACQUIRE
-	XFRM_MSG_EXPIRE,
-#define XFRM_MSG_EXPIRE XFRM_MSG_EXPIRE
-
-	XFRM_MSG_UPDPOLICY,
-#define XFRM_MSG_UPDPOLICY XFRM_MSG_UPDPOLICY
-	XFRM_MSG_UPDSA,
-#define XFRM_MSG_UPDSA XFRM_MSG_UPDSA
-
-	XFRM_MSG_POLEXPIRE,
-#define XFRM_MSG_POLEXPIRE XFRM_MSG_POLEXPIRE
-
-	XFRM_MSG_FLUSHSA,
-#define XFRM_MSG_FLUSHSA XFRM_MSG_FLUSHSA
-	XFRM_MSG_FLUSHPOLICY,
-#define XFRM_MSG_FLUSHPOLICY XFRM_MSG_FLUSHPOLICY
-
-	XFRM_MSG_NEWAE,
-#define XFRM_MSG_NEWAE XFRM_MSG_NEWAE
-	XFRM_MSG_GETAE,
-#define XFRM_MSG_GETAE XFRM_MSG_GETAE
-
-	XFRM_MSG_REPORT,
-#define XFRM_MSG_REPORT XFRM_MSG_REPORT
-
-	XFRM_MSG_MIGRATE,
-#define XFRM_MSG_MIGRATE XFRM_MSG_MIGRATE
-
-	XFRM_MSG_NEWSADINFO,
-#define XFRM_MSG_NEWSADINFO XFRM_MSG_NEWSADINFO
-	XFRM_MSG_GETSADINFO,
-#define XFRM_MSG_GETSADINFO XFRM_MSG_GETSADINFO
-
-	XFRM_MSG_NEWSPDINFO,
-#define XFRM_MSG_NEWSPDINFO XFRM_MSG_NEWSPDINFO
-	XFRM_MSG_GETSPDINFO,
-#define XFRM_MSG_GETSPDINFO XFRM_MSG_GETSPDINFO
-
-	XFRM_MSG_MAPPING,
-#define XFRM_MSG_MAPPING XFRM_MSG_MAPPING
-	__XFRM_MSG_MAX
-};
-#define XFRM_MSG_MAX (__XFRM_MSG_MAX - 1)
-
-#define XFRM_NR_MSGTYPES (XFRM_MSG_MAX + 1 - XFRM_MSG_BASE)
-
-/*
- * Generic LSM security context for comunicating to user space
- * NOTE: Same format as sadb_x_sec_ctx
- */
-struct xfrm_user_sec_ctx {
-	__u16			len;
-	__u16			exttype;
-	__u8			ctx_alg;  /* LSMs: e.g., selinux == 1 */
-	__u8			ctx_doi;
-	__u16			ctx_len;
-};
-
-struct xfrm_user_tmpl {
-	struct xfrm_id		id;
-	__u16			family;
-	xfrm_address_t		saddr;
-	__u32			reqid;
-	__u8			mode;
-	__u8			share;
-	__u8			optional;
-	__u32			aalgos;
-	__u32			ealgos;
-	__u32			calgos;
-};
-
-struct xfrm_encap_tmpl {
-	__u16		encap_type;
-	__be16		encap_sport;
-	__be16		encap_dport;
-	xfrm_address_t	encap_oa;
-};
-
-/* AEVENT flags  */
-enum xfrm_ae_ftype_t {
-	XFRM_AE_UNSPEC,
-	XFRM_AE_RTHR=1,	/* replay threshold*/
-	XFRM_AE_RVAL=2, /* replay value */
-	XFRM_AE_LVAL=4, /* lifetime value */
-	XFRM_AE_ETHR=8, /* expiry timer threshold */
-	XFRM_AE_CR=16, /* Event cause is replay update */
-	XFRM_AE_CE=32, /* Event cause is timer expiry */
-	XFRM_AE_CU=64, /* Event cause is policy update */
-	__XFRM_AE_MAX
-
-#define XFRM_AE_MAX (__XFRM_AE_MAX - 1)
-};
-
-struct xfrm_userpolicy_type {
-	__u8		type;
-	__u16		reserved1;
-	__u8		reserved2;
-};
-
-/* Netlink message attributes.  */
-enum xfrm_attr_type_t {
-	XFRMA_UNSPEC,
-	XFRMA_ALG_AUTH,		/* struct xfrm_algo */
-	XFRMA_ALG_CRYPT,	/* struct xfrm_algo */
-	XFRMA_ALG_COMP,		/* struct xfrm_algo */
-	XFRMA_ENCAP,		/* struct xfrm_algo + struct xfrm_encap_tmpl */
-	XFRMA_TMPL,		/* 1 or more struct xfrm_user_tmpl */
-	XFRMA_SA,		/* struct xfrm_usersa_info  */
-	XFRMA_POLICY,		/*struct xfrm_userpolicy_info */
-	XFRMA_SEC_CTX,		/* struct xfrm_sec_ctx */
-	XFRMA_LTIME_VAL,
-	XFRMA_REPLAY_VAL,
-	XFRMA_REPLAY_THRESH,
-	XFRMA_ETIMER_THRESH,
-	XFRMA_SRCADDR,		/* xfrm_address_t */
-	XFRMA_COADDR,		/* xfrm_address_t */
-	XFRMA_LASTUSED,		/* unsigned long  */
-	XFRMA_POLICY_TYPE,	/* struct xfrm_userpolicy_type */
-	XFRMA_MIGRATE,
-	XFRMA_ALG_AEAD,		/* struct xfrm_algo_aead */
-	XFRMA_KMADDRESS,        /* struct xfrm_user_kmaddress */
-	XFRMA_ALG_AUTH_TRUNC,	/* struct xfrm_algo_auth */
-	XFRMA_MARK,		/* struct xfrm_mark */
-	XFRMA_TFCPAD,		/* __u32 */
-	XFRMA_REPLAY_ESN_VAL,	/* struct xfrm_replay_state_esn */
-	XFRMA_SA_EXTRA_FLAGS,	/* __u32 */
-	XFRMA_PROTO,		/* __u8 */
-	XFRMA_ADDRESS_FILTER,	/* struct xfrm_address_filter */
-	XFRMA_PAD,
-	XFRMA_OFFLOAD_DEV,	/* struct xfrm_state_offload */
-	XFRMA_OUTPUT_MARK,	/* __u32 */
-	__XFRMA_MAX
-
-#define XFRMA_MAX (__XFRMA_MAX - 1)
-};
-
-struct xfrm_mark {
-	__u32           v; /* value */
-	__u32           m; /* mask */
-};
-
-enum xfrm_sadattr_type_t {
-	XFRMA_SAD_UNSPEC,
-	XFRMA_SAD_CNT,
-	XFRMA_SAD_HINFO,
-	__XFRMA_SAD_MAX
-
-#define XFRMA_SAD_MAX (__XFRMA_SAD_MAX - 1)
-};
-
-struct xfrmu_sadhinfo {
-	__u32 sadhcnt; /* current hash bkts */
-	__u32 sadhmcnt; /* max allowed hash bkts */
-};
-
-enum xfrm_spdattr_type_t {
-	XFRMA_SPD_UNSPEC,
-	XFRMA_SPD_INFO,
-	XFRMA_SPD_HINFO,
-	XFRMA_SPD_IPV4_HTHRESH,
-	XFRMA_SPD_IPV6_HTHRESH,
-	__XFRMA_SPD_MAX
-
-#define XFRMA_SPD_MAX (__XFRMA_SPD_MAX - 1)
-};
-
-struct xfrmu_spdinfo {
-	__u32 incnt;
-	__u32 outcnt;
-	__u32 fwdcnt;
-	__u32 inscnt;
-	__u32 outscnt;
-	__u32 fwdscnt;
-};
-
-struct xfrmu_spdhinfo {
-	__u32 spdhcnt;
-	__u32 spdhmcnt;
-};
-
-struct xfrmu_spdhthresh {
-	__u8 lbits;
-	__u8 rbits;
-};
-
-struct xfrm_usersa_info {
-	struct xfrm_selector		sel;
-	struct xfrm_id			id;
-	xfrm_address_t			saddr;
-	struct xfrm_lifetime_cfg	lft;
-	struct xfrm_lifetime_cur	curlft;
-	struct xfrm_stats		stats;
-	__u32				seq;
-	__u32				reqid;
-	__u16				family;
-	__u8				mode;		/* XFRM_MODE_xxx */
-	__u8				replay_window;
-	__u8				flags;
-#define XFRM_STATE_NOECN	1
-#define XFRM_STATE_DECAP_DSCP	2
-#define XFRM_STATE_NOPMTUDISC	4
-#define XFRM_STATE_WILDRECV	8
-#define XFRM_STATE_ICMP		16
-#define XFRM_STATE_AF_UNSPEC	32
-#define XFRM_STATE_ALIGN4	64
-#define XFRM_STATE_ESN		128
-};
-
-#define XFRM_SA_XFLAG_DONT_ENCAP_DSCP	1
-
-struct xfrm_usersa_id {
-	xfrm_address_t			daddr;
-	__be32				spi;
-	__u16				family;
-	__u8				proto;
-};
-
-struct xfrm_aevent_id {
-	struct xfrm_usersa_id		sa_id;
-	xfrm_address_t			saddr;
-	__u32				flags;
-	__u32				reqid;
-};
-
-struct xfrm_userspi_info {
-	struct xfrm_usersa_info		info;
-	__u32				min;
-	__u32				max;
-};
-
-struct xfrm_userpolicy_info {
-	struct xfrm_selector		sel;
-	struct xfrm_lifetime_cfg	lft;
-	struct xfrm_lifetime_cur	curlft;
-	__u32				priority;
-	__u32				index;
-	__u8				dir;
-	__u8				action;
-#define XFRM_POLICY_ALLOW	0
-#define XFRM_POLICY_BLOCK	1
-	__u8				flags;
-#define XFRM_POLICY_LOCALOK	1	/* Allow user to override global policy */
-	/* Automatically expand selector to include matching ICMP payloads. */
-#define XFRM_POLICY_ICMP	2
-	__u8				share;
-};
-
-struct xfrm_userpolicy_id {
-	struct xfrm_selector		sel;
-	__u32				index;
-	__u8				dir;
-};
-
-struct xfrm_user_acquire {
-	struct xfrm_id			id;
-	xfrm_address_t			saddr;
-	struct xfrm_selector		sel;
-	struct xfrm_userpolicy_info	policy;
-	__u32				aalgos;
-	__u32				ealgos;
-	__u32				calgos;
-	__u32				seq;
-};
-
-struct xfrm_user_expire {
-	struct xfrm_usersa_info		state;
-	__u8				hard;
-};
-
-struct xfrm_user_polexpire {
-	struct xfrm_userpolicy_info	pol;
-	__u8				hard;
-};
-
-struct xfrm_usersa_flush {
-	__u8				proto;
-};
-
-struct xfrm_user_report {
-	__u8				proto;
-	struct xfrm_selector		sel;
-};
-
-/* Used by MIGRATE to pass addresses IKE should use to perform
- * SA negotiation with the peer */
-struct xfrm_user_kmaddress {
-	xfrm_address_t                  local;
-	xfrm_address_t                  remote;
-	__u32				reserved;
-	__u16				family;
-};
-
-struct xfrm_user_migrate {
-	xfrm_address_t			old_daddr;
-	xfrm_address_t			old_saddr;
-	xfrm_address_t			new_daddr;
-	xfrm_address_t			new_saddr;
-	__u8				proto;
-	__u8				mode;
-	__u16				reserved;
-	__u32				reqid;
-	__u16				old_family;
-	__u16				new_family;
-};
-
-struct xfrm_user_mapping {
-	struct xfrm_usersa_id		id;
-	__u32				reqid;
-	xfrm_address_t			old_saddr;
-	xfrm_address_t			new_saddr;
-	__be16				old_sport;
-	__be16				new_sport;
-};
-
-struct xfrm_address_filter {
-	xfrm_address_t			saddr;
-	xfrm_address_t			daddr;
-	__u16				family;
-	__u8				splen;
-	__u8				dplen;
-};
-
-struct xfrm_user_offload {
-	int				ifindex;
-	__u8				flags;
-};
-#define XFRM_OFFLOAD_IPV6	1
-#define XFRM_OFFLOAD_INBOUND	2
-
-/* backwards compatibility for userspace */
-#define XFRMGRP_ACQUIRE		1
-#define XFRMGRP_EXPIRE		2
-#define XFRMGRP_SA		4
-#define XFRMGRP_POLICY		8
-#define XFRMGRP_REPORT		0x20
-
-enum xfrm_nlgroups {
-	XFRMNLGRP_NONE,
-#define XFRMNLGRP_NONE		XFRMNLGRP_NONE
-	XFRMNLGRP_ACQUIRE,
-#define XFRMNLGRP_ACQUIRE	XFRMNLGRP_ACQUIRE
-	XFRMNLGRP_EXPIRE,
-#define XFRMNLGRP_EXPIRE	XFRMNLGRP_EXPIRE
-	XFRMNLGRP_SA,
-#define XFRMNLGRP_SA		XFRMNLGRP_SA
-	XFRMNLGRP_POLICY,
-#define XFRMNLGRP_POLICY	XFRMNLGRP_POLICY
-	XFRMNLGRP_AEVENTS,
-#define XFRMNLGRP_AEVENTS	XFRMNLGRP_AEVENTS
-	XFRMNLGRP_REPORT,
-#define XFRMNLGRP_REPORT	XFRMNLGRP_REPORT
-	XFRMNLGRP_MIGRATE,
-#define XFRMNLGRP_MIGRATE	XFRMNLGRP_MIGRATE
-	XFRMNLGRP_MAPPING,
-#define XFRMNLGRP_MAPPING	XFRMNLGRP_MAPPING
-	__XFRMNLGRP_MAX
-};
-#define XFRMNLGRP_MAX	(__XFRMNLGRP_MAX - 1)
-
-#endif /* _LINUX_XFRM_H */
diff --git a/include/uapi/linux/atm.h b/include/uapi/linux/atm.h
new file mode 100644
index 0000000..08e27be
--- /dev/null
+++ b/include/uapi/linux/atm.h
@@ -0,0 +1,241 @@
+/* atm.h - general ATM declarations */
+ 
+/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
+ 
+
+/*
+ * WARNING: User-space programs should not #include <linux/atm.h> directly.
+ *          Instead, #include <atm.h>
+ */
+
+#ifndef _LINUX_ATM_H
+#define _LINUX_ATM_H
+
+/*
+ * BEGIN_xx and END_xx markers are used for automatic generation of
+ * documentation. Do not change them.
+ */
+
+
+#include <linux/atmapi.h>
+#include <linux/atmsap.h>
+#include <linux/atmioc.h>
+#include <linux/types.h>
+
+
+/* general ATM constants */
+#define ATM_CELL_SIZE		    53	/* ATM cell size incl. header */
+#define ATM_CELL_PAYLOAD	    48	/* ATM payload size */
+#define ATM_AAL0_SDU		    52	/* AAL0 SDU size */
+#define ATM_MAX_AAL34_PDU	 65535	/* maximum AAL3/4 PDU payload */
+#define ATM_AAL5_TRAILER	     8	/* AAL5 trailer size */
+#define ATM_MAX_AAL5_PDU	 65535	/* maximum AAL5 PDU payload */
+#define ATM_MAX_CDV		  9999	/* maximum (default) CDV */
+#define ATM_NOT_RSV_VCI		    32	/* first non-reserved VCI value */
+
+#define ATM_MAX_VPI		   255	/* maximum VPI at the UNI */
+#define ATM_MAX_VPI_NNI		  4096	/* maximum VPI at the NNI */
+#define ATM_MAX_VCI		 65535	/* maximum VCI */
+
+
+/* "protcol" values for the socket system call */
+#define ATM_NO_AAL	0		/* AAL not specified */
+#define ATM_AAL0	13		/* "raw" ATM cells */
+#define ATM_AAL1	1		/* AAL1 (CBR) */
+#define ATM_AAL2	2		/* AAL2 (VBR) */
+#define ATM_AAL34	3		/* AAL3/4 (data) */
+#define ATM_AAL5	5		/* AAL5 (data) */
+
+/*
+ * socket option name coding functions
+ *
+ * Note that __SO_ENCODE and __SO_LEVEL are somewhat a hack since the
+ * << 22 only reserves 9 bits for the level.  On some architectures
+ * SOL_SOCKET is 0xFFFF, so that's a bit of a problem
+ */
+
+#define __SO_ENCODE(l,n,t)	((((l) & 0x1FF) << 22) | ((n) << 16) | \
+				sizeof(t))
+#define __SO_LEVEL_MATCH(c,m)	(((c) >> 22) == ((m) & 0x1FF))
+#define __SO_NUMBER(c)		(((c) >> 16) & 0x3f)
+#define __SO_SIZE(c)		((c) & 0x3fff)
+
+/*
+ * ATM layer
+ */
+
+#define SO_SETCLP	__SO_ENCODE(SOL_ATM,0,int)
+			    /* set CLP bit value - TODO */
+#define SO_CIRANGE	__SO_ENCODE(SOL_ATM,1,struct atm_cirange)
+			    /* connection identifier range; socket must be
+			       bound or connected */
+#define SO_ATMQOS	__SO_ENCODE(SOL_ATM,2,struct atm_qos)
+			    /* Quality of Service setting */
+#define SO_ATMSAP	__SO_ENCODE(SOL_ATM,3,struct atm_sap)
+			    /* Service Access Point */
+#define SO_ATMPVC	__SO_ENCODE(SOL_ATM,4,struct sockaddr_atmpvc)
+			    /* "PVC" address (also for SVCs); get only */
+#define SO_MULTIPOINT	__SO_ENCODE(SOL_ATM, 5, int)
+			    /* make this vc a p2mp */
+
+
+/*
+ * Note @@@: since the socket layers don't really distinguish the control and
+ * the data plane but generally seems to be data plane-centric, any layer is
+ * about equally wrong for the SAP. If you have a better idea about this,
+ * please speak up ...
+ */
+
+
+/* ATM cell header (for AAL0) */
+
+/* BEGIN_CH */
+#define ATM_HDR_GFC_MASK	0xf0000000
+#define ATM_HDR_GFC_SHIFT	28
+#define ATM_HDR_VPI_MASK	0x0ff00000
+#define ATM_HDR_VPI_SHIFT	20
+#define ATM_HDR_VCI_MASK	0x000ffff0
+#define ATM_HDR_VCI_SHIFT	4
+#define ATM_HDR_PTI_MASK	0x0000000e
+#define ATM_HDR_PTI_SHIFT	1
+#define ATM_HDR_CLP		0x00000001
+/* END_CH */
+
+
+/* PTI codings */
+
+/* BEGIN_PTI */
+#define ATM_PTI_US0	0  /* user data cell, congestion not exp, SDU-type 0 */
+#define ATM_PTI_US1	1  /* user data cell, congestion not exp, SDU-type 1 */
+#define ATM_PTI_UCES0	2  /* user data cell, cong. experienced, SDU-type 0 */
+#define ATM_PTI_UCES1	3  /* user data cell, cong. experienced, SDU-type 1 */
+#define ATM_PTI_SEGF5	4  /* segment OAM F5 flow related cell */
+#define ATM_PTI_E2EF5	5  /* end-to-end OAM F5 flow related cell */
+#define ATM_PTI_RSV_RM	6  /* reserved for traffic control/resource mgmt */
+#define ATM_PTI_RSV	7  /* reserved */
+/* END_PTI */
+
+
+/*
+ * The following items should stay in linux/atm.h, which should be linked to
+ * netatm/atm.h
+ */
+
+/* Traffic description */
+
+#define ATM_NONE	0		/* no traffic */
+#define ATM_UBR		1
+#define ATM_CBR		2
+#define ATM_VBR		3
+#define ATM_ABR		4
+#define ATM_ANYCLASS	5		/* compatible with everything */
+
+#define ATM_MAX_PCR	-1		/* maximum available PCR */
+
+struct atm_trafprm {
+	unsigned char	traffic_class;	/* traffic class (ATM_UBR, ...) */
+	int		max_pcr;	/* maximum PCR in cells per second */
+	int		pcr;		/* desired PCR in cells per second */
+	int		min_pcr;	/* minimum PCR in cells per second */
+	int		max_cdv;	/* maximum CDV in microseconds */
+	int		max_sdu;	/* maximum SDU in bytes */
+        /* extra params for ABR */
+        unsigned int 	icr;         	/* Initial Cell Rate (24-bit) */
+        unsigned int	tbe;		/* Transient Buffer Exposure (24-bit) */ 
+        unsigned int 	frtt : 24;	/* Fixed Round Trip Time (24-bit) */
+        unsigned int 	rif  : 4;       /* Rate Increment Factor (4-bit) */
+        unsigned int 	rdf  : 4;       /* Rate Decrease Factor (4-bit) */
+        unsigned int nrm_pres  :1;      /* nrm present bit */
+        unsigned int trm_pres  :1;     	/* rm present bit */
+        unsigned int adtf_pres :1;     	/* adtf present bit */
+        unsigned int cdf_pres  :1;    	/* cdf present bit*/
+        unsigned int nrm       :3;     	/* Max # of Cells for each forward RM cell (3-bit) */
+        unsigned int trm       :3;    	/* Time between forward RM cells (3-bit) */    
+	unsigned int adtf      :10;     /* ACR Decrease Time Factor (10-bit) */
+	unsigned int cdf       :3;      /* Cutoff Decrease Factor (3-bit) */
+        unsigned int spare     :9;      /* spare bits */ 
+};
+
+struct atm_qos {
+	struct atm_trafprm txtp;	/* parameters in TX direction */
+	struct atm_trafprm rxtp __ATM_API_ALIGN;
+					/* parameters in RX direction */
+	unsigned char aal __ATM_API_ALIGN;
+};
+
+/* PVC addressing */
+
+#define ATM_ITF_ANY	-1		/* "magic" PVC address values */
+#define ATM_VPI_ANY	-1
+#define ATM_VCI_ANY	-1
+#define ATM_VPI_UNSPEC	-2
+#define ATM_VCI_UNSPEC	-2
+
+
+struct sockaddr_atmpvc {
+	unsigned short 	sap_family;	/* address family, AF_ATMPVC  */
+	struct {			/* PVC address */
+		short	itf;		/* ATM interface */
+		short	vpi;		/* VPI (only 8 bits at UNI) */
+		int	vci;		/* VCI (only 16 bits at UNI) */
+	} sap_addr __ATM_API_ALIGN;	/* PVC address */
+};
+
+/* SVC addressing */
+
+#define	ATM_ESA_LEN	20		/* ATM End System Address length */
+#define ATM_E164_LEN	12		/* maximum E.164 number length */
+
+#define ATM_AFI_DCC	0x39		/* DCC ATM Format */
+#define ATM_AFI_ICD	0x47		/* ICD ATM Format */
+#define ATM_AFI_E164	0x45		/* E.164 ATM Format */
+#define ATM_AFI_LOCAL	0x49		/* Local ATM Format */ 
+
+#define ATM_AFI_DCC_GROUP	0xBD	/* DCC ATM Group Format */
+#define ATM_AFI_ICD_GROUP	0xC5	/* ICD ATM Group Format */
+#define ATM_AFI_E164_GROUP	0xC3	/* E.164 ATM Group Format */
+#define ATM_AFI_LOCAL_GROUP	0xC7	/* Local ATM Group Format */
+
+#define ATM_LIJ_NONE	0		/* no leaf-initiated join */
+#define ATM_LIJ		1		/* request joining */
+#define ATM_LIJ_RPJ	2		/* set to root-prompted join */
+#define ATM_LIJ_NJ	3		/* set to network join */
+
+
+struct sockaddr_atmsvc {
+    unsigned short 	sas_family;	/* address family, AF_ATMSVC */
+    struct {				/* SVC address */
+        unsigned char	prv[ATM_ESA_LEN];/* private ATM address */
+        char		pub[ATM_E164_LEN+1]; /* public address (E.164) */
+    					/* unused addresses must be bzero'ed */
+	char		lij_type;	/* role in LIJ call; one of ATM_LIJ* */
+	__u32	lij_id;		/* LIJ call identifier */
+    } sas_addr __ATM_API_ALIGN;		/* SVC address */
+};
+
+
+static __inline__ int atmsvc_addr_in_use(struct sockaddr_atmsvc addr)
+{
+	return *addr.sas_addr.prv || *addr.sas_addr.pub;
+}
+
+
+static __inline__ int atmpvc_addr_in_use(struct sockaddr_atmpvc addr)
+{
+	return addr.sap_addr.itf || addr.sap_addr.vpi || addr.sap_addr.vci;
+}
+
+
+/*
+ * Some stuff for linux/sockios.h
+ */
+
+struct atmif_sioc {
+	int number;
+	int length;
+	void *arg;
+};
+
+
+typedef unsigned short atm_backend_t;
+#endif /* _LINUX_ATM_H */
diff --git a/include/uapi/linux/atmapi.h b/include/uapi/linux/atmapi.h
new file mode 100644
index 0000000..8fe54d9
--- /dev/null
+++ b/include/uapi/linux/atmapi.h
@@ -0,0 +1,29 @@
+/* atmapi.h - ATM API user space/kernel compatibility */
+ 
+/* Written 1999,2000 by Werner Almesberger, EPFL ICA */
+ 
+
+#ifndef _LINUX_ATMAPI_H
+#define _LINUX_ATMAPI_H
+
+#if defined(__sparc__) || defined(__ia64__)
+/* such alignment is not required on 32 bit sparcs, but we can't
+   figure that we are on a sparc64 while compiling user-space programs. */
+#define __ATM_API_ALIGN	__attribute__((aligned(8)))
+#else
+#define __ATM_API_ALIGN
+#endif
+
+
+/*
+ * Opaque type for kernel pointers. Note that _ is never accessed. We need
+ * the struct in order hide the array, so that we can make simple assignments
+ * instead of being forced to use memcpy. It also improves error reporting for
+ * code that still assumes that we're passing unsigned longs.
+ *
+ * Convention: NULL pointers are passed as a field of all zeroes.
+ */
+ 
+typedef struct { unsigned char _[8]; } __ATM_API_ALIGN atm_kptr_t;
+
+#endif
diff --git a/include/uapi/linux/atmarp.h b/include/uapi/linux/atmarp.h
new file mode 100644
index 0000000..231f4bd
--- /dev/null
+++ b/include/uapi/linux/atmarp.h
@@ -0,0 +1,41 @@
+/* atmarp.h - ATM ARP protocol and kernel-demon interface definitions */
+ 
+/* Written 1995-1999 by Werner Almesberger, EPFL LRC/ICA */
+ 
+
+#ifndef _LINUX_ATMARP_H
+#define _LINUX_ATMARP_H
+
+#include <linux/types.h>
+#include <linux/atmapi.h>
+#include <linux/atmioc.h>
+
+
+#define ATMARP_RETRY_DELAY 30		/* request next resolution or forget
+					   NAK after 30 sec - should go into
+					   atmclip.h */
+#define ATMARP_MAX_UNRES_PACKETS 5	/* queue that many packets while
+					   waiting for the resolver */
+
+
+#define ATMARPD_CTRL	_IO('a',ATMIOC_CLIP+1)	/* become atmarpd ctrl sock */
+#define ATMARP_MKIP	_IO('a',ATMIOC_CLIP+2)	/* attach socket to IP */
+#define ATMARP_SETENTRY	_IO('a',ATMIOC_CLIP+3)	/* fill or hide ARP entry */
+#define ATMARP_ENCAP	_IO('a',ATMIOC_CLIP+5)	/* change encapsulation */
+
+
+enum atmarp_ctrl_type {
+	act_invalid,		/* catch uninitialized structures */
+	act_need,		/* need address resolution */
+	act_up,			/* interface is coming up */
+	act_down,		/* interface is going down */
+	act_change		/* interface configuration has changed */
+};
+
+struct atmarp_ctrl {
+	enum atmarp_ctrl_type	type;	/* message type */
+	int			itf_num;/* interface number (if present) */
+	__be32			ip;	/* IP address (act_need only) */
+};
+
+#endif
diff --git a/include/uapi/linux/atmdev.h b/include/uapi/linux/atmdev.h
new file mode 100644
index 0000000..8faa8b9
--- /dev/null
+++ b/include/uapi/linux/atmdev.h
@@ -0,0 +1,215 @@
+/* atmdev.h - ATM device driver declarations and various related items */
+ 
+/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
+ 
+
+#ifndef LINUX_ATMDEV_H
+#define LINUX_ATMDEV_H
+
+
+#include <linux/atmapi.h>
+#include <linux/atm.h>
+#include <linux/atmioc.h>
+
+
+#define ESI_LEN		6
+
+#define ATM_OC3_PCR	(155520000/270*260/8/53)
+			/* OC3 link rate:  155520000 bps
+			   SONET overhead: /270*260 (9 section, 1 path)
+			   bits per cell:  /8/53
+			   max cell rate:  353207.547 cells/sec */
+#define ATM_25_PCR	((25600000/8-8000)/54)
+			/* 25 Mbps ATM cell rate (59111) */
+#define ATM_OC12_PCR	(622080000/1080*1040/8/53)
+			/* OC12 link rate: 622080000 bps
+			   SONET overhead: /1080*1040
+			   bits per cell:  /8/53
+			   max cell rate:  1412830.188 cells/sec */
+#define ATM_DS3_PCR	(8000*12)
+			/* DS3: 12 cells in a 125 usec time slot */
+
+
+#define __AAL_STAT_ITEMS \
+    __HANDLE_ITEM(tx);			/* TX okay */ \
+    __HANDLE_ITEM(tx_err);		/* TX errors */ \
+    __HANDLE_ITEM(rx);			/* RX okay */ \
+    __HANDLE_ITEM(rx_err);		/* RX errors */ \
+    __HANDLE_ITEM(rx_drop);		/* RX out of memory */
+
+struct atm_aal_stats {
+#define __HANDLE_ITEM(i) int i
+	__AAL_STAT_ITEMS
+#undef __HANDLE_ITEM
+};
+
+
+struct atm_dev_stats {
+	struct atm_aal_stats aal0;
+	struct atm_aal_stats aal34;
+	struct atm_aal_stats aal5;
+} __ATM_API_ALIGN;
+
+
+#define ATM_GETLINKRATE	_IOW('a',ATMIOC_ITF+1,struct atmif_sioc)
+					/* get link rate */
+#define ATM_GETNAMES	_IOW('a',ATMIOC_ITF+3,struct atm_iobuf)
+					/* get interface names (numbers) */
+#define ATM_GETTYPE	_IOW('a',ATMIOC_ITF+4,struct atmif_sioc)
+					/* get interface type name */
+#define ATM_GETESI	_IOW('a',ATMIOC_ITF+5,struct atmif_sioc)
+					/* get interface ESI */
+#define ATM_GETADDR	_IOW('a',ATMIOC_ITF+6,struct atmif_sioc)
+					/* get itf's local ATM addr. list */
+#define ATM_RSTADDR	_IOW('a',ATMIOC_ITF+7,struct atmif_sioc)
+					/* reset itf's ATM address list */
+#define ATM_ADDADDR	_IOW('a',ATMIOC_ITF+8,struct atmif_sioc)
+					/* add a local ATM address */
+#define ATM_DELADDR	_IOW('a',ATMIOC_ITF+9,struct atmif_sioc)
+					/* remove a local ATM address */
+#define ATM_GETCIRANGE	_IOW('a',ATMIOC_ITF+10,struct atmif_sioc)
+					/* get connection identifier range */
+#define ATM_SETCIRANGE	_IOW('a',ATMIOC_ITF+11,struct atmif_sioc)
+					/* set connection identifier range */
+#define ATM_SETESI	_IOW('a',ATMIOC_ITF+12,struct atmif_sioc)
+					/* set interface ESI */
+#define ATM_SETESIF	_IOW('a',ATMIOC_ITF+13,struct atmif_sioc)
+					/* force interface ESI */
+#define ATM_ADDLECSADDR	_IOW('a', ATMIOC_ITF+14, struct atmif_sioc)
+					/* register a LECS address */
+#define ATM_DELLECSADDR	_IOW('a', ATMIOC_ITF+15, struct atmif_sioc)
+					/* unregister a LECS address */
+#define ATM_GETLECSADDR	_IOW('a', ATMIOC_ITF+16, struct atmif_sioc)
+					/* retrieve LECS address(es) */
+
+#define ATM_GETSTAT	_IOW('a',ATMIOC_SARCOM+0,struct atmif_sioc)
+					/* get AAL layer statistics */
+#define ATM_GETSTATZ	_IOW('a',ATMIOC_SARCOM+1,struct atmif_sioc)
+					/* get AAL layer statistics and zero */
+#define ATM_GETLOOP	_IOW('a',ATMIOC_SARCOM+2,struct atmif_sioc)
+					/* get loopback mode */
+#define ATM_SETLOOP	_IOW('a',ATMIOC_SARCOM+3,struct atmif_sioc)
+					/* set loopback mode */
+#define ATM_QUERYLOOP	_IOW('a',ATMIOC_SARCOM+4,struct atmif_sioc)
+					/* query supported loopback modes */
+#define ATM_SETSC	_IOW('a',ATMIOC_SPECIAL+1,int)
+					/* enable or disable single-copy */
+#define ATM_SETBACKEND	_IOW('a',ATMIOC_SPECIAL+2,atm_backend_t)
+					/* set backend handler */
+#define ATM_NEWBACKENDIF _IOW('a',ATMIOC_SPECIAL+3,atm_backend_t)
+					/* use backend to make new if */
+#define ATM_ADDPARTY  	_IOW('a', ATMIOC_SPECIAL+4,struct atm_iobuf)
+ 					/* add party to p2mp call */
+#ifdef CONFIG_COMPAT
+/* It actually takes struct sockaddr_atmsvc, not struct atm_iobuf */
+#define COMPAT_ATM_ADDPARTY  	_IOW('a', ATMIOC_SPECIAL+4,struct compat_atm_iobuf)
+#endif
+#define ATM_DROPPARTY 	_IOW('a', ATMIOC_SPECIAL+5,int)
+					/* drop party from p2mp call */
+
+/*
+ * These are backend handkers that can be set via the ATM_SETBACKEND call
+ * above.  In the future we may support dynamic loading of these - for now,
+ * they're just being used to share the ATMIOC_BACKEND ioctls
+ */
+#define ATM_BACKEND_RAW		0	
+#define ATM_BACKEND_PPP		1	/* PPPoATM - RFC2364 */
+#define ATM_BACKEND_BR2684	2	/* Bridged RFC1483/2684 */
+
+/* for ATM_GETTYPE */
+#define ATM_ITFTYP_LEN	8	/* maximum length of interface type name */
+
+/*
+ * Loopback modes for ATM_{PHY,SAR}_{GET,SET}LOOP
+ */
+
+/* Point of loopback				CPU-->SAR-->PHY-->line--> ... */
+#define __ATM_LM_NONE	0	/* no loop back     ^     ^     ^      ^      */
+#define __ATM_LM_AAL	1	/* loop back PDUs --'     |     |      |      */
+#define __ATM_LM_ATM	2	/* loop back ATM cells ---'     |      |      */
+/* RESERVED		4	loop back on PHY side  ---'		      */
+#define __ATM_LM_PHY	8	/* loop back bits (digital) ----'      |      */
+#define __ATM_LM_ANALOG 16	/* loop back the analog signal --------'      */
+
+/* Direction of loopback */
+#define __ATM_LM_MKLOC(n)	((n))	    /* Local (i.e. loop TX to RX) */
+#define __ATM_LM_MKRMT(n)	((n) << 8)  /* Remote (i.e. loop RX to TX) */
+
+#define __ATM_LM_XTLOC(n)	((n) & 0xff)
+#define __ATM_LM_XTRMT(n)	(((n) >> 8) & 0xff)
+
+#define ATM_LM_NONE	0	/* no loopback */
+
+#define ATM_LM_LOC_AAL	__ATM_LM_MKLOC(__ATM_LM_AAL)
+#define ATM_LM_LOC_ATM	__ATM_LM_MKLOC(__ATM_LM_ATM)
+#define ATM_LM_LOC_PHY	__ATM_LM_MKLOC(__ATM_LM_PHY)
+#define ATM_LM_LOC_ANALOG __ATM_LM_MKLOC(__ATM_LM_ANALOG)
+
+#define ATM_LM_RMT_AAL	__ATM_LM_MKRMT(__ATM_LM_AAL)
+#define ATM_LM_RMT_ATM	__ATM_LM_MKRMT(__ATM_LM_ATM)
+#define ATM_LM_RMT_PHY	__ATM_LM_MKRMT(__ATM_LM_PHY)
+#define ATM_LM_RMT_ANALOG __ATM_LM_MKRMT(__ATM_LM_ANALOG)
+
+/*
+ * Note: ATM_LM_LOC_* and ATM_LM_RMT_* can be combined, provided that
+ * __ATM_LM_XTLOC(x) <= __ATM_LM_XTRMT(x)
+ */
+
+
+struct atm_iobuf {
+	int length;
+	void *buffer;
+};
+
+/* for ATM_GETCIRANGE / ATM_SETCIRANGE */
+
+#define ATM_CI_MAX      -1              /* use maximum range of VPI/VCI */
+ 
+struct atm_cirange {
+	signed char	vpi_bits;	/* 1..8, ATM_CI_MAX (-1) for maximum */
+	signed char	vci_bits;	/* 1..16, ATM_CI_MAX (-1) for maximum */
+};
+
+/* for ATM_SETSC; actually taken from the ATM_VF number space */
+
+#define ATM_SC_RX	1024		/* enable RX single-copy */
+#define ATM_SC_TX	2048		/* enable TX single-copy */
+
+#define ATM_BACKLOG_DEFAULT 32 /* if we get more, we're likely to time out
+				  anyway */
+
+/* MF: change_qos (Modify) flags */
+
+#define ATM_MF_IMMED	 1	/* Block until change is effective */
+#define ATM_MF_INC_RSV	 2	/* Change reservation on increase */
+#define ATM_MF_INC_SHP	 4	/* Change shaping on increase */
+#define ATM_MF_DEC_RSV	 8	/* Change reservation on decrease */
+#define ATM_MF_DEC_SHP	16	/* Change shaping on decrease */
+#define ATM_MF_BWD	32	/* Set the backward direction parameters */
+
+#define ATM_MF_SET	(ATM_MF_INC_RSV | ATM_MF_INC_SHP | ATM_MF_DEC_RSV | \
+			  ATM_MF_DEC_SHP | ATM_MF_BWD)
+
+/*
+ * ATM_VS_* are used to express VC state in a human-friendly way.
+ */
+
+#define ATM_VS_IDLE	0	/* VC is not used */
+#define ATM_VS_CONNECTED 1	/* VC is connected */
+#define ATM_VS_CLOSING	2	/* VC is closing */
+#define ATM_VS_LISTEN	3	/* VC is listening for incoming setups */
+#define ATM_VS_INUSE	4	/* VC is in use (registered with atmsigd) */
+#define ATM_VS_BOUND	5	/* VC is bound */
+
+#define ATM_VS2TXT_MAP \
+    "IDLE", "CONNECTED", "CLOSING", "LISTEN", "INUSE", "BOUND"
+
+#define ATM_VF2TXT_MAP \
+    "ADDR",	"READY",	"PARTIAL",	"REGIS", \
+    "RELEASED", "HASQOS",	"LISTEN",	"META", \
+    "256",	"512",		"1024",		"2048", \
+    "SESSION",	"HASSAP",	"BOUND",	"CLOSE"
+
+
+
+#endif /* LINUX_ATMDEV_H */
diff --git a/include/uapi/linux/atmioc.h b/include/uapi/linux/atmioc.h
new file mode 100644
index 0000000..37f67aa
--- /dev/null
+++ b/include/uapi/linux/atmioc.h
@@ -0,0 +1,41 @@
+/* atmioc.h - ranges for ATM-related ioctl numbers */
+ 
+/* Written 1995-1999 by Werner Almesberger, EPFL LRC/ICA */
+
+
+/*
+ * See http://icawww1.epfl.ch/linux-atm/magic.html for the complete list of
+ * "magic" ioctl numbers.
+ */
+
+
+#ifndef _LINUX_ATMIOC_H
+#define _LINUX_ATMIOC_H
+
+#include <asm/ioctl.h>
+		/* everybody including atmioc.h will also need _IO{,R,W,WR} */
+
+#define ATMIOC_PHYCOM	  0x00 /* PHY device common ioctls, globally unique */
+#define ATMIOC_PHYCOM_END 0x0f
+#define ATMIOC_PHYTYP	  0x10 /* PHY dev type ioctls, unique per PHY type */
+#define ATMIOC_PHYTYP_END 0x2f
+#define ATMIOC_PHYPRV	  0x30 /* PHY dev private ioctls, unique per driver */
+#define ATMIOC_PHYPRV_END 0x4f
+#define ATMIOC_SARCOM	  0x50 /* SAR device common ioctls, globally unique */
+#define ATMIOC_SARCOM_END 0x50
+#define ATMIOC_SARPRV	  0x60 /* SAR dev private ioctls, unique per driver */
+#define ATMIOC_SARPRV_END 0x7f
+#define ATMIOC_ITF	  0x80 /* Interface ioctls, globally unique */
+#define ATMIOC_ITF_END	  0x8f
+#define ATMIOC_BACKEND	  0x90 /* ATM generic backend ioctls, u. per backend */
+#define ATMIOC_BACKEND_END 0xaf
+/* 0xb0-0xbf: Reserved for future use */
+#define ATMIOC_AREQUIPA	  0xc0 /* Application requested IP over ATM, glob. u. */
+#define ATMIOC_LANE	  0xd0 /* LAN Emulation, globally unique */
+#define ATMIOC_MPOA       0xd8 /* MPOA, globally unique */
+#define	ATMIOC_CLIP	  0xe0 /* Classical IP over ATM control, globally u. */
+#define	ATMIOC_CLIP_END	  0xef
+#define	ATMIOC_SPECIAL	  0xf0 /* Special-purpose controls, globally unique */
+#define	ATMIOC_SPECIAL_END 0xff
+
+#endif
diff --git a/include/uapi/linux/atmsap.h b/include/uapi/linux/atmsap.h
new file mode 100644
index 0000000..799b104
--- /dev/null
+++ b/include/uapi/linux/atmsap.h
@@ -0,0 +1,162 @@
+/* atmsap.h - ATM Service Access Point addressing definitions */
+
+/* Written 1995-1999 by Werner Almesberger, EPFL LRC/ICA */
+
+
+#ifndef _LINUX_ATMSAP_H
+#define _LINUX_ATMSAP_H
+
+#include <linux/atmapi.h>
+
+/*
+ * BEGIN_xx and END_xx markers are used for automatic generation of
+ * documentation. Do not change them.
+ */
+
+
+/*
+ * Layer 2 protocol identifiers
+ */
+
+/* BEGIN_L2 */
+#define ATM_L2_NONE	0	/* L2 not specified */
+#define ATM_L2_ISO1745  0x01	/* Basic mode ISO 1745 */
+#define ATM_L2_Q291	0x02	/* ITU-T Q.291 (Rec. I.441) */
+#define ATM_L2_X25_LL	0x06	/* ITU-T X.25, link layer */
+#define ATM_L2_X25_ML	0x07	/* ITU-T X.25, multilink */
+#define ATM_L2_LAPB	0x08	/* Extended LAPB, half-duplex (Rec. T.71) */
+#define ATM_L2_HDLC_ARM	0x09	/* HDLC ARM (ISO/IEC 4335) */
+#define ATM_L2_HDLC_NRM	0x0a	/* HDLC NRM (ISO/IEC 4335) */
+#define ATM_L2_HDLC_ABM	0x0b	/* HDLC ABM (ISO/IEC 4335) */
+#define ATM_L2_ISO8802	0x0c	/* LAN LLC (ISO/IEC 8802/2) */
+#define ATM_L2_X75	0x0d	/* ITU-T X.75, SLP */
+#define ATM_L2_Q922	0x0e	/* ITU-T Q.922 */
+#define ATM_L2_USER	0x10	/* user-specified */
+#define ATM_L2_ISO7776	0x11	/* ISO 7776 DTE-DTE */
+/* END_L2 */
+
+
+/*
+ * Layer 3 protocol identifiers
+ */
+
+/* BEGIN_L3 */
+#define ATM_L3_NONE	0	/* L3 not specified */
+#define ATM_L3_X25	0x06	/* ITU-T X.25, packet layer */
+#define ATM_L3_ISO8208	0x07	/* ISO/IEC 8208 */
+#define ATM_L3_X223	0x08	/* ITU-T X.223 | ISO/IEC 8878 */
+#define ATM_L3_ISO8473	0x09	/* ITU-T X.233 | ISO/IEC 8473 */
+#define ATM_L3_T70	0x0a	/* ITU-T T.70 minimum network layer */
+#define ATM_L3_TR9577	0x0b	/* ISO/IEC TR 9577 */
+#define ATM_L3_H310	0x0c	/* ITU-T Recommendation H.310 */
+#define ATM_L3_H321	0x0d	/* ITU-T Recommendation H.321 */
+#define ATM_L3_USER	0x10	/* user-specified */
+/* END_L3 */
+
+
+/*
+ * High layer identifiers
+ */
+
+/* BEGIN_HL */
+#define ATM_HL_NONE	0	/* HL not specified */
+#define ATM_HL_ISO	0x01	/* ISO */
+#define ATM_HL_USER	0x02	/* user-specific */
+#define ATM_HL_HLP	0x03	/* high layer profile - UNI 3.0 only */
+#define ATM_HL_VENDOR	0x04	/* vendor-specific application identifier */
+/* END_HL */
+
+
+/*
+ * ITU-T coded mode of operation
+ */
+
+/* BEGIN_IMD */
+#define ATM_IMD_NONE	 0	/* mode not specified */
+#define ATM_IMD_NORMAL	 1	/* normal mode of operation */
+#define ATM_IMD_EXTENDED 2	/* extended mode of operation */
+/* END_IMD */
+
+/*
+ * H.310 code points
+ */
+
+#define ATM_TT_NONE	0	/* terminal type not specified */
+#define ATM_TT_RX	1	/* receive only */
+#define ATM_TT_TX	2	/* send only */
+#define ATM_TT_RXTX	3	/* receive and send */
+
+#define ATM_MC_NONE	0	/* no multiplexing */
+#define ATM_MC_TS	1	/* transport stream (TS) */
+#define ATM_MC_TS_FEC	2	/* transport stream with forward error corr. */
+#define ATM_MC_PS	3	/* program stream (PS) */
+#define ATM_MC_PS_FEC	4	/* program stream with forward error corr. */
+#define ATM_MC_H221	5	/* ITU-T Rec. H.221 */
+
+/*
+ * SAP structures
+ */
+
+#define ATM_MAX_HLI	8	/* maximum high-layer information length */
+
+
+struct atm_blli {
+    unsigned char l2_proto;	/* layer 2 protocol */
+    union {
+	struct {
+	    unsigned char mode;	/* mode of operation (ATM_IMD_xxx), 0 if */
+				/* absent */
+	    unsigned char window; /* window size (k), 1-127 (0 to omit) */
+	} itu;			/* ITU-T encoding */
+	unsigned char user;	/* user-specified l2 information */
+    } l2;
+    unsigned char l3_proto;	/* layer 3 protocol */
+    union {
+	struct {
+	    unsigned char mode;	/* mode of operation (ATM_IMD_xxx), 0 if */
+				/* absent */
+	    unsigned char def_size; /* default packet size (log2), 4-12 (0 to */
+				    /* omit) */
+	    unsigned char window;/* packet window size, 1-127 (0 to omit) */
+	} itu;			/* ITU-T encoding */
+	unsigned char user;	/* user specified l3 information */
+	struct {		      /* if l3_proto = ATM_L3_H310 */
+	    unsigned char term_type;  /* terminal type */
+	    unsigned char fw_mpx_cap; /* forward multiplexing capability */
+				      /* only if term_type != ATM_TT_NONE */
+	    unsigned char bw_mpx_cap; /* backward multiplexing capability */
+				      /* only if term_type != ATM_TT_NONE */
+	} h310;
+	struct {		  /* if l3_proto = ATM_L3_TR9577 */
+	    unsigned char ipi;	  /* initial protocol id */
+	    unsigned char snap[5];/* IEEE 802.1 SNAP identifier */
+				  /* (only if ipi == NLPID_IEEE802_1_SNAP) */
+	} tr9577;
+    } l3;
+} __ATM_API_ALIGN;
+
+
+struct atm_bhli {
+    unsigned char hl_type;	/* high layer information type */
+    unsigned char hl_length;	/* length (only if hl_type == ATM_HL_USER || */
+				/* hl_type == ATM_HL_ISO) */
+    unsigned char hl_info[ATM_MAX_HLI];/* high layer information */
+};
+
+
+#define ATM_MAX_BLLI	3		/* maximum number of BLLI elements */
+
+
+struct atm_sap {
+	struct atm_bhli bhli;		/* local SAP, high-layer information */
+	struct atm_blli blli[ATM_MAX_BLLI] __ATM_API_ALIGN;
+					/* local SAP, low-layer info */
+};
+
+
+static __inline__ int blli_in_use(struct atm_blli blli)
+{
+	return blli.l2_proto || blli.l3_proto;
+}
+
+#endif
diff --git a/include/uapi/linux/bpf.h b/include/uapi/linux/bpf.h
new file mode 100644
index 0000000..0895a52
--- /dev/null
+++ b/include/uapi/linux/bpf.h
@@ -0,0 +1,867 @@
+/* Copyright (c) 2011-2014 PLUMgrid, http://plumgrid.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU General Public
+ * License as published by the Free Software Foundation.
+ */
+#ifndef __LINUX_BPF_H__
+#define __LINUX_BPF_H__
+
+#include <linux/types.h>
+#include <linux/bpf_common.h>
+
+/* Extended instruction set based on top of classic BPF */
+
+/* instruction classes */
+#define BPF_ALU64	0x07	/* alu mode in double word width */
+
+/* ld/ldx fields */
+#define BPF_DW		0x18	/* double word */
+#define BPF_XADD	0xc0	/* exclusive add */
+
+/* alu/jmp fields */
+#define BPF_MOV		0xb0	/* mov reg to reg */
+#define BPF_ARSH	0xc0	/* sign extending arithmetic shift right */
+
+/* change endianness of a register */
+#define BPF_END		0xd0	/* flags for endianness conversion: */
+#define BPF_TO_LE	0x00	/* convert to little-endian */
+#define BPF_TO_BE	0x08	/* convert to big-endian */
+#define BPF_FROM_LE	BPF_TO_LE
+#define BPF_FROM_BE	BPF_TO_BE
+
+/* jmp encodings */
+#define BPF_JNE		0x50	/* jump != */
+#define BPF_JLT		0xa0	/* LT is unsigned, '<' */
+#define BPF_JLE		0xb0	/* LE is unsigned, '<=' */
+#define BPF_JSGT	0x60	/* SGT is signed '>', GT in x86 */
+#define BPF_JSGE	0x70	/* SGE is signed '>=', GE in x86 */
+#define BPF_JSLT	0xc0	/* SLT is signed, '<' */
+#define BPF_JSLE	0xd0	/* SLE is signed, '<=' */
+#define BPF_CALL	0x80	/* function call */
+#define BPF_EXIT	0x90	/* function return */
+
+/* Register numbers */
+enum {
+	BPF_REG_0 = 0,
+	BPF_REG_1,
+	BPF_REG_2,
+	BPF_REG_3,
+	BPF_REG_4,
+	BPF_REG_5,
+	BPF_REG_6,
+	BPF_REG_7,
+	BPF_REG_8,
+	BPF_REG_9,
+	BPF_REG_10,
+	__MAX_BPF_REG,
+};
+
+/* BPF has 10 general purpose 64-bit registers and stack frame. */
+#define MAX_BPF_REG	__MAX_BPF_REG
+
+struct bpf_insn {
+	__u8	code;		/* opcode */
+	__u8	dst_reg:4;	/* dest register */
+	__u8	src_reg:4;	/* source register */
+	__s16	off;		/* signed offset */
+	__s32	imm;		/* signed immediate constant */
+};
+
+/* Key of an a BPF_MAP_TYPE_LPM_TRIE entry */
+struct bpf_lpm_trie_key {
+	__u32	prefixlen;	/* up to 32 for AF_INET, 128 for AF_INET6 */
+	__u8	data[0];	/* Arbitrary size */
+};
+
+/* BPF syscall commands, see bpf(2) man-page for details. */
+enum bpf_cmd {
+	BPF_MAP_CREATE,
+	BPF_MAP_LOOKUP_ELEM,
+	BPF_MAP_UPDATE_ELEM,
+	BPF_MAP_DELETE_ELEM,
+	BPF_MAP_GET_NEXT_KEY,
+	BPF_PROG_LOAD,
+	BPF_OBJ_PIN,
+	BPF_OBJ_GET,
+	BPF_PROG_ATTACH,
+	BPF_PROG_DETACH,
+	BPF_PROG_TEST_RUN,
+	BPF_PROG_GET_NEXT_ID,
+	BPF_MAP_GET_NEXT_ID,
+	BPF_PROG_GET_FD_BY_ID,
+	BPF_MAP_GET_FD_BY_ID,
+	BPF_OBJ_GET_INFO_BY_FD,
+};
+
+enum bpf_map_type {
+	BPF_MAP_TYPE_UNSPEC,
+	BPF_MAP_TYPE_HASH,
+	BPF_MAP_TYPE_ARRAY,
+	BPF_MAP_TYPE_PROG_ARRAY,
+	BPF_MAP_TYPE_PERF_EVENT_ARRAY,
+	BPF_MAP_TYPE_PERCPU_HASH,
+	BPF_MAP_TYPE_PERCPU_ARRAY,
+	BPF_MAP_TYPE_STACK_TRACE,
+	BPF_MAP_TYPE_CGROUP_ARRAY,
+	BPF_MAP_TYPE_LRU_HASH,
+	BPF_MAP_TYPE_LRU_PERCPU_HASH,
+	BPF_MAP_TYPE_LPM_TRIE,
+	BPF_MAP_TYPE_ARRAY_OF_MAPS,
+	BPF_MAP_TYPE_HASH_OF_MAPS,
+	BPF_MAP_TYPE_DEVMAP,
+	BPF_MAP_TYPE_SOCKMAP,
+};
+
+enum bpf_prog_type {
+	BPF_PROG_TYPE_UNSPEC,
+	BPF_PROG_TYPE_SOCKET_FILTER,
+	BPF_PROG_TYPE_KPROBE,
+	BPF_PROG_TYPE_SCHED_CLS,
+	BPF_PROG_TYPE_SCHED_ACT,
+	BPF_PROG_TYPE_TRACEPOINT,
+	BPF_PROG_TYPE_XDP,
+	BPF_PROG_TYPE_PERF_EVENT,
+	BPF_PROG_TYPE_CGROUP_SKB,
+	BPF_PROG_TYPE_CGROUP_SOCK,
+	BPF_PROG_TYPE_LWT_IN,
+	BPF_PROG_TYPE_LWT_OUT,
+	BPF_PROG_TYPE_LWT_XMIT,
+	BPF_PROG_TYPE_SOCK_OPS,
+	BPF_PROG_TYPE_SK_SKB,
+};
+
+enum bpf_attach_type {
+	BPF_CGROUP_INET_INGRESS,
+	BPF_CGROUP_INET_EGRESS,
+	BPF_CGROUP_INET_SOCK_CREATE,
+	BPF_CGROUP_SOCK_OPS,
+	BPF_SK_SKB_STREAM_PARSER,
+	BPF_SK_SKB_STREAM_VERDICT,
+	__MAX_BPF_ATTACH_TYPE
+};
+
+#define MAX_BPF_ATTACH_TYPE __MAX_BPF_ATTACH_TYPE
+
+/* If BPF_F_ALLOW_OVERRIDE flag is used in BPF_PROG_ATTACH command
+ * to the given target_fd cgroup the descendent cgroup will be able to
+ * override effective bpf program that was inherited from this cgroup
+ */
+#define BPF_F_ALLOW_OVERRIDE	(1U << 0)
+
+/* If BPF_F_STRICT_ALIGNMENT is used in BPF_PROG_LOAD command, the
+ * verifier will perform strict alignment checking as if the kernel
+ * has been built with CONFIG_EFFICIENT_UNALIGNED_ACCESS not set,
+ * and NET_IP_ALIGN defined to 2.
+ */
+#define BPF_F_STRICT_ALIGNMENT	(1U << 0)
+
+#define BPF_PSEUDO_MAP_FD	1
+
+/* flags for BPF_MAP_UPDATE_ELEM command */
+#define BPF_ANY		0 /* create new element or update existing */
+#define BPF_NOEXIST	1 /* create new element if it didn't exist */
+#define BPF_EXIST	2 /* update existing element */
+
+/* flags for BPF_MAP_CREATE command */
+#define BPF_F_NO_PREALLOC	(1U << 0)
+/* Instead of having one common LRU list in the
+ * BPF_MAP_TYPE_LRU_[PERCPU_]HASH map, use a percpu LRU list
+ * which can scale and perform better.
+ * Note, the LRU nodes (including free nodes) cannot be moved
+ * across different LRU lists.
+ */
+#define BPF_F_NO_COMMON_LRU	(1U << 1)
+/* Specify numa node during map creation */
+#define BPF_F_NUMA_NODE		(1U << 2)
+
+union bpf_attr {
+	struct { /* anonymous struct used by BPF_MAP_CREATE command */
+		__u32	map_type;	/* one of enum bpf_map_type */
+		__u32	key_size;	/* size of key in bytes */
+		__u32	value_size;	/* size of value in bytes */
+		__u32	max_entries;	/* max number of entries in a map */
+		__u32	map_flags;	/* BPF_MAP_CREATE related
+					 * flags defined above.
+					 */
+		__u32	inner_map_fd;	/* fd pointing to the inner map */
+		__u32	numa_node;	/* numa node (effective only if
+					 * BPF_F_NUMA_NODE is set).
+					 */
+	};
+
+	struct { /* anonymous struct used by BPF_MAP_*_ELEM commands */
+		__u32		map_fd;
+		__aligned_u64	key;
+		union {
+			__aligned_u64 value;
+			__aligned_u64 next_key;
+		};
+		__u64		flags;
+	};
+
+	struct { /* anonymous struct used by BPF_PROG_LOAD command */
+		__u32		prog_type;	/* one of enum bpf_prog_type */
+		__u32		insn_cnt;
+		__aligned_u64	insns;
+		__aligned_u64	license;
+		__u32		log_level;	/* verbosity level of verifier */
+		__u32		log_size;	/* size of user buffer */
+		__aligned_u64	log_buf;	/* user supplied buffer */
+		__u32		kern_version;	/* checked when prog_type=kprobe */
+		__u32		prog_flags;
+	};
+
+	struct { /* anonymous struct used by BPF_OBJ_* commands */
+		__aligned_u64	pathname;
+		__u32		bpf_fd;
+	};
+
+	struct { /* anonymous struct used by BPF_PROG_ATTACH/DETACH commands */
+		__u32		target_fd;	/* container object to attach to */
+		__u32		attach_bpf_fd;	/* eBPF program to attach */
+		__u32		attach_type;
+		__u32		attach_flags;
+	};
+
+	struct { /* anonymous struct used by BPF_PROG_TEST_RUN command */
+		__u32		prog_fd;
+		__u32		retval;
+		__u32		data_size_in;
+		__u32		data_size_out;
+		__aligned_u64	data_in;
+		__aligned_u64	data_out;
+		__u32		repeat;
+		__u32		duration;
+	} test;
+
+	struct { /* anonymous struct used by BPF_*_GET_*_ID */
+		union {
+			__u32		start_id;
+			__u32		prog_id;
+			__u32		map_id;
+		};
+		__u32		next_id;
+	};
+
+	struct { /* anonymous struct used by BPF_OBJ_GET_INFO_BY_FD */
+		__u32		bpf_fd;
+		__u32		info_len;
+		__aligned_u64	info;
+	} info;
+} __attribute__((aligned(8)));
+
+/* BPF helper function descriptions:
+ *
+ * void *bpf_map_lookup_elem(&map, &key)
+ *     Return: Map value or NULL
+ *
+ * int bpf_map_update_elem(&map, &key, &value, flags)
+ *     Return: 0 on success or negative error
+ *
+ * int bpf_map_delete_elem(&map, &key)
+ *     Return: 0 on success or negative error
+ *
+ * int bpf_probe_read(void *dst, int size, void *src)
+ *     Return: 0 on success or negative error
+ *
+ * u64 bpf_ktime_get_ns(void)
+ *     Return: current ktime
+ *
+ * int bpf_trace_printk(const char *fmt, int fmt_size, ...)
+ *     Return: length of buffer written or negative error
+ *
+ * u32 bpf_prandom_u32(void)
+ *     Return: random value
+ *
+ * u32 bpf_raw_smp_processor_id(void)
+ *     Return: SMP processor ID
+ *
+ * int bpf_skb_store_bytes(skb, offset, from, len, flags)
+ *     store bytes into packet
+ *     @skb: pointer to skb
+ *     @offset: offset within packet from skb->mac_header
+ *     @from: pointer where to copy bytes from
+ *     @len: number of bytes to store into packet
+ *     @flags: bit 0 - if true, recompute skb->csum
+ *             other bits - reserved
+ *     Return: 0 on success or negative error
+ *
+ * int bpf_l3_csum_replace(skb, offset, from, to, flags)
+ *     recompute IP checksum
+ *     @skb: pointer to skb
+ *     @offset: offset within packet where IP checksum is located
+ *     @from: old value of header field
+ *     @to: new value of header field
+ *     @flags: bits 0-3 - size of header field
+ *             other bits - reserved
+ *     Return: 0 on success or negative error
+ *
+ * int bpf_l4_csum_replace(skb, offset, from, to, flags)
+ *     recompute TCP/UDP checksum
+ *     @skb: pointer to skb
+ *     @offset: offset within packet where TCP/UDP checksum is located
+ *     @from: old value of header field
+ *     @to: new value of header field
+ *     @flags: bits 0-3 - size of header field
+ *             bit 4 - is pseudo header
+ *             other bits - reserved
+ *     Return: 0 on success or negative error
+ *
+ * int bpf_tail_call(ctx, prog_array_map, index)
+ *     jump into another BPF program
+ *     @ctx: context pointer passed to next program
+ *     @prog_array_map: pointer to map which type is BPF_MAP_TYPE_PROG_ARRAY
+ *     @index: index inside array that selects specific program to run
+ *     Return: 0 on success or negative error
+ *
+ * int bpf_clone_redirect(skb, ifindex, flags)
+ *     redirect to another netdev
+ *     @skb: pointer to skb
+ *     @ifindex: ifindex of the net device
+ *     @flags: bit 0 - if set, redirect to ingress instead of egress
+ *             other bits - reserved
+ *     Return: 0 on success or negative error
+ *
+ * u64 bpf_get_current_pid_tgid(void)
+ *     Return: current->tgid << 32 | current->pid
+ *
+ * u64 bpf_get_current_uid_gid(void)
+ *     Return: current_gid << 32 | current_uid
+ *
+ * int bpf_get_current_comm(char *buf, int size_of_buf)
+ *     stores current->comm into buf
+ *     Return: 0 on success or negative error
+ *
+ * u32 bpf_get_cgroup_classid(skb)
+ *     retrieve a proc's classid
+ *     @skb: pointer to skb
+ *     Return: classid if != 0
+ *
+ * int bpf_skb_vlan_push(skb, vlan_proto, vlan_tci)
+ *     Return: 0 on success or negative error
+ *
+ * int bpf_skb_vlan_pop(skb)
+ *     Return: 0 on success or negative error
+ *
+ * int bpf_skb_get_tunnel_key(skb, key, size, flags)
+ * int bpf_skb_set_tunnel_key(skb, key, size, flags)
+ *     retrieve or populate tunnel metadata
+ *     @skb: pointer to skb
+ *     @key: pointer to 'struct bpf_tunnel_key'
+ *     @size: size of 'struct bpf_tunnel_key'
+ *     @flags: room for future extensions
+ *     Return: 0 on success or negative error
+ *
+ * u64 bpf_perf_event_read(map, flags)
+ *     read perf event counter value
+ *     @map: pointer to perf_event_array map
+ *     @flags: index of event in the map or bitmask flags
+ *     Return: value of perf event counter read or error code
+ *
+ * int bpf_redirect(ifindex, flags)
+ *     redirect to another netdev
+ *     @ifindex: ifindex of the net device
+ *     @flags:
+ *	  cls_bpf:
+ *          bit 0 - if set, redirect to ingress instead of egress
+ *          other bits - reserved
+ *	  xdp_bpf:
+ *	    all bits - reserved
+ *     Return: cls_bpf: TC_ACT_REDIRECT on success or TC_ACT_SHOT on error
+ *	       xdp_bfp: XDP_REDIRECT on success or XDP_ABORT on error
+ * int bpf_redirect_map(map, key, flags)
+ *     redirect to endpoint in map
+ *     @map: pointer to dev map
+ *     @key: index in map to lookup
+ *     @flags: --
+ *     Return: XDP_REDIRECT on success or XDP_ABORT on error
+ *
+ * u32 bpf_get_route_realm(skb)
+ *     retrieve a dst's tclassid
+ *     @skb: pointer to skb
+ *     Return: realm if != 0
+ *
+ * int bpf_perf_event_output(ctx, map, flags, data, size)
+ *     output perf raw sample
+ *     @ctx: struct pt_regs*
+ *     @map: pointer to perf_event_array map
+ *     @flags: index of event in the map or bitmask flags
+ *     @data: data on stack to be output as raw data
+ *     @size: size of data
+ *     Return: 0 on success or negative error
+ *
+ * int bpf_get_stackid(ctx, map, flags)
+ *     walk user or kernel stack and return id
+ *     @ctx: struct pt_regs*
+ *     @map: pointer to stack_trace map
+ *     @flags: bits 0-7 - numer of stack frames to skip
+ *             bit 8 - collect user stack instead of kernel
+ *             bit 9 - compare stacks by hash only
+ *             bit 10 - if two different stacks hash into the same stackid
+ *                      discard old
+ *             other bits - reserved
+ *     Return: >= 0 stackid on success or negative error
+ *
+ * s64 bpf_csum_diff(from, from_size, to, to_size, seed)
+ *     calculate csum diff
+ *     @from: raw from buffer
+ *     @from_size: length of from buffer
+ *     @to: raw to buffer
+ *     @to_size: length of to buffer
+ *     @seed: optional seed
+ *     Return: csum result or negative error code
+ *
+ * int bpf_skb_get_tunnel_opt(skb, opt, size)
+ *     retrieve tunnel options metadata
+ *     @skb: pointer to skb
+ *     @opt: pointer to raw tunnel option data
+ *     @size: size of @opt
+ *     Return: option size
+ *
+ * int bpf_skb_set_tunnel_opt(skb, opt, size)
+ *     populate tunnel options metadata
+ *     @skb: pointer to skb
+ *     @opt: pointer to raw tunnel option data
+ *     @size: size of @opt
+ *     Return: 0 on success or negative error
+ *
+ * int bpf_skb_change_proto(skb, proto, flags)
+ *     Change protocol of the skb. Currently supported is v4 -> v6,
+ *     v6 -> v4 transitions. The helper will also resize the skb. eBPF
+ *     program is expected to fill the new headers via skb_store_bytes
+ *     and lX_csum_replace.
+ *     @skb: pointer to skb
+ *     @proto: new skb->protocol type
+ *     @flags: reserved
+ *     Return: 0 on success or negative error
+ *
+ * int bpf_skb_change_type(skb, type)
+ *     Change packet type of skb.
+ *     @skb: pointer to skb
+ *     @type: new skb->pkt_type type
+ *     Return: 0 on success or negative error
+ *
+ * int bpf_skb_under_cgroup(skb, map, index)
+ *     Check cgroup2 membership of skb
+ *     @skb: pointer to skb
+ *     @map: pointer to bpf_map in BPF_MAP_TYPE_CGROUP_ARRAY type
+ *     @index: index of the cgroup in the bpf_map
+ *     Return:
+ *       == 0 skb failed the cgroup2 descendant test
+ *       == 1 skb succeeded the cgroup2 descendant test
+ *        < 0 error
+ *
+ * u32 bpf_get_hash_recalc(skb)
+ *     Retrieve and possibly recalculate skb->hash.
+ *     @skb: pointer to skb
+ *     Return: hash
+ *
+ * u64 bpf_get_current_task(void)
+ *     Returns current task_struct
+ *     Return: current
+ *
+ * int bpf_probe_write_user(void *dst, void *src, int len)
+ *     safely attempt to write to a location
+ *     @dst: destination address in userspace
+ *     @src: source address on stack
+ *     @len: number of bytes to copy
+ *     Return: 0 on success or negative error
+ *
+ * int bpf_current_task_under_cgroup(map, index)
+ *     Check cgroup2 membership of current task
+ *     @map: pointer to bpf_map in BPF_MAP_TYPE_CGROUP_ARRAY type
+ *     @index: index of the cgroup in the bpf_map
+ *     Return:
+ *       == 0 current failed the cgroup2 descendant test
+ *       == 1 current succeeded the cgroup2 descendant test
+ *        < 0 error
+ *
+ * int bpf_skb_change_tail(skb, len, flags)
+ *     The helper will resize the skb to the given new size, to be used f.e.
+ *     with control messages.
+ *     @skb: pointer to skb
+ *     @len: new skb length
+ *     @flags: reserved
+ *     Return: 0 on success or negative error
+ *
+ * int bpf_skb_pull_data(skb, len)
+ *     The helper will pull in non-linear data in case the skb is non-linear
+ *     and not all of len are part of the linear section. Only needed for
+ *     read/write with direct packet access.
+ *     @skb: pointer to skb
+ *     @len: len to make read/writeable
+ *     Return: 0 on success or negative error
+ *
+ * s64 bpf_csum_update(skb, csum)
+ *     Adds csum into skb->csum in case of CHECKSUM_COMPLETE.
+ *     @skb: pointer to skb
+ *     @csum: csum to add
+ *     Return: csum on success or negative error
+ *
+ * void bpf_set_hash_invalid(skb)
+ *     Invalidate current skb->hash.
+ *     @skb: pointer to skb
+ *
+ * int bpf_get_numa_node_id()
+ *     Return: Id of current NUMA node.
+ *
+ * int bpf_skb_change_head()
+ *     Grows headroom of skb and adjusts MAC header offset accordingly.
+ *     Will extends/reallocae as required automatically.
+ *     May change skb data pointer and will thus invalidate any check
+ *     performed for direct packet access.
+ *     @skb: pointer to skb
+ *     @len: length of header to be pushed in front
+ *     @flags: Flags (unused for now)
+ *     Return: 0 on success or negative error
+ *
+ * int bpf_xdp_adjust_head(xdp_md, delta)
+ *     Adjust the xdp_md.data by delta
+ *     @xdp_md: pointer to xdp_md
+ *     @delta: An positive/negative integer to be added to xdp_md.data
+ *     Return: 0 on success or negative on error
+ *
+ * int bpf_probe_read_str(void *dst, int size, const void *unsafe_ptr)
+ *     Copy a NUL terminated string from unsafe address. In case the string
+ *     length is smaller than size, the target is not padded with further NUL
+ *     bytes. In case the string length is larger than size, just count-1
+ *     bytes are copied and the last byte is set to NUL.
+ *     @dst: destination address
+ *     @size: maximum number of bytes to copy, including the trailing NUL
+ *     @unsafe_ptr: unsafe address
+ *     Return:
+ *       > 0 length of the string including the trailing NUL on success
+ *       < 0 error
+ *
+ * u64 bpf_get_socket_cookie(skb)
+ *     Get the cookie for the socket stored inside sk_buff.
+ *     @skb: pointer to skb
+ *     Return: 8 Bytes non-decreasing number on success or 0 if the socket
+ *     field is missing inside sk_buff
+ *
+ * u32 bpf_get_socket_uid(skb)
+ *     Get the owner uid of the socket stored inside sk_buff.
+ *     @skb: pointer to skb
+ *     Return: uid of the socket owner on success or overflowuid if failed.
+ *
+ * u32 bpf_set_hash(skb, hash)
+ *     Set full skb->hash.
+ *     @skb: pointer to skb
+ *     @hash: hash to set
+ *
+ * int bpf_setsockopt(bpf_socket, level, optname, optval, optlen)
+ *     Calls setsockopt. Not all opts are available, only those with
+ *     integer optvals plus TCP_CONGESTION.
+ *     Supported levels: SOL_SOCKET and IPROTO_TCP
+ *     @bpf_socket: pointer to bpf_socket
+ *     @level: SOL_SOCKET or IPROTO_TCP
+ *     @optname: option name
+ *     @optval: pointer to option value
+ *     @optlen: length of optval in byes
+ *     Return: 0 or negative error
+ *
+ * int bpf_skb_adjust_room(skb, len_diff, mode, flags)
+ *     Grow or shrink room in sk_buff.
+ *     @skb: pointer to skb
+ *     @len_diff: (signed) amount of room to grow/shrink
+ *     @mode: operation mode (enum bpf_adj_room_mode)
+ *     @flags: reserved for future use
+ *     Return: 0 on success or negative error code
+ *
+ * int bpf_sk_redirect_map(map, key, flags)
+ *     Redirect skb to a sock in map using key as a lookup key for the
+ *     sock in map.
+ *     @map: pointer to sockmap
+ *     @key: key to lookup sock in map
+ *     @flags: reserved for future use
+ *     Return: SK_REDIRECT
+ *
+ * int bpf_sock_map_update(skops, map, key, flags)
+ *	@skops: pointer to bpf_sock_ops
+ *	@map: pointer to sockmap to update
+ *	@key: key to insert/update sock in map
+ *	@flags: same flags as map update elem
+ */
+#define __BPF_FUNC_MAPPER(FN)		\
+	FN(unspec),			\
+	FN(map_lookup_elem),		\
+	FN(map_update_elem),		\
+	FN(map_delete_elem),		\
+	FN(probe_read),			\
+	FN(ktime_get_ns),		\
+	FN(trace_printk),		\
+	FN(get_prandom_u32),		\
+	FN(get_smp_processor_id),	\
+	FN(skb_store_bytes),		\
+	FN(l3_csum_replace),		\
+	FN(l4_csum_replace),		\
+	FN(tail_call),			\
+	FN(clone_redirect),		\
+	FN(get_current_pid_tgid),	\
+	FN(get_current_uid_gid),	\
+	FN(get_current_comm),		\
+	FN(get_cgroup_classid),		\
+	FN(skb_vlan_push),		\
+	FN(skb_vlan_pop),		\
+	FN(skb_get_tunnel_key),		\
+	FN(skb_set_tunnel_key),		\
+	FN(perf_event_read),		\
+	FN(redirect),			\
+	FN(get_route_realm),		\
+	FN(perf_event_output),		\
+	FN(skb_load_bytes),		\
+	FN(get_stackid),		\
+	FN(csum_diff),			\
+	FN(skb_get_tunnel_opt),		\
+	FN(skb_set_tunnel_opt),		\
+	FN(skb_change_proto),		\
+	FN(skb_change_type),		\
+	FN(skb_under_cgroup),		\
+	FN(get_hash_recalc),		\
+	FN(get_current_task),		\
+	FN(probe_write_user),		\
+	FN(current_task_under_cgroup),	\
+	FN(skb_change_tail),		\
+	FN(skb_pull_data),		\
+	FN(csum_update),		\
+	FN(set_hash_invalid),		\
+	FN(get_numa_node_id),		\
+	FN(skb_change_head),		\
+	FN(xdp_adjust_head),		\
+	FN(probe_read_str),		\
+	FN(get_socket_cookie),		\
+	FN(get_socket_uid),		\
+	FN(set_hash),			\
+	FN(setsockopt),			\
+	FN(skb_adjust_room),		\
+	FN(redirect_map),		\
+	FN(sk_redirect_map),		\
+	FN(sock_map_update),		\
+
+/* integer value in 'imm' field of BPF_CALL instruction selects which helper
+ * function eBPF program intends to call
+ */
+#define __BPF_ENUM_FN(x) BPF_FUNC_ ## x
+enum bpf_func_id {
+	__BPF_FUNC_MAPPER(__BPF_ENUM_FN)
+	__BPF_FUNC_MAX_ID,
+};
+#undef __BPF_ENUM_FN
+
+/* All flags used by eBPF helper functions, placed here. */
+
+/* BPF_FUNC_skb_store_bytes flags. */
+#define BPF_F_RECOMPUTE_CSUM		(1ULL << 0)
+#define BPF_F_INVALIDATE_HASH		(1ULL << 1)
+
+/* BPF_FUNC_l3_csum_replace and BPF_FUNC_l4_csum_replace flags.
+ * First 4 bits are for passing the header field size.
+ */
+#define BPF_F_HDR_FIELD_MASK		0xfULL
+
+/* BPF_FUNC_l4_csum_replace flags. */
+#define BPF_F_PSEUDO_HDR		(1ULL << 4)
+#define BPF_F_MARK_MANGLED_0		(1ULL << 5)
+#define BPF_F_MARK_ENFORCE		(1ULL << 6)
+
+/* BPF_FUNC_clone_redirect and BPF_FUNC_redirect flags. */
+#define BPF_F_INGRESS			(1ULL << 0)
+
+/* BPF_FUNC_skb_set_tunnel_key and BPF_FUNC_skb_get_tunnel_key flags. */
+#define BPF_F_TUNINFO_IPV6		(1ULL << 0)
+
+/* BPF_FUNC_get_stackid flags. */
+#define BPF_F_SKIP_FIELD_MASK		0xffULL
+#define BPF_F_USER_STACK		(1ULL << 8)
+#define BPF_F_FAST_STACK_CMP		(1ULL << 9)
+#define BPF_F_REUSE_STACKID		(1ULL << 10)
+
+/* BPF_FUNC_skb_set_tunnel_key flags. */
+#define BPF_F_ZERO_CSUM_TX		(1ULL << 1)
+#define BPF_F_DONT_FRAGMENT		(1ULL << 2)
+
+/* BPF_FUNC_perf_event_output and BPF_FUNC_perf_event_read flags. */
+#define BPF_F_INDEX_MASK		0xffffffffULL
+#define BPF_F_CURRENT_CPU		BPF_F_INDEX_MASK
+/* BPF_FUNC_perf_event_output for sk_buff input context. */
+#define BPF_F_CTXLEN_MASK		(0xfffffULL << 32)
+
+/* Mode for BPF_FUNC_skb_adjust_room helper. */
+enum bpf_adj_room_mode {
+	BPF_ADJ_ROOM_NET,
+};
+
+/* user accessible mirror of in-kernel sk_buff.
+ * new fields can only be added to the end of this structure
+ */
+struct __sk_buff {
+	__u32 len;
+	__u32 pkt_type;
+	__u32 mark;
+	__u32 queue_mapping;
+	__u32 protocol;
+	__u32 vlan_present;
+	__u32 vlan_tci;
+	__u32 vlan_proto;
+	__u32 priority;
+	__u32 ingress_ifindex;
+	__u32 ifindex;
+	__u32 tc_index;
+	__u32 cb[5];
+	__u32 hash;
+	__u32 tc_classid;
+	__u32 data;
+	__u32 data_end;
+	__u32 napi_id;
+
+	/* accessed by BPF_PROG_TYPE_sk_skb types */
+	__u32 family;
+	__u32 remote_ip4;	/* Stored in network byte order */
+	__u32 local_ip4;	/* Stored in network byte order */
+	__u32 remote_ip6[4];	/* Stored in network byte order */
+	__u32 local_ip6[4];	/* Stored in network byte order */
+	__u32 remote_port;	/* Stored in network byte order */
+	__u32 local_port;	/* stored in host byte order */
+};
+
+struct bpf_tunnel_key {
+	__u32 tunnel_id;
+	union {
+		__u32 remote_ipv4;
+		__u32 remote_ipv6[4];
+	};
+	__u8 tunnel_tos;
+	__u8 tunnel_ttl;
+	__u16 tunnel_ext;
+	__u32 tunnel_label;
+};
+
+/* Generic BPF return codes which all BPF program types may support.
+ * The values are binary compatible with their TC_ACT_* counter-part to
+ * provide backwards compatibility with existing SCHED_CLS and SCHED_ACT
+ * programs.
+ *
+ * XDP is handled seprately, see XDP_*.
+ */
+enum bpf_ret_code {
+	BPF_OK = 0,
+	/* 1 reserved */
+	BPF_DROP = 2,
+	/* 3-6 reserved */
+	BPF_REDIRECT = 7,
+	/* >127 are reserved for prog type specific return codes */
+};
+
+struct bpf_sock {
+	__u32 bound_dev_if;
+	__u32 family;
+	__u32 type;
+	__u32 protocol;
+	__u32 mark;
+	__u32 priority;
+};
+
+#define XDP_PACKET_HEADROOM 256
+
+/* User return codes for XDP prog type.
+ * A valid XDP program must return one of these defined values. All other
+ * return codes are reserved for future use. Unknown return codes will
+ * result in packet drops and a warning via bpf_warn_invalid_xdp_action().
+ */
+enum xdp_action {
+	XDP_ABORTED = 0,
+	XDP_DROP,
+	XDP_PASS,
+	XDP_TX,
+	XDP_REDIRECT,
+};
+
+/* user accessible metadata for XDP packet hook
+ * new fields must be added to the end of this structure
+ */
+struct xdp_md {
+	__u32 data;
+	__u32 data_end;
+};
+
+enum sk_action {
+	SK_ABORTED = 0,
+	SK_DROP,
+	SK_REDIRECT,
+};
+
+#define BPF_TAG_SIZE	8
+
+struct bpf_prog_info {
+	__u32 type;
+	__u32 id;
+	__u8  tag[BPF_TAG_SIZE];
+	__u32 jited_prog_len;
+	__u32 xlated_prog_len;
+	__aligned_u64 jited_prog_insns;
+	__aligned_u64 xlated_prog_insns;
+} __attribute__((aligned(8)));
+
+struct bpf_map_info {
+	__u32 type;
+	__u32 id;
+	__u32 key_size;
+	__u32 value_size;
+	__u32 max_entries;
+	__u32 map_flags;
+} __attribute__((aligned(8)));
+
+/* User bpf_sock_ops struct to access socket values and specify request ops
+ * and their replies.
+ * Some of this fields are in network (bigendian) byte order and may need
+ * to be converted before use (bpf_ntohl() defined in samples/bpf/bpf_endian.h).
+ * New fields can only be added at the end of this structure
+ */
+struct bpf_sock_ops {
+	__u32 op;
+	union {
+		__u32 reply;
+		__u32 replylong[4];
+	};
+	__u32 family;
+	__u32 remote_ip4;	/* Stored in network byte order */
+	__u32 local_ip4;	/* Stored in network byte order */
+	__u32 remote_ip6[4];	/* Stored in network byte order */
+	__u32 local_ip6[4];	/* Stored in network byte order */
+	__u32 remote_port;	/* Stored in network byte order */
+	__u32 local_port;	/* stored in host byte order */
+};
+
+/* List of known BPF sock_ops operators.
+ * New entries can only be added at the end
+ */
+enum {
+	BPF_SOCK_OPS_VOID,
+	BPF_SOCK_OPS_TIMEOUT_INIT,	/* Should return SYN-RTO value to use or
+					 * -1 if default value should be used
+					 */
+	BPF_SOCK_OPS_RWND_INIT,		/* Should return initial advertized
+					 * window (in packets) or -1 if default
+					 * value should be used
+					 */
+	BPF_SOCK_OPS_TCP_CONNECT_CB,	/* Calls BPF program right before an
+					 * active connection is initialized
+					 */
+	BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB,	/* Calls BPF program when an
+						 * active connection is
+						 * established
+						 */
+	BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB,	/* Calls BPF program when a
+						 * passive connection is
+						 * established
+						 */
+	BPF_SOCK_OPS_NEEDS_ECN,		/* If connection's congestion control
+					 * needs ECN
+					 */
+};
+
+#define TCP_BPF_IW		1001	/* Set TCP initial congestion window */
+#define TCP_BPF_SNDCWND_CLAMP	1002	/* Set sndcwnd_clamp */
+
+#endif /* __LINUX_BPF_H__ */
diff --git a/include/uapi/linux/bpf_common.h b/include/uapi/linux/bpf_common.h
new file mode 100644
index 0000000..afe7433
--- /dev/null
+++ b/include/uapi/linux/bpf_common.h
@@ -0,0 +1,55 @@
+#ifndef __LINUX_BPF_COMMON_H__
+#define __LINUX_BPF_COMMON_H__
+
+/* Instruction classes */
+#define BPF_CLASS(code) ((code) & 0x07)
+#define		BPF_LD		0x00
+#define		BPF_LDX		0x01
+#define		BPF_ST		0x02
+#define		BPF_STX		0x03
+#define		BPF_ALU		0x04
+#define		BPF_JMP		0x05
+#define		BPF_RET		0x06
+#define		BPF_MISC        0x07
+
+/* ld/ldx fields */
+#define BPF_SIZE(code)  ((code) & 0x18)
+#define		BPF_W		0x00
+#define		BPF_H		0x08
+#define		BPF_B		0x10
+#define BPF_MODE(code)  ((code) & 0xe0)
+#define		BPF_IMM		0x00
+#define		BPF_ABS		0x20
+#define		BPF_IND		0x40
+#define		BPF_MEM		0x60
+#define		BPF_LEN		0x80
+#define		BPF_MSH		0xa0
+
+/* alu/jmp fields */
+#define BPF_OP(code)    ((code) & 0xf0)
+#define		BPF_ADD		0x00
+#define		BPF_SUB		0x10
+#define		BPF_MUL		0x20
+#define		BPF_DIV		0x30
+#define		BPF_OR		0x40
+#define		BPF_AND		0x50
+#define		BPF_LSH		0x60
+#define		BPF_RSH		0x70
+#define		BPF_NEG		0x80
+#define		BPF_MOD		0x90
+#define		BPF_XOR		0xa0
+
+#define		BPF_JA		0x00
+#define		BPF_JEQ		0x10
+#define		BPF_JGT		0x20
+#define		BPF_JGE		0x30
+#define		BPF_JSET        0x40
+#define BPF_SRC(code)   ((code) & 0x08)
+#define		BPF_K		0x00
+#define		BPF_X		0x08
+
+#ifndef BPF_MAXINSNS
+#define BPF_MAXINSNS 4096
+#endif
+
+#endif /* __LINUX_BPF_COMMON_H__ */
diff --git a/include/uapi/linux/can.h b/include/uapi/linux/can.h
new file mode 100644
index 0000000..f7a810d
--- /dev/null
+++ b/include/uapi/linux/can.h
@@ -0,0 +1,201 @@
+/*
+ * linux/can.h
+ *
+ * Definitions for CAN network layer (socket addr / CAN frame / CAN filter)
+ *
+ * Authors: Oliver Hartkopp <oliver.hartkopp@volkswagen.de>
+ *          Urs Thuermann   <urs.thuermann@volkswagen.de>
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Volkswagen nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * Alternatively, provided that this notice is retained in full, this
+ * software may be distributed under the terms of the GNU General
+ * Public License ("GPL") version 2, in which case the provisions of the
+ * GPL apply INSTEAD OF those given above.
+ *
+ * The provided data structures and external interfaces from this code
+ * are not restricted to be used by modules with a GPL compatible license.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ */
+
+#ifndef _CAN_H
+#define _CAN_H
+
+#include <linux/types.h>
+#include <linux/socket.h>
+
+/* controller area network (CAN) kernel definitions */
+
+/* special address description flags for the CAN_ID */
+#define CAN_EFF_FLAG 0x80000000U /* EFF/SFF is set in the MSB */
+#define CAN_RTR_FLAG 0x40000000U /* remote transmission request */
+#define CAN_ERR_FLAG 0x20000000U /* error message frame */
+
+/* valid bits in CAN ID for frame formats */
+#define CAN_SFF_MASK 0x000007FFU /* standard frame format (SFF) */
+#define CAN_EFF_MASK 0x1FFFFFFFU /* extended frame format (EFF) */
+#define CAN_ERR_MASK 0x1FFFFFFFU /* omit EFF, RTR, ERR flags */
+
+/*
+ * Controller Area Network Identifier structure
+ *
+ * bit 0-28	: CAN identifier (11/29 bit)
+ * bit 29	: error message frame flag (0 = data frame, 1 = error message)
+ * bit 30	: remote transmission request flag (1 = rtr frame)
+ * bit 31	: frame format flag (0 = standard 11 bit, 1 = extended 29 bit)
+ */
+typedef __u32 canid_t;
+
+#define CAN_SFF_ID_BITS		11
+#define CAN_EFF_ID_BITS		29
+
+/*
+ * Controller Area Network Error Message Frame Mask structure
+ *
+ * bit 0-28	: error class mask (see include/linux/can/error.h)
+ * bit 29-31	: set to zero
+ */
+typedef __u32 can_err_mask_t;
+
+/* CAN payload length and DLC definitions according to ISO 11898-1 */
+#define CAN_MAX_DLC 8
+#define CAN_MAX_DLEN 8
+
+/* CAN FD payload length and DLC definitions according to ISO 11898-7 */
+#define CANFD_MAX_DLC 15
+#define CANFD_MAX_DLEN 64
+
+/**
+ * struct can_frame - basic CAN frame structure
+ * @can_id:  CAN ID of the frame and CAN_*_FLAG flags, see canid_t definition
+ * @can_dlc: frame payload length in byte (0 .. 8) aka data length code
+ *           N.B. the DLC field from ISO 11898-1 Chapter 8.4.2.3 has a 1:1
+ *           mapping of the 'data length code' to the real payload length
+ * @__pad:   padding
+ * @__res0:  reserved / padding
+ * @__res1:  reserved / padding
+ * @data:    CAN frame payload (up to 8 byte)
+ */
+struct can_frame {
+	canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */
+	__u8    can_dlc; /* frame payload length in byte (0 .. CAN_MAX_DLEN) */
+	__u8    __pad;   /* padding */
+	__u8    __res0;  /* reserved / padding */
+	__u8    __res1;  /* reserved / padding */
+	__u8    data[CAN_MAX_DLEN] __attribute__((aligned(8)));
+};
+
+/*
+ * defined bits for canfd_frame.flags
+ *
+ * The use of struct canfd_frame implies the Extended Data Length (EDL) bit to
+ * be set in the CAN frame bitstream on the wire. The EDL bit switch turns
+ * the CAN controllers bitstream processor into the CAN FD mode which creates
+ * two new options within the CAN FD frame specification:
+ *
+ * Bit Rate Switch - to indicate a second bitrate is/was used for the payload
+ * Error State Indicator - represents the error state of the transmitting node
+ *
+ * As the CANFD_ESI bit is internally generated by the transmitting CAN
+ * controller only the CANFD_BRS bit is relevant for real CAN controllers when
+ * building a CAN FD frame for transmission. Setting the CANFD_ESI bit can make
+ * sense for virtual CAN interfaces to test applications with echoed frames.
+ */
+#define CANFD_BRS 0x01 /* bit rate switch (second bitrate for payload data) */
+#define CANFD_ESI 0x02 /* error state indicator of the transmitting node */
+
+/**
+ * struct canfd_frame - CAN flexible data rate frame structure
+ * @can_id: CAN ID of the frame and CAN_*_FLAG flags, see canid_t definition
+ * @len:    frame payload length in byte (0 .. CANFD_MAX_DLEN)
+ * @flags:  additional flags for CAN FD
+ * @__res0: reserved / padding
+ * @__res1: reserved / padding
+ * @data:   CAN FD frame payload (up to CANFD_MAX_DLEN byte)
+ */
+struct canfd_frame {
+	canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */
+	__u8    len;     /* frame payload length in byte */
+	__u8    flags;   /* additional flags for CAN FD */
+	__u8    __res0;  /* reserved / padding */
+	__u8    __res1;  /* reserved / padding */
+	__u8    data[CANFD_MAX_DLEN] __attribute__((aligned(8)));
+};
+
+#define CAN_MTU		(sizeof(struct can_frame))
+#define CANFD_MTU	(sizeof(struct canfd_frame))
+
+/* particular protocols of the protocol family PF_CAN */
+#define CAN_RAW		1 /* RAW sockets */
+#define CAN_BCM		2 /* Broadcast Manager */
+#define CAN_TP16	3 /* VAG Transport Protocol v1.6 */
+#define CAN_TP20	4 /* VAG Transport Protocol v2.0 */
+#define CAN_MCNET	5 /* Bosch MCNet */
+#define CAN_ISOTP	6 /* ISO 15765-2 Transport Protocol */
+#define CAN_NPROTO	7
+
+#define SOL_CAN_BASE 100
+
+/**
+ * struct sockaddr_can - the sockaddr structure for CAN sockets
+ * @can_family:  address family number AF_CAN.
+ * @can_ifindex: CAN network interface index.
+ * @can_addr:    protocol specific address information
+ */
+struct sockaddr_can {
+	__kernel_sa_family_t can_family;
+	int         can_ifindex;
+	union {
+		/* transport protocol class address information (e.g. ISOTP) */
+		struct { canid_t rx_id, tx_id; } tp;
+
+		/* reserved for future CAN protocols address information */
+	} can_addr;
+};
+
+/**
+ * struct can_filter - CAN ID based filter in can_register().
+ * @can_id:   relevant bits of CAN ID which are not masked out.
+ * @can_mask: CAN mask (see description)
+ *
+ * Description:
+ * A filter matches, when
+ *
+ *          <received_can_id> & mask == can_id & mask
+ *
+ * The filter can be inverted (CAN_INV_FILTER bit set in can_id) or it can
+ * filter for error message frames (CAN_ERR_FLAG bit set in mask).
+ */
+struct can_filter {
+	canid_t can_id;
+	canid_t can_mask;
+};
+
+#define CAN_INV_FILTER 0x20000000U /* to be set in can_filter.can_id */
+#define CAN_RAW_FILTER_MAX 512 /* maximum number of can_filter set via setsockopt() */
+
+#endif /* !_UAPI_CAN_H */
diff --git a/include/uapi/linux/can/netlink.h b/include/uapi/linux/can/netlink.h
new file mode 100644
index 0000000..b9214bd
--- /dev/null
+++ b/include/uapi/linux/can/netlink.h
@@ -0,0 +1,142 @@
+/*
+ * linux/can/netlink.h
+ *
+ * Definitions for the CAN netlink interface
+ *
+ * Copyright (c) 2009 Wolfgang Grandegger <wg@grandegger.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _CAN_NETLINK_H
+#define _CAN_NETLINK_H
+
+#include <linux/types.h>
+
+/*
+ * CAN bit-timing parameters
+ *
+ * For further information, please read chapter "8 BIT TIMING
+ * REQUIREMENTS" of the "Bosch CAN Specification version 2.0"
+ * at http://www.semiconductors.bosch.de/pdf/can2spec.pdf.
+ */
+struct can_bittiming {
+	__u32 bitrate;		/* Bit-rate in bits/second */
+	__u32 sample_point;	/* Sample point in one-tenth of a percent */
+	__u32 tq;		/* Time quanta (TQ) in nanoseconds */
+	__u32 prop_seg;		/* Propagation segment in TQs */
+	__u32 phase_seg1;	/* Phase buffer segment 1 in TQs */
+	__u32 phase_seg2;	/* Phase buffer segment 2 in TQs */
+	__u32 sjw;		/* Synchronisation jump width in TQs */
+	__u32 brp;		/* Bit-rate prescaler */
+};
+
+/*
+ * CAN harware-dependent bit-timing constant
+ *
+ * Used for calculating and checking bit-timing parameters
+ */
+struct can_bittiming_const {
+	char name[16];		/* Name of the CAN controller hardware */
+	__u32 tseg1_min;	/* Time segement 1 = prop_seg + phase_seg1 */
+	__u32 tseg1_max;
+	__u32 tseg2_min;	/* Time segement 2 = phase_seg2 */
+	__u32 tseg2_max;
+	__u32 sjw_max;		/* Synchronisation jump width */
+	__u32 brp_min;		/* Bit-rate prescaler */
+	__u32 brp_max;
+	__u32 brp_inc;
+};
+
+/*
+ * CAN clock parameters
+ */
+struct can_clock {
+	__u32 freq;		/* CAN system clock frequency in Hz */
+};
+
+/*
+ * CAN operational and error states
+ */
+enum can_state {
+	CAN_STATE_ERROR_ACTIVE = 0,	/* RX/TX error count < 96 */
+	CAN_STATE_ERROR_WARNING,	/* RX/TX error count < 128 */
+	CAN_STATE_ERROR_PASSIVE,	/* RX/TX error count < 256 */
+	CAN_STATE_BUS_OFF,		/* RX/TX error count >= 256 */
+	CAN_STATE_STOPPED,		/* Device is stopped */
+	CAN_STATE_SLEEPING,		/* Device is sleeping */
+	CAN_STATE_MAX
+};
+
+/*
+ * CAN bus error counters
+ */
+struct can_berr_counter {
+	__u16 txerr;
+	__u16 rxerr;
+};
+
+/*
+ * CAN controller mode
+ */
+struct can_ctrlmode {
+	__u32 mask;
+	__u32 flags;
+};
+
+#define CAN_CTRLMODE_LOOPBACK		0x01	/* Loopback mode */
+#define CAN_CTRLMODE_LISTENONLY		0x02	/* Listen-only mode */
+#define CAN_CTRLMODE_3_SAMPLES		0x04	/* Triple sampling mode */
+#define CAN_CTRLMODE_ONE_SHOT		0x08	/* One-Shot mode */
+#define CAN_CTRLMODE_BERR_REPORTING	0x10	/* Bus-error reporting */
+#define CAN_CTRLMODE_FD			0x20	/* CAN FD mode */
+#define CAN_CTRLMODE_PRESUME_ACK	0x40	/* Ignore missing CAN ACKs */
+#define CAN_CTRLMODE_FD_NON_ISO		0x80	/* CAN FD in non-ISO mode */
+
+/*
+ * CAN device statistics
+ */
+struct can_device_stats {
+	__u32 bus_error;	/* Bus errors */
+	__u32 error_warning;	/* Changes to error warning state */
+	__u32 error_passive;	/* Changes to error passive state */
+	__u32 bus_off;		/* Changes to bus off state */
+	__u32 arbitration_lost; /* Arbitration lost errors */
+	__u32 restarts;		/* CAN controller re-starts */
+};
+
+/*
+ * CAN netlink interface
+ */
+enum {
+	IFLA_CAN_UNSPEC,
+	IFLA_CAN_BITTIMING,
+	IFLA_CAN_BITTIMING_CONST,
+	IFLA_CAN_CLOCK,
+	IFLA_CAN_STATE,
+	IFLA_CAN_CTRLMODE,
+	IFLA_CAN_RESTART_MS,
+	IFLA_CAN_RESTART,
+	IFLA_CAN_BERR_COUNTER,
+	IFLA_CAN_DATA_BITTIMING,
+	IFLA_CAN_DATA_BITTIMING_CONST,
+	IFLA_CAN_TERMINATION,
+	IFLA_CAN_TERMINATION_CONST,
+	IFLA_CAN_BITRATE_CONST,
+	IFLA_CAN_DATA_BITRATE_CONST,
+	__IFLA_CAN_MAX
+};
+
+#define IFLA_CAN_MAX	(__IFLA_CAN_MAX - 1)
+
+/* u16 termination range: 1..65535 Ohms */
+#define CAN_TERMINATION_DISABLED 0
+
+#endif /* !_UAPI_CAN_NETLINK_H */
diff --git a/include/uapi/linux/can/vxcan.h b/include/uapi/linux/can/vxcan.h
new file mode 100644
index 0000000..5b29e8a
--- /dev/null
+++ b/include/uapi/linux/can/vxcan.h
@@ -0,0 +1,12 @@
+#ifndef _CAN_VXCAN_H
+#define _CAN_VXCAN_H
+
+enum {
+	VXCAN_INFO_UNSPEC,
+	VXCAN_INFO_PEER,
+
+	__VXCAN_INFO_MAX
+#define VXCAN_INFO_MAX	(__VXCAN_INFO_MAX - 1)
+};
+
+#endif
diff --git a/include/uapi/linux/devlink.h b/include/uapi/linux/devlink.h
new file mode 100644
index 0000000..a62695e
--- /dev/null
+++ b/include/uapi/linux/devlink.h
@@ -0,0 +1,247 @@
+/*
+ * include/uapi/linux/devlink.h - Network physical device Netlink interface
+ * Copyright (c) 2016 Mellanox Technologies. All rights reserved.
+ * Copyright (c) 2016 Jiri Pirko <jiri@mellanox.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _LINUX_DEVLINK_H_
+#define _LINUX_DEVLINK_H_
+
+#define DEVLINK_GENL_NAME "devlink"
+#define DEVLINK_GENL_VERSION 0x1
+#define DEVLINK_GENL_MCGRP_CONFIG_NAME "config"
+
+enum devlink_command {
+	/* don't change the order or add anything between, this is ABI! */
+	DEVLINK_CMD_UNSPEC,
+
+	DEVLINK_CMD_GET,		/* can dump */
+	DEVLINK_CMD_SET,
+	DEVLINK_CMD_NEW,
+	DEVLINK_CMD_DEL,
+
+	DEVLINK_CMD_PORT_GET,		/* can dump */
+	DEVLINK_CMD_PORT_SET,
+	DEVLINK_CMD_PORT_NEW,
+	DEVLINK_CMD_PORT_DEL,
+
+	DEVLINK_CMD_PORT_SPLIT,
+	DEVLINK_CMD_PORT_UNSPLIT,
+
+	DEVLINK_CMD_SB_GET,		/* can dump */
+	DEVLINK_CMD_SB_SET,
+	DEVLINK_CMD_SB_NEW,
+	DEVLINK_CMD_SB_DEL,
+
+	DEVLINK_CMD_SB_POOL_GET,	/* can dump */
+	DEVLINK_CMD_SB_POOL_SET,
+	DEVLINK_CMD_SB_POOL_NEW,
+	DEVLINK_CMD_SB_POOL_DEL,
+
+	DEVLINK_CMD_SB_PORT_POOL_GET,	/* can dump */
+	DEVLINK_CMD_SB_PORT_POOL_SET,
+	DEVLINK_CMD_SB_PORT_POOL_NEW,
+	DEVLINK_CMD_SB_PORT_POOL_DEL,
+
+	DEVLINK_CMD_SB_TC_POOL_BIND_GET,	/* can dump */
+	DEVLINK_CMD_SB_TC_POOL_BIND_SET,
+	DEVLINK_CMD_SB_TC_POOL_BIND_NEW,
+	DEVLINK_CMD_SB_TC_POOL_BIND_DEL,
+
+	/* Shared buffer occupancy monitoring commands */
+	DEVLINK_CMD_SB_OCC_SNAPSHOT,
+	DEVLINK_CMD_SB_OCC_MAX_CLEAR,
+
+	DEVLINK_CMD_ESWITCH_GET,
+#define DEVLINK_CMD_ESWITCH_MODE_GET /* obsolete, never use this! */ \
+	DEVLINK_CMD_ESWITCH_GET
+
+	DEVLINK_CMD_ESWITCH_SET,
+#define DEVLINK_CMD_ESWITCH_MODE_SET /* obsolete, never use this! */ \
+	DEVLINK_CMD_ESWITCH_SET
+
+	DEVLINK_CMD_DPIPE_TABLE_GET,
+	DEVLINK_CMD_DPIPE_ENTRIES_GET,
+	DEVLINK_CMD_DPIPE_HEADERS_GET,
+	DEVLINK_CMD_DPIPE_TABLE_COUNTERS_SET,
+
+	/* add new commands above here */
+	__DEVLINK_CMD_MAX,
+	DEVLINK_CMD_MAX = __DEVLINK_CMD_MAX - 1
+};
+
+enum devlink_port_type {
+	DEVLINK_PORT_TYPE_NOTSET,
+	DEVLINK_PORT_TYPE_AUTO,
+	DEVLINK_PORT_TYPE_ETH,
+	DEVLINK_PORT_TYPE_IB,
+};
+
+enum devlink_sb_pool_type {
+	DEVLINK_SB_POOL_TYPE_INGRESS,
+	DEVLINK_SB_POOL_TYPE_EGRESS,
+};
+
+/* static threshold - limiting the maximum number of bytes.
+ * dynamic threshold - limiting the maximum number of bytes
+ *   based on the currently available free space in the shared buffer pool.
+ *   In this mode, the maximum quota is calculated based
+ *   on the following formula:
+ *     max_quota = alpha / (1 + alpha) * Free_Buffer
+ *   While Free_Buffer is the amount of none-occupied buffer associated to
+ *   the relevant pool.
+ *   The value range which can be passed is 0-20 and serves
+ *   for computation of alpha by following formula:
+ *     alpha = 2 ^ (passed_value - 10)
+ */
+
+enum devlink_sb_threshold_type {
+	DEVLINK_SB_THRESHOLD_TYPE_STATIC,
+	DEVLINK_SB_THRESHOLD_TYPE_DYNAMIC,
+};
+
+#define DEVLINK_SB_THRESHOLD_TO_ALPHA_MAX 20
+
+enum devlink_eswitch_mode {
+	DEVLINK_ESWITCH_MODE_LEGACY,
+	DEVLINK_ESWITCH_MODE_SWITCHDEV,
+};
+
+enum devlink_eswitch_inline_mode {
+	DEVLINK_ESWITCH_INLINE_MODE_NONE,
+	DEVLINK_ESWITCH_INLINE_MODE_LINK,
+	DEVLINK_ESWITCH_INLINE_MODE_NETWORK,
+	DEVLINK_ESWITCH_INLINE_MODE_TRANSPORT,
+};
+
+enum devlink_eswitch_encap_mode {
+	DEVLINK_ESWITCH_ENCAP_MODE_NONE,
+	DEVLINK_ESWITCH_ENCAP_MODE_BASIC,
+};
+
+enum devlink_attr {
+	/* don't change the order or add anything between, this is ABI! */
+	DEVLINK_ATTR_UNSPEC,
+
+	/* bus name + dev name together are a handle for devlink entity */
+	DEVLINK_ATTR_BUS_NAME,			/* string */
+	DEVLINK_ATTR_DEV_NAME,			/* string */
+
+	DEVLINK_ATTR_PORT_INDEX,		/* u32 */
+	DEVLINK_ATTR_PORT_TYPE,			/* u16 */
+	DEVLINK_ATTR_PORT_DESIRED_TYPE,		/* u16 */
+	DEVLINK_ATTR_PORT_NETDEV_IFINDEX,	/* u32 */
+	DEVLINK_ATTR_PORT_NETDEV_NAME,		/* string */
+	DEVLINK_ATTR_PORT_IBDEV_NAME,		/* string */
+	DEVLINK_ATTR_PORT_SPLIT_COUNT,		/* u32 */
+	DEVLINK_ATTR_PORT_SPLIT_GROUP,		/* u32 */
+	DEVLINK_ATTR_SB_INDEX,			/* u32 */
+	DEVLINK_ATTR_SB_SIZE,			/* u32 */
+	DEVLINK_ATTR_SB_INGRESS_POOL_COUNT,	/* u16 */
+	DEVLINK_ATTR_SB_EGRESS_POOL_COUNT,	/* u16 */
+	DEVLINK_ATTR_SB_INGRESS_TC_COUNT,	/* u16 */
+	DEVLINK_ATTR_SB_EGRESS_TC_COUNT,	/* u16 */
+	DEVLINK_ATTR_SB_POOL_INDEX,		/* u16 */
+	DEVLINK_ATTR_SB_POOL_TYPE,		/* u8 */
+	DEVLINK_ATTR_SB_POOL_SIZE,		/* u32 */
+	DEVLINK_ATTR_SB_POOL_THRESHOLD_TYPE,	/* u8 */
+	DEVLINK_ATTR_SB_THRESHOLD,		/* u32 */
+	DEVLINK_ATTR_SB_TC_INDEX,		/* u16 */
+	DEVLINK_ATTR_SB_OCC_CUR,		/* u32 */
+	DEVLINK_ATTR_SB_OCC_MAX,		/* u32 */
+	DEVLINK_ATTR_ESWITCH_MODE,		/* u16 */
+	DEVLINK_ATTR_ESWITCH_INLINE_MODE,	/* u8 */
+
+	DEVLINK_ATTR_DPIPE_TABLES,		/* nested */
+	DEVLINK_ATTR_DPIPE_TABLE,		/* nested */
+	DEVLINK_ATTR_DPIPE_TABLE_NAME,		/* string */
+	DEVLINK_ATTR_DPIPE_TABLE_SIZE,		/* u64 */
+	DEVLINK_ATTR_DPIPE_TABLE_MATCHES,	/* nested */
+	DEVLINK_ATTR_DPIPE_TABLE_ACTIONS,	/* nested */
+	DEVLINK_ATTR_DPIPE_TABLE_COUNTERS_ENABLED,	/* u8 */
+
+	DEVLINK_ATTR_DPIPE_ENTRIES,		/* nested */
+	DEVLINK_ATTR_DPIPE_ENTRY,		/* nested */
+	DEVLINK_ATTR_DPIPE_ENTRY_INDEX,		/* u64 */
+	DEVLINK_ATTR_DPIPE_ENTRY_MATCH_VALUES,	/* nested */
+	DEVLINK_ATTR_DPIPE_ENTRY_ACTION_VALUES,	/* nested */
+	DEVLINK_ATTR_DPIPE_ENTRY_COUNTER,	/* u64 */
+
+	DEVLINK_ATTR_DPIPE_MATCH,		/* nested */
+	DEVLINK_ATTR_DPIPE_MATCH_VALUE,		/* nested */
+	DEVLINK_ATTR_DPIPE_MATCH_TYPE,		/* u32 */
+
+	DEVLINK_ATTR_DPIPE_ACTION,		/* nested */
+	DEVLINK_ATTR_DPIPE_ACTION_VALUE,	/* nested */
+	DEVLINK_ATTR_DPIPE_ACTION_TYPE,		/* u32 */
+
+	DEVLINK_ATTR_DPIPE_VALUE,
+	DEVLINK_ATTR_DPIPE_VALUE_MASK,
+	DEVLINK_ATTR_DPIPE_VALUE_MAPPING,	/* u32 */
+
+	DEVLINK_ATTR_DPIPE_HEADERS,		/* nested */
+	DEVLINK_ATTR_DPIPE_HEADER,		/* nested */
+	DEVLINK_ATTR_DPIPE_HEADER_NAME,		/* string */
+	DEVLINK_ATTR_DPIPE_HEADER_ID,		/* u32 */
+	DEVLINK_ATTR_DPIPE_HEADER_FIELDS,	/* nested */
+	DEVLINK_ATTR_DPIPE_HEADER_GLOBAL,	/* u8 */
+	DEVLINK_ATTR_DPIPE_HEADER_INDEX,	/* u32 */
+
+	DEVLINK_ATTR_DPIPE_FIELD,		/* nested */
+	DEVLINK_ATTR_DPIPE_FIELD_NAME,		/* string */
+	DEVLINK_ATTR_DPIPE_FIELD_ID,		/* u32 */
+	DEVLINK_ATTR_DPIPE_FIELD_BITWIDTH,	/* u32 */
+	DEVLINK_ATTR_DPIPE_FIELD_MAPPING_TYPE,	/* u32 */
+
+	DEVLINK_ATTR_PAD,
+
+	DEVLINK_ATTR_ESWITCH_ENCAP_MODE,	/* u8 */
+
+	/* add new attributes above here, update the policy in devlink.c */
+
+	__DEVLINK_ATTR_MAX,
+	DEVLINK_ATTR_MAX = __DEVLINK_ATTR_MAX - 1
+};
+
+/* Mapping between internal resource described by the field and system
+ * structure
+ */
+enum devlink_dpipe_field_mapping_type {
+	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_NONE,
+	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_IFINDEX,
+};
+
+/* Match type - specify the type of the match */
+enum devlink_dpipe_match_type {
+	DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT,
+};
+
+/* Action type - specify the action type */
+enum devlink_dpipe_action_type {
+	DEVLINK_DPIPE_ACTION_TYPE_FIELD_MODIFY,
+};
+
+enum devlink_dpipe_field_ethernet_id {
+	DEVLINK_DPIPE_FIELD_ETHERNET_DST_MAC,
+};
+
+enum devlink_dpipe_field_ipv4_id {
+	DEVLINK_DPIPE_FIELD_IPV4_DST_IP,
+};
+
+enum devlink_dpipe_field_ipv6_id {
+	DEVLINK_DPIPE_FIELD_IPV6_DST_IP,
+};
+
+enum devlink_dpipe_header_id {
+	DEVLINK_DPIPE_HEADER_ETHERNET,
+	DEVLINK_DPIPE_HEADER_IPV4,
+	DEVLINK_DPIPE_HEADER_IPV6,
+};
+
+#endif /* _LINUX_DEVLINK_H_ */
diff --git a/include/uapi/linux/elf-em.h b/include/uapi/linux/elf-em.h
new file mode 100644
index 0000000..9cd1de9
--- /dev/null
+++ b/include/uapi/linux/elf-em.h
@@ -0,0 +1,60 @@
+#ifndef _LINUX_ELF_EM_H
+#define _LINUX_ELF_EM_H
+
+/* These constants define the various ELF target machines */
+#define EM_NONE		0
+#define EM_M32		1
+#define EM_SPARC	2
+#define EM_386		3
+#define EM_68K		4
+#define EM_88K		5
+#define EM_486		6	/* Perhaps disused */
+#define EM_860		7
+#define EM_MIPS		8	/* MIPS R3000 (officially, big-endian only) */
+				/* Next two are historical and binaries and
+				   modules of these types will be rejected by
+				   Linux.  */
+#define EM_MIPS_RS3_LE	10	/* MIPS R3000 little-endian */
+#define EM_MIPS_RS4_BE	10	/* MIPS R4000 big-endian */
+
+#define EM_PARISC	15	/* HPPA */
+#define EM_SPARC32PLUS	18	/* Sun's "v8plus" */
+#define EM_PPC		20	/* PowerPC */
+#define EM_PPC64	21	 /* PowerPC64 */
+#define EM_SPU		23	/* Cell BE SPU */
+#define EM_ARM		40	/* ARM 32 bit */
+#define EM_SH		42	/* SuperH */
+#define EM_SPARCV9	43	/* SPARC v9 64-bit */
+#define EM_H8_300	46	/* Renesas H8/300 */
+#define EM_IA_64	50	/* HP/Intel IA-64 */
+#define EM_X86_64	62	/* AMD x86-64 */
+#define EM_S390		22	/* IBM S/390 */
+#define EM_CRIS		76	/* Axis Communications 32-bit embedded processor */
+#define EM_M32R		88	/* Renesas M32R */
+#define EM_MN10300	89	/* Panasonic/MEI MN10300, AM33 */
+#define EM_OPENRISC     92     /* OpenRISC 32-bit embedded processor */
+#define EM_BLACKFIN     106     /* ADI Blackfin Processor */
+#define EM_ALTERA_NIOS2	113	/* Altera Nios II soft-core processor */
+#define EM_TI_C6000	140	/* TI C6X DSPs */
+#define EM_AARCH64	183	/* ARM 64 bit */
+#define EM_TILEPRO	188	/* Tilera TILEPro */
+#define EM_MICROBLAZE	189	/* Xilinx MicroBlaze */
+#define EM_TILEGX	191	/* Tilera TILE-Gx */
+#define EM_BPF		247	/* Linux BPF - in-kernel virtual machine */
+#define EM_FRV		0x5441	/* Fujitsu FR-V */
+
+/*
+ * This is an interim value that we will use until the committee comes
+ * up with a final number.
+ */
+#define EM_ALPHA	0x9026
+
+/* Bogus old m32r magic number, used by old tools. */
+#define EM_CYGNUS_M32R	0x9041
+/* This is the old interim value for S/390 architecture */
+#define EM_S390_OLD	0xA390
+/* Also Panasonic/MEI MN10300, AM33 */
+#define EM_CYGNUS_MN10300 0xbeef
+
+
+#endif /* _LINUX_ELF_EM_H */
diff --git a/include/uapi/linux/fib_rules.h b/include/uapi/linux/fib_rules.h
new file mode 100644
index 0000000..bbf02a6
--- /dev/null
+++ b/include/uapi/linux/fib_rules.h
@@ -0,0 +1,80 @@
+#ifndef __LINUX_FIB_RULES_H
+#define __LINUX_FIB_RULES_H
+
+#include <linux/types.h>
+#include <linux/rtnetlink.h>
+
+/* rule is permanent, and cannot be deleted */
+#define FIB_RULE_PERMANENT	0x00000001
+#define FIB_RULE_INVERT		0x00000002
+#define FIB_RULE_UNRESOLVED	0x00000004
+#define FIB_RULE_IIF_DETACHED	0x00000008
+#define FIB_RULE_DEV_DETACHED	FIB_RULE_IIF_DETACHED
+#define FIB_RULE_OIF_DETACHED	0x00000010
+
+/* try to find source address in routing lookups */
+#define FIB_RULE_FIND_SADDR	0x00010000
+
+struct fib_rule_hdr {
+	__u8		family;
+	__u8		dst_len;
+	__u8		src_len;
+	__u8		tos;
+
+	__u8		table;
+	__u8		res1;	/* reserved */
+	__u8		res2;	/* reserved */
+	__u8		action;
+
+	__u32		flags;
+};
+
+struct fib_rule_uid_range {
+	__u32		start;
+	__u32		end;
+};
+
+enum {
+	FRA_UNSPEC,
+	FRA_DST,	/* destination address */
+	FRA_SRC,	/* source address */
+	FRA_IIFNAME,	/* interface name */
+#define FRA_IFNAME	FRA_IIFNAME
+	FRA_GOTO,	/* target to jump to (FR_ACT_GOTO) */
+	FRA_UNUSED2,
+	FRA_PRIORITY,	/* priority/preference */
+	FRA_UNUSED3,
+	FRA_UNUSED4,
+	FRA_UNUSED5,
+	FRA_FWMARK,	/* mark */
+	FRA_FLOW,	/* flow/class id */
+	FRA_TUN_ID,
+	FRA_SUPPRESS_IFGROUP,
+	FRA_SUPPRESS_PREFIXLEN,
+	FRA_TABLE,	/* Extended table id */
+	FRA_FWMASK,	/* mask for netfilter mark */
+	FRA_OIFNAME,
+	FRA_PAD,
+	FRA_L3MDEV,	/* iif or oif is l3mdev goto its table */
+	FRA_UID_RANGE,	/* UID range */
+	__FRA_MAX
+};
+
+#define FRA_MAX (__FRA_MAX - 1)
+
+enum {
+	FR_ACT_UNSPEC,
+	FR_ACT_TO_TBL,		/* Pass to fixed table */
+	FR_ACT_GOTO,		/* Jump to another rule */
+	FR_ACT_NOP,		/* No operation */
+	FR_ACT_RES3,
+	FR_ACT_RES4,
+	FR_ACT_BLACKHOLE,	/* Drop without notification */
+	FR_ACT_UNREACHABLE,	/* Drop with ENETUNREACH */
+	FR_ACT_PROHIBIT,	/* Drop with EACCES */
+	__FR_ACT_MAX,
+};
+
+#define FR_ACT_MAX (__FR_ACT_MAX - 1)
+
+#endif
diff --git a/include/uapi/linux/filter.h b/include/uapi/linux/filter.h
new file mode 100644
index 0000000..e4f2f74
--- /dev/null
+++ b/include/uapi/linux/filter.h
@@ -0,0 +1,89 @@
+/*
+ * Linux Socket Filter Data Structures
+ */
+
+#ifndef __LINUX_FILTER_H__
+#define __LINUX_FILTER_H__
+
+
+#include <linux/types.h>
+#include <linux/bpf_common.h>
+
+/*
+ * Current version of the filter code architecture.
+ */
+#define BPF_MAJOR_VERSION 1
+#define BPF_MINOR_VERSION 1
+
+/*
+ *	Try and keep these values and structures similar to BSD, especially
+ *	the BPF code definitions which need to match so you can share filters
+ */
+ 
+struct sock_filter {	/* Filter block */
+	__u16	code;   /* Actual filter code */
+	__u8	jt;	/* Jump true */
+	__u8	jf;	/* Jump false */
+	__u32	k;      /* Generic multiuse field */
+};
+
+struct sock_fprog {	/* Required for SO_ATTACH_FILTER. */
+	unsigned short		len;	/* Number of filter blocks */
+	struct sock_filter *filter;
+};
+
+/* ret - BPF_K and BPF_X also apply */
+#define BPF_RVAL(code)  ((code) & 0x18)
+#define         BPF_A           0x10
+
+/* misc */
+#define BPF_MISCOP(code) ((code) & 0xf8)
+#define         BPF_TAX         0x00
+#define         BPF_TXA         0x80
+
+/*
+ * Macros for filter block array initializers.
+ */
+#ifndef BPF_STMT
+#define BPF_STMT(code, k) { (unsigned short)(code), 0, 0, k }
+#endif
+#ifndef BPF_JUMP
+#define BPF_JUMP(code, k, jt, jf) { (unsigned short)(code), jt, jf, k }
+#endif
+
+/*
+ * Number of scratch memory words for: BPF_ST and BPF_STX
+ */
+#define BPF_MEMWORDS 16
+
+/* RATIONALE. Negative offsets are invalid in BPF.
+   We use them to reference ancillary data.
+   Unlike introduction new instructions, it does not break
+   existing compilers/optimizers.
+ */
+#define SKF_AD_OFF    (-0x1000)
+#define SKF_AD_PROTOCOL 0
+#define SKF_AD_PKTTYPE 	4
+#define SKF_AD_IFINDEX 	8
+#define SKF_AD_NLATTR	12
+#define SKF_AD_NLATTR_NEST	16
+#define SKF_AD_MARK 	20
+#define SKF_AD_QUEUE	24
+#define SKF_AD_HATYPE	28
+#define SKF_AD_RXHASH	32
+#define SKF_AD_CPU	36
+#define SKF_AD_ALU_XOR_X	40
+#define SKF_AD_VLAN_TAG	44
+#define SKF_AD_VLAN_TAG_PRESENT 48
+#define SKF_AD_PAY_OFFSET	52
+#define SKF_AD_RANDOM	56
+#define SKF_AD_VLAN_TPID	60
+#define SKF_AD_MAX	64
+
+#define SKF_NET_OFF	(-0x100000)
+#define SKF_LL_OFF	(-0x200000)
+
+#define BPF_NET_OFF	SKF_NET_OFF
+#define BPF_LL_OFF	SKF_LL_OFF
+
+#endif /* __LINUX_FILTER_H__ */
diff --git a/include/uapi/linux/fou.h b/include/uapi/linux/fou.h
new file mode 100644
index 0000000..744c323
--- /dev/null
+++ b/include/uapi/linux/fou.h
@@ -0,0 +1,41 @@
+/* fou.h - FOU Interface */
+
+#ifndef _LINUX_FOU_H
+#define _LINUX_FOU_H
+
+/* NETLINK_GENERIC related info
+ */
+#define FOU_GENL_NAME		"fou"
+#define FOU_GENL_VERSION	0x1
+
+enum {
+	FOU_ATTR_UNSPEC,
+	FOU_ATTR_PORT,				/* u16 */
+	FOU_ATTR_AF,				/* u8 */
+	FOU_ATTR_IPPROTO,			/* u8 */
+	FOU_ATTR_TYPE,				/* u8 */
+	FOU_ATTR_REMCSUM_NOPARTIAL,		/* flag */
+
+	__FOU_ATTR_MAX,
+};
+
+#define FOU_ATTR_MAX		(__FOU_ATTR_MAX - 1)
+
+enum {
+	FOU_CMD_UNSPEC,
+	FOU_CMD_ADD,
+	FOU_CMD_DEL,
+	FOU_CMD_GET,
+
+	__FOU_CMD_MAX,
+};
+
+enum {
+	FOU_ENCAP_UNSPEC,
+	FOU_ENCAP_DIRECT,
+	FOU_ENCAP_GUE,
+};
+
+#define FOU_CMD_MAX	(__FOU_CMD_MAX - 1)
+
+#endif /* _LINUX_FOU_H */
diff --git a/include/uapi/linux/gen_stats.h b/include/uapi/linux/gen_stats.h
new file mode 100644
index 0000000..52deccc
--- /dev/null
+++ b/include/uapi/linux/gen_stats.h
@@ -0,0 +1,79 @@
+#ifndef __LINUX_GEN_STATS_H
+#define __LINUX_GEN_STATS_H
+
+#include <linux/types.h>
+
+enum {
+	TCA_STATS_UNSPEC,
+	TCA_STATS_BASIC,
+	TCA_STATS_RATE_EST,
+	TCA_STATS_QUEUE,
+	TCA_STATS_APP,
+	TCA_STATS_RATE_EST64,
+	TCA_STATS_PAD,
+	__TCA_STATS_MAX,
+};
+#define TCA_STATS_MAX (__TCA_STATS_MAX - 1)
+
+/**
+ * struct gnet_stats_basic - byte/packet throughput statistics
+ * @bytes: number of seen bytes
+ * @packets: number of seen packets
+ */
+struct gnet_stats_basic {
+	__u64	bytes;
+	__u32	packets;
+};
+struct gnet_stats_basic_packed {
+	__u64	bytes;
+	__u32	packets;
+} __attribute__ ((packed));
+
+/**
+ * struct gnet_stats_rate_est - rate estimator
+ * @bps: current byte rate
+ * @pps: current packet rate
+ */
+struct gnet_stats_rate_est {
+	__u32	bps;
+	__u32	pps;
+};
+
+/**
+ * struct gnet_stats_rate_est64 - rate estimator
+ * @bps: current byte rate
+ * @pps: current packet rate
+ */
+struct gnet_stats_rate_est64 {
+	__u64	bps;
+	__u64	pps;
+};
+
+/**
+ * struct gnet_stats_queue - queuing statistics
+ * @qlen: queue length
+ * @backlog: backlog size of queue
+ * @drops: number of dropped packets
+ * @requeues: number of requeues
+ * @overlimits: number of enqueues over the limit
+ */
+struct gnet_stats_queue {
+	__u32	qlen;
+	__u32	backlog;
+	__u32	drops;
+	__u32	requeues;
+	__u32	overlimits;
+};
+
+/**
+ * struct gnet_estimator - rate estimator configuration
+ * @interval: sampling period
+ * @ewma_log: the log of measurement window weight
+ */
+struct gnet_estimator {
+	signed char	interval;
+	unsigned char	ewma_log;
+};
+
+
+#endif /* __LINUX_GEN_STATS_H */
diff --git a/include/uapi/linux/genetlink.h b/include/uapi/linux/genetlink.h
new file mode 100644
index 0000000..08239d8
--- /dev/null
+++ b/include/uapi/linux/genetlink.h
@@ -0,0 +1,88 @@
+#ifndef __LINUX_GENERIC_NETLINK_H
+#define __LINUX_GENERIC_NETLINK_H
+
+#include <linux/types.h>
+#include <linux/netlink.h>
+
+#define GENL_NAMSIZ	16	/* length of family name */
+
+#define GENL_MIN_ID	NLMSG_MIN_TYPE
+#define GENL_MAX_ID	1023
+
+struct genlmsghdr {
+	__u8	cmd;
+	__u8	version;
+	__u16	reserved;
+};
+
+#define GENL_HDRLEN	NLMSG_ALIGN(sizeof(struct genlmsghdr))
+
+#define GENL_ADMIN_PERM		0x01
+#define GENL_CMD_CAP_DO		0x02
+#define GENL_CMD_CAP_DUMP	0x04
+#define GENL_CMD_CAP_HASPOL	0x08
+#define GENL_UNS_ADMIN_PERM	0x10
+
+/*
+ * List of reserved static generic netlink identifiers:
+ */
+#define GENL_ID_CTRL		NLMSG_MIN_TYPE
+#define GENL_ID_VFS_DQUOT	(NLMSG_MIN_TYPE + 1)
+#define GENL_ID_PMCRAID		(NLMSG_MIN_TYPE + 2)
+/* must be last reserved + 1 */
+#define GENL_START_ALLOC	(NLMSG_MIN_TYPE + 3)
+
+/**************************************************************************
+ * Controller
+ **************************************************************************/
+
+enum {
+	CTRL_CMD_UNSPEC,
+	CTRL_CMD_NEWFAMILY,
+	CTRL_CMD_DELFAMILY,
+	CTRL_CMD_GETFAMILY,
+	CTRL_CMD_NEWOPS,
+	CTRL_CMD_DELOPS,
+	CTRL_CMD_GETOPS,
+	CTRL_CMD_NEWMCAST_GRP,
+	CTRL_CMD_DELMCAST_GRP,
+	CTRL_CMD_GETMCAST_GRP, /* unused */
+	__CTRL_CMD_MAX,
+};
+
+#define CTRL_CMD_MAX (__CTRL_CMD_MAX - 1)
+
+enum {
+	CTRL_ATTR_UNSPEC,
+	CTRL_ATTR_FAMILY_ID,
+	CTRL_ATTR_FAMILY_NAME,
+	CTRL_ATTR_VERSION,
+	CTRL_ATTR_HDRSIZE,
+	CTRL_ATTR_MAXATTR,
+	CTRL_ATTR_OPS,
+	CTRL_ATTR_MCAST_GROUPS,
+	__CTRL_ATTR_MAX,
+};
+
+#define CTRL_ATTR_MAX (__CTRL_ATTR_MAX - 1)
+
+enum {
+	CTRL_ATTR_OP_UNSPEC,
+	CTRL_ATTR_OP_ID,
+	CTRL_ATTR_OP_FLAGS,
+	__CTRL_ATTR_OP_MAX,
+};
+
+#define CTRL_ATTR_OP_MAX (__CTRL_ATTR_OP_MAX - 1)
+
+enum {
+	CTRL_ATTR_MCAST_GRP_UNSPEC,
+	CTRL_ATTR_MCAST_GRP_NAME,
+	CTRL_ATTR_MCAST_GRP_ID,
+	__CTRL_ATTR_MCAST_GRP_MAX,
+};
+
+#define CTRL_ATTR_MCAST_GRP_MAX (__CTRL_ATTR_MCAST_GRP_MAX - 1)
+
+
+#endif /* __LINUX_GENERIC_NETLINK_H */
diff --git a/include/uapi/linux/hdlc/ioctl.h b/include/uapi/linux/hdlc/ioctl.h
new file mode 100644
index 0000000..04bc027
--- /dev/null
+++ b/include/uapi/linux/hdlc/ioctl.h
@@ -0,0 +1,84 @@
+#ifndef __HDLC_IOCTL_H__
+#define __HDLC_IOCTL_H__
+
+
+#define GENERIC_HDLC_VERSION 4	/* For synchronization with sethdlc utility */
+
+#define CLOCK_DEFAULT   0	/* Default setting */
+#define CLOCK_EXT	1	/* External TX and RX clock - DTE */
+#define CLOCK_INT	2	/* Internal TX and RX clock - DCE */
+#define CLOCK_TXINT	3	/* Internal TX and external RX clock */
+#define CLOCK_TXFROMRX	4	/* TX clock derived from external RX clock */
+
+
+#define ENCODING_DEFAULT	0 /* Default setting */
+#define ENCODING_NRZ		1
+#define ENCODING_NRZI		2
+#define ENCODING_FM_MARK	3
+#define ENCODING_FM_SPACE	4
+#define ENCODING_MANCHESTER	5
+
+
+#define PARITY_DEFAULT		0 /* Default setting */
+#define PARITY_NONE		1 /* No parity */
+#define PARITY_CRC16_PR0	2 /* CRC16, initial value 0x0000 */
+#define PARITY_CRC16_PR1	3 /* CRC16, initial value 0xFFFF */
+#define PARITY_CRC16_PR0_CCITT	4 /* CRC16, initial 0x0000, ITU-T version */
+#define PARITY_CRC16_PR1_CCITT	5 /* CRC16, initial 0xFFFF, ITU-T version */
+#define PARITY_CRC32_PR0_CCITT	6 /* CRC32, initial value 0x00000000 */
+#define PARITY_CRC32_PR1_CCITT	7 /* CRC32, initial value 0xFFFFFFFF */
+
+#define LMI_DEFAULT		0 /* Default setting */
+#define LMI_NONE		1 /* No LMI, all PVCs are static */
+#define LMI_ANSI		2 /* ANSI Annex D */
+#define LMI_CCITT		3 /* ITU-T Annex A */
+#define LMI_CISCO		4 /* The "original" LMI, aka Gang of Four */
+
+#ifndef __ASSEMBLY__
+
+typedef struct {
+	unsigned int clock_rate; /* bits per second */
+	unsigned int clock_type; /* internal, external, TX-internal etc. */
+	unsigned short loopback;
+} sync_serial_settings;          /* V.35, V.24, X.21 */
+
+typedef struct {
+	unsigned int clock_rate; /* bits per second */
+	unsigned int clock_type; /* internal, external, TX-internal etc. */
+	unsigned short loopback;
+	unsigned int slot_map;
+} te1_settings;                  /* T1, E1 */
+
+typedef struct {
+	unsigned short encoding;
+	unsigned short parity;
+} raw_hdlc_proto;
+
+typedef struct {
+	unsigned int t391;
+	unsigned int t392;
+	unsigned int n391;
+	unsigned int n392;
+	unsigned int n393;
+	unsigned short lmi;
+	unsigned short dce; /* 1 for DCE (network side) operation */
+} fr_proto;
+
+typedef struct {
+	unsigned int dlci;
+} fr_proto_pvc;          /* for creating/deleting FR PVCs */
+
+typedef struct {
+	unsigned int dlci;
+	char master[IFNAMSIZ];	/* Name of master FRAD device */
+}fr_proto_pvc_info;		/* for returning PVC information only */
+
+typedef struct {
+    unsigned int interval;
+    unsigned int timeout;
+} cisco_proto;
+
+/* PPP doesn't need any info now - supply length = 0 to ioctl */
+
+#endif /* __ASSEMBLY__ */
+#endif /* __HDLC_IOCTL_H__ */
diff --git a/include/uapi/linux/icmpv6.h b/include/uapi/linux/icmpv6.h
new file mode 100644
index 0000000..a2e839e
--- /dev/null
+++ b/include/uapi/linux/icmpv6.h
@@ -0,0 +1,166 @@
+#ifndef _LINUX_ICMPV6_H
+#define _LINUX_ICMPV6_H
+
+#include <linux/types.h>
+#include <asm/byteorder.h>
+
+struct icmp6hdr {
+
+	__u8		icmp6_type;
+	__u8		icmp6_code;
+	__sum16		icmp6_cksum;
+
+
+	union {
+		__be32			un_data32[1];
+		__be16			un_data16[2];
+		__u8			un_data8[4];
+
+		struct icmpv6_echo {
+			__be16		identifier;
+			__be16		sequence;
+		} u_echo;
+
+                struct icmpv6_nd_advt {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+                        __u32		reserved:5,
+                        		override:1,
+                        		solicited:1,
+                        		router:1,
+					reserved2:24;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+                        __u32		router:1,
+					solicited:1,
+                        		override:1,
+                        		reserved:29;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif						
+                } u_nd_advt;
+
+                struct icmpv6_nd_ra {
+			__u8		hop_limit;
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+			__u8		reserved:3,
+					router_pref:2,
+					home_agent:1,
+					other:1,
+					managed:1;
+
+#elif defined(__BIG_ENDIAN_BITFIELD)
+			__u8		managed:1,
+					other:1,
+					home_agent:1,
+					router_pref:2,
+					reserved:3;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif
+			__be16		rt_lifetime;
+                } u_nd_ra;
+
+	} icmp6_dataun;
+
+#define icmp6_identifier	icmp6_dataun.u_echo.identifier
+#define icmp6_sequence		icmp6_dataun.u_echo.sequence
+#define icmp6_pointer		icmp6_dataun.un_data32[0]
+#define icmp6_mtu		icmp6_dataun.un_data32[0]
+#define icmp6_unused		icmp6_dataun.un_data32[0]
+#define icmp6_maxdelay		icmp6_dataun.un_data16[0]
+#define icmp6_router		icmp6_dataun.u_nd_advt.router
+#define icmp6_solicited		icmp6_dataun.u_nd_advt.solicited
+#define icmp6_override		icmp6_dataun.u_nd_advt.override
+#define icmp6_ndiscreserved	icmp6_dataun.u_nd_advt.reserved
+#define icmp6_hop_limit		icmp6_dataun.u_nd_ra.hop_limit
+#define icmp6_addrconf_managed	icmp6_dataun.u_nd_ra.managed
+#define icmp6_addrconf_other	icmp6_dataun.u_nd_ra.other
+#define icmp6_rt_lifetime	icmp6_dataun.u_nd_ra.rt_lifetime
+#define icmp6_router_pref	icmp6_dataun.u_nd_ra.router_pref
+};
+
+
+#define ICMPV6_ROUTER_PREF_LOW		0x3
+#define ICMPV6_ROUTER_PREF_MEDIUM	0x0
+#define ICMPV6_ROUTER_PREF_HIGH		0x1
+#define ICMPV6_ROUTER_PREF_INVALID	0x2
+
+#define ICMPV6_DEST_UNREACH		1
+#define ICMPV6_PKT_TOOBIG		2
+#define ICMPV6_TIME_EXCEED		3
+#define ICMPV6_PARAMPROB		4
+
+#define ICMPV6_INFOMSG_MASK		0x80
+
+#define ICMPV6_ECHO_REQUEST		128
+#define ICMPV6_ECHO_REPLY		129
+#define ICMPV6_MGM_QUERY		130
+#define ICMPV6_MGM_REPORT       	131
+#define ICMPV6_MGM_REDUCTION    	132
+
+#define ICMPV6_NI_QUERY			139
+#define ICMPV6_NI_REPLY			140
+
+#define ICMPV6_MLD2_REPORT		143
+
+#define ICMPV6_DHAAD_REQUEST		144
+#define ICMPV6_DHAAD_REPLY		145
+#define ICMPV6_MOBILE_PREFIX_SOL	146
+#define ICMPV6_MOBILE_PREFIX_ADV	147
+
+/*
+ *	Codes for Destination Unreachable
+ */
+#define ICMPV6_NOROUTE			0
+#define ICMPV6_ADM_PROHIBITED		1
+#define ICMPV6_NOT_NEIGHBOUR		2
+#define ICMPV6_ADDR_UNREACH		3
+#define ICMPV6_PORT_UNREACH		4
+#define ICMPV6_POLICY_FAIL		5
+#define ICMPV6_REJECT_ROUTE		6
+
+/*
+ *	Codes for Time Exceeded
+ */
+#define ICMPV6_EXC_HOPLIMIT		0
+#define ICMPV6_EXC_FRAGTIME		1
+
+/*
+ *	Codes for Parameter Problem
+ */
+#define ICMPV6_HDR_FIELD		0
+#define ICMPV6_UNK_NEXTHDR		1
+#define ICMPV6_UNK_OPTION		2
+
+/*
+ *	constants for (set|get)sockopt
+ */
+
+#define ICMPV6_FILTER			1
+
+/*
+ *	ICMPV6 filter
+ */
+
+#define ICMPV6_FILTER_BLOCK		1
+#define ICMPV6_FILTER_PASS		2
+#define ICMPV6_FILTER_BLOCKOTHERS	3
+#define ICMPV6_FILTER_PASSONLY		4
+
+struct icmp6_filter {
+	__u32		data[8];
+};
+
+/*
+ *	Definitions for MLDv2
+ */
+#define MLD2_MODE_IS_INCLUDE	1
+#define MLD2_MODE_IS_EXCLUDE	2
+#define MLD2_CHANGE_TO_INCLUDE	3
+#define MLD2_CHANGE_TO_EXCLUDE	4
+#define MLD2_ALLOW_NEW_SOURCES	5
+#define MLD2_BLOCK_OLD_SOURCES	6
+
+#define MLD2_ALL_MCR_INIT { { { 0xff,0x02,0,0,0,0,0,0,0,0,0,0,0,0,0,0x16 } } }
+
+
+#endif /* _LINUX_ICMPV6_H */
diff --git a/include/uapi/linux/if.h b/include/uapi/linux/if.h
new file mode 100644
index 0000000..b4ba020
--- /dev/null
+++ b/include/uapi/linux/if.h
@@ -0,0 +1,292 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Global definitions for the INET interface module.
+ *
+ * Version:	@(#)if.h	1.0.2	04/18/93
+ *
+ * Authors:	Original taken from Berkeley UNIX 4.3, (c) UCB 1982-1988
+ *		Ross Biro
+ *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_IF_H
+#define _LINUX_IF_H
+
+#include <linux/libc-compat.h>          /* for compatibility with glibc */
+#include <linux/types.h>		/* for "__kernel_caddr_t" et al	*/
+#include <linux/socket.h>		/* for "struct sockaddr" et al	*/
+		/* for "__user" et al           */
+
+#include <sys/socket.h>			/* for struct sockaddr.		*/
+
+#if __UAPI_DEF_IF_IFNAMSIZ
+#define	IFNAMSIZ	16
+#endif /* __UAPI_DEF_IF_IFNAMSIZ */
+#define	IFALIASZ	256
+#include <linux/hdlc/ioctl.h>
+
+/* For glibc compatibility. An empty enum does not compile. */
+#if __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO != 0 || \
+    __UAPI_DEF_IF_NET_DEVICE_FLAGS != 0
+/**
+ * enum net_device_flags - &struct net_device flags
+ *
+ * These are the &struct net_device flags, they can be set by drivers, the
+ * kernel and some can be triggered by userspace. Userspace can query and
+ * set these flags using userspace utilities but there is also a sysfs
+ * entry available for all dev flags which can be queried and set. These flags
+ * are shared for all types of net_devices. The sysfs entries are available
+ * via /sys/class/net/<dev>/flags. Flags which can be toggled through sysfs
+ * are annotated below, note that only a few flags can be toggled and some
+ * other flags are always preserved from the original net_device flags
+ * even if you try to set them via sysfs. Flags which are always preserved
+ * are kept under the flag grouping @IFF_VOLATILE. Flags which are __volatile__
+ * are annotated below as such.
+ *
+ * You should have a pretty good reason to be extending these flags.
+ *
+ * @IFF_UP: interface is up. Can be toggled through sysfs.
+ * @IFF_BROADCAST: broadcast address valid. Volatile.
+ * @IFF_DEBUG: turn on debugging. Can be toggled through sysfs.
+ * @IFF_LOOPBACK: is a loopback net. Volatile.
+ * @IFF_POINTOPOINT: interface is has p-p link. Volatile.
+ * @IFF_NOTRAILERS: avoid use of trailers. Can be toggled through sysfs.
+ *	Volatile.
+ * @IFF_RUNNING: interface RFC2863 OPER_UP. Volatile.
+ * @IFF_NOARP: no ARP protocol. Can be toggled through sysfs. Volatile.
+ * @IFF_PROMISC: receive all packets. Can be toggled through sysfs.
+ * @IFF_ALLMULTI: receive all multicast packets. Can be toggled through
+ *	sysfs.
+ * @IFF_MASTER: master of a load balancer. Volatile.
+ * @IFF_SLAVE: slave of a load balancer. Volatile.
+ * @IFF_MULTICAST: Supports multicast. Can be toggled through sysfs.
+ * @IFF_PORTSEL: can set media type. Can be toggled through sysfs.
+ * @IFF_AUTOMEDIA: auto media select active. Can be toggled through sysfs.
+ * @IFF_DYNAMIC: dialup device with changing addresses. Can be toggled
+ *	through sysfs.
+ * @IFF_LOWER_UP: driver signals L1 up. Volatile.
+ * @IFF_DORMANT: driver signals dormant. Volatile.
+ * @IFF_ECHO: echo sent packets. Volatile.
+ */
+enum net_device_flags {
+/* for compatibility with glibc net/if.h */
+#if __UAPI_DEF_IF_NET_DEVICE_FLAGS
+	IFF_UP				= 1<<0,  /* sysfs */
+	IFF_BROADCAST			= 1<<1,  /* __volatile__ */
+	IFF_DEBUG			= 1<<2,  /* sysfs */
+	IFF_LOOPBACK			= 1<<3,  /* __volatile__ */
+	IFF_POINTOPOINT			= 1<<4,  /* __volatile__ */
+	IFF_NOTRAILERS			= 1<<5,  /* sysfs */
+	IFF_RUNNING			= 1<<6,  /* __volatile__ */
+	IFF_NOARP			= 1<<7,  /* sysfs */
+	IFF_PROMISC			= 1<<8,  /* sysfs */
+	IFF_ALLMULTI			= 1<<9,  /* sysfs */
+	IFF_MASTER			= 1<<10, /* __volatile__ */
+	IFF_SLAVE			= 1<<11, /* __volatile__ */
+	IFF_MULTICAST			= 1<<12, /* sysfs */
+	IFF_PORTSEL			= 1<<13, /* sysfs */
+	IFF_AUTOMEDIA			= 1<<14, /* sysfs */
+	IFF_DYNAMIC			= 1<<15, /* sysfs */
+#endif /* __UAPI_DEF_IF_NET_DEVICE_FLAGS */
+#if __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO
+	IFF_LOWER_UP			= 1<<16, /* __volatile__ */
+	IFF_DORMANT			= 1<<17, /* __volatile__ */
+	IFF_ECHO			= 1<<18, /* __volatile__ */
+#endif /* __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO */
+};
+#endif /* __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO != 0 || __UAPI_DEF_IF_NET_DEVICE_FLAGS != 0 */
+
+/* for compatibility with glibc net/if.h */
+#if __UAPI_DEF_IF_NET_DEVICE_FLAGS
+#define IFF_UP				IFF_UP
+#define IFF_BROADCAST			IFF_BROADCAST
+#define IFF_DEBUG			IFF_DEBUG
+#define IFF_LOOPBACK			IFF_LOOPBACK
+#define IFF_POINTOPOINT			IFF_POINTOPOINT
+#define IFF_NOTRAILERS			IFF_NOTRAILERS
+#define IFF_RUNNING			IFF_RUNNING
+#define IFF_NOARP			IFF_NOARP
+#define IFF_PROMISC			IFF_PROMISC
+#define IFF_ALLMULTI			IFF_ALLMULTI
+#define IFF_MASTER			IFF_MASTER
+#define IFF_SLAVE			IFF_SLAVE
+#define IFF_MULTICAST			IFF_MULTICAST
+#define IFF_PORTSEL			IFF_PORTSEL
+#define IFF_AUTOMEDIA			IFF_AUTOMEDIA
+#define IFF_DYNAMIC			IFF_DYNAMIC
+#endif /* __UAPI_DEF_IF_NET_DEVICE_FLAGS */
+
+#if __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO
+#define IFF_LOWER_UP			IFF_LOWER_UP
+#define IFF_DORMANT			IFF_DORMANT
+#define IFF_ECHO			IFF_ECHO
+#endif /* __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO */
+
+#define IFF_VOLATILE	(IFF_LOOPBACK|IFF_POINTOPOINT|IFF_BROADCAST|IFF_ECHO|\
+		IFF_MASTER|IFF_SLAVE|IFF_RUNNING|IFF_LOWER_UP|IFF_DORMANT)
+
+#define IF_GET_IFACE	0x0001		/* for querying only */
+#define IF_GET_PROTO	0x0002
+
+/* For definitions see hdlc.h */
+#define IF_IFACE_V35	0x1000		/* V.35 serial interface	*/
+#define IF_IFACE_V24	0x1001		/* V.24 serial interface	*/
+#define IF_IFACE_X21	0x1002		/* X.21 serial interface	*/
+#define IF_IFACE_T1	0x1003		/* T1 telco serial interface	*/
+#define IF_IFACE_E1	0x1004		/* E1 telco serial interface	*/
+#define IF_IFACE_SYNC_SERIAL 0x1005	/* can't be set by software	*/
+#define IF_IFACE_X21D   0x1006          /* X.21 Dual Clocking (FarSite) */
+
+/* For definitions see hdlc.h */
+#define IF_PROTO_HDLC	0x2000		/* raw HDLC protocol		*/
+#define IF_PROTO_PPP	0x2001		/* PPP protocol			*/
+#define IF_PROTO_CISCO	0x2002		/* Cisco HDLC protocol		*/
+#define IF_PROTO_FR	0x2003		/* Frame Relay protocol		*/
+#define IF_PROTO_FR_ADD_PVC 0x2004	/*    Create FR PVC		*/
+#define IF_PROTO_FR_DEL_PVC 0x2005	/*    Delete FR PVC		*/
+#define IF_PROTO_X25	0x2006		/* X.25				*/
+#define IF_PROTO_HDLC_ETH 0x2007	/* raw HDLC, Ethernet emulation	*/
+#define IF_PROTO_FR_ADD_ETH_PVC 0x2008	/*  Create FR Ethernet-bridged PVC */
+#define IF_PROTO_FR_DEL_ETH_PVC 0x2009	/*  Delete FR Ethernet-bridged PVC */
+#define IF_PROTO_FR_PVC	0x200A		/* for reading PVC status	*/
+#define IF_PROTO_FR_ETH_PVC 0x200B
+#define IF_PROTO_RAW    0x200C          /* RAW Socket                   */
+
+/* RFC 2863 operational status */
+enum {
+	IF_OPER_UNKNOWN,
+	IF_OPER_NOTPRESENT,
+	IF_OPER_DOWN,
+	IF_OPER_LOWERLAYERDOWN,
+	IF_OPER_TESTING,
+	IF_OPER_DORMANT,
+	IF_OPER_UP,
+};
+
+/* link modes */
+enum {
+	IF_LINK_MODE_DEFAULT,
+	IF_LINK_MODE_DORMANT,	/* limit upward transition to dormant */
+};
+
+/*
+ *	Device mapping structure. I'd just gone off and designed a 
+ *	beautiful scheme using only loadable modules with arguments
+ *	for driver options and along come the PCMCIA people 8)
+ *
+ *	Ah well. The get() side of this is good for WDSETUP, and it'll
+ *	be handy for debugging things. The set side is fine for now and
+ *	being very small might be worth keeping for clean configuration.
+ */
+
+/* for compatibility with glibc net/if.h */
+#if __UAPI_DEF_IF_IFMAP
+struct ifmap {
+	unsigned long mem_start;
+	unsigned long mem_end;
+	unsigned short base_addr; 
+	unsigned char irq;
+	unsigned char dma;
+	unsigned char port;
+	/* 3 bytes spare */
+};
+#endif /* __UAPI_DEF_IF_IFMAP */
+
+struct if_settings {
+	unsigned int type;	/* Type of physical device or protocol */
+	unsigned int size;	/* Size of the data allocated by the caller */
+	union {
+		/* {atm/eth/dsl}_settings anyone ? */
+		raw_hdlc_proto		*raw_hdlc;
+		cisco_proto		*cisco;
+		fr_proto		*fr;
+		fr_proto_pvc		*fr_pvc;
+		fr_proto_pvc_info	*fr_pvc_info;
+
+		/* interface settings */
+		sync_serial_settings	*sync;
+		te1_settings		*te1;
+	} ifs_ifsu;
+};
+
+/*
+ * Interface request structure used for socket
+ * ioctl's.  All interface ioctl's must have parameter
+ * definitions which begin with ifr_name.  The
+ * remainder may be interface specific.
+ */
+
+/* for compatibility with glibc net/if.h */
+#if __UAPI_DEF_IF_IFREQ
+struct ifreq {
+#define IFHWADDRLEN	6
+	union
+	{
+		char	ifrn_name[IFNAMSIZ];		/* if name, e.g. "en0" */
+	} ifr_ifrn;
+	
+	union {
+		struct	sockaddr ifru_addr;
+		struct	sockaddr ifru_dstaddr;
+		struct	sockaddr ifru_broadaddr;
+		struct	sockaddr ifru_netmask;
+		struct  sockaddr ifru_hwaddr;
+		short	ifru_flags;
+		int	ifru_ivalue;
+		int	ifru_mtu;
+		struct  ifmap ifru_map;
+		char	ifru_slave[IFNAMSIZ];	/* Just fits the size */
+		char	ifru_newname[IFNAMSIZ];
+		void *	ifru_data;
+		struct	if_settings ifru_settings;
+	} ifr_ifru;
+};
+#endif /* __UAPI_DEF_IF_IFREQ */
+
+#define ifr_name	ifr_ifrn.ifrn_name	/* interface name 	*/
+#define ifr_hwaddr	ifr_ifru.ifru_hwaddr	/* MAC address 		*/
+#define	ifr_addr	ifr_ifru.ifru_addr	/* address		*/
+#define	ifr_dstaddr	ifr_ifru.ifru_dstaddr	/* other end of p-p lnk	*/
+#define	ifr_broadaddr	ifr_ifru.ifru_broadaddr	/* broadcast address	*/
+#define	ifr_netmask	ifr_ifru.ifru_netmask	/* interface net mask	*/
+#define	ifr_flags	ifr_ifru.ifru_flags	/* flags		*/
+#define	ifr_metric	ifr_ifru.ifru_ivalue	/* metric		*/
+#define	ifr_mtu		ifr_ifru.ifru_mtu	/* mtu			*/
+#define ifr_map		ifr_ifru.ifru_map	/* device map		*/
+#define ifr_slave	ifr_ifru.ifru_slave	/* slave device		*/
+#define	ifr_data	ifr_ifru.ifru_data	/* for use by interface	*/
+#define ifr_ifindex	ifr_ifru.ifru_ivalue	/* interface index	*/
+#define ifr_bandwidth	ifr_ifru.ifru_ivalue    /* link bandwidth	*/
+#define ifr_qlen	ifr_ifru.ifru_ivalue	/* Queue length 	*/
+#define ifr_newname	ifr_ifru.ifru_newname	/* New name		*/
+#define ifr_settings	ifr_ifru.ifru_settings	/* Device/proto settings*/
+
+/*
+ * Structure used in SIOCGIFCONF request.
+ * Used to retrieve interface configuration
+ * for machine (useful for programs which
+ * must know all networks accessible).
+ */
+
+/* for compatibility with glibc net/if.h */
+#if __UAPI_DEF_IF_IFCONF
+struct ifconf  {
+	int	ifc_len;			/* size of buffer	*/
+	union {
+		char *ifcu_buf;
+		struct ifreq *ifcu_req;
+	} ifc_ifcu;
+};
+#endif /* __UAPI_DEF_IF_IFCONF */
+
+#define	ifc_buf	ifc_ifcu.ifcu_buf		/* buffer address	*/
+#define	ifc_req	ifc_ifcu.ifcu_req		/* array of structures	*/
+
+#endif /* _LINUX_IF_H */
diff --git a/include/uapi/linux/if_addr.h b/include/uapi/linux/if_addr.h
new file mode 100644
index 0000000..26f0ecf
--- /dev/null
+++ b/include/uapi/linux/if_addr.h
@@ -0,0 +1,67 @@
+#ifndef __LINUX_IF_ADDR_H
+#define __LINUX_IF_ADDR_H
+
+#include <linux/types.h>
+#include <linux/netlink.h>
+
+struct ifaddrmsg {
+	__u8		ifa_family;
+	__u8		ifa_prefixlen;	/* The prefix length		*/
+	__u8		ifa_flags;	/* Flags			*/
+	__u8		ifa_scope;	/* Address scope		*/
+	__u32		ifa_index;	/* Link index			*/
+};
+
+/*
+ * Important comment:
+ * IFA_ADDRESS is prefix address, rather than local interface address.
+ * It makes no difference for normally configured broadcast interfaces,
+ * but for point-to-point IFA_ADDRESS is DESTINATION address,
+ * local address is supplied in IFA_LOCAL attribute.
+ *
+ * IFA_FLAGS is a u32 attribute that extends the u8 field ifa_flags.
+ * If present, the value from struct ifaddrmsg will be ignored.
+ */
+enum {
+	IFA_UNSPEC,
+	IFA_ADDRESS,
+	IFA_LOCAL,
+	IFA_LABEL,
+	IFA_BROADCAST,
+	IFA_ANYCAST,
+	IFA_CACHEINFO,
+	IFA_MULTICAST,
+	IFA_FLAGS,
+	__IFA_MAX,
+};
+
+#define IFA_MAX (__IFA_MAX - 1)
+
+/* ifa_flags */
+#define IFA_F_SECONDARY		0x01
+#define IFA_F_TEMPORARY		IFA_F_SECONDARY
+
+#define	IFA_F_NODAD		0x02
+#define IFA_F_OPTIMISTIC	0x04
+#define IFA_F_DADFAILED		0x08
+#define	IFA_F_HOMEADDRESS	0x10
+#define IFA_F_DEPRECATED	0x20
+#define IFA_F_TENTATIVE		0x40
+#define IFA_F_PERMANENT		0x80
+#define IFA_F_MANAGETEMPADDR	0x100
+#define IFA_F_NOPREFIXROUTE	0x200
+#define IFA_F_MCAUTOJOIN	0x400
+#define IFA_F_STABLE_PRIVACY	0x800
+
+struct ifa_cacheinfo {
+	__u32	ifa_prefered;
+	__u32	ifa_valid;
+	__u32	cstamp; /* created timestamp, hundredths of seconds */
+	__u32	tstamp; /* updated timestamp, hundredths of seconds */
+};
+
+/* backwards compatibility for userspace */
+#define IFA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct ifaddrmsg))))
+#define IFA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct ifaddrmsg))
+
+#endif
diff --git a/include/uapi/linux/if_addrlabel.h b/include/uapi/linux/if_addrlabel.h
new file mode 100644
index 0000000..54580c2
--- /dev/null
+++ b/include/uapi/linux/if_addrlabel.h
@@ -0,0 +1,32 @@
+/*
+ * if_addrlabel.h - netlink interface for address labels
+ *
+ * Copyright (C)2007 USAGI/WIDE Project,  All Rights Reserved.
+ *
+ * Authors:
+ *	YOSHIFUJI Hideaki @ USAGI/WIDE <yoshfuji@linux-ipv6.org>
+ */
+
+#ifndef __LINUX_IF_ADDRLABEL_H
+#define __LINUX_IF_ADDRLABEL_H
+
+#include <linux/types.h>
+
+struct ifaddrlblmsg {
+	__u8		ifal_family;		/* Address family */
+	__u8		__ifal_reserved;	/* Reserved */
+	__u8		ifal_prefixlen;		/* Prefix length */
+	__u8		ifal_flags;		/* Flags */
+	__u32		ifal_index;		/* Link index */
+	__u32		ifal_seq;		/* sequence number */
+};
+
+enum {
+	IFAL_ADDRESS = 1,
+	IFAL_LABEL = 2,
+	__IFAL_MAX
+};
+
+#define IFAL_MAX	(__IFAL_MAX - 1)
+
+#endif
diff --git a/include/uapi/linux/if_alg.h b/include/uapi/linux/if_alg.h
new file mode 100644
index 0000000..f2acd2f
--- /dev/null
+++ b/include/uapi/linux/if_alg.h
@@ -0,0 +1,42 @@
+/*
+ * if_alg: User-space algorithm interface
+ *
+ * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ */
+
+#ifndef _LINUX_IF_ALG_H
+#define _LINUX_IF_ALG_H
+
+#include <linux/types.h>
+
+struct sockaddr_alg {
+	__u16	salg_family;
+	__u8	salg_type[14];
+	__u32	salg_feat;
+	__u32	salg_mask;
+	__u8	salg_name[64];
+};
+
+struct af_alg_iv {
+	__u32	ivlen;
+	__u8	iv[0];
+};
+
+/* Socket options */
+#define ALG_SET_KEY			1
+#define ALG_SET_IV			2
+#define ALG_SET_OP			3
+#define ALG_SET_AEAD_ASSOCLEN		4
+#define ALG_SET_AEAD_AUTHSIZE		5
+
+/* Operations */
+#define ALG_OP_DECRYPT			0
+#define ALG_OP_ENCRYPT			1
+
+#endif	/* _LINUX_IF_ALG_H */
diff --git a/include/uapi/linux/if_arp.h b/include/uapi/linux/if_arp.h
new file mode 100644
index 0000000..199f253
--- /dev/null
+++ b/include/uapi/linux/if_arp.h
@@ -0,0 +1,163 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Global definitions for the ARP (RFC 826) protocol.
+ *
+ * Version:	@(#)if_arp.h	1.0.1	04/16/93
+ *
+ * Authors:	Original taken from Berkeley UNIX 4.3, (c) UCB 1986-1988
+ *		Portions taken from the KA9Q/NOS (v2.00m PA0GRI) source.
+ *		Ross Biro
+ *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *		Florian La Roche,
+ *		Jonathan Layes <layes@loran.com>
+ *		Arnaldo Carvalho de Melo <acme@conectiva.com.br> ARPHRD_HWX25
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_IF_ARP_H
+#define _LINUX_IF_ARP_H
+
+#include <linux/netdevice.h>
+
+/* ARP protocol HARDWARE identifiers. */
+#define ARPHRD_NETROM	0		/* from KA9Q: NET/ROM pseudo	*/
+#define ARPHRD_ETHER 	1		/* Ethernet 10Mbps		*/
+#define	ARPHRD_EETHER	2		/* Experimental Ethernet	*/
+#define	ARPHRD_AX25	3		/* AX.25 Level 2		*/
+#define	ARPHRD_PRONET	4		/* PROnet token ring		*/
+#define	ARPHRD_CHAOS	5		/* Chaosnet			*/
+#define	ARPHRD_IEEE802	6		/* IEEE 802.2 Ethernet/TR/TB	*/
+#define	ARPHRD_ARCNET	7		/* ARCnet			*/
+#define	ARPHRD_APPLETLK	8		/* APPLEtalk			*/
+#define ARPHRD_DLCI	15		/* Frame Relay DLCI		*/
+#define ARPHRD_ATM	19		/* ATM 				*/
+#define ARPHRD_METRICOM	23		/* Metricom STRIP (new IANA id)	*/
+#define	ARPHRD_IEEE1394	24		/* IEEE 1394 IPv4 - RFC 2734	*/
+#define ARPHRD_EUI64	27		/* EUI-64                       */
+#define ARPHRD_INFINIBAND 32		/* InfiniBand			*/
+
+/* Dummy types for non ARP hardware */
+#define ARPHRD_SLIP	256
+#define ARPHRD_CSLIP	257
+#define ARPHRD_SLIP6	258
+#define ARPHRD_CSLIP6	259
+#define ARPHRD_RSRVD	260		/* Notional KISS type 		*/
+#define ARPHRD_ADAPT	264
+#define ARPHRD_ROSE	270
+#define ARPHRD_X25	271		/* CCITT X.25			*/
+#define ARPHRD_HWX25	272		/* Boards with X.25 in firmware	*/
+#define ARPHRD_CAN	280		/* Controller Area Network      */
+#define ARPHRD_PPP	512
+#define ARPHRD_CISCO	513		/* Cisco HDLC	 		*/
+#define ARPHRD_HDLC	ARPHRD_CISCO
+#define ARPHRD_LAPB	516		/* LAPB				*/
+#define ARPHRD_DDCMP    517		/* Digital's DDCMP protocol     */
+#define ARPHRD_RAWHDLC	518		/* Raw HDLC			*/
+#define ARPHRD_RAWIP    519		/* Raw IP                       */
+
+#define ARPHRD_TUNNEL	768		/* IPIP tunnel			*/
+#define ARPHRD_TUNNEL6	769		/* IP6IP6 tunnel       		*/
+#define ARPHRD_FRAD	770             /* Frame Relay Access Device    */
+#define ARPHRD_SKIP	771		/* SKIP vif			*/
+#define ARPHRD_LOOPBACK	772		/* Loopback device		*/
+#define ARPHRD_LOCALTLK 773		/* Localtalk device		*/
+#define ARPHRD_FDDI	774		/* Fiber Distributed Data Interface */
+#define ARPHRD_BIF      775             /* AP1000 BIF                   */
+#define ARPHRD_SIT	776		/* sit0 device - IPv6-in-IPv4	*/
+#define ARPHRD_IPDDP	777		/* IP over DDP tunneller	*/
+#define ARPHRD_IPGRE	778		/* GRE over IP			*/
+#define ARPHRD_PIMREG	779		/* PIMSM register interface	*/
+#define ARPHRD_HIPPI	780		/* High Performance Parallel Interface */
+#define ARPHRD_ASH	781		/* Nexus 64Mbps Ash		*/
+#define ARPHRD_ECONET	782		/* Acorn Econet			*/
+#define ARPHRD_IRDA 	783		/* Linux-IrDA			*/
+/* ARP works differently on different FC media .. so  */
+#define ARPHRD_FCPP	784		/* Point to point fibrechannel	*/
+#define ARPHRD_FCAL	785		/* Fibrechannel arbitrated loop */
+#define ARPHRD_FCPL	786		/* Fibrechannel public loop	*/
+#define ARPHRD_FCFABRIC	787		/* Fibrechannel fabric		*/
+	/* 787->799 reserved for fibrechannel media types */
+#define ARPHRD_IEEE802_TR 800		/* Magic type ident for TR	*/
+#define ARPHRD_IEEE80211 801		/* IEEE 802.11			*/
+#define ARPHRD_IEEE80211_PRISM 802	/* IEEE 802.11 + Prism2 header  */
+#define ARPHRD_IEEE80211_RADIOTAP 803	/* IEEE 802.11 + radiotap header */
+#define ARPHRD_IEEE802154	  804
+#define ARPHRD_IEEE802154_MONITOR 805	/* IEEE 802.15.4 network monitor */
+
+#define ARPHRD_PHONET	820		/* PhoNet media type		*/
+#define ARPHRD_PHONET_PIPE 821		/* PhoNet pipe header		*/
+#define ARPHRD_CAIF	822		/* CAIF media type		*/
+#define ARPHRD_IP6GRE	823		/* GRE over IPv6		*/
+#define ARPHRD_NETLINK	824		/* Netlink header		*/
+#define ARPHRD_6LOWPAN	825		/* IPv6 over LoWPAN             */
+#define ARPHRD_VSOCKMON	826		/* Vsock monitor header		*/
+
+#define ARPHRD_VOID	  0xFFFF	/* Void type, nothing is known */
+#define ARPHRD_NONE	  0xFFFE	/* zero header length */
+
+/* ARP protocol opcodes. */
+#define	ARPOP_REQUEST	1		/* ARP request			*/
+#define	ARPOP_REPLY	2		/* ARP reply			*/
+#define	ARPOP_RREQUEST	3		/* RARP request			*/
+#define	ARPOP_RREPLY	4		/* RARP reply			*/
+#define	ARPOP_InREQUEST	8		/* InARP request		*/
+#define	ARPOP_InREPLY	9		/* InARP reply			*/
+#define	ARPOP_NAK	10		/* (ATM)ARP NAK			*/
+
+
+/* ARP ioctl request. */
+struct arpreq {
+  struct sockaddr	arp_pa;		/* protocol address		*/
+  struct sockaddr	arp_ha;		/* hardware address		*/
+  int			arp_flags;	/* flags			*/
+  struct sockaddr       arp_netmask;    /* netmask (only for proxy arps) */
+  char			arp_dev[16];
+};
+
+struct arpreq_old {
+  struct sockaddr	arp_pa;		/* protocol address		*/
+  struct sockaddr	arp_ha;		/* hardware address		*/
+  int			arp_flags;	/* flags			*/
+  struct sockaddr       arp_netmask;    /* netmask (only for proxy arps) */
+};
+
+/* ARP Flag values. */
+#define ATF_COM		0x02		/* completed entry (ha valid)	*/
+#define	ATF_PERM	0x04		/* permanent entry		*/
+#define	ATF_PUBL	0x08		/* publish entry		*/
+#define	ATF_USETRAILERS	0x10		/* has requested trailers	*/
+#define ATF_NETMASK     0x20            /* want to use a netmask (only
+					   for proxy entries) */
+#define ATF_DONTPUB	0x40		/* don't answer this addresses	*/
+
+/*
+ *	This structure defines an ethernet arp header.
+ */
+
+struct arphdr {
+	__be16		ar_hrd;		/* format of hardware address	*/
+	__be16		ar_pro;		/* format of protocol address	*/
+	unsigned char	ar_hln;		/* length of hardware address	*/
+	unsigned char	ar_pln;		/* length of protocol address	*/
+	__be16		ar_op;		/* ARP opcode (command)		*/
+
+#if 0
+	 /*
+	  *	 Ethernet looks like this : This bit is variable sized however...
+	  */
+	unsigned char		ar_sha[ETH_ALEN];	/* sender hardware address	*/
+	unsigned char		ar_sip[4];		/* sender IP address		*/
+	unsigned char		ar_tha[ETH_ALEN];	/* target hardware address	*/
+	unsigned char		ar_tip[4];		/* target IP address		*/
+#endif
+
+};
+
+
+#endif /* _LINUX_IF_ARP_H */
diff --git a/include/uapi/linux/if_bonding.h b/include/uapi/linux/if_bonding.h
new file mode 100644
index 0000000..9635a62
--- /dev/null
+++ b/include/uapi/linux/if_bonding.h
@@ -0,0 +1,130 @@
+/*
+ * Bond several ethernet interfaces into a Cisco, running 'Etherchannel'.
+ *
+ *
+ * Portions are (c) Copyright 1995 Simon "Guru Aleph-Null" Janes
+ * NCM: Network and Communications Management, Inc.
+ *
+ * BUT, I'm the one who modified it for ethernet, so:
+ * (c) Copyright 1999, Thomas Davis, tadavis@lbl.gov
+ *
+ *	This software may be used and distributed according to the terms
+ *	of the GNU Public License, incorporated herein by reference.
+ *
+ * 2003/03/18 - Amir Noam <amir.noam at intel dot com>
+ *	- Added support for getting slave's speed and duplex via ethtool.
+ *	  Needed for 802.3ad and other future modes.
+ *
+ * 2003/03/18 - Tsippy Mendelson <tsippy.mendelson at intel dot com> and
+ *		Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Enable support of modes that need to use the unique mac address of
+ *	  each slave.
+ *
+ * 2003/03/18 - Tsippy Mendelson <tsippy.mendelson at intel dot com> and
+ *		Amir Noam <amir.noam at intel dot com>
+ *	- Moved driver's private data types to bonding.h
+ *
+ * 2003/03/18 - Amir Noam <amir.noam at intel dot com>,
+ *		Tsippy Mendelson <tsippy.mendelson at intel dot com> and
+ *		Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Added support for IEEE 802.3ad Dynamic link aggregation mode.
+ *
+ * 2003/05/01 - Amir Noam <amir.noam at intel dot com>
+ *	- Added ABI version control to restore compatibility between
+ *	  new/old ifenslave and new/old bonding.
+ *
+ * 2003/12/01 - Shmulik Hen <shmulik.hen at intel dot com>
+ *	- Code cleanup and style changes
+ *
+ * 2005/05/05 - Jason Gabler <jygabler at lbl dot gov>
+ *      - added definitions for various XOR hashing policies
+ */
+
+#ifndef _LINUX_IF_BONDING_H
+#define _LINUX_IF_BONDING_H
+
+#include <linux/if.h>
+#include <linux/types.h>
+#include <linux/if_ether.h>
+
+/* userland - kernel ABI version (2003/05/08) */
+#define BOND_ABI_VERSION 2
+
+/*
+ * We can remove these ioctl definitions in 2.5.  People should use the
+ * SIOC*** versions of them instead
+ */
+#define BOND_ENSLAVE_OLD		(SIOCDEVPRIVATE)
+#define BOND_RELEASE_OLD		(SIOCDEVPRIVATE + 1)
+#define BOND_SETHWADDR_OLD		(SIOCDEVPRIVATE + 2)
+#define BOND_SLAVE_INFO_QUERY_OLD	(SIOCDEVPRIVATE + 11)
+#define BOND_INFO_QUERY_OLD		(SIOCDEVPRIVATE + 12)
+#define BOND_CHANGE_ACTIVE_OLD		(SIOCDEVPRIVATE + 13)
+
+#define BOND_CHECK_MII_STATUS	(SIOCGMIIPHY)
+
+#define BOND_MODE_ROUNDROBIN	0
+#define BOND_MODE_ACTIVEBACKUP	1
+#define BOND_MODE_XOR		2
+#define BOND_MODE_BROADCAST	3
+#define BOND_MODE_8023AD        4
+#define BOND_MODE_TLB           5
+#define BOND_MODE_ALB		6 /* TLB + RLB (receive load balancing) */
+
+/* each slave's link has 4 states */
+#define BOND_LINK_UP    0           /* link is up and running */
+#define BOND_LINK_FAIL  1           /* link has just gone down */
+#define BOND_LINK_DOWN  2           /* link has been down for too long time */
+#define BOND_LINK_BACK  3           /* link is going back */
+
+/* each slave has several states */
+#define BOND_STATE_ACTIVE       0   /* link is active */
+#define BOND_STATE_BACKUP       1   /* link is backup */
+
+#define BOND_DEFAULT_MAX_BONDS  1   /* Default maximum number of devices to support */
+
+#define BOND_DEFAULT_TX_QUEUES 16   /* Default number of tx queues per device */
+
+#define BOND_DEFAULT_RESEND_IGMP	1 /* Default number of IGMP membership reports */
+
+/* hashing types */
+#define BOND_XMIT_POLICY_LAYER2		0 /* layer 2 (MAC only), default */
+#define BOND_XMIT_POLICY_LAYER34	1 /* layer 3+4 (IP ^ (TCP || UDP)) */
+#define BOND_XMIT_POLICY_LAYER23	2 /* layer 2+3 (IP ^ MAC) */
+#define BOND_XMIT_POLICY_ENCAP23	3 /* encapsulated layer 2+3 */
+#define BOND_XMIT_POLICY_ENCAP34	4 /* encapsulated layer 3+4 */
+
+typedef struct ifbond {
+	__s32 bond_mode;
+	__s32 num_slaves;
+	__s32 miimon;
+} ifbond;
+
+typedef struct ifslave {
+	__s32 slave_id; /* Used as an IN param to the BOND_SLAVE_INFO_QUERY ioctl */
+	char slave_name[IFNAMSIZ];
+	__s8 link;
+	__s8 state;
+	__u32  link_failure_count;
+} ifslave;
+
+struct ad_info {
+	__u16 aggregator_id;
+	__u16 ports;
+	__u16 actor_key;
+	__u16 partner_key;
+	__u8 partner_system[ETH_ALEN];
+};
+
+#endif /* _LINUX_IF_BONDING_H */
+
+/*
+ * Local variables:
+ *  version-control: t
+ *  kept-new-versions: 5
+ *  c-indent-level: 8
+ *  c-basic-offset: 8
+ *  tab-width: 8
+ * End:
+ */
+
diff --git a/include/uapi/linux/if_bridge.h b/include/uapi/linux/if_bridge.h
new file mode 100644
index 0000000..156f443
--- /dev/null
+++ b/include/uapi/linux/if_bridge.h
@@ -0,0 +1,294 @@
+/*
+ *	Linux ethernet bridge
+ *
+ *	Authors:
+ *	Lennert Buytenhek		<buytenh@gnu.org>
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _LINUX_IF_BRIDGE_H
+#define _LINUX_IF_BRIDGE_H
+
+#include <linux/types.h>
+#include <linux/if_ether.h>
+#include <linux/in6.h>
+
+#define SYSFS_BRIDGE_ATTR	"bridge"
+#define SYSFS_BRIDGE_FDB	"brforward"
+#define SYSFS_BRIDGE_PORT_SUBDIR "brif"
+#define SYSFS_BRIDGE_PORT_ATTR	"brport"
+#define SYSFS_BRIDGE_PORT_LINK	"bridge"
+
+#define BRCTL_VERSION 1
+
+#define BRCTL_GET_VERSION 0
+#define BRCTL_GET_BRIDGES 1
+#define BRCTL_ADD_BRIDGE 2
+#define BRCTL_DEL_BRIDGE 3
+#define BRCTL_ADD_IF 4
+#define BRCTL_DEL_IF 5
+#define BRCTL_GET_BRIDGE_INFO 6
+#define BRCTL_GET_PORT_LIST 7
+#define BRCTL_SET_BRIDGE_FORWARD_DELAY 8
+#define BRCTL_SET_BRIDGE_HELLO_TIME 9
+#define BRCTL_SET_BRIDGE_MAX_AGE 10
+#define BRCTL_SET_AGEING_TIME 11
+#define BRCTL_SET_GC_INTERVAL 12
+#define BRCTL_GET_PORT_INFO 13
+#define BRCTL_SET_BRIDGE_STP_STATE 14
+#define BRCTL_SET_BRIDGE_PRIORITY 15
+#define BRCTL_SET_PORT_PRIORITY 16
+#define BRCTL_SET_PATH_COST 17
+#define BRCTL_GET_FDB_ENTRIES 18
+
+#define BR_STATE_DISABLED 0
+#define BR_STATE_LISTENING 1
+#define BR_STATE_LEARNING 2
+#define BR_STATE_FORWARDING 3
+#define BR_STATE_BLOCKING 4
+
+struct __bridge_info {
+	__u64 designated_root;
+	__u64 bridge_id;
+	__u32 root_path_cost;
+	__u32 max_age;
+	__u32 hello_time;
+	__u32 forward_delay;
+	__u32 bridge_max_age;
+	__u32 bridge_hello_time;
+	__u32 bridge_forward_delay;
+	__u8 topology_change;
+	__u8 topology_change_detected;
+	__u8 root_port;
+	__u8 stp_enabled;
+	__u32 ageing_time;
+	__u32 gc_interval;
+	__u32 hello_timer_value;
+	__u32 tcn_timer_value;
+	__u32 topology_change_timer_value;
+	__u32 gc_timer_value;
+};
+
+struct __port_info {
+	__u64 designated_root;
+	__u64 designated_bridge;
+	__u16 port_id;
+	__u16 designated_port;
+	__u32 path_cost;
+	__u32 designated_cost;
+	__u8 state;
+	__u8 top_change_ack;
+	__u8 config_pending;
+	__u8 unused0;
+	__u32 message_age_timer_value;
+	__u32 forward_delay_timer_value;
+	__u32 hold_timer_value;
+};
+
+struct __fdb_entry {
+	__u8 mac_addr[ETH_ALEN];
+	__u8 port_no;
+	__u8 is_local;
+	__u32 ageing_timer_value;
+	__u8 port_hi;
+	__u8 pad0;
+	__u16 unused;
+};
+
+/* Bridge Flags */
+#define BRIDGE_FLAGS_MASTER	1	/* Bridge command to/from master */
+#define BRIDGE_FLAGS_SELF	2	/* Bridge command to/from lowerdev */
+
+#define BRIDGE_MODE_VEB		0	/* Default loopback mode */
+#define BRIDGE_MODE_VEPA	1	/* 802.1Qbg defined VEPA mode */
+#define BRIDGE_MODE_UNDEF	0xFFFF  /* mode undefined */
+
+/* Bridge management nested attributes
+ * [IFLA_AF_SPEC] = {
+ *     [IFLA_BRIDGE_FLAGS]
+ *     [IFLA_BRIDGE_MODE]
+ *     [IFLA_BRIDGE_VLAN_INFO]
+ * }
+ */
+enum {
+	IFLA_BRIDGE_FLAGS,
+	IFLA_BRIDGE_MODE,
+	IFLA_BRIDGE_VLAN_INFO,
+	IFLA_BRIDGE_VLAN_TUNNEL_INFO,
+	__IFLA_BRIDGE_MAX,
+};
+#define IFLA_BRIDGE_MAX (__IFLA_BRIDGE_MAX - 1)
+
+#define BRIDGE_VLAN_INFO_MASTER	(1<<0)	/* Operate on Bridge device as well */
+#define BRIDGE_VLAN_INFO_PVID	(1<<1)	/* VLAN is PVID, ingress untagged */
+#define BRIDGE_VLAN_INFO_UNTAGGED	(1<<2)	/* VLAN egresses untagged */
+#define BRIDGE_VLAN_INFO_RANGE_BEGIN	(1<<3) /* VLAN is start of vlan range */
+#define BRIDGE_VLAN_INFO_RANGE_END	(1<<4) /* VLAN is end of vlan range */
+#define BRIDGE_VLAN_INFO_BRENTRY	(1<<5) /* Global bridge VLAN entry */
+
+struct bridge_vlan_info {
+	__u16 flags;
+	__u16 vid;
+};
+
+enum {
+	IFLA_BRIDGE_VLAN_TUNNEL_UNSPEC,
+	IFLA_BRIDGE_VLAN_TUNNEL_ID,
+	IFLA_BRIDGE_VLAN_TUNNEL_VID,
+	IFLA_BRIDGE_VLAN_TUNNEL_FLAGS,
+	__IFLA_BRIDGE_VLAN_TUNNEL_MAX,
+};
+
+#define IFLA_BRIDGE_VLAN_TUNNEL_MAX (__IFLA_BRIDGE_VLAN_TUNNEL_MAX - 1)
+
+struct bridge_vlan_xstats {
+	__u64 rx_bytes;
+	__u64 rx_packets;
+	__u64 tx_bytes;
+	__u64 tx_packets;
+	__u16 vid;
+	__u16 flags;
+	__u32 pad2;
+};
+
+/* Bridge multicast database attributes
+ * [MDBA_MDB] = {
+ *     [MDBA_MDB_ENTRY] = {
+ *         [MDBA_MDB_ENTRY_INFO] {
+ *		struct br_mdb_entry
+ *		[MDBA_MDB_EATTR attributes]
+ *         }
+ *     }
+ * }
+ * [MDBA_ROUTER] = {
+ *    [MDBA_ROUTER_PORT] = {
+ *        u32 ifindex
+ *        [MDBA_ROUTER_PATTR attributes]
+ *    }
+ * }
+ */
+enum {
+	MDBA_UNSPEC,
+	MDBA_MDB,
+	MDBA_ROUTER,
+	__MDBA_MAX,
+};
+#define MDBA_MAX (__MDBA_MAX - 1)
+
+enum {
+	MDBA_MDB_UNSPEC,
+	MDBA_MDB_ENTRY,
+	__MDBA_MDB_MAX,
+};
+#define MDBA_MDB_MAX (__MDBA_MDB_MAX - 1)
+
+enum {
+	MDBA_MDB_ENTRY_UNSPEC,
+	MDBA_MDB_ENTRY_INFO,
+	__MDBA_MDB_ENTRY_MAX,
+};
+#define MDBA_MDB_ENTRY_MAX (__MDBA_MDB_ENTRY_MAX - 1)
+
+/* per mdb entry additional attributes */
+enum {
+	MDBA_MDB_EATTR_UNSPEC,
+	MDBA_MDB_EATTR_TIMER,
+	__MDBA_MDB_EATTR_MAX
+};
+#define MDBA_MDB_EATTR_MAX (__MDBA_MDB_EATTR_MAX - 1)
+
+/* multicast router types */
+enum {
+	MDB_RTR_TYPE_DISABLED,
+	MDB_RTR_TYPE_TEMP_QUERY,
+	MDB_RTR_TYPE_PERM,
+	MDB_RTR_TYPE_TEMP
+};
+
+enum {
+	MDBA_ROUTER_UNSPEC,
+	MDBA_ROUTER_PORT,
+	__MDBA_ROUTER_MAX,
+};
+#define MDBA_ROUTER_MAX (__MDBA_ROUTER_MAX - 1)
+
+/* router port attributes */
+enum {
+	MDBA_ROUTER_PATTR_UNSPEC,
+	MDBA_ROUTER_PATTR_TIMER,
+	MDBA_ROUTER_PATTR_TYPE,
+	__MDBA_ROUTER_PATTR_MAX
+};
+#define MDBA_ROUTER_PATTR_MAX (__MDBA_ROUTER_PATTR_MAX - 1)
+
+struct br_port_msg {
+	__u8  family;
+	__u32 ifindex;
+};
+
+struct br_mdb_entry {
+	__u32 ifindex;
+#define MDB_TEMPORARY 0
+#define MDB_PERMANENT 1
+	__u8 state;
+#define MDB_FLAGS_OFFLOAD	(1 << 0)
+	__u8 flags;
+	__u16 vid;
+	struct {
+		union {
+			__be32	ip4;
+			struct in6_addr ip6;
+		} u;
+		__be16		proto;
+	} addr;
+};
+
+enum {
+	MDBA_SET_ENTRY_UNSPEC,
+	MDBA_SET_ENTRY,
+	__MDBA_SET_ENTRY_MAX,
+};
+#define MDBA_SET_ENTRY_MAX (__MDBA_SET_ENTRY_MAX - 1)
+
+/* Embedded inside LINK_XSTATS_TYPE_BRIDGE */
+enum {
+	BRIDGE_XSTATS_UNSPEC,
+	BRIDGE_XSTATS_VLAN,
+	BRIDGE_XSTATS_MCAST,
+	BRIDGE_XSTATS_PAD,
+	__BRIDGE_XSTATS_MAX
+};
+#define BRIDGE_XSTATS_MAX (__BRIDGE_XSTATS_MAX - 1)
+
+enum {
+	BR_MCAST_DIR_RX,
+	BR_MCAST_DIR_TX,
+	BR_MCAST_DIR_SIZE
+};
+
+/* IGMP/MLD statistics */
+struct br_mcast_stats {
+	__u64 igmp_v1queries[BR_MCAST_DIR_SIZE];
+	__u64 igmp_v2queries[BR_MCAST_DIR_SIZE];
+	__u64 igmp_v3queries[BR_MCAST_DIR_SIZE];
+	__u64 igmp_leaves[BR_MCAST_DIR_SIZE];
+	__u64 igmp_v1reports[BR_MCAST_DIR_SIZE];
+	__u64 igmp_v2reports[BR_MCAST_DIR_SIZE];
+	__u64 igmp_v3reports[BR_MCAST_DIR_SIZE];
+	__u64 igmp_parse_errors;
+
+	__u64 mld_v1queries[BR_MCAST_DIR_SIZE];
+	__u64 mld_v2queries[BR_MCAST_DIR_SIZE];
+	__u64 mld_leaves[BR_MCAST_DIR_SIZE];
+	__u64 mld_v1reports[BR_MCAST_DIR_SIZE];
+	__u64 mld_v2reports[BR_MCAST_DIR_SIZE];
+	__u64 mld_parse_errors;
+
+	__u64 mcast_bytes[BR_MCAST_DIR_SIZE];
+	__u64 mcast_packets[BR_MCAST_DIR_SIZE];
+};
+#endif /* _LINUX_IF_BRIDGE_H */
diff --git a/include/uapi/linux/if_ether.h b/include/uapi/linux/if_ether.h
new file mode 100644
index 0000000..7dde037
--- /dev/null
+++ b/include/uapi/linux/if_ether.h
@@ -0,0 +1,158 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Global definitions for the Ethernet IEEE 802.3 interface.
+ *
+ * Version:	@(#)if_ether.h	1.0.1a	02/08/94
+ *
+ * Author:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *		Donald Becker, <becker@super.org>
+ *		Alan Cox, <alan@lxorguk.ukuu.org.uk>
+ *		Steve Whitehouse, <gw7rrm@eeshack3.swan.ac.uk>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _LINUX_IF_ETHER_H
+#define _LINUX_IF_ETHER_H
+
+#include <linux/types.h>
+
+/*
+ *	IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
+ *	and FCS/CRC (frame check sequence).
+ */
+
+#define ETH_ALEN	6		/* Octets in one ethernet addr	 */
+#define ETH_HLEN	14		/* Total octets in header.	 */
+#define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
+#define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
+#define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */
+#define ETH_FCS_LEN	4		/* Octets in the FCS		 */
+
+#define ETH_MIN_MTU	68		/* Min IPv4 MTU per RFC791	*/
+#define ETH_MAX_MTU	0xFFFFU		/* 65535, same as IP_MAX_MTU	*/
+
+/*
+ *	These are the defined Ethernet Protocol ID's.
+ */
+
+#define ETH_P_LOOP	0x0060		/* Ethernet Loopback packet	*/
+#define ETH_P_PUP	0x0200		/* Xerox PUP packet		*/
+#define ETH_P_PUPAT	0x0201		/* Xerox PUP Addr Trans packet	*/
+#define ETH_P_TSN	0x22F0		/* TSN (IEEE 1722) packet	*/
+#define ETH_P_IP	0x0800		/* Internet Protocol packet	*/
+#define ETH_P_X25	0x0805		/* CCITT X.25			*/
+#define ETH_P_ARP	0x0806		/* Address Resolution packet	*/
+#define	ETH_P_BPQ	0x08FF		/* G8BPQ AX.25 Ethernet Packet	[ NOT AN OFFICIALLY REGISTERED ID ] */
+#define ETH_P_IEEEPUP	0x0a00		/* Xerox IEEE802.3 PUP packet */
+#define ETH_P_IEEEPUPAT	0x0a01		/* Xerox IEEE802.3 PUP Addr Trans packet */
+#define ETH_P_BATMAN	0x4305		/* B.A.T.M.A.N.-Advanced packet [ NOT AN OFFICIALLY REGISTERED ID ] */
+#define ETH_P_DEC       0x6000          /* DEC Assigned proto           */
+#define ETH_P_DNA_DL    0x6001          /* DEC DNA Dump/Load            */
+#define ETH_P_DNA_RC    0x6002          /* DEC DNA Remote Console       */
+#define ETH_P_DNA_RT    0x6003          /* DEC DNA Routing              */
+#define ETH_P_LAT       0x6004          /* DEC LAT                      */
+#define ETH_P_DIAG      0x6005          /* DEC Diagnostics              */
+#define ETH_P_CUST      0x6006          /* DEC Customer use             */
+#define ETH_P_SCA       0x6007          /* DEC Systems Comms Arch       */
+#define ETH_P_TEB	0x6558		/* Trans Ether Bridging		*/
+#define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
+#define ETH_P_ATALK	0x809B		/* Appletalk DDP		*/
+#define ETH_P_AARP	0x80F3		/* Appletalk AARP		*/
+#define ETH_P_8021Q	0x8100          /* 802.1Q VLAN Extended Header  */
+#define ETH_P_ERSPAN	0x88BE		/* ERSPAN type II		*/
+#define ETH_P_IPX	0x8137		/* IPX over DIX			*/
+#define ETH_P_IPV6	0x86DD		/* IPv6 over bluebook		*/
+#define ETH_P_PAUSE	0x8808		/* IEEE Pause frames. See 802.3 31B */
+#define ETH_P_SLOW	0x8809		/* Slow Protocol. See 802.3ad 43B */
+#define ETH_P_WCCP	0x883E		/* Web-cache coordination protocol
+					 * defined in draft-wilson-wrec-wccp-v2-00.txt */
+#define ETH_P_MPLS_UC	0x8847		/* MPLS Unicast traffic		*/
+#define ETH_P_MPLS_MC	0x8848		/* MPLS Multicast traffic	*/
+#define ETH_P_ATMMPOA	0x884c		/* MultiProtocol Over ATM	*/
+#define ETH_P_PPP_DISC	0x8863		/* PPPoE discovery messages     */
+#define ETH_P_PPP_SES	0x8864		/* PPPoE session messages	*/
+#define ETH_P_LINK_CTL	0x886c		/* HPNA, wlan link local tunnel */
+#define ETH_P_ATMFATE	0x8884		/* Frame-based ATM Transport
+					 * over Ethernet
+					 */
+#define ETH_P_PAE	0x888E		/* Port Access Entity (IEEE 802.1X) */
+#define ETH_P_AOE	0x88A2		/* ATA over Ethernet		*/
+#define ETH_P_8021AD	0x88A8          /* 802.1ad Service VLAN		*/
+#define ETH_P_802_EX1	0x88B5		/* 802.1 Local Experimental 1.  */
+#define ETH_P_TIPC	0x88CA		/* TIPC 			*/
+#define ETH_P_MACSEC	0x88E5		/* 802.1ae MACsec */
+#define ETH_P_8021AH	0x88E7          /* 802.1ah Backbone Service Tag */
+#define ETH_P_MVRP	0x88F5          /* 802.1Q MVRP                  */
+#define ETH_P_1588	0x88F7		/* IEEE 1588 Timesync */
+#define ETH_P_NCSI	0x88F8		/* NCSI protocol		*/
+#define ETH_P_PRP	0x88FB		/* IEC 62439-3 PRP/HSRv0	*/
+#define ETH_P_FCOE	0x8906		/* Fibre Channel over Ethernet  */
+#define ETH_P_IBOE	0x8915		/* Infiniband over Ethernet	*/
+#define ETH_P_TDLS	0x890D          /* TDLS */
+#define ETH_P_FIP	0x8914		/* FCoE Initialization Protocol */
+#define ETH_P_80221	0x8917		/* IEEE 802.21 Media Independent Handover Protocol */
+#define ETH_P_HSR	0x892F		/* IEC 62439-3 HSRv1	*/
+#define ETH_P_NSH	0x894F		/* Network Service Header */
+#define ETH_P_LOOPBACK	0x9000		/* Ethernet loopback packet, per IEEE 802.3 */
+#define ETH_P_QINQ1	0x9100		/* deprecated QinQ VLAN [ NOT AN OFFICIALLY REGISTERED ID ] */
+#define ETH_P_QINQ2	0x9200		/* deprecated QinQ VLAN [ NOT AN OFFICIALLY REGISTERED ID ] */
+#define ETH_P_QINQ3	0x9300		/* deprecated QinQ VLAN [ NOT AN OFFICIALLY REGISTERED ID ] */
+#define ETH_P_EDSA	0xDADA		/* Ethertype DSA [ NOT AN OFFICIALLY REGISTERED ID ] */
+#define ETH_P_IFE	0xED3E		/* ForCES inter-FE LFB type */
+#define ETH_P_AF_IUCV   0xFBFB		/* IBM af_iucv [ NOT AN OFFICIALLY REGISTERED ID ] */
+
+#define ETH_P_802_3_MIN	0x0600		/* If the value in the ethernet type is less than this value
+					 * then the frame is Ethernet II. Else it is 802.3 */
+
+/*
+ *	Non DIX types. Won't clash for 1500 types.
+ */
+
+#define ETH_P_802_3	0x0001		/* Dummy type for 802.3 frames  */
+#define ETH_P_AX25	0x0002		/* Dummy protocol id for AX.25  */
+#define ETH_P_ALL	0x0003		/* Every packet (be careful!!!) */
+#define ETH_P_802_2	0x0004		/* 802.2 frames 		*/
+#define ETH_P_SNAP	0x0005		/* Internal only		*/
+#define ETH_P_DDCMP     0x0006          /* DEC DDCMP: Internal only     */
+#define ETH_P_WAN_PPP   0x0007          /* Dummy type for WAN PPP frames*/
+#define ETH_P_PPP_MP    0x0008          /* Dummy type for PPP MP frames */
+#define ETH_P_LOCALTALK 0x0009		/* Localtalk pseudo type 	*/
+#define ETH_P_CAN	0x000C		/* CAN: Controller Area Network */
+#define ETH_P_CANFD	0x000D		/* CANFD: CAN flexible data rate*/
+#define ETH_P_PPPTALK	0x0010		/* Dummy type for Atalk over PPP*/
+#define ETH_P_TR_802_2	0x0011		/* 802.2 frames 		*/
+#define ETH_P_MOBITEX	0x0015		/* Mobitex (kaz@cafe.net)	*/
+#define ETH_P_CONTROL	0x0016		/* Card specific control frames */
+#define ETH_P_IRDA	0x0017		/* Linux-IrDA			*/
+#define ETH_P_ECONET	0x0018		/* Acorn Econet			*/
+#define ETH_P_HDLC	0x0019		/* HDLC frames			*/
+#define ETH_P_ARCNET	0x001A		/* 1A for ArcNet :-)            */
+#define ETH_P_DSA	0x001B		/* Distributed Switch Arch.	*/
+#define ETH_P_TRAILER	0x001C		/* Trailer switch tagging	*/
+#define ETH_P_PHONET	0x00F5		/* Nokia Phonet frames          */
+#define ETH_P_IEEE802154 0x00F6		/* IEEE802.15.4 frame		*/
+#define ETH_P_CAIF	0x00F7		/* ST-Ericsson CAIF protocol	*/
+#define ETH_P_XDSA	0x00F8		/* Multiplexed DSA protocol	*/
+#define ETH_P_MAP	0x00F9		/* Qualcomm multiplexing and
+					 * aggregation protocol
+					 */
+
+/*
+ *	This is an Ethernet frame header.
+ */
+
+struct ethhdr {
+	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
+	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
+	__be16		h_proto;		/* packet type ID field	*/
+} __attribute__((packed));
+
+
+#endif /* _LINUX_IF_ETHER_H */
diff --git a/include/uapi/linux/if_link.h b/include/uapi/linux/if_link.h
new file mode 100644
index 0000000..1f97d05
--- /dev/null
+++ b/include/uapi/linux/if_link.h
@@ -0,0 +1,928 @@
+#ifndef _LINUX_IF_LINK_H
+#define _LINUX_IF_LINK_H
+
+#include <linux/types.h>
+#include <linux/netlink.h>
+
+/* This struct should be in sync with struct rtnl_link_stats64 */
+struct rtnl_link_stats {
+	__u32	rx_packets;		/* total packets received	*/
+	__u32	tx_packets;		/* total packets transmitted	*/
+	__u32	rx_bytes;		/* total bytes received 	*/
+	__u32	tx_bytes;		/* total bytes transmitted	*/
+	__u32	rx_errors;		/* bad packets received		*/
+	__u32	tx_errors;		/* packet transmit problems	*/
+	__u32	rx_dropped;		/* no space in linux buffers	*/
+	__u32	tx_dropped;		/* no space available in linux	*/
+	__u32	multicast;		/* multicast packets received	*/
+	__u32	collisions;
+
+	/* detailed rx_errors: */
+	__u32	rx_length_errors;
+	__u32	rx_over_errors;		/* receiver ring buff overflow	*/
+	__u32	rx_crc_errors;		/* recved pkt with crc error	*/
+	__u32	rx_frame_errors;	/* recv'd frame alignment error */
+	__u32	rx_fifo_errors;		/* recv'r fifo overrun		*/
+	__u32	rx_missed_errors;	/* receiver missed packet	*/
+
+	/* detailed tx_errors */
+	__u32	tx_aborted_errors;
+	__u32	tx_carrier_errors;
+	__u32	tx_fifo_errors;
+	__u32	tx_heartbeat_errors;
+	__u32	tx_window_errors;
+
+	/* for cslip etc */
+	__u32	rx_compressed;
+	__u32	tx_compressed;
+
+	__u32	rx_nohandler;		/* dropped, no handler found	*/
+};
+
+/* The main device statistics structure */
+struct rtnl_link_stats64 {
+	__u64	rx_packets;		/* total packets received	*/
+	__u64	tx_packets;		/* total packets transmitted	*/
+	__u64	rx_bytes;		/* total bytes received 	*/
+	__u64	tx_bytes;		/* total bytes transmitted	*/
+	__u64	rx_errors;		/* bad packets received		*/
+	__u64	tx_errors;		/* packet transmit problems	*/
+	__u64	rx_dropped;		/* no space in linux buffers	*/
+	__u64	tx_dropped;		/* no space available in linux	*/
+	__u64	multicast;		/* multicast packets received	*/
+	__u64	collisions;
+
+	/* detailed rx_errors: */
+	__u64	rx_length_errors;
+	__u64	rx_over_errors;		/* receiver ring buff overflow	*/
+	__u64	rx_crc_errors;		/* recved pkt with crc error	*/
+	__u64	rx_frame_errors;	/* recv'd frame alignment error */
+	__u64	rx_fifo_errors;		/* recv'r fifo overrun		*/
+	__u64	rx_missed_errors;	/* receiver missed packet	*/
+
+	/* detailed tx_errors */
+	__u64	tx_aborted_errors;
+	__u64	tx_carrier_errors;
+	__u64	tx_fifo_errors;
+	__u64	tx_heartbeat_errors;
+	__u64	tx_window_errors;
+
+	/* for cslip etc */
+	__u64	rx_compressed;
+	__u64	tx_compressed;
+
+	__u64	rx_nohandler;		/* dropped, no handler found	*/
+};
+
+/* The struct should be in sync with struct ifmap */
+struct rtnl_link_ifmap {
+	__u64	mem_start;
+	__u64	mem_end;
+	__u64	base_addr;
+	__u16	irq;
+	__u8	dma;
+	__u8	port;
+};
+
+/*
+ * IFLA_AF_SPEC
+ *   Contains nested attributes for address family specific attributes.
+ *   Each address family may create a attribute with the address family
+ *   number as type and create its own attribute structure in it.
+ *
+ *   Example:
+ *   [IFLA_AF_SPEC] = {
+ *       [AF_INET] = {
+ *           [IFLA_INET_CONF] = ...,
+ *       },
+ *       [AF_INET6] = {
+ *           [IFLA_INET6_FLAGS] = ...,
+ *           [IFLA_INET6_CONF] = ...,
+ *       }
+ *   }
+ */
+
+enum {
+	IFLA_UNSPEC,
+	IFLA_ADDRESS,
+	IFLA_BROADCAST,
+	IFLA_IFNAME,
+	IFLA_MTU,
+	IFLA_LINK,
+	IFLA_QDISC,
+	IFLA_STATS,
+	IFLA_COST,
+#define IFLA_COST IFLA_COST
+	IFLA_PRIORITY,
+#define IFLA_PRIORITY IFLA_PRIORITY
+	IFLA_MASTER,
+#define IFLA_MASTER IFLA_MASTER
+	IFLA_WIRELESS,		/* Wireless Extension event - see wireless.h */
+#define IFLA_WIRELESS IFLA_WIRELESS
+	IFLA_PROTINFO,		/* Protocol specific information for a link */
+#define IFLA_PROTINFO IFLA_PROTINFO
+	IFLA_TXQLEN,
+#define IFLA_TXQLEN IFLA_TXQLEN
+	IFLA_MAP,
+#define IFLA_MAP IFLA_MAP
+	IFLA_WEIGHT,
+#define IFLA_WEIGHT IFLA_WEIGHT
+	IFLA_OPERSTATE,
+	IFLA_LINKMODE,
+	IFLA_LINKINFO,
+#define IFLA_LINKINFO IFLA_LINKINFO
+	IFLA_NET_NS_PID,
+	IFLA_IFALIAS,
+	IFLA_NUM_VF,		/* Number of VFs if device is SR-IOV PF */
+	IFLA_VFINFO_LIST,
+	IFLA_STATS64,
+	IFLA_VF_PORTS,
+	IFLA_PORT_SELF,
+	IFLA_AF_SPEC,
+	IFLA_GROUP,		/* Group the device belongs to */
+	IFLA_NET_NS_FD,
+	IFLA_EXT_MASK,		/* Extended info mask, VFs, etc */
+	IFLA_PROMISCUITY,	/* Promiscuity count: > 0 means acts PROMISC */
+#define IFLA_PROMISCUITY IFLA_PROMISCUITY
+	IFLA_NUM_TX_QUEUES,
+	IFLA_NUM_RX_QUEUES,
+	IFLA_CARRIER,
+	IFLA_PHYS_PORT_ID,
+	IFLA_CARRIER_CHANGES,
+	IFLA_PHYS_SWITCH_ID,
+	IFLA_LINK_NETNSID,
+	IFLA_PHYS_PORT_NAME,
+	IFLA_PROTO_DOWN,
+	IFLA_GSO_MAX_SEGS,
+	IFLA_GSO_MAX_SIZE,
+	IFLA_PAD,
+	IFLA_XDP,
+	IFLA_EVENT,
+	__IFLA_MAX
+};
+
+
+#define IFLA_MAX (__IFLA_MAX - 1)
+
+/* backwards compatibility for userspace */
+#define IFLA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct ifinfomsg))))
+#define IFLA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct ifinfomsg))
+
+enum {
+	IFLA_INET_UNSPEC,
+	IFLA_INET_CONF,
+	__IFLA_INET_MAX,
+};
+
+#define IFLA_INET_MAX (__IFLA_INET_MAX - 1)
+
+/* ifi_flags.
+
+   IFF_* flags.
+
+   The only change is:
+   IFF_LOOPBACK, IFF_BROADCAST and IFF_POINTOPOINT are
+   more not changeable by user. They describe link media
+   characteristics and set by device driver.
+
+   Comments:
+   - Combination IFF_BROADCAST|IFF_POINTOPOINT is invalid
+   - If neither of these three flags are set;
+     the interface is NBMA.
+
+   - IFF_MULTICAST does not mean anything special:
+   multicasts can be used on all not-NBMA links.
+   IFF_MULTICAST means that this media uses special encapsulation
+   for multicast frames. Apparently, all IFF_POINTOPOINT and
+   IFF_BROADCAST devices are able to use multicasts too.
+ */
+
+/* IFLA_LINK.
+   For usual devices it is equal ifi_index.
+   If it is a "virtual interface" (f.e. tunnel), ifi_link
+   can point to real physical interface (f.e. for bandwidth calculations),
+   or maybe 0, what means, that real media is unknown (usual
+   for IPIP tunnels, when route to endpoint is allowed to change)
+ */
+
+/* Subtype attributes for IFLA_PROTINFO */
+enum {
+	IFLA_INET6_UNSPEC,
+	IFLA_INET6_FLAGS,	/* link flags			*/
+	IFLA_INET6_CONF,	/* sysctl parameters		*/
+	IFLA_INET6_STATS,	/* statistics			*/
+	IFLA_INET6_MCAST,	/* MC things. What of them?	*/
+	IFLA_INET6_CACHEINFO,	/* time values and max reasm size */
+	IFLA_INET6_ICMP6STATS,	/* statistics (icmpv6)		*/
+	IFLA_INET6_TOKEN,	/* device token			*/
+	IFLA_INET6_ADDR_GEN_MODE, /* implicit address generator mode */
+	__IFLA_INET6_MAX
+};
+
+#define IFLA_INET6_MAX	(__IFLA_INET6_MAX - 1)
+
+enum in6_addr_gen_mode {
+	IN6_ADDR_GEN_MODE_EUI64,
+	IN6_ADDR_GEN_MODE_NONE,
+	IN6_ADDR_GEN_MODE_STABLE_PRIVACY,
+	IN6_ADDR_GEN_MODE_RANDOM,
+};
+
+/* Bridge section */
+
+enum {
+	IFLA_BR_UNSPEC,
+	IFLA_BR_FORWARD_DELAY,
+	IFLA_BR_HELLO_TIME,
+	IFLA_BR_MAX_AGE,
+	IFLA_BR_AGEING_TIME,
+	IFLA_BR_STP_STATE,
+	IFLA_BR_PRIORITY,
+	IFLA_BR_VLAN_FILTERING,
+	IFLA_BR_VLAN_PROTOCOL,
+	IFLA_BR_GROUP_FWD_MASK,
+	IFLA_BR_ROOT_ID,
+	IFLA_BR_BRIDGE_ID,
+	IFLA_BR_ROOT_PORT,
+	IFLA_BR_ROOT_PATH_COST,
+	IFLA_BR_TOPOLOGY_CHANGE,
+	IFLA_BR_TOPOLOGY_CHANGE_DETECTED,
+	IFLA_BR_HELLO_TIMER,
+	IFLA_BR_TCN_TIMER,
+	IFLA_BR_TOPOLOGY_CHANGE_TIMER,
+	IFLA_BR_GC_TIMER,
+	IFLA_BR_GROUP_ADDR,
+	IFLA_BR_FDB_FLUSH,
+	IFLA_BR_MCAST_ROUTER,
+	IFLA_BR_MCAST_SNOOPING,
+	IFLA_BR_MCAST_QUERY_USE_IFADDR,
+	IFLA_BR_MCAST_QUERIER,
+	IFLA_BR_MCAST_HASH_ELASTICITY,
+	IFLA_BR_MCAST_HASH_MAX,
+	IFLA_BR_MCAST_LAST_MEMBER_CNT,
+	IFLA_BR_MCAST_STARTUP_QUERY_CNT,
+	IFLA_BR_MCAST_LAST_MEMBER_INTVL,
+	IFLA_BR_MCAST_MEMBERSHIP_INTVL,
+	IFLA_BR_MCAST_QUERIER_INTVL,
+	IFLA_BR_MCAST_QUERY_INTVL,
+	IFLA_BR_MCAST_QUERY_RESPONSE_INTVL,
+	IFLA_BR_MCAST_STARTUP_QUERY_INTVL,
+	IFLA_BR_NF_CALL_IPTABLES,
+	IFLA_BR_NF_CALL_IP6TABLES,
+	IFLA_BR_NF_CALL_ARPTABLES,
+	IFLA_BR_VLAN_DEFAULT_PVID,
+	IFLA_BR_PAD,
+	IFLA_BR_VLAN_STATS_ENABLED,
+	IFLA_BR_MCAST_STATS_ENABLED,
+	IFLA_BR_MCAST_IGMP_VERSION,
+	IFLA_BR_MCAST_MLD_VERSION,
+	__IFLA_BR_MAX,
+};
+
+#define IFLA_BR_MAX	(__IFLA_BR_MAX - 1)
+
+struct ifla_bridge_id {
+	__u8	prio[2];
+	__u8	addr[6]; /* ETH_ALEN */
+};
+
+enum {
+	BRIDGE_MODE_UNSPEC,
+	BRIDGE_MODE_HAIRPIN,
+};
+
+enum {
+	IFLA_BRPORT_UNSPEC,
+	IFLA_BRPORT_STATE,	/* Spanning tree state     */
+	IFLA_BRPORT_PRIORITY,	/* "             priority  */
+	IFLA_BRPORT_COST,	/* "             cost      */
+	IFLA_BRPORT_MODE,	/* mode (hairpin)          */
+	IFLA_BRPORT_GUARD,	/* bpdu guard              */
+	IFLA_BRPORT_PROTECT,	/* root port protection    */
+	IFLA_BRPORT_FAST_LEAVE,	/* multicast fast leave    */
+	IFLA_BRPORT_LEARNING,	/* mac learning */
+	IFLA_BRPORT_UNICAST_FLOOD, /* flood unicast traffic */
+	IFLA_BRPORT_PROXYARP,	/* proxy ARP */
+	IFLA_BRPORT_LEARNING_SYNC, /* mac learning sync from device */
+	IFLA_BRPORT_PROXYARP_WIFI, /* proxy ARP for Wi-Fi */
+	IFLA_BRPORT_ROOT_ID,	/* designated root */
+	IFLA_BRPORT_BRIDGE_ID,	/* designated bridge */
+	IFLA_BRPORT_DESIGNATED_PORT,
+	IFLA_BRPORT_DESIGNATED_COST,
+	IFLA_BRPORT_ID,
+	IFLA_BRPORT_NO,
+	IFLA_BRPORT_TOPOLOGY_CHANGE_ACK,
+	IFLA_BRPORT_CONFIG_PENDING,
+	IFLA_BRPORT_MESSAGE_AGE_TIMER,
+	IFLA_BRPORT_FORWARD_DELAY_TIMER,
+	IFLA_BRPORT_HOLD_TIMER,
+	IFLA_BRPORT_FLUSH,
+	IFLA_BRPORT_MULTICAST_ROUTER,
+	IFLA_BRPORT_PAD,
+	IFLA_BRPORT_MCAST_FLOOD,
+	IFLA_BRPORT_MCAST_TO_UCAST,
+	IFLA_BRPORT_VLAN_TUNNEL,
+	IFLA_BRPORT_BCAST_FLOOD,
+	__IFLA_BRPORT_MAX
+};
+#define IFLA_BRPORT_MAX (__IFLA_BRPORT_MAX - 1)
+
+struct ifla_cacheinfo {
+	__u32	max_reasm_len;
+	__u32	tstamp;		/* ipv6InterfaceTable updated timestamp */
+	__u32	reachable_time;
+	__u32	retrans_time;
+};
+
+enum {
+	IFLA_INFO_UNSPEC,
+	IFLA_INFO_KIND,
+	IFLA_INFO_DATA,
+	IFLA_INFO_XSTATS,
+	IFLA_INFO_SLAVE_KIND,
+	IFLA_INFO_SLAVE_DATA,
+	__IFLA_INFO_MAX,
+};
+
+#define IFLA_INFO_MAX	(__IFLA_INFO_MAX - 1)
+
+/* VLAN section */
+
+enum {
+	IFLA_VLAN_UNSPEC,
+	IFLA_VLAN_ID,
+	IFLA_VLAN_FLAGS,
+	IFLA_VLAN_EGRESS_QOS,
+	IFLA_VLAN_INGRESS_QOS,
+	IFLA_VLAN_PROTOCOL,
+	__IFLA_VLAN_MAX,
+};
+
+#define IFLA_VLAN_MAX	(__IFLA_VLAN_MAX - 1)
+
+struct ifla_vlan_flags {
+	__u32	flags;
+	__u32	mask;
+};
+
+enum {
+	IFLA_VLAN_QOS_UNSPEC,
+	IFLA_VLAN_QOS_MAPPING,
+	__IFLA_VLAN_QOS_MAX
+};
+
+#define IFLA_VLAN_QOS_MAX	(__IFLA_VLAN_QOS_MAX - 1)
+
+struct ifla_vlan_qos_mapping {
+	__u32 from;
+	__u32 to;
+};
+
+/* MACVLAN section */
+enum {
+	IFLA_MACVLAN_UNSPEC,
+	IFLA_MACVLAN_MODE,
+	IFLA_MACVLAN_FLAGS,
+	IFLA_MACVLAN_MACADDR_MODE,
+	IFLA_MACVLAN_MACADDR,
+	IFLA_MACVLAN_MACADDR_DATA,
+	IFLA_MACVLAN_MACADDR_COUNT,
+	__IFLA_MACVLAN_MAX,
+};
+
+#define IFLA_MACVLAN_MAX (__IFLA_MACVLAN_MAX - 1)
+
+enum macvlan_mode {
+	MACVLAN_MODE_PRIVATE = 1, /* don't talk to other macvlans */
+	MACVLAN_MODE_VEPA    = 2, /* talk to other ports through ext bridge */
+	MACVLAN_MODE_BRIDGE  = 4, /* talk to bridge ports directly */
+	MACVLAN_MODE_PASSTHRU = 8,/* take over the underlying device */
+	MACVLAN_MODE_SOURCE  = 16,/* use source MAC address list to assign */
+};
+
+enum macvlan_macaddr_mode {
+	MACVLAN_MACADDR_ADD,
+	MACVLAN_MACADDR_DEL,
+	MACVLAN_MACADDR_FLUSH,
+	MACVLAN_MACADDR_SET,
+};
+
+#define MACVLAN_FLAG_NOPROMISC	1
+
+/* VRF section */
+enum {
+	IFLA_VRF_UNSPEC,
+	IFLA_VRF_TABLE,
+	__IFLA_VRF_MAX
+};
+
+#define IFLA_VRF_MAX (__IFLA_VRF_MAX - 1)
+
+enum {
+	IFLA_VRF_PORT_UNSPEC,
+	IFLA_VRF_PORT_TABLE,
+	__IFLA_VRF_PORT_MAX
+};
+
+#define IFLA_VRF_PORT_MAX (__IFLA_VRF_PORT_MAX - 1)
+
+/* MACSEC section */
+enum {
+	IFLA_MACSEC_UNSPEC,
+	IFLA_MACSEC_SCI,
+	IFLA_MACSEC_PORT,
+	IFLA_MACSEC_ICV_LEN,
+	IFLA_MACSEC_CIPHER_SUITE,
+	IFLA_MACSEC_WINDOW,
+	IFLA_MACSEC_ENCODING_SA,
+	IFLA_MACSEC_ENCRYPT,
+	IFLA_MACSEC_PROTECT,
+	IFLA_MACSEC_INC_SCI,
+	IFLA_MACSEC_ES,
+	IFLA_MACSEC_SCB,
+	IFLA_MACSEC_REPLAY_PROTECT,
+	IFLA_MACSEC_VALIDATION,
+	IFLA_MACSEC_PAD,
+	__IFLA_MACSEC_MAX,
+};
+
+#define IFLA_MACSEC_MAX (__IFLA_MACSEC_MAX - 1)
+
+enum macsec_validation_type {
+	MACSEC_VALIDATE_DISABLED = 0,
+	MACSEC_VALIDATE_CHECK = 1,
+	MACSEC_VALIDATE_STRICT = 2,
+	__MACSEC_VALIDATE_END,
+	MACSEC_VALIDATE_MAX = __MACSEC_VALIDATE_END - 1,
+};
+
+/* IPVLAN section */
+enum {
+	IFLA_IPVLAN_UNSPEC,
+	IFLA_IPVLAN_MODE,
+	__IFLA_IPVLAN_MAX
+};
+
+#define IFLA_IPVLAN_MAX (__IFLA_IPVLAN_MAX - 1)
+
+enum ipvlan_mode {
+	IPVLAN_MODE_L2 = 0,
+	IPVLAN_MODE_L3,
+	IPVLAN_MODE_L3S,
+	IPVLAN_MODE_MAX
+};
+
+/* VXLAN section */
+enum {
+	IFLA_VXLAN_UNSPEC,
+	IFLA_VXLAN_ID,
+	IFLA_VXLAN_GROUP,	/* group or remote address */
+	IFLA_VXLAN_LINK,
+	IFLA_VXLAN_LOCAL,
+	IFLA_VXLAN_TTL,
+	IFLA_VXLAN_TOS,
+	IFLA_VXLAN_LEARNING,
+	IFLA_VXLAN_AGEING,
+	IFLA_VXLAN_LIMIT,
+	IFLA_VXLAN_PORT_RANGE,	/* source port */
+	IFLA_VXLAN_PROXY,
+	IFLA_VXLAN_RSC,
+	IFLA_VXLAN_L2MISS,
+	IFLA_VXLAN_L3MISS,
+	IFLA_VXLAN_PORT,	/* destination port */
+	IFLA_VXLAN_GROUP6,
+	IFLA_VXLAN_LOCAL6,
+	IFLA_VXLAN_UDP_CSUM,
+	IFLA_VXLAN_UDP_ZERO_CSUM6_TX,
+	IFLA_VXLAN_UDP_ZERO_CSUM6_RX,
+	IFLA_VXLAN_REMCSUM_TX,
+	IFLA_VXLAN_REMCSUM_RX,
+	IFLA_VXLAN_GBP,
+	IFLA_VXLAN_REMCSUM_NOPARTIAL,
+	IFLA_VXLAN_COLLECT_METADATA,
+	IFLA_VXLAN_LABEL,
+	IFLA_VXLAN_GPE,
+	__IFLA_VXLAN_MAX
+};
+#define IFLA_VXLAN_MAX	(__IFLA_VXLAN_MAX - 1)
+
+struct ifla_vxlan_port_range {
+	__be16	low;
+	__be16	high;
+};
+
+/* GENEVE section */
+enum {
+	IFLA_GENEVE_UNSPEC,
+	IFLA_GENEVE_ID,
+	IFLA_GENEVE_REMOTE,
+	IFLA_GENEVE_TTL,
+	IFLA_GENEVE_TOS,
+	IFLA_GENEVE_PORT,	/* destination port */
+	IFLA_GENEVE_COLLECT_METADATA,
+	IFLA_GENEVE_REMOTE6,
+	IFLA_GENEVE_UDP_CSUM,
+	IFLA_GENEVE_UDP_ZERO_CSUM6_TX,
+	IFLA_GENEVE_UDP_ZERO_CSUM6_RX,
+	IFLA_GENEVE_LABEL,
+	__IFLA_GENEVE_MAX
+};
+#define IFLA_GENEVE_MAX	(__IFLA_GENEVE_MAX - 1)
+
+/* PPP section */
+enum {
+	IFLA_PPP_UNSPEC,
+	IFLA_PPP_DEV_FD,
+	__IFLA_PPP_MAX
+};
+#define IFLA_PPP_MAX (__IFLA_PPP_MAX - 1)
+
+/* GTP section */
+
+enum ifla_gtp_role {
+	GTP_ROLE_GGSN = 0,
+	GTP_ROLE_SGSN,
+};
+
+enum {
+	IFLA_GTP_UNSPEC,
+	IFLA_GTP_FD0,
+	IFLA_GTP_FD1,
+	IFLA_GTP_PDP_HASHSIZE,
+	IFLA_GTP_ROLE,
+	__IFLA_GTP_MAX,
+};
+#define IFLA_GTP_MAX (__IFLA_GTP_MAX - 1)
+
+/* Bonding section */
+
+enum {
+	IFLA_BOND_UNSPEC,
+	IFLA_BOND_MODE,
+	IFLA_BOND_ACTIVE_SLAVE,
+	IFLA_BOND_MIIMON,
+	IFLA_BOND_UPDELAY,
+	IFLA_BOND_DOWNDELAY,
+	IFLA_BOND_USE_CARRIER,
+	IFLA_BOND_ARP_INTERVAL,
+	IFLA_BOND_ARP_IP_TARGET,
+	IFLA_BOND_ARP_VALIDATE,
+	IFLA_BOND_ARP_ALL_TARGETS,
+	IFLA_BOND_PRIMARY,
+	IFLA_BOND_PRIMARY_RESELECT,
+	IFLA_BOND_FAIL_OVER_MAC,
+	IFLA_BOND_XMIT_HASH_POLICY,
+	IFLA_BOND_RESEND_IGMP,
+	IFLA_BOND_NUM_PEER_NOTIF,
+	IFLA_BOND_ALL_SLAVES_ACTIVE,
+	IFLA_BOND_MIN_LINKS,
+	IFLA_BOND_LP_INTERVAL,
+	IFLA_BOND_PACKETS_PER_SLAVE,
+	IFLA_BOND_AD_LACP_RATE,
+	IFLA_BOND_AD_SELECT,
+	IFLA_BOND_AD_INFO,
+	IFLA_BOND_AD_ACTOR_SYS_PRIO,
+	IFLA_BOND_AD_USER_PORT_KEY,
+	IFLA_BOND_AD_ACTOR_SYSTEM,
+	IFLA_BOND_TLB_DYNAMIC_LB,
+	__IFLA_BOND_MAX,
+};
+
+#define IFLA_BOND_MAX	(__IFLA_BOND_MAX - 1)
+
+enum {
+	IFLA_BOND_AD_INFO_UNSPEC,
+	IFLA_BOND_AD_INFO_AGGREGATOR,
+	IFLA_BOND_AD_INFO_NUM_PORTS,
+	IFLA_BOND_AD_INFO_ACTOR_KEY,
+	IFLA_BOND_AD_INFO_PARTNER_KEY,
+	IFLA_BOND_AD_INFO_PARTNER_MAC,
+	__IFLA_BOND_AD_INFO_MAX,
+};
+
+#define IFLA_BOND_AD_INFO_MAX	(__IFLA_BOND_AD_INFO_MAX - 1)
+
+enum {
+	IFLA_BOND_SLAVE_UNSPEC,
+	IFLA_BOND_SLAVE_STATE,
+	IFLA_BOND_SLAVE_MII_STATUS,
+	IFLA_BOND_SLAVE_LINK_FAILURE_COUNT,
+	IFLA_BOND_SLAVE_PERM_HWADDR,
+	IFLA_BOND_SLAVE_QUEUE_ID,
+	IFLA_BOND_SLAVE_AD_AGGREGATOR_ID,
+	IFLA_BOND_SLAVE_AD_ACTOR_OPER_PORT_STATE,
+	IFLA_BOND_SLAVE_AD_PARTNER_OPER_PORT_STATE,
+	__IFLA_BOND_SLAVE_MAX,
+};
+
+#define IFLA_BOND_SLAVE_MAX	(__IFLA_BOND_SLAVE_MAX - 1)
+
+/* SR-IOV virtual function management section */
+
+enum {
+	IFLA_VF_INFO_UNSPEC,
+	IFLA_VF_INFO,
+	__IFLA_VF_INFO_MAX,
+};
+
+#define IFLA_VF_INFO_MAX (__IFLA_VF_INFO_MAX - 1)
+
+enum {
+	IFLA_VF_UNSPEC,
+	IFLA_VF_MAC,		/* Hardware queue specific attributes */
+	IFLA_VF_VLAN,		/* VLAN ID and QoS */
+	IFLA_VF_TX_RATE,	/* Max TX Bandwidth Allocation */
+	IFLA_VF_SPOOFCHK,	/* Spoof Checking on/off switch */
+	IFLA_VF_LINK_STATE,	/* link state enable/disable/auto switch */
+	IFLA_VF_RATE,		/* Min and Max TX Bandwidth Allocation */
+	IFLA_VF_RSS_QUERY_EN,	/* RSS Redirection Table and Hash Key query
+				 * on/off switch
+				 */
+	IFLA_VF_STATS,		/* network device statistics */
+	IFLA_VF_TRUST,		/* Trust VF */
+	IFLA_VF_IB_NODE_GUID,	/* VF Infiniband node GUID */
+	IFLA_VF_IB_PORT_GUID,	/* VF Infiniband port GUID */
+	IFLA_VF_VLAN_LIST,	/* nested list of vlans, option for QinQ */
+	__IFLA_VF_MAX,
+};
+
+#define IFLA_VF_MAX (__IFLA_VF_MAX - 1)
+
+struct ifla_vf_mac {
+	__u32 vf;
+	__u8 mac[32]; /* MAX_ADDR_LEN */
+};
+
+struct ifla_vf_vlan {
+	__u32 vf;
+	__u32 vlan; /* 0 - 4095, 0 disables VLAN filter */
+	__u32 qos;
+};
+
+enum {
+	IFLA_VF_VLAN_INFO_UNSPEC,
+	IFLA_VF_VLAN_INFO,	/* VLAN ID, QoS and VLAN protocol */
+	__IFLA_VF_VLAN_INFO_MAX,
+};
+
+#define IFLA_VF_VLAN_INFO_MAX (__IFLA_VF_VLAN_INFO_MAX - 1)
+#define MAX_VLAN_LIST_LEN 1
+
+struct ifla_vf_vlan_info {
+	__u32 vf;
+	__u32 vlan; /* 0 - 4095, 0 disables VLAN filter */
+	__u32 qos;
+	__be16 vlan_proto; /* VLAN protocol either 802.1Q or 802.1ad */
+};
+
+struct ifla_vf_tx_rate {
+	__u32 vf;
+	__u32 rate; /* Max TX bandwidth in Mbps, 0 disables throttling */
+};
+
+struct ifla_vf_rate {
+	__u32 vf;
+	__u32 min_tx_rate; /* Min Bandwidth in Mbps */
+	__u32 max_tx_rate; /* Max Bandwidth in Mbps */
+};
+
+struct ifla_vf_spoofchk {
+	__u32 vf;
+	__u32 setting;
+};
+
+struct ifla_vf_guid {
+	__u32 vf;
+	__u64 guid;
+};
+
+enum {
+	IFLA_VF_LINK_STATE_AUTO,	/* link state of the uplink */
+	IFLA_VF_LINK_STATE_ENABLE,	/* link always up */
+	IFLA_VF_LINK_STATE_DISABLE,	/* link always down */
+	__IFLA_VF_LINK_STATE_MAX,
+};
+
+struct ifla_vf_link_state {
+	__u32 vf;
+	__u32 link_state;
+};
+
+struct ifla_vf_rss_query_en {
+	__u32 vf;
+	__u32 setting;
+};
+
+enum {
+	IFLA_VF_STATS_RX_PACKETS,
+	IFLA_VF_STATS_TX_PACKETS,
+	IFLA_VF_STATS_RX_BYTES,
+	IFLA_VF_STATS_TX_BYTES,
+	IFLA_VF_STATS_BROADCAST,
+	IFLA_VF_STATS_MULTICAST,
+	IFLA_VF_STATS_PAD,
+	__IFLA_VF_STATS_MAX,
+};
+
+#define IFLA_VF_STATS_MAX (__IFLA_VF_STATS_MAX - 1)
+
+struct ifla_vf_trust {
+	__u32 vf;
+	__u32 setting;
+};
+
+/* VF ports management section
+ *
+ *	Nested layout of set/get msg is:
+ *
+ *		[IFLA_NUM_VF]
+ *		[IFLA_VF_PORTS]
+ *			[IFLA_VF_PORT]
+ *				[IFLA_PORT_*], ...
+ *			[IFLA_VF_PORT]
+ *				[IFLA_PORT_*], ...
+ *			...
+ *		[IFLA_PORT_SELF]
+ *			[IFLA_PORT_*], ...
+ */
+
+enum {
+	IFLA_VF_PORT_UNSPEC,
+	IFLA_VF_PORT,			/* nest */
+	__IFLA_VF_PORT_MAX,
+};
+
+#define IFLA_VF_PORT_MAX (__IFLA_VF_PORT_MAX - 1)
+
+enum {
+	IFLA_PORT_UNSPEC,
+	IFLA_PORT_VF,			/* __u32 */
+	IFLA_PORT_PROFILE,		/* string */
+	IFLA_PORT_VSI_TYPE,		/* 802.1Qbg (pre-)standard VDP */
+	IFLA_PORT_INSTANCE_UUID,	/* binary UUID */
+	IFLA_PORT_HOST_UUID,		/* binary UUID */
+	IFLA_PORT_REQUEST,		/* __u8 */
+	IFLA_PORT_RESPONSE,		/* __u16, output only */
+	__IFLA_PORT_MAX,
+};
+
+#define IFLA_PORT_MAX (__IFLA_PORT_MAX - 1)
+
+#define PORT_PROFILE_MAX	40
+#define PORT_UUID_MAX		16
+#define PORT_SELF_VF		-1
+
+enum {
+	PORT_REQUEST_PREASSOCIATE = 0,
+	PORT_REQUEST_PREASSOCIATE_RR,
+	PORT_REQUEST_ASSOCIATE,
+	PORT_REQUEST_DISASSOCIATE,
+};
+
+enum {
+	PORT_VDP_RESPONSE_SUCCESS = 0,
+	PORT_VDP_RESPONSE_INVALID_FORMAT,
+	PORT_VDP_RESPONSE_INSUFFICIENT_RESOURCES,
+	PORT_VDP_RESPONSE_UNUSED_VTID,
+	PORT_VDP_RESPONSE_VTID_VIOLATION,
+	PORT_VDP_RESPONSE_VTID_VERSION_VIOALTION,
+	PORT_VDP_RESPONSE_OUT_OF_SYNC,
+	/* 0x08-0xFF reserved for future VDP use */
+	PORT_PROFILE_RESPONSE_SUCCESS = 0x100,
+	PORT_PROFILE_RESPONSE_INPROGRESS,
+	PORT_PROFILE_RESPONSE_INVALID,
+	PORT_PROFILE_RESPONSE_BADSTATE,
+	PORT_PROFILE_RESPONSE_INSUFFICIENT_RESOURCES,
+	PORT_PROFILE_RESPONSE_ERROR,
+};
+
+struct ifla_port_vsi {
+	__u8 vsi_mgr_id;
+	__u8 vsi_type_id[3];
+	__u8 vsi_type_version;
+	__u8 pad[3];
+};
+
+
+/* IPoIB section */
+
+enum {
+	IFLA_IPOIB_UNSPEC,
+	IFLA_IPOIB_PKEY,
+	IFLA_IPOIB_MODE,
+	IFLA_IPOIB_UMCAST,
+	__IFLA_IPOIB_MAX
+};
+
+enum {
+	IPOIB_MODE_DATAGRAM  = 0, /* using unreliable datagram QPs */
+	IPOIB_MODE_CONNECTED = 1, /* using connected QPs */
+};
+
+#define IFLA_IPOIB_MAX (__IFLA_IPOIB_MAX - 1)
+
+
+/* HSR section */
+
+enum {
+	IFLA_HSR_UNSPEC,
+	IFLA_HSR_SLAVE1,
+	IFLA_HSR_SLAVE2,
+	IFLA_HSR_MULTICAST_SPEC,	/* Last byte of supervision addr */
+	IFLA_HSR_SUPERVISION_ADDR,	/* Supervision frame multicast addr */
+	IFLA_HSR_SEQ_NR,
+	IFLA_HSR_VERSION,		/* HSR version */
+	__IFLA_HSR_MAX,
+};
+
+#define IFLA_HSR_MAX (__IFLA_HSR_MAX - 1)
+
+/* STATS section */
+
+struct if_stats_msg {
+	__u8  family;
+	__u8  pad1;
+	__u16 pad2;
+	__u32 ifindex;
+	__u32 filter_mask;
+};
+
+/* A stats attribute can be netdev specific or a global stat.
+ * For netdev stats, lets use the prefix IFLA_STATS_LINK_*
+ */
+enum {
+	IFLA_STATS_UNSPEC, /* also used as 64bit pad attribute */
+	IFLA_STATS_LINK_64,
+	IFLA_STATS_LINK_XSTATS,
+	IFLA_STATS_LINK_XSTATS_SLAVE,
+	IFLA_STATS_LINK_OFFLOAD_XSTATS,
+	IFLA_STATS_AF_SPEC,
+	__IFLA_STATS_MAX,
+};
+
+#define IFLA_STATS_MAX (__IFLA_STATS_MAX - 1)
+
+#define IFLA_STATS_FILTER_BIT(ATTR)	(1 << (ATTR - 1))
+
+/* These are embedded into IFLA_STATS_LINK_XSTATS:
+ * [IFLA_STATS_LINK_XSTATS]
+ * -> [LINK_XSTATS_TYPE_xxx]
+ *    -> [rtnl link type specific attributes]
+ */
+enum {
+	LINK_XSTATS_TYPE_UNSPEC,
+	LINK_XSTATS_TYPE_BRIDGE,
+	__LINK_XSTATS_TYPE_MAX
+};
+#define LINK_XSTATS_TYPE_MAX (__LINK_XSTATS_TYPE_MAX - 1)
+
+/* These are stats embedded into IFLA_STATS_LINK_OFFLOAD_XSTATS */
+enum {
+	IFLA_OFFLOAD_XSTATS_UNSPEC,
+	IFLA_OFFLOAD_XSTATS_CPU_HIT, /* struct rtnl_link_stats64 */
+	__IFLA_OFFLOAD_XSTATS_MAX
+};
+#define IFLA_OFFLOAD_XSTATS_MAX (__IFLA_OFFLOAD_XSTATS_MAX - 1)
+
+/* XDP section */
+
+#define XDP_FLAGS_UPDATE_IF_NOEXIST	(1U << 0)
+#define XDP_FLAGS_SKB_MODE		(1U << 1)
+#define XDP_FLAGS_DRV_MODE		(1U << 2)
+#define XDP_FLAGS_HW_MODE		(1U << 3)
+#define XDP_FLAGS_MODES			(XDP_FLAGS_SKB_MODE | \
+					 XDP_FLAGS_DRV_MODE | \
+					 XDP_FLAGS_HW_MODE)
+#define XDP_FLAGS_MASK			(XDP_FLAGS_UPDATE_IF_NOEXIST | \
+					 XDP_FLAGS_MODES)
+
+/* These are stored into IFLA_XDP_ATTACHED on dump. */
+enum {
+	XDP_ATTACHED_NONE = 0,
+	XDP_ATTACHED_DRV,
+	XDP_ATTACHED_SKB,
+	XDP_ATTACHED_HW,
+};
+
+enum {
+	IFLA_XDP_UNSPEC,
+	IFLA_XDP_FD,
+	IFLA_XDP_ATTACHED,
+	IFLA_XDP_FLAGS,
+	IFLA_XDP_PROG_ID,
+	__IFLA_XDP_MAX,
+};
+
+#define IFLA_XDP_MAX (__IFLA_XDP_MAX - 1)
+
+enum {
+	IFLA_EVENT_NONE,
+	IFLA_EVENT_REBOOT,		/* internal reset / reboot */
+	IFLA_EVENT_FEATURES,		/* change in offload features */
+	IFLA_EVENT_BONDING_FAILOVER,	/* change in active slave */
+	IFLA_EVENT_NOTIFY_PEERS,	/* re-sent grat. arp/ndisc */
+	IFLA_EVENT_IGMP_RESEND,		/* re-sent IGMP JOIN */
+	IFLA_EVENT_BONDING_OPTIONS,	/* change in bonding options */
+};
+
+#endif /* _LINUX_IF_LINK_H */
diff --git a/include/uapi/linux/if_macsec.h b/include/uapi/linux/if_macsec.h
new file mode 100644
index 0000000..22939a3
--- /dev/null
+++ b/include/uapi/linux/if_macsec.h
@@ -0,0 +1,171 @@
+/*
+ * include/uapi/linux/if_macsec.h - MACsec device
+ *
+ * Copyright (c) 2015 Sabrina Dubroca <sd@queasysnail.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _MACSEC_H
+#define _MACSEC_H
+
+#include <linux/types.h>
+
+#define MACSEC_GENL_NAME "macsec"
+#define MACSEC_GENL_VERSION 1
+
+#define MACSEC_MAX_KEY_LEN 128
+
+#define MACSEC_KEYID_LEN 16
+
+#define MACSEC_DEFAULT_CIPHER_ID   0x0080020001000001ULL
+#define MACSEC_DEFAULT_CIPHER_ALT  0x0080C20001000001ULL
+
+#define MACSEC_MIN_ICV_LEN 8
+#define MACSEC_MAX_ICV_LEN 32
+/* upper limit for ICV length as recommended by IEEE802.1AE-2006 */
+#define MACSEC_STD_ICV_LEN 16
+
+enum macsec_attrs {
+	MACSEC_ATTR_UNSPEC,
+	MACSEC_ATTR_IFINDEX,     /* u32, ifindex of the MACsec netdevice */
+	MACSEC_ATTR_RXSC_CONFIG, /* config, nested macsec_rxsc_attrs */
+	MACSEC_ATTR_SA_CONFIG,   /* config, nested macsec_sa_attrs */
+	MACSEC_ATTR_SECY,        /* dump, nested macsec_secy_attrs */
+	MACSEC_ATTR_TXSA_LIST,   /* dump, nested, macsec_sa_attrs for each TXSA */
+	MACSEC_ATTR_RXSC_LIST,   /* dump, nested, macsec_rxsc_attrs for each RXSC */
+	MACSEC_ATTR_TXSC_STATS,  /* dump, nested, macsec_txsc_stats_attr */
+	MACSEC_ATTR_SECY_STATS,  /* dump, nested, macsec_secy_stats_attr */
+	__MACSEC_ATTR_END,
+	NUM_MACSEC_ATTR = __MACSEC_ATTR_END,
+	MACSEC_ATTR_MAX = __MACSEC_ATTR_END - 1,
+};
+
+enum macsec_secy_attrs {
+	MACSEC_SECY_ATTR_UNSPEC,
+	MACSEC_SECY_ATTR_SCI,
+	MACSEC_SECY_ATTR_ENCODING_SA,
+	MACSEC_SECY_ATTR_WINDOW,
+	MACSEC_SECY_ATTR_CIPHER_SUITE,
+	MACSEC_SECY_ATTR_ICV_LEN,
+	MACSEC_SECY_ATTR_PROTECT,
+	MACSEC_SECY_ATTR_REPLAY,
+	MACSEC_SECY_ATTR_OPER,
+	MACSEC_SECY_ATTR_VALIDATE,
+	MACSEC_SECY_ATTR_ENCRYPT,
+	MACSEC_SECY_ATTR_INC_SCI,
+	MACSEC_SECY_ATTR_ES,
+	MACSEC_SECY_ATTR_SCB,
+	MACSEC_SECY_ATTR_PAD,
+	__MACSEC_SECY_ATTR_END,
+	NUM_MACSEC_SECY_ATTR = __MACSEC_SECY_ATTR_END,
+	MACSEC_SECY_ATTR_MAX = __MACSEC_SECY_ATTR_END - 1,
+};
+
+enum macsec_rxsc_attrs {
+	MACSEC_RXSC_ATTR_UNSPEC,
+	MACSEC_RXSC_ATTR_SCI,     /* config/dump, u64 */
+	MACSEC_RXSC_ATTR_ACTIVE,  /* config/dump, u8 0..1 */
+	MACSEC_RXSC_ATTR_SA_LIST, /* dump, nested */
+	MACSEC_RXSC_ATTR_STATS,   /* dump, nested, macsec_rxsc_stats_attr */
+	MACSEC_RXSC_ATTR_PAD,
+	__MACSEC_RXSC_ATTR_END,
+	NUM_MACSEC_RXSC_ATTR = __MACSEC_RXSC_ATTR_END,
+	MACSEC_RXSC_ATTR_MAX = __MACSEC_RXSC_ATTR_END - 1,
+};
+
+enum macsec_sa_attrs {
+	MACSEC_SA_ATTR_UNSPEC,
+	MACSEC_SA_ATTR_AN,     /* config/dump, u8 0..3 */
+	MACSEC_SA_ATTR_ACTIVE, /* config/dump, u8 0..1 */
+	MACSEC_SA_ATTR_PN,     /* config/dump, u32 */
+	MACSEC_SA_ATTR_KEY,    /* config, data */
+	MACSEC_SA_ATTR_KEYID,  /* config/dump, 128-bit */
+	MACSEC_SA_ATTR_STATS,  /* dump, nested, macsec_sa_stats_attr */
+	MACSEC_SA_ATTR_PAD,
+	__MACSEC_SA_ATTR_END,
+	NUM_MACSEC_SA_ATTR = __MACSEC_SA_ATTR_END,
+	MACSEC_SA_ATTR_MAX = __MACSEC_SA_ATTR_END - 1,
+};
+
+enum macsec_nl_commands {
+	MACSEC_CMD_GET_TXSC,
+	MACSEC_CMD_ADD_RXSC,
+	MACSEC_CMD_DEL_RXSC,
+	MACSEC_CMD_UPD_RXSC,
+	MACSEC_CMD_ADD_TXSA,
+	MACSEC_CMD_DEL_TXSA,
+	MACSEC_CMD_UPD_TXSA,
+	MACSEC_CMD_ADD_RXSA,
+	MACSEC_CMD_DEL_RXSA,
+	MACSEC_CMD_UPD_RXSA,
+};
+
+/* u64 per-RXSC stats */
+enum macsec_rxsc_stats_attr {
+	MACSEC_RXSC_STATS_ATTR_UNSPEC,
+	MACSEC_RXSC_STATS_ATTR_IN_OCTETS_VALIDATED,
+	MACSEC_RXSC_STATS_ATTR_IN_OCTETS_DECRYPTED,
+	MACSEC_RXSC_STATS_ATTR_IN_PKTS_UNCHECKED,
+	MACSEC_RXSC_STATS_ATTR_IN_PKTS_DELAYED,
+	MACSEC_RXSC_STATS_ATTR_IN_PKTS_OK,
+	MACSEC_RXSC_STATS_ATTR_IN_PKTS_INVALID,
+	MACSEC_RXSC_STATS_ATTR_IN_PKTS_LATE,
+	MACSEC_RXSC_STATS_ATTR_IN_PKTS_NOT_VALID,
+	MACSEC_RXSC_STATS_ATTR_IN_PKTS_NOT_USING_SA,
+	MACSEC_RXSC_STATS_ATTR_IN_PKTS_UNUSED_SA,
+	MACSEC_RXSC_STATS_ATTR_PAD,
+	__MACSEC_RXSC_STATS_ATTR_END,
+	NUM_MACSEC_RXSC_STATS_ATTR = __MACSEC_RXSC_STATS_ATTR_END,
+	MACSEC_RXSC_STATS_ATTR_MAX = __MACSEC_RXSC_STATS_ATTR_END - 1,
+};
+
+/* u32 per-{RX,TX}SA stats */
+enum macsec_sa_stats_attr {
+	MACSEC_SA_STATS_ATTR_UNSPEC,
+	MACSEC_SA_STATS_ATTR_IN_PKTS_OK,
+	MACSEC_SA_STATS_ATTR_IN_PKTS_INVALID,
+	MACSEC_SA_STATS_ATTR_IN_PKTS_NOT_VALID,
+	MACSEC_SA_STATS_ATTR_IN_PKTS_NOT_USING_SA,
+	MACSEC_SA_STATS_ATTR_IN_PKTS_UNUSED_SA,
+	MACSEC_SA_STATS_ATTR_OUT_PKTS_PROTECTED,
+	MACSEC_SA_STATS_ATTR_OUT_PKTS_ENCRYPTED,
+	__MACSEC_SA_STATS_ATTR_END,
+	NUM_MACSEC_SA_STATS_ATTR = __MACSEC_SA_STATS_ATTR_END,
+	MACSEC_SA_STATS_ATTR_MAX = __MACSEC_SA_STATS_ATTR_END - 1,
+};
+
+/* u64 per-TXSC stats */
+enum macsec_txsc_stats_attr {
+	MACSEC_TXSC_STATS_ATTR_UNSPEC,
+	MACSEC_TXSC_STATS_ATTR_OUT_PKTS_PROTECTED,
+	MACSEC_TXSC_STATS_ATTR_OUT_PKTS_ENCRYPTED,
+	MACSEC_TXSC_STATS_ATTR_OUT_OCTETS_PROTECTED,
+	MACSEC_TXSC_STATS_ATTR_OUT_OCTETS_ENCRYPTED,
+	MACSEC_TXSC_STATS_ATTR_PAD,
+	__MACSEC_TXSC_STATS_ATTR_END,
+	NUM_MACSEC_TXSC_STATS_ATTR = __MACSEC_TXSC_STATS_ATTR_END,
+	MACSEC_TXSC_STATS_ATTR_MAX = __MACSEC_TXSC_STATS_ATTR_END - 1,
+};
+
+/* u64 per-SecY stats */
+enum macsec_secy_stats_attr {
+	MACSEC_SECY_STATS_ATTR_UNSPEC,
+	MACSEC_SECY_STATS_ATTR_OUT_PKTS_UNTAGGED,
+	MACSEC_SECY_STATS_ATTR_IN_PKTS_UNTAGGED,
+	MACSEC_SECY_STATS_ATTR_OUT_PKTS_TOO_LONG,
+	MACSEC_SECY_STATS_ATTR_IN_PKTS_NO_TAG,
+	MACSEC_SECY_STATS_ATTR_IN_PKTS_BAD_TAG,
+	MACSEC_SECY_STATS_ATTR_IN_PKTS_UNKNOWN_SCI,
+	MACSEC_SECY_STATS_ATTR_IN_PKTS_NO_SCI,
+	MACSEC_SECY_STATS_ATTR_IN_PKTS_OVERRUN,
+	MACSEC_SECY_STATS_ATTR_PAD,
+	__MACSEC_SECY_STATS_ATTR_END,
+	NUM_MACSEC_SECY_STATS_ATTR = __MACSEC_SECY_STATS_ATTR_END,
+	MACSEC_SECY_STATS_ATTR_MAX = __MACSEC_SECY_STATS_ATTR_END - 1,
+};
+
+#endif /* _MACSEC_H */
diff --git a/include/uapi/linux/if_packet.h b/include/uapi/linux/if_packet.h
new file mode 100644
index 0000000..4df96a7
--- /dev/null
+++ b/include/uapi/linux/if_packet.h
@@ -0,0 +1,302 @@
+#ifndef __LINUX_IF_PACKET_H
+#define __LINUX_IF_PACKET_H
+
+#include <linux/types.h>
+
+struct sockaddr_pkt {
+	unsigned short spkt_family;
+	unsigned char spkt_device[14];
+	__be16 spkt_protocol;
+};
+
+struct sockaddr_ll {
+	unsigned short	sll_family;
+	__be16		sll_protocol;
+	int		sll_ifindex;
+	unsigned short	sll_hatype;
+	unsigned char	sll_pkttype;
+	unsigned char	sll_halen;
+	unsigned char	sll_addr[8];
+};
+
+/* Packet types */
+
+#define PACKET_HOST		0		/* To us		*/
+#define PACKET_BROADCAST	1		/* To all		*/
+#define PACKET_MULTICAST	2		/* To group		*/
+#define PACKET_OTHERHOST	3		/* To someone else 	*/
+#define PACKET_OUTGOING		4		/* Outgoing of any type */
+#define PACKET_LOOPBACK		5		/* MC/BRD frame looped back */
+#define PACKET_USER		6		/* To user space	*/
+#define PACKET_KERNEL		7		/* To kernel space	*/
+/* Unused, PACKET_FASTROUTE and PACKET_LOOPBACK are invisible to user space */
+#define PACKET_FASTROUTE	6		/* Fastrouted frame	*/
+
+/* Packet socket options */
+
+#define PACKET_ADD_MEMBERSHIP		1
+#define PACKET_DROP_MEMBERSHIP		2
+#define PACKET_RECV_OUTPUT		3
+/* Value 4 is still used by obsolete turbo-packet. */
+#define PACKET_RX_RING			5
+#define PACKET_STATISTICS		6
+#define PACKET_COPY_THRESH		7
+#define PACKET_AUXDATA			8
+#define PACKET_ORIGDEV			9
+#define PACKET_VERSION			10
+#define PACKET_HDRLEN			11
+#define PACKET_RESERVE			12
+#define PACKET_TX_RING			13
+#define PACKET_LOSS			14
+#define PACKET_VNET_HDR			15
+#define PACKET_TX_TIMESTAMP		16
+#define PACKET_TIMESTAMP		17
+#define PACKET_FANOUT			18
+#define PACKET_TX_HAS_OFF		19
+#define PACKET_QDISC_BYPASS		20
+#define PACKET_ROLLOVER_STATS		21
+#define PACKET_FANOUT_DATA		22
+
+#define PACKET_FANOUT_HASH		0
+#define PACKET_FANOUT_LB		1
+#define PACKET_FANOUT_CPU		2
+#define PACKET_FANOUT_ROLLOVER		3
+#define PACKET_FANOUT_RND		4
+#define PACKET_FANOUT_QM		5
+#define PACKET_FANOUT_CBPF		6
+#define PACKET_FANOUT_EBPF		7
+#define PACKET_FANOUT_FLAG_ROLLOVER	0x1000
+#define PACKET_FANOUT_FLAG_UNIQUEID	0x2000
+#define PACKET_FANOUT_FLAG_DEFRAG	0x8000
+
+struct tpacket_stats {
+	unsigned int	tp_packets;
+	unsigned int	tp_drops;
+};
+
+struct tpacket_stats_v3 {
+	unsigned int	tp_packets;
+	unsigned int	tp_drops;
+	unsigned int	tp_freeze_q_cnt;
+};
+
+struct tpacket_rollover_stats {
+	__aligned_u64	tp_all;
+	__aligned_u64	tp_huge;
+	__aligned_u64	tp_failed;
+};
+
+union tpacket_stats_u {
+	struct tpacket_stats stats1;
+	struct tpacket_stats_v3 stats3;
+};
+
+struct tpacket_auxdata {
+	__u32		tp_status;
+	__u32		tp_len;
+	__u32		tp_snaplen;
+	__u16		tp_mac;
+	__u16		tp_net;
+	__u16		tp_vlan_tci;
+	__u16		tp_vlan_tpid;
+};
+
+/* Rx ring - header status */
+#define TP_STATUS_KERNEL		      0
+#define TP_STATUS_USER			(1 << 0)
+#define TP_STATUS_COPY			(1 << 1)
+#define TP_STATUS_LOSING		(1 << 2)
+#define TP_STATUS_CSUMNOTREADY		(1 << 3)
+#define TP_STATUS_VLAN_VALID		(1 << 4) /* auxdata has valid tp_vlan_tci */
+#define TP_STATUS_BLK_TMO		(1 << 5)
+#define TP_STATUS_VLAN_TPID_VALID	(1 << 6) /* auxdata has valid tp_vlan_tpid */
+#define TP_STATUS_CSUM_VALID		(1 << 7)
+
+/* Tx ring - header status */
+#define TP_STATUS_AVAILABLE	      0
+#define TP_STATUS_SEND_REQUEST	(1 << 0)
+#define TP_STATUS_SENDING	(1 << 1)
+#define TP_STATUS_WRONG_FORMAT	(1 << 2)
+
+/* Rx and Tx ring - header status */
+#define TP_STATUS_TS_SOFTWARE		(1 << 29)
+#define TP_STATUS_TS_SYS_HARDWARE	(1 << 30) /* deprecated, never set */
+#define TP_STATUS_TS_RAW_HARDWARE	(1 << 31)
+
+/* Rx ring - feature request bits */
+#define TP_FT_REQ_FILL_RXHASH	0x1
+
+struct tpacket_hdr {
+	unsigned long	tp_status;
+	unsigned int	tp_len;
+	unsigned int	tp_snaplen;
+	unsigned short	tp_mac;
+	unsigned short	tp_net;
+	unsigned int	tp_sec;
+	unsigned int	tp_usec;
+};
+
+#define TPACKET_ALIGNMENT	16
+#define TPACKET_ALIGN(x)	(((x)+TPACKET_ALIGNMENT-1)&~(TPACKET_ALIGNMENT-1))
+#define TPACKET_HDRLEN		(TPACKET_ALIGN(sizeof(struct tpacket_hdr)) + sizeof(struct sockaddr_ll))
+
+struct tpacket2_hdr {
+	__u32		tp_status;
+	__u32		tp_len;
+	__u32		tp_snaplen;
+	__u16		tp_mac;
+	__u16		tp_net;
+	__u32		tp_sec;
+	__u32		tp_nsec;
+	__u16		tp_vlan_tci;
+	__u16		tp_vlan_tpid;
+	__u8		tp_padding[4];
+};
+
+struct tpacket_hdr_variant1 {
+	__u32	tp_rxhash;
+	__u32	tp_vlan_tci;
+	__u16	tp_vlan_tpid;
+	__u16	tp_padding;
+};
+
+struct tpacket3_hdr {
+	__u32		tp_next_offset;
+	__u32		tp_sec;
+	__u32		tp_nsec;
+	__u32		tp_snaplen;
+	__u32		tp_len;
+	__u32		tp_status;
+	__u16		tp_mac;
+	__u16		tp_net;
+	/* pkt_hdr variants */
+	union {
+		struct tpacket_hdr_variant1 hv1;
+	};
+	__u8		tp_padding[8];
+};
+
+struct tpacket_bd_ts {
+	unsigned int ts_sec;
+	union {
+		unsigned int ts_usec;
+		unsigned int ts_nsec;
+	};
+};
+
+struct tpacket_hdr_v1 {
+	__u32	block_status;
+	__u32	num_pkts;
+	__u32	offset_to_first_pkt;
+
+	/* Number of valid bytes (including padding)
+	 * blk_len <= tp_block_size
+	 */
+	__u32	blk_len;
+
+	/*
+	 * Quite a few uses of sequence number:
+	 * 1. Make sure cache flush etc worked.
+	 *    Well, one can argue - why not use the increasing ts below?
+	 *    But look at 2. below first.
+	 * 2. When you pass around blocks to other user space decoders,
+	 *    you can see which blk[s] is[are] outstanding etc.
+	 * 3. Validate kernel code.
+	 */
+	__aligned_u64	seq_num;
+
+	/*
+	 * ts_last_pkt:
+	 *
+	 * Case 1.	Block has 'N'(N >=1) packets and TMO'd(timed out)
+	 *		ts_last_pkt == 'time-stamp of last packet' and NOT the
+	 *		time when the timer fired and the block was closed.
+	 *		By providing the ts of the last packet we can absolutely
+	 *		guarantee that time-stamp wise, the first packet in the
+	 *		next block will never precede the last packet of the
+	 *		previous block.
+	 * Case 2.	Block has zero packets and TMO'd
+	 *		ts_last_pkt = time when the timer fired and the block
+	 *		was closed.
+	 * Case 3.	Block has 'N' packets and NO TMO.
+	 *		ts_last_pkt = time-stamp of the last pkt in the block.
+	 *
+	 * ts_first_pkt:
+	 *		Is always the time-stamp when the block was opened.
+	 *		Case a)	ZERO packets
+	 *			No packets to deal with but atleast you know the
+	 *			time-interval of this block.
+	 *		Case b) Non-zero packets
+	 *			Use the ts of the first packet in the block.
+	 *
+	 */
+	struct tpacket_bd_ts	ts_first_pkt, ts_last_pkt;
+};
+
+union tpacket_bd_header_u {
+	struct tpacket_hdr_v1 bh1;
+};
+
+struct tpacket_block_desc {
+	__u32 version;
+	__u32 offset_to_priv;
+	union tpacket_bd_header_u hdr;
+};
+
+#define TPACKET2_HDRLEN		(TPACKET_ALIGN(sizeof(struct tpacket2_hdr)) + sizeof(struct sockaddr_ll))
+#define TPACKET3_HDRLEN		(TPACKET_ALIGN(sizeof(struct tpacket3_hdr)) + sizeof(struct sockaddr_ll))
+
+enum tpacket_versions {
+	TPACKET_V1,
+	TPACKET_V2,
+	TPACKET_V3
+};
+
+/*
+   Frame structure:
+
+   - Start. Frame must be aligned to TPACKET_ALIGNMENT=16
+   - struct tpacket_hdr
+   - pad to TPACKET_ALIGNMENT=16
+   - struct sockaddr_ll
+   - Gap, chosen so that packet data (Start+tp_net) alignes to TPACKET_ALIGNMENT=16
+   - Start+tp_mac: [ Optional MAC header ]
+   - Start+tp_net: Packet data, aligned to TPACKET_ALIGNMENT=16.
+   - Pad to align to TPACKET_ALIGNMENT=16
+ */
+
+struct tpacket_req {
+	unsigned int	tp_block_size;	/* Minimal size of contiguous block */
+	unsigned int	tp_block_nr;	/* Number of blocks */
+	unsigned int	tp_frame_size;	/* Size of frame */
+	unsigned int	tp_frame_nr;	/* Total number of frames */
+};
+
+struct tpacket_req3 {
+	unsigned int	tp_block_size;	/* Minimal size of contiguous block */
+	unsigned int	tp_block_nr;	/* Number of blocks */
+	unsigned int	tp_frame_size;	/* Size of frame */
+	unsigned int	tp_frame_nr;	/* Total number of frames */
+	unsigned int	tp_retire_blk_tov; /* timeout in msecs */
+	unsigned int	tp_sizeof_priv; /* offset to private data area */
+	unsigned int	tp_feature_req_word;
+};
+
+union tpacket_req_u {
+	struct tpacket_req	req;
+	struct tpacket_req3	req3;
+};
+
+struct packet_mreq {
+	int		mr_ifindex;
+	unsigned short	mr_type;
+	unsigned short	mr_alen;
+	unsigned char	mr_address[8];
+};
+
+#define PACKET_MR_MULTICAST	0
+#define PACKET_MR_PROMISC	1
+#define PACKET_MR_ALLMULTI	2
+#define PACKET_MR_UNICAST	3
+
+#endif
diff --git a/include/uapi/linux/if_tun.h b/include/uapi/linux/if_tun.h
new file mode 100644
index 0000000..d5ecb42
--- /dev/null
+++ b/include/uapi/linux/if_tun.h
@@ -0,0 +1,107 @@
+/*
+ *  Universal TUN/TAP device driver.
+ *  Copyright (C) 1999-2000 Maxim Krasnyansky <max_mk@yahoo.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ */
+
+#ifndef __IF_TUN_H
+#define __IF_TUN_H
+
+#include <linux/types.h>
+#include <linux/if_ether.h>
+#include <linux/filter.h>
+
+/* Read queue size */
+#define TUN_READQ_SIZE	500
+/* TUN device type flags: deprecated. Use IFF_TUN/IFF_TAP instead. */
+#define TUN_TUN_DEV 	IFF_TUN
+#define TUN_TAP_DEV	IFF_TAP
+#define TUN_TYPE_MASK   0x000f
+
+/* Ioctl defines */
+#define TUNSETNOCSUM  _IOW('T', 200, int) 
+#define TUNSETDEBUG   _IOW('T', 201, int) 
+#define TUNSETIFF     _IOW('T', 202, int) 
+#define TUNSETPERSIST _IOW('T', 203, int) 
+#define TUNSETOWNER   _IOW('T', 204, int)
+#define TUNSETLINK    _IOW('T', 205, int)
+#define TUNSETGROUP   _IOW('T', 206, int)
+#define TUNGETFEATURES _IOR('T', 207, unsigned int)
+#define TUNSETOFFLOAD  _IOW('T', 208, unsigned int)
+#define TUNSETTXFILTER _IOW('T', 209, unsigned int)
+#define TUNGETIFF      _IOR('T', 210, unsigned int)
+#define TUNGETSNDBUF   _IOR('T', 211, int)
+#define TUNSETSNDBUF   _IOW('T', 212, int)
+#define TUNATTACHFILTER _IOW('T', 213, struct sock_fprog)
+#define TUNDETACHFILTER _IOW('T', 214, struct sock_fprog)
+#define TUNGETVNETHDRSZ _IOR('T', 215, int)
+#define TUNSETVNETHDRSZ _IOW('T', 216, int)
+#define TUNSETQUEUE  _IOW('T', 217, int)
+#define TUNSETIFINDEX	_IOW('T', 218, unsigned int)
+#define TUNGETFILTER _IOR('T', 219, struct sock_fprog)
+#define TUNSETVNETLE _IOW('T', 220, int)
+#define TUNGETVNETLE _IOR('T', 221, int)
+/* The TUNSETVNETBE and TUNGETVNETBE ioctls are for cross-endian support on
+ * little-endian hosts. Not all kernel configurations support them, but all
+ * configurations that support SET also support GET.
+ */
+#define TUNSETVNETBE _IOW('T', 222, int)
+#define TUNGETVNETBE _IOR('T', 223, int)
+
+/* TUNSETIFF ifr flags */
+#define IFF_TUN		0x0001
+#define IFF_TAP		0x0002
+#define IFF_NO_PI	0x1000
+/* This flag has no real effect */
+#define IFF_ONE_QUEUE	0x2000
+#define IFF_VNET_HDR	0x4000
+#define IFF_TUN_EXCL	0x8000
+#define IFF_MULTI_QUEUE 0x0100
+#define IFF_ATTACH_QUEUE 0x0200
+#define IFF_DETACH_QUEUE 0x0400
+/* read-only flag */
+#define IFF_PERSIST	0x0800
+#define IFF_NOFILTER	0x1000
+
+/* Socket options */
+#define TUN_TX_TIMESTAMP 1
+
+/* Features for GSO (TUNSETOFFLOAD). */
+#define TUN_F_CSUM	0x01	/* You can hand me unchecksummed packets. */
+#define TUN_F_TSO4	0x02	/* I can handle TSO for IPv4 packets */
+#define TUN_F_TSO6	0x04	/* I can handle TSO for IPv6 packets */
+#define TUN_F_TSO_ECN	0x08	/* I can handle TSO with ECN bits. */
+#define TUN_F_UFO	0x10	/* I can handle UFO packets */
+
+/* Protocol info prepended to the packets (when IFF_NO_PI is not set) */
+#define TUN_PKT_STRIP	0x0001
+struct tun_pi {
+	__u16  flags;
+	__be16 proto;
+};
+
+/*
+ * Filter spec (used for SETXXFILTER ioctls)
+ * This stuff is applicable only to the TAP (Ethernet) devices.
+ * If the count is zero the filter is disabled and the driver accepts
+ * all packets (promisc mode).
+ * If the filter is enabled in order to accept broadcast packets
+ * broadcast addr must be explicitly included in the addr list.
+ */
+#define TUN_FLT_ALLMULTI 0x0001 /* Accept all multicast packets */
+struct tun_filter {
+	__u16  flags; /* TUN_FLT_ flags see above */
+	__u16  count; /* Number of addresses */
+	__u8   addr[0][ETH_ALEN];
+};
+
+#endif /* __IF_TUN_H */
diff --git a/include/uapi/linux/if_tunnel.h b/include/uapi/linux/if_tunnel.h
new file mode 100644
index 0000000..21834ca
--- /dev/null
+++ b/include/uapi/linux/if_tunnel.h
@@ -0,0 +1,158 @@
+#ifndef _IF_TUNNEL_H_
+#define _IF_TUNNEL_H_
+
+#include <linux/types.h>
+#include <linux/if.h>
+#include <linux/ip.h>
+#include <linux/in6.h>
+#include <asm/byteorder.h>
+
+
+#define SIOCGETTUNNEL   (SIOCDEVPRIVATE + 0)
+#define SIOCADDTUNNEL   (SIOCDEVPRIVATE + 1)
+#define SIOCDELTUNNEL   (SIOCDEVPRIVATE + 2)
+#define SIOCCHGTUNNEL   (SIOCDEVPRIVATE + 3)
+#define SIOCGETPRL      (SIOCDEVPRIVATE + 4)
+#define SIOCADDPRL      (SIOCDEVPRIVATE + 5)
+#define SIOCDELPRL      (SIOCDEVPRIVATE + 6)
+#define SIOCCHGPRL      (SIOCDEVPRIVATE + 7)
+#define SIOCGET6RD      (SIOCDEVPRIVATE + 8)
+#define SIOCADD6RD      (SIOCDEVPRIVATE + 9)
+#define SIOCDEL6RD      (SIOCDEVPRIVATE + 10)
+#define SIOCCHG6RD      (SIOCDEVPRIVATE + 11)
+
+#define GRE_CSUM	__cpu_to_be16(0x8000)
+#define GRE_ROUTING	__cpu_to_be16(0x4000)
+#define GRE_KEY		__cpu_to_be16(0x2000)
+#define GRE_SEQ		__cpu_to_be16(0x1000)
+#define GRE_STRICT	__cpu_to_be16(0x0800)
+#define GRE_REC		__cpu_to_be16(0x0700)
+#define GRE_ACK		__cpu_to_be16(0x0080)
+#define GRE_FLAGS	__cpu_to_be16(0x0078)
+#define GRE_VERSION	__cpu_to_be16(0x0007)
+
+#define GRE_IS_CSUM(f)		((f) & GRE_CSUM)
+#define GRE_IS_ROUTING(f)	((f) & GRE_ROUTING)
+#define GRE_IS_KEY(f)		((f) & GRE_KEY)
+#define GRE_IS_SEQ(f)		((f) & GRE_SEQ)
+#define GRE_IS_STRICT(f)	((f) & GRE_STRICT)
+#define GRE_IS_REC(f)		((f) & GRE_REC)
+#define GRE_IS_ACK(f)		((f) & GRE_ACK)
+
+#define GRE_VERSION_0		__cpu_to_be16(0x0000)
+#define GRE_VERSION_1		__cpu_to_be16(0x0001)
+#define GRE_PROTO_PPP		__cpu_to_be16(0x880b)
+#define GRE_PPTP_KEY_MASK	__cpu_to_be32(0xffff)
+
+struct ip_tunnel_parm {
+	char			name[IFNAMSIZ];
+	int			link;
+	__be16			i_flags;
+	__be16			o_flags;
+	__be32			i_key;
+	__be32			o_key;
+	struct iphdr		iph;
+};
+
+enum {
+	IFLA_IPTUN_UNSPEC,
+	IFLA_IPTUN_LINK,
+	IFLA_IPTUN_LOCAL,
+	IFLA_IPTUN_REMOTE,
+	IFLA_IPTUN_TTL,
+	IFLA_IPTUN_TOS,
+	IFLA_IPTUN_ENCAP_LIMIT,
+	IFLA_IPTUN_FLOWINFO,
+	IFLA_IPTUN_FLAGS,
+	IFLA_IPTUN_PROTO,
+	IFLA_IPTUN_PMTUDISC,
+	IFLA_IPTUN_6RD_PREFIX,
+	IFLA_IPTUN_6RD_RELAY_PREFIX,
+	IFLA_IPTUN_6RD_PREFIXLEN,
+	IFLA_IPTUN_6RD_RELAY_PREFIXLEN,
+	IFLA_IPTUN_ENCAP_TYPE,
+	IFLA_IPTUN_ENCAP_FLAGS,
+	IFLA_IPTUN_ENCAP_SPORT,
+	IFLA_IPTUN_ENCAP_DPORT,
+	IFLA_IPTUN_COLLECT_METADATA,
+	IFLA_IPTUN_FWMARK,
+	__IFLA_IPTUN_MAX,
+};
+#define IFLA_IPTUN_MAX	(__IFLA_IPTUN_MAX - 1)
+
+enum tunnel_encap_types {
+	TUNNEL_ENCAP_NONE,
+	TUNNEL_ENCAP_FOU,
+	TUNNEL_ENCAP_GUE,
+};
+
+#define TUNNEL_ENCAP_FLAG_CSUM		(1<<0)
+#define TUNNEL_ENCAP_FLAG_CSUM6		(1<<1)
+#define TUNNEL_ENCAP_FLAG_REMCSUM	(1<<2)
+
+/* SIT-mode i_flags */
+#define	SIT_ISATAP	0x0001
+
+struct ip_tunnel_prl {
+	__be32			addr;
+	__u16			flags;
+	__u16			__reserved;
+	__u32			datalen;
+	__u32			__reserved2;
+	/* data follows */
+};
+
+/* PRL flags */
+#define	PRL_DEFAULT		0x0001
+
+struct ip_tunnel_6rd {
+	struct in6_addr		prefix;
+	__be32			relay_prefix;
+	__u16			prefixlen;
+	__u16			relay_prefixlen;
+};
+
+enum {
+	IFLA_GRE_UNSPEC,
+	IFLA_GRE_LINK,
+	IFLA_GRE_IFLAGS,
+	IFLA_GRE_OFLAGS,
+	IFLA_GRE_IKEY,
+	IFLA_GRE_OKEY,
+	IFLA_GRE_LOCAL,
+	IFLA_GRE_REMOTE,
+	IFLA_GRE_TTL,
+	IFLA_GRE_TOS,
+	IFLA_GRE_PMTUDISC,
+	IFLA_GRE_ENCAP_LIMIT,
+	IFLA_GRE_FLOWINFO,
+	IFLA_GRE_FLAGS,
+	IFLA_GRE_ENCAP_TYPE,
+	IFLA_GRE_ENCAP_FLAGS,
+	IFLA_GRE_ENCAP_SPORT,
+	IFLA_GRE_ENCAP_DPORT,
+	IFLA_GRE_COLLECT_METADATA,
+	IFLA_GRE_IGNORE_DF,
+	IFLA_GRE_FWMARK,
+	IFLA_GRE_ERSPAN_INDEX,
+	__IFLA_GRE_MAX,
+};
+
+#define IFLA_GRE_MAX	(__IFLA_GRE_MAX - 1)
+
+/* VTI-mode i_flags */
+#define VTI_ISVTI ((__be16)0x0001)
+
+enum {
+	IFLA_VTI_UNSPEC,
+	IFLA_VTI_LINK,
+	IFLA_VTI_IKEY,
+	IFLA_VTI_OKEY,
+	IFLA_VTI_LOCAL,
+	IFLA_VTI_REMOTE,
+	IFLA_VTI_FWMARK,
+	__IFLA_VTI_MAX,
+};
+
+#define IFLA_VTI_MAX	(__IFLA_VTI_MAX - 1)
+#endif /* _IF_TUNNEL_H_ */
diff --git a/include/uapi/linux/if_vlan.h b/include/uapi/linux/if_vlan.h
new file mode 100644
index 0000000..24ae007
--- /dev/null
+++ b/include/uapi/linux/if_vlan.h
@@ -0,0 +1,64 @@
+/*
+ * VLAN		An implementation of 802.1Q VLAN tagging.
+ *
+ * Authors:	Ben Greear <greearb@candelatech.com>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef _LINUX_IF_VLAN_H_
+#define _LINUX_IF_VLAN_H_
+
+
+/* VLAN IOCTLs are found in sockios.h */
+
+/* Passed in vlan_ioctl_args structure to determine behaviour. */
+enum vlan_ioctl_cmds {
+	ADD_VLAN_CMD,
+	DEL_VLAN_CMD,
+	SET_VLAN_INGRESS_PRIORITY_CMD,
+	SET_VLAN_EGRESS_PRIORITY_CMD,
+	GET_VLAN_INGRESS_PRIORITY_CMD,
+	GET_VLAN_EGRESS_PRIORITY_CMD,
+	SET_VLAN_NAME_TYPE_CMD,
+	SET_VLAN_FLAG_CMD,
+	GET_VLAN_REALDEV_NAME_CMD, /* If this works, you know it's a VLAN device, btw */
+	GET_VLAN_VID_CMD /* Get the VID of this VLAN (specified by name) */
+};
+
+enum vlan_flags {
+	VLAN_FLAG_REORDER_HDR	= 0x1,
+	VLAN_FLAG_GVRP		= 0x2,
+	VLAN_FLAG_LOOSE_BINDING	= 0x4,
+	VLAN_FLAG_MVRP		= 0x8,
+};
+
+enum vlan_name_types {
+	VLAN_NAME_TYPE_PLUS_VID, /* Name will look like:  vlan0005 */
+	VLAN_NAME_TYPE_RAW_PLUS_VID, /* name will look like:  eth1.0005 */
+	VLAN_NAME_TYPE_PLUS_VID_NO_PAD, /* Name will look like:  vlan5 */
+	VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD, /* Name will look like:  eth0.5 */
+	VLAN_NAME_TYPE_HIGHEST
+};
+
+struct vlan_ioctl_args {
+	int cmd; /* Should be one of the vlan_ioctl_cmds enum above. */
+	char device1[24];
+
+        union {
+		char device2[24];
+		int VID;
+		unsigned int skb_priority;
+		unsigned int name_type;
+		unsigned int bind_type;
+		unsigned int flag; /* Matches vlan_dev_priv flags */
+        } u;
+
+	short vlan_qos;   
+};
+
+#endif /* _LINUX_IF_VLAN_H_ */
diff --git a/include/uapi/linux/ife.h b/include/uapi/linux/ife.h
new file mode 100644
index 0000000..2954da3
--- /dev/null
+++ b/include/uapi/linux/ife.h
@@ -0,0 +1,18 @@
+#ifndef __UAPI_IFE_H
+#define __UAPI_IFE_H
+
+#define IFE_METAHDRLEN 2
+
+enum {
+	IFE_META_SKBMARK = 1,
+	IFE_META_HASHID,
+	IFE_META_PRIO,
+	IFE_META_QMAP,
+	IFE_META_TCINDEX,
+	__IFE_META_MAX
+};
+
+/*Can be overridden at runtime by module option*/
+#define IFE_META_MAX (__IFE_META_MAX - 1)
+
+#endif
diff --git a/include/uapi/linux/ila.h b/include/uapi/linux/ila.h
new file mode 100644
index 0000000..7e328d7
--- /dev/null
+++ b/include/uapi/linux/ila.h
@@ -0,0 +1,45 @@
+/* ila.h - ILA Interface */
+
+#ifndef _LINUX_ILA_H
+#define _LINUX_ILA_H
+
+/* NETLINK_GENERIC related info */
+#define ILA_GENL_NAME		"ila"
+#define ILA_GENL_VERSION	0x1
+
+enum {
+	ILA_ATTR_UNSPEC,
+	ILA_ATTR_LOCATOR,			/* u64 */
+	ILA_ATTR_IDENTIFIER,			/* u64 */
+	ILA_ATTR_LOCATOR_MATCH,			/* u64 */
+	ILA_ATTR_IFINDEX,			/* s32 */
+	ILA_ATTR_DIR,				/* u32 */
+	ILA_ATTR_PAD,
+	ILA_ATTR_CSUM_MODE,			/* u8 */
+
+	__ILA_ATTR_MAX,
+};
+
+#define ILA_ATTR_MAX		(__ILA_ATTR_MAX - 1)
+
+enum {
+	ILA_CMD_UNSPEC,
+	ILA_CMD_ADD,
+	ILA_CMD_DEL,
+	ILA_CMD_GET,
+
+	__ILA_CMD_MAX,
+};
+
+#define ILA_CMD_MAX	(__ILA_CMD_MAX - 1)
+
+#define ILA_DIR_IN	(1 << 0)
+#define ILA_DIR_OUT	(1 << 1)
+
+enum {
+	ILA_CSUM_ADJUST_TRANSPORT,
+	ILA_CSUM_NEUTRAL_MAP,
+	ILA_CSUM_NO_ACTION,
+};
+
+#endif /* _LINUX_ILA_H */
diff --git a/include/uapi/linux/in.h b/include/uapi/linux/in.h
new file mode 100644
index 0000000..9439efa
--- /dev/null
+++ b/include/uapi/linux/in.h
@@ -0,0 +1,300 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Definitions of the Internet Protocol.
+ *
+ * Version:	@(#)in.h	1.0.1	04/21/93
+ *
+ * Authors:	Original taken from the GNU Project <netinet/in.h> file.
+ *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_IN_H
+#define _LINUX_IN_H
+
+#include <linux/types.h>
+#include <linux/libc-compat.h>
+#include <linux/socket.h>
+
+#if __UAPI_DEF_IN_IPPROTO
+/* Standard well-defined IP protocols.  */
+enum {
+  IPPROTO_IP = 0,		/* Dummy protocol for TCP		*/
+#define IPPROTO_IP		IPPROTO_IP
+  IPPROTO_ICMP = 1,		/* Internet Control Message Protocol	*/
+#define IPPROTO_ICMP		IPPROTO_ICMP
+  IPPROTO_IGMP = 2,		/* Internet Group Management Protocol	*/
+#define IPPROTO_IGMP		IPPROTO_IGMP
+  IPPROTO_IPIP = 4,		/* IPIP tunnels (older KA9Q tunnels use 94) */
+#define IPPROTO_IPIP		IPPROTO_IPIP
+  IPPROTO_TCP = 6,		/* Transmission Control Protocol	*/
+#define IPPROTO_TCP		IPPROTO_TCP
+  IPPROTO_EGP = 8,		/* Exterior Gateway Protocol		*/
+#define IPPROTO_EGP		IPPROTO_EGP
+  IPPROTO_PUP = 12,		/* PUP protocol				*/
+#define IPPROTO_PUP		IPPROTO_PUP
+  IPPROTO_UDP = 17,		/* User Datagram Protocol		*/
+#define IPPROTO_UDP		IPPROTO_UDP
+  IPPROTO_IDP = 22,		/* XNS IDP protocol			*/
+#define IPPROTO_IDP		IPPROTO_IDP
+  IPPROTO_TP = 29,		/* SO Transport Protocol Class 4	*/
+#define IPPROTO_TP		IPPROTO_TP
+  IPPROTO_DCCP = 33,		/* Datagram Congestion Control Protocol */
+#define IPPROTO_DCCP		IPPROTO_DCCP
+  IPPROTO_IPV6 = 41,		/* IPv6-in-IPv4 tunnelling		*/
+#define IPPROTO_IPV6		IPPROTO_IPV6
+  IPPROTO_RSVP = 46,		/* RSVP Protocol			*/
+#define IPPROTO_RSVP		IPPROTO_RSVP
+  IPPROTO_GRE = 47,		/* Cisco GRE tunnels (rfc 1701,1702)	*/
+#define IPPROTO_GRE		IPPROTO_GRE
+  IPPROTO_ESP = 50,		/* Encapsulation Security Payload protocol */
+#define IPPROTO_ESP		IPPROTO_ESP
+  IPPROTO_AH = 51,		/* Authentication Header protocol	*/
+#define IPPROTO_AH		IPPROTO_AH
+  IPPROTO_MTP = 92,		/* Multicast Transport Protocol		*/
+#define IPPROTO_MTP		IPPROTO_MTP
+  IPPROTO_BEETPH = 94,		/* IP option pseudo header for BEET	*/
+#define IPPROTO_BEETPH		IPPROTO_BEETPH
+  IPPROTO_ENCAP = 98,		/* Encapsulation Header			*/
+#define IPPROTO_ENCAP		IPPROTO_ENCAP
+  IPPROTO_PIM = 103,		/* Protocol Independent Multicast	*/
+#define IPPROTO_PIM		IPPROTO_PIM
+  IPPROTO_COMP = 108,		/* Compression Header Protocol		*/
+#define IPPROTO_COMP		IPPROTO_COMP
+  IPPROTO_SCTP = 132,		/* Stream Control Transport Protocol	*/
+#define IPPROTO_SCTP		IPPROTO_SCTP
+  IPPROTO_UDPLITE = 136,	/* UDP-Lite (RFC 3828)			*/
+#define IPPROTO_UDPLITE		IPPROTO_UDPLITE
+  IPPROTO_MPLS = 137,		/* MPLS in IP (RFC 4023)		*/
+#define IPPROTO_MPLS		IPPROTO_MPLS
+  IPPROTO_RAW = 255,		/* Raw IP packets			*/
+#define IPPROTO_RAW		IPPROTO_RAW
+  IPPROTO_MAX
+};
+#endif
+
+#if __UAPI_DEF_IN_ADDR
+/* Internet address. */
+struct in_addr {
+	__be32	s_addr;
+};
+#endif
+
+#define IP_TOS		1
+#define IP_TTL		2
+#define IP_HDRINCL	3
+#define IP_OPTIONS	4
+#define IP_ROUTER_ALERT	5
+#define IP_RECVOPTS	6
+#define IP_RETOPTS	7
+#define IP_PKTINFO	8
+#define IP_PKTOPTIONS	9
+#define IP_MTU_DISCOVER	10
+#define IP_RECVERR	11
+#define IP_RECVTTL	12
+#define	IP_RECVTOS	13
+#define IP_MTU		14
+#define IP_FREEBIND	15
+#define IP_IPSEC_POLICY	16
+#define IP_XFRM_POLICY	17
+#define IP_PASSSEC	18
+#define IP_TRANSPARENT	19
+
+/* BSD compatibility */
+#define IP_RECVRETOPTS	IP_RETOPTS
+
+/* TProxy original addresses */
+#define IP_ORIGDSTADDR       20
+#define IP_RECVORIGDSTADDR   IP_ORIGDSTADDR
+
+#define IP_MINTTL       21
+#define IP_NODEFRAG     22
+#define IP_CHECKSUM	23
+#define IP_BIND_ADDRESS_NO_PORT	24
+#define IP_RECVFRAGSIZE	25
+
+/* IP_MTU_DISCOVER values */
+#define IP_PMTUDISC_DONT		0	/* Never send DF frames */
+#define IP_PMTUDISC_WANT		1	/* Use per route hints	*/
+#define IP_PMTUDISC_DO			2	/* Always DF		*/
+#define IP_PMTUDISC_PROBE		3       /* Ignore dst pmtu      */
+/* Always use interface mtu (ignores dst pmtu) but don't set DF flag.
+ * Also incoming ICMP frag_needed notifications will be ignored on
+ * this socket to prevent accepting spoofed ones.
+ */
+#define IP_PMTUDISC_INTERFACE		4
+/* weaker version of IP_PMTUDISC_INTERFACE, which allos packets to get
+ * fragmented if they exeed the interface mtu
+ */
+#define IP_PMTUDISC_OMIT		5
+
+#define IP_MULTICAST_IF			32
+#define IP_MULTICAST_TTL 		33
+#define IP_MULTICAST_LOOP 		34
+#define IP_ADD_MEMBERSHIP		35
+#define IP_DROP_MEMBERSHIP		36
+#define IP_UNBLOCK_SOURCE		37
+#define IP_BLOCK_SOURCE			38
+#define IP_ADD_SOURCE_MEMBERSHIP	39
+#define IP_DROP_SOURCE_MEMBERSHIP	40
+#define IP_MSFILTER			41
+#define MCAST_JOIN_GROUP		42
+#define MCAST_BLOCK_SOURCE		43
+#define MCAST_UNBLOCK_SOURCE		44
+#define MCAST_LEAVE_GROUP		45
+#define MCAST_JOIN_SOURCE_GROUP		46
+#define MCAST_LEAVE_SOURCE_GROUP	47
+#define MCAST_MSFILTER			48
+#define IP_MULTICAST_ALL		49
+#define IP_UNICAST_IF			50
+
+#define MCAST_EXCLUDE	0
+#define MCAST_INCLUDE	1
+
+/* These need to appear somewhere around here */
+#define IP_DEFAULT_MULTICAST_TTL        1
+#define IP_DEFAULT_MULTICAST_LOOP       1
+
+/* Request struct for multicast socket ops */
+
+#if __UAPI_DEF_IP_MREQ
+struct ip_mreq  {
+	struct in_addr imr_multiaddr;	/* IP multicast address of group */
+	struct in_addr imr_interface;	/* local IP address of interface */
+};
+
+struct ip_mreqn {
+	struct in_addr	imr_multiaddr;		/* IP multicast address of group */
+	struct in_addr	imr_address;		/* local IP address of interface */
+	int		imr_ifindex;		/* Interface index */
+};
+
+struct ip_mreq_source {
+	__be32		imr_multiaddr;
+	__be32		imr_interface;
+	__be32		imr_sourceaddr;
+};
+
+struct ip_msfilter {
+	__be32		imsf_multiaddr;
+	__be32		imsf_interface;
+	__u32		imsf_fmode;
+	__u32		imsf_numsrc;
+	__be32		imsf_slist[1];
+};
+
+#define IP_MSFILTER_SIZE(numsrc) \
+	(sizeof(struct ip_msfilter) - sizeof(__u32) \
+	+ (numsrc) * sizeof(__u32))
+
+struct group_req {
+	__u32				 gr_interface;	/* interface index */
+	struct __kernel_sockaddr_storage gr_group;	/* group address */
+};
+
+struct group_source_req {
+	__u32				 gsr_interface;	/* interface index */
+	struct __kernel_sockaddr_storage gsr_group;	/* group address */
+	struct __kernel_sockaddr_storage gsr_source;	/* source address */
+};
+
+struct group_filter {
+	__u32				 gf_interface;	/* interface index */
+	struct __kernel_sockaddr_storage gf_group;	/* multicast address */
+	__u32				 gf_fmode;	/* filter mode */
+	__u32				 gf_numsrc;	/* number of sources */
+	struct __kernel_sockaddr_storage gf_slist[1];	/* interface index */
+};
+
+#define GROUP_FILTER_SIZE(numsrc) \
+	(sizeof(struct group_filter) - sizeof(struct __kernel_sockaddr_storage) \
+	+ (numsrc) * sizeof(struct __kernel_sockaddr_storage))
+#endif
+
+#if __UAPI_DEF_IN_PKTINFO
+struct in_pktinfo {
+	int		ipi_ifindex;
+	struct in_addr	ipi_spec_dst;
+	struct in_addr	ipi_addr;
+};
+#endif
+
+/* Structure describing an Internet (IP) socket address. */
+#if  __UAPI_DEF_SOCKADDR_IN
+#define __SOCK_SIZE__	16		/* sizeof(struct sockaddr)	*/
+struct sockaddr_in {
+  __kernel_sa_family_t	sin_family;	/* Address family		*/
+  __be16		sin_port;	/* Port number			*/
+  struct in_addr	sin_addr;	/* Internet address		*/
+
+  /* Pad to size of `struct sockaddr'. */
+  unsigned char		__pad[__SOCK_SIZE__ - sizeof(short int) -
+			sizeof(unsigned short int) - sizeof(struct in_addr)];
+};
+#define sin_zero	__pad		/* for BSD UNIX comp. -FvK	*/
+#endif
+
+#if __UAPI_DEF_IN_CLASS
+/*
+ * Definitions of the bits in an Internet address integer.
+ * On subnets, host and network parts are found according
+ * to the subnet mask, not these masks.
+ */
+#define	IN_CLASSA(a)		((((long int) (a)) & 0x80000000) == 0)
+#define	IN_CLASSA_NET		0xff000000
+#define	IN_CLASSA_NSHIFT	24
+#define	IN_CLASSA_HOST		(0xffffffff & ~IN_CLASSA_NET)
+#define	IN_CLASSA_MAX		128
+
+#define	IN_CLASSB(a)		((((long int) (a)) & 0xc0000000) == 0x80000000)
+#define	IN_CLASSB_NET		0xffff0000
+#define	IN_CLASSB_NSHIFT	16
+#define	IN_CLASSB_HOST		(0xffffffff & ~IN_CLASSB_NET)
+#define	IN_CLASSB_MAX		65536
+
+#define	IN_CLASSC(a)		((((long int) (a)) & 0xe0000000) == 0xc0000000)
+#define	IN_CLASSC_NET		0xffffff00
+#define	IN_CLASSC_NSHIFT	8
+#define	IN_CLASSC_HOST		(0xffffffff & ~IN_CLASSC_NET)
+
+#define	IN_CLASSD(a)		((((long int) (a)) & 0xf0000000) == 0xe0000000)
+#define	IN_MULTICAST(a)		IN_CLASSD(a)
+#define IN_MULTICAST_NET	0xF0000000
+
+#define	IN_EXPERIMENTAL(a)	((((long int) (a)) & 0xf0000000) == 0xf0000000)
+#define	IN_BADCLASS(a)		IN_EXPERIMENTAL((a))
+
+/* Address to accept any incoming messages. */
+#define	INADDR_ANY		((unsigned long int) 0x00000000)
+
+/* Address to send to all hosts. */
+#define	INADDR_BROADCAST	((unsigned long int) 0xffffffff)
+
+/* Address indicating an error return. */
+#define	INADDR_NONE		((unsigned long int) 0xffffffff)
+
+/* Network number for local host loopback. */
+#define	IN_LOOPBACKNET		127
+
+/* Address to loopback in software to local host.  */
+#define	INADDR_LOOPBACK		0x7f000001	/* 127.0.0.1   */
+#define	IN_LOOPBACK(a)		((((long int) (a)) & 0xff000000) == 0x7f000000)
+
+/* Defines for Multicast INADDR */
+#define INADDR_UNSPEC_GROUP   	0xe0000000U	/* 224.0.0.0   */
+#define INADDR_ALLHOSTS_GROUP 	0xe0000001U	/* 224.0.0.1   */
+#define INADDR_ALLRTRS_GROUP    0xe0000002U	/* 224.0.0.2 */
+#define INADDR_MAX_LOCAL_GROUP  0xe00000ffU	/* 224.0.0.255 */
+#endif
+
+/* <asm/byteorder.h> contains the htonl type stuff.. */
+#include <asm/byteorder.h> 
+
+
+#endif /* _LINUX_IN_H */
diff --git a/include/uapi/linux/in6.h b/include/uapi/linux/in6.h
new file mode 100644
index 0000000..6f3bdee
--- /dev/null
+++ b/include/uapi/linux/in6.h
@@ -0,0 +1,296 @@
+/*
+ *	Types and definitions for AF_INET6 
+ *	Linux INET6 implementation 
+ *
+ *	Authors:
+ *	Pedro Roque		<roque@di.fc.ul.pt>	
+ *
+ *	Sources:
+ *	IPv6 Program Interfaces for BSD Systems
+ *      <draft-ietf-ipngwg-bsd-api-05.txt>
+ *
+ *	Advanced Sockets API for IPv6
+ *	<draft-stevens-advanced-api-00.txt>
+ *
+ *	This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _LINUX_IN6_H
+#define _LINUX_IN6_H
+
+#include <linux/types.h>
+#include <linux/libc-compat.h>
+
+/*
+ *	IPv6 address structure
+ */
+
+#if __UAPI_DEF_IN6_ADDR
+struct in6_addr {
+	union {
+		__u8		u6_addr8[16];
+#if __UAPI_DEF_IN6_ADDR_ALT
+		__be16		u6_addr16[8];
+		__be32		u6_addr32[4];
+#endif
+	} in6_u;
+#define s6_addr			in6_u.u6_addr8
+#if __UAPI_DEF_IN6_ADDR_ALT
+#define s6_addr16		in6_u.u6_addr16
+#define s6_addr32		in6_u.u6_addr32
+#endif
+};
+#endif /* __UAPI_DEF_IN6_ADDR */
+
+#if __UAPI_DEF_SOCKADDR_IN6
+struct sockaddr_in6 {
+	unsigned short int	sin6_family;    /* AF_INET6 */
+	__be16			sin6_port;      /* Transport layer port # */
+	__be32			sin6_flowinfo;  /* IPv6 flow information */
+	struct in6_addr		sin6_addr;      /* IPv6 address */
+	__u32			sin6_scope_id;  /* scope id (new in RFC2553) */
+};
+#endif /* __UAPI_DEF_SOCKADDR_IN6 */
+
+#if __UAPI_DEF_IPV6_MREQ
+struct ipv6_mreq {
+	/* IPv6 multicast address of group */
+	struct in6_addr ipv6mr_multiaddr;
+
+	/* local IPv6 address of interface */
+	int		ipv6mr_ifindex;
+};
+#endif /* __UAPI_DEF_IVP6_MREQ */
+
+#define ipv6mr_acaddr	ipv6mr_multiaddr
+
+struct in6_flowlabel_req {
+	struct in6_addr	flr_dst;
+	__be32	flr_label;
+	__u8	flr_action;
+	__u8	flr_share;
+	__u16	flr_flags;
+	__u16 	flr_expires;
+	__u16	flr_linger;
+	__u32	__flr_pad;
+	/* Options in format of IPV6_PKTOPTIONS */
+};
+
+#define IPV6_FL_A_GET	0
+#define IPV6_FL_A_PUT	1
+#define IPV6_FL_A_RENEW	2
+
+#define IPV6_FL_F_CREATE	1
+#define IPV6_FL_F_EXCL		2
+#define IPV6_FL_F_REFLECT	4
+#define IPV6_FL_F_REMOTE	8
+
+#define IPV6_FL_S_NONE		0
+#define IPV6_FL_S_EXCL		1
+#define IPV6_FL_S_PROCESS	2
+#define IPV6_FL_S_USER		3
+#define IPV6_FL_S_ANY		255
+
+
+/*
+ *	Bitmask constant declarations to help applications select out the 
+ *	flow label and priority fields.
+ *
+ *	Note that this are in host byte order while the flowinfo field of
+ *	sockaddr_in6 is in network byte order.
+ */
+
+#define IPV6_FLOWINFO_FLOWLABEL		0x000fffff
+#define IPV6_FLOWINFO_PRIORITY		0x0ff00000
+
+/* These definitions are obsolete */
+#define IPV6_PRIORITY_UNCHARACTERIZED	0x0000
+#define IPV6_PRIORITY_FILLER		0x0100
+#define IPV6_PRIORITY_UNATTENDED	0x0200
+#define IPV6_PRIORITY_RESERVED1		0x0300
+#define IPV6_PRIORITY_BULK		0x0400
+#define IPV6_PRIORITY_RESERVED2		0x0500
+#define IPV6_PRIORITY_INTERACTIVE	0x0600
+#define IPV6_PRIORITY_CONTROL		0x0700
+#define IPV6_PRIORITY_8			0x0800
+#define IPV6_PRIORITY_9			0x0900
+#define IPV6_PRIORITY_10		0x0a00
+#define IPV6_PRIORITY_11		0x0b00
+#define IPV6_PRIORITY_12		0x0c00
+#define IPV6_PRIORITY_13		0x0d00
+#define IPV6_PRIORITY_14		0x0e00
+#define IPV6_PRIORITY_15		0x0f00
+
+/*
+ *	IPV6 extension headers
+ */
+#if __UAPI_DEF_IPPROTO_V6
+#define IPPROTO_HOPOPTS		0	/* IPv6 hop-by-hop options	*/
+#define IPPROTO_ROUTING		43	/* IPv6 routing header		*/
+#define IPPROTO_FRAGMENT	44	/* IPv6 fragmentation header	*/
+#define IPPROTO_ICMPV6		58	/* ICMPv6			*/
+#define IPPROTO_NONE		59	/* IPv6 no next header		*/
+#define IPPROTO_DSTOPTS		60	/* IPv6 destination options	*/
+#define IPPROTO_MH		135	/* IPv6 mobility header		*/
+#endif /* __UAPI_DEF_IPPROTO_V6 */
+
+/*
+ *	IPv6 TLV options.
+ */
+#define IPV6_TLV_PAD1		0
+#define IPV6_TLV_PADN		1
+#define IPV6_TLV_ROUTERALERT	5
+#define IPV6_TLV_CALIPSO	7	/* RFC 5570 */
+#define IPV6_TLV_JUMBO		194
+#define IPV6_TLV_HAO		201	/* home address option */
+
+/*
+ *	IPV6 socket options
+ */
+#if __UAPI_DEF_IPV6_OPTIONS
+#define IPV6_ADDRFORM		1
+#define IPV6_2292PKTINFO	2
+#define IPV6_2292HOPOPTS	3
+#define IPV6_2292DSTOPTS	4
+#define IPV6_2292RTHDR		5
+#define IPV6_2292PKTOPTIONS	6
+#define IPV6_CHECKSUM		7
+#define IPV6_2292HOPLIMIT	8
+#define IPV6_NEXTHOP		9
+#define IPV6_AUTHHDR		10	/* obsolete */
+#define IPV6_FLOWINFO		11
+
+#define IPV6_UNICAST_HOPS	16
+#define IPV6_MULTICAST_IF	17
+#define IPV6_MULTICAST_HOPS	18
+#define IPV6_MULTICAST_LOOP	19
+#define IPV6_ADD_MEMBERSHIP	20
+#define IPV6_DROP_MEMBERSHIP	21
+#define IPV6_ROUTER_ALERT	22
+#define IPV6_MTU_DISCOVER	23
+#define IPV6_MTU		24
+#define IPV6_RECVERR		25
+#define IPV6_V6ONLY		26
+#define IPV6_JOIN_ANYCAST	27
+#define IPV6_LEAVE_ANYCAST	28
+
+/* IPV6_MTU_DISCOVER values */
+#define IPV6_PMTUDISC_DONT		0
+#define IPV6_PMTUDISC_WANT		1
+#define IPV6_PMTUDISC_DO		2
+#define IPV6_PMTUDISC_PROBE		3
+/* same as IPV6_PMTUDISC_PROBE, provided for symetry with IPv4
+ * also see comments on IP_PMTUDISC_INTERFACE
+ */
+#define IPV6_PMTUDISC_INTERFACE		4
+/* weaker version of IPV6_PMTUDISC_INTERFACE, which allows packets to
+ * get fragmented if they exceed the interface mtu
+ */
+#define IPV6_PMTUDISC_OMIT		5
+
+/* Flowlabel */
+#define IPV6_FLOWLABEL_MGR	32
+#define IPV6_FLOWINFO_SEND	33
+
+#define IPV6_IPSEC_POLICY	34
+#define IPV6_XFRM_POLICY	35
+#define IPV6_HDRINCL		36
+#endif
+
+/*
+ * Multicast:
+ * Following socket options are shared between IPv4 and IPv6.
+ *
+ * MCAST_JOIN_GROUP		42
+ * MCAST_BLOCK_SOURCE		43
+ * MCAST_UNBLOCK_SOURCE		44
+ * MCAST_LEAVE_GROUP		45
+ * MCAST_JOIN_SOURCE_GROUP	46
+ * MCAST_LEAVE_SOURCE_GROUP	47
+ * MCAST_MSFILTER		48
+ */
+
+/*
+ * Advanced API (RFC3542) (1)
+ *
+ * Note: IPV6_RECVRTHDRDSTOPTS does not exist. see net/ipv6/datagram.c.
+ */
+
+#define IPV6_RECVPKTINFO	49
+#define IPV6_PKTINFO		50
+#define IPV6_RECVHOPLIMIT	51
+#define IPV6_HOPLIMIT		52
+#define IPV6_RECVHOPOPTS	53
+#define IPV6_HOPOPTS		54
+#define IPV6_RTHDRDSTOPTS	55
+#define IPV6_RECVRTHDR		56
+#define IPV6_RTHDR		57
+#define IPV6_RECVDSTOPTS	58
+#define IPV6_DSTOPTS		59
+#define IPV6_RECVPATHMTU	60
+#define IPV6_PATHMTU		61
+#define IPV6_DONTFRAG		62
+#if 0	/* not yet */
+#define IPV6_USE_MIN_MTU	63
+#endif
+
+/*
+ * Netfilter (1)
+ *
+ * Following socket options are used in ip6_tables;
+ * see include/linux/netfilter_ipv6/ip6_tables.h.
+ *
+ * IP6T_SO_SET_REPLACE / IP6T_SO_GET_INFO		64
+ * IP6T_SO_SET_ADD_COUNTERS / IP6T_SO_GET_ENTRIES	65
+ */
+
+/*
+ * Advanced API (RFC3542) (2)
+ */
+#define IPV6_RECVTCLASS		66
+#define IPV6_TCLASS		67
+
+/*
+ * Netfilter (2)
+ *
+ * Following socket options are used in ip6_tables;
+ * see include/linux/netfilter_ipv6/ip6_tables.h.
+ *
+ * IP6T_SO_GET_REVISION_MATCH	68
+ * IP6T_SO_GET_REVISION_TARGET	69
+ * IP6T_SO_ORIGINAL_DST		80
+ */
+
+#define IPV6_AUTOFLOWLABEL	70
+/* RFC5014: Source address selection */
+#define IPV6_ADDR_PREFERENCES	72
+
+#define IPV6_PREFER_SRC_TMP		0x0001
+#define IPV6_PREFER_SRC_PUBLIC		0x0002
+#define IPV6_PREFER_SRC_PUBTMP_DEFAULT	0x0100
+#define IPV6_PREFER_SRC_COA		0x0004
+#define IPV6_PREFER_SRC_HOME		0x0400
+#define IPV6_PREFER_SRC_CGA		0x0008
+#define IPV6_PREFER_SRC_NONCGA		0x0800
+
+/* RFC5082: Generalized Ttl Security Mechanism */
+#define IPV6_MINHOPCOUNT		73
+
+#define IPV6_ORIGDSTADDR        74
+#define IPV6_RECVORIGDSTADDR    IPV6_ORIGDSTADDR
+#define IPV6_TRANSPARENT        75
+#define IPV6_UNICAST_IF         76
+#define IPV6_RECVFRAGSIZE	77
+
+/*
+ * Multicast Routing:
+ * see include/uapi/linux/mroute6.h.
+ *
+ * MRT6_BASE			200
+ * ...
+ * MRT6_MAX
+ */
+#endif /* _LINUX_IN6_H */
diff --git a/include/uapi/linux/in_route.h b/include/uapi/linux/in_route.h
new file mode 100644
index 0000000..b261b8c
--- /dev/null
+++ b/include/uapi/linux/in_route.h
@@ -0,0 +1,32 @@
+#ifndef _LINUX_IN_ROUTE_H
+#define _LINUX_IN_ROUTE_H
+
+/* IPv4 routing cache flags */
+
+#define RTCF_DEAD	RTNH_F_DEAD
+#define RTCF_ONLINK	RTNH_F_ONLINK
+
+/* Obsolete flag. About to be deleted */
+#define RTCF_NOPMTUDISC RTM_F_NOPMTUDISC
+
+#define RTCF_NOTIFY	0x00010000
+#define RTCF_DIRECTDST	0x00020000 /* unused */
+#define RTCF_REDIRECTED	0x00040000
+#define RTCF_TPROXY	0x00080000 /* unused */
+
+#define RTCF_FAST	0x00200000 /* unused */
+#define RTCF_MASQ	0x00400000 /* unused */
+#define RTCF_SNAT	0x00800000 /* unused */
+#define RTCF_DOREDIRECT 0x01000000
+#define RTCF_DIRECTSRC	0x04000000
+#define RTCF_DNAT	0x08000000
+#define RTCF_BROADCAST	0x10000000
+#define RTCF_MULTICAST	0x20000000
+#define RTCF_REJECT	0x40000000 /* unused */
+#define RTCF_LOCAL	0x80000000
+
+#define RTCF_NAT	(RTCF_DNAT|RTCF_SNAT)
+
+#define RT_TOS(tos)	((tos)&IPTOS_TOS_MASK)
+
+#endif /* _LINUX_IN_ROUTE_H */
diff --git a/include/uapi/linux/inet_diag.h b/include/uapi/linux/inet_diag.h
new file mode 100644
index 0000000..bada4d7
--- /dev/null
+++ b/include/uapi/linux/inet_diag.h
@@ -0,0 +1,196 @@
+#ifndef _INET_DIAG_H_
+#define _INET_DIAG_H_
+
+#include <linux/types.h>
+
+/* Just some random number */
+#define TCPDIAG_GETSOCK 18
+#define DCCPDIAG_GETSOCK 19
+
+#define INET_DIAG_GETSOCK_MAX 24
+
+/* Socket identity */
+struct inet_diag_sockid {
+	__be16	idiag_sport;
+	__be16	idiag_dport;
+	__be32	idiag_src[4];
+	__be32	idiag_dst[4];
+	__u32	idiag_if;
+	__u32	idiag_cookie[2];
+#define INET_DIAG_NOCOOKIE (~0U)
+};
+
+/* Request structure */
+
+struct inet_diag_req {
+	__u8	idiag_family;		/* Family of addresses. */
+	__u8	idiag_src_len;
+	__u8	idiag_dst_len;
+	__u8	idiag_ext;		/* Query extended information */
+
+	struct inet_diag_sockid id;
+
+	__u32	idiag_states;		/* States to dump */
+	__u32	idiag_dbs;		/* Tables to dump (NI) */
+};
+
+struct inet_diag_req_v2 {
+	__u8	sdiag_family;
+	__u8	sdiag_protocol;
+	__u8	idiag_ext;
+	__u8	pad;
+	__u32	idiag_states;
+	struct inet_diag_sockid id;
+};
+
+/*
+ * SOCK_RAW sockets require the underlied protocol to be
+ * additionally specified so we can use @pad member for
+ * this, but we can't rename it because userspace programs
+ * still may depend on this name. Instead lets use another
+ * structure definition as an alias for struct
+ * @inet_diag_req_v2.
+ */
+struct inet_diag_req_raw {
+	__u8	sdiag_family;
+	__u8	sdiag_protocol;
+	__u8	idiag_ext;
+	__u8	sdiag_raw_protocol;
+	__u32	idiag_states;
+	struct inet_diag_sockid id;
+};
+
+enum {
+	INET_DIAG_REQ_NONE,
+	INET_DIAG_REQ_BYTECODE,
+};
+
+#define INET_DIAG_REQ_MAX INET_DIAG_REQ_BYTECODE
+
+/* Bytecode is sequence of 4 byte commands followed by variable arguments.
+ * All the commands identified by "code" are conditional jumps forward:
+ * to offset cc+"yes" or to offset cc+"no". "yes" is supposed to be
+ * length of the command and its arguments.
+ */
+ 
+struct inet_diag_bc_op {
+	unsigned char	code;
+	unsigned char	yes;
+	unsigned short	no;
+};
+
+enum {
+	INET_DIAG_BC_NOP,
+	INET_DIAG_BC_JMP,
+	INET_DIAG_BC_S_GE,
+	INET_DIAG_BC_S_LE,
+	INET_DIAG_BC_D_GE,
+	INET_DIAG_BC_D_LE,
+	INET_DIAG_BC_AUTO,
+	INET_DIAG_BC_S_COND,
+	INET_DIAG_BC_D_COND,
+	INET_DIAG_BC_DEV_COND,   /* u32 ifindex */
+	INET_DIAG_BC_MARK_COND,
+};
+
+struct inet_diag_hostcond {
+	__u8	family;
+	__u8	prefix_len;
+	int	port;
+	__be32	addr[0];
+};
+
+struct inet_diag_markcond {
+	__u32 mark;
+	__u32 mask;
+};
+
+/* Base info structure. It contains socket identity (addrs/ports/cookie)
+ * and, alas, the information shown by netstat. */
+struct inet_diag_msg {
+	__u8	idiag_family;
+	__u8	idiag_state;
+	__u8	idiag_timer;
+	__u8	idiag_retrans;
+
+	struct inet_diag_sockid id;
+
+	__u32	idiag_expires;
+	__u32	idiag_rqueue;
+	__u32	idiag_wqueue;
+	__u32	idiag_uid;
+	__u32	idiag_inode;
+};
+
+/* Extensions */
+
+enum {
+	INET_DIAG_NONE,
+	INET_DIAG_MEMINFO,
+	INET_DIAG_INFO,
+	INET_DIAG_VEGASINFO,
+	INET_DIAG_CONG,
+	INET_DIAG_TOS,
+	INET_DIAG_TCLASS,
+	INET_DIAG_SKMEMINFO,
+	INET_DIAG_SHUTDOWN,
+	INET_DIAG_DCTCPINFO,
+	INET_DIAG_PROTOCOL,  /* response attribute only */
+	INET_DIAG_SKV6ONLY,
+	INET_DIAG_LOCALS,
+	INET_DIAG_PEERS,
+	INET_DIAG_PAD,
+	INET_DIAG_MARK,
+	INET_DIAG_BBRINFO,
+	INET_DIAG_CLASS_ID,
+	INET_DIAG_MD5SIG,
+	__INET_DIAG_MAX,
+};
+
+#define INET_DIAG_MAX (__INET_DIAG_MAX - 1)
+
+/* INET_DIAG_MEM */
+
+struct inet_diag_meminfo {
+	__u32	idiag_rmem;
+	__u32	idiag_wmem;
+	__u32	idiag_fmem;
+	__u32	idiag_tmem;
+};
+
+/* INET_DIAG_VEGASINFO */
+
+struct tcpvegas_info {
+	__u32	tcpv_enabled;
+	__u32	tcpv_rttcnt;
+	__u32	tcpv_rtt;
+	__u32	tcpv_minrtt;
+};
+
+/* INET_DIAG_DCTCPINFO */
+
+struct tcp_dctcp_info {
+	__u16	dctcp_enabled;
+	__u16	dctcp_ce_state;
+	__u32	dctcp_alpha;
+	__u32	dctcp_ab_ecn;
+	__u32	dctcp_ab_tot;
+};
+
+/* INET_DIAG_BBRINFO */
+
+struct tcp_bbr_info {
+	/* u64 bw: max-filtered BW (app throughput) estimate in Byte per sec: */
+	__u32	bbr_bw_lo;		/* lower 32 bits of bw */
+	__u32	bbr_bw_hi;		/* upper 32 bits of bw */
+	__u32	bbr_min_rtt;		/* min-filtered RTT in uSec */
+	__u32	bbr_pacing_gain;	/* pacing gain shifted left 8 bits */
+	__u32	bbr_cwnd_gain;		/* cwnd gain shifted left 8 bits */
+};
+
+union tcp_cc_info {
+	struct tcpvegas_info	vegas;
+	struct tcp_dctcp_info	dctcp;
+	struct tcp_bbr_info	bbr;
+};
+#endif /* _INET_DIAG_H_ */
diff --git a/include/uapi/linux/ip.h b/include/uapi/linux/ip.h
new file mode 100644
index 0000000..1907284
--- /dev/null
+++ b/include/uapi/linux/ip.h
@@ -0,0 +1,175 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Definitions for the IP protocol.
+ *
+ * Version:	@(#)ip.h	1.0.2	04/28/93
+ *
+ * Authors:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_IP_H
+#define _LINUX_IP_H
+#include <linux/types.h>
+#include <asm/byteorder.h>
+
+#define IPTOS_TOS_MASK		0x1E
+#define IPTOS_TOS(tos)		((tos)&IPTOS_TOS_MASK)
+#define	IPTOS_LOWDELAY		0x10
+#define	IPTOS_THROUGHPUT	0x08
+#define	IPTOS_RELIABILITY	0x04
+#define	IPTOS_MINCOST		0x02
+
+#define IPTOS_PREC_MASK		0xE0
+#define IPTOS_PREC(tos)		((tos)&IPTOS_PREC_MASK)
+#define IPTOS_PREC_NETCONTROL           0xe0
+#define IPTOS_PREC_INTERNETCONTROL      0xc0
+#define IPTOS_PREC_CRITIC_ECP           0xa0
+#define IPTOS_PREC_FLASHOVERRIDE        0x80
+#define IPTOS_PREC_FLASH                0x60
+#define IPTOS_PREC_IMMEDIATE            0x40
+#define IPTOS_PREC_PRIORITY             0x20
+#define IPTOS_PREC_ROUTINE              0x00
+
+
+/* IP options */
+#define IPOPT_COPY		0x80
+#define IPOPT_CLASS_MASK	0x60
+#define IPOPT_NUMBER_MASK	0x1f
+
+#define	IPOPT_COPIED(o)		((o)&IPOPT_COPY)
+#define	IPOPT_CLASS(o)		((o)&IPOPT_CLASS_MASK)
+#define	IPOPT_NUMBER(o)		((o)&IPOPT_NUMBER_MASK)
+
+#define	IPOPT_CONTROL		0x00
+#define	IPOPT_RESERVED1		0x20
+#define	IPOPT_MEASUREMENT	0x40
+#define	IPOPT_RESERVED2		0x60
+
+#define IPOPT_END	(0 |IPOPT_CONTROL)
+#define IPOPT_NOOP	(1 |IPOPT_CONTROL)
+#define IPOPT_SEC	(2 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_LSRR	(3 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_TIMESTAMP	(4 |IPOPT_MEASUREMENT)
+#define IPOPT_CIPSO	(6 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_RR	(7 |IPOPT_CONTROL)
+#define IPOPT_SID	(8 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_SSRR	(9 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_RA	(20|IPOPT_CONTROL|IPOPT_COPY)
+
+#define IPVERSION	4
+#define MAXTTL		255
+#define IPDEFTTL	64
+
+#define IPOPT_OPTVAL 0
+#define IPOPT_OLEN   1
+#define IPOPT_OFFSET 2
+#define IPOPT_MINOFF 4
+#define MAX_IPOPTLEN 40
+#define IPOPT_NOP IPOPT_NOOP
+#define IPOPT_EOL IPOPT_END
+#define IPOPT_TS  IPOPT_TIMESTAMP
+
+#define	IPOPT_TS_TSONLY		0		/* timestamps only */
+#define	IPOPT_TS_TSANDADDR	1		/* timestamps and addresses */
+#define	IPOPT_TS_PRESPEC	3		/* specified modules only */
+
+#define IPV4_BEET_PHMAXLEN 8
+
+struct iphdr {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8	ihl:4,
+		version:4;
+#elif defined (__BIG_ENDIAN_BITFIELD)
+	__u8	version:4,
+  		ihl:4;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif
+	__u8	tos;
+	__be16	tot_len;
+	__be16	id;
+	__be16	frag_off;
+	__u8	ttl;
+	__u8	protocol;
+	__sum16	check;
+	__be32	saddr;
+	__be32	daddr;
+	/*The options start here. */
+};
+
+
+struct ip_auth_hdr {
+	__u8  nexthdr;
+	__u8  hdrlen;		/* This one is measured in 32 bit units! */
+	__be16 reserved;
+	__be32 spi;
+	__be32 seq_no;		/* Sequence number */
+	__u8  auth_data[0];	/* Variable len but >=4. Mind the 64 bit alignment! */
+};
+
+struct ip_esp_hdr {
+	__be32 spi;
+	__be32 seq_no;		/* Sequence number */
+	__u8  enc_data[0];	/* Variable len but >=8. Mind the 64 bit alignment! */
+};
+
+struct ip_comp_hdr {
+	__u8 nexthdr;
+	__u8 flags;
+	__be16 cpi;
+};
+
+struct ip_beet_phdr {
+	__u8 nexthdr;
+	__u8 hdrlen;
+	__u8 padlen;
+	__u8 reserved;
+};
+
+/* index values for the variables in ipv4_devconf */
+enum
+{
+	IPV4_DEVCONF_FORWARDING=1,
+	IPV4_DEVCONF_MC_FORWARDING,
+	IPV4_DEVCONF_PROXY_ARP,
+	IPV4_DEVCONF_ACCEPT_REDIRECTS,
+	IPV4_DEVCONF_SECURE_REDIRECTS,
+	IPV4_DEVCONF_SEND_REDIRECTS,
+	IPV4_DEVCONF_SHARED_MEDIA,
+	IPV4_DEVCONF_RP_FILTER,
+	IPV4_DEVCONF_ACCEPT_SOURCE_ROUTE,
+	IPV4_DEVCONF_BOOTP_RELAY,
+	IPV4_DEVCONF_LOG_MARTIANS,
+	IPV4_DEVCONF_TAG,
+	IPV4_DEVCONF_ARPFILTER,
+	IPV4_DEVCONF_MEDIUM_ID,
+	IPV4_DEVCONF_NOXFRM,
+	IPV4_DEVCONF_NOPOLICY,
+	IPV4_DEVCONF_FORCE_IGMP_VERSION,
+	IPV4_DEVCONF_ARP_ANNOUNCE,
+	IPV4_DEVCONF_ARP_IGNORE,
+	IPV4_DEVCONF_PROMOTE_SECONDARIES,
+	IPV4_DEVCONF_ARP_ACCEPT,
+	IPV4_DEVCONF_ARP_NOTIFY,
+	IPV4_DEVCONF_ACCEPT_LOCAL,
+	IPV4_DEVCONF_SRC_VMARK,
+	IPV4_DEVCONF_PROXY_ARP_PVLAN,
+	IPV4_DEVCONF_ROUTE_LOCALNET,
+	IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL,
+	IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL,
+	IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN,
+	IPV4_DEVCONF_DROP_UNICAST_IN_L2_MULTICAST,
+	IPV4_DEVCONF_DROP_GRATUITOUS_ARP,
+	__IPV4_DEVCONF_MAX
+};
+
+#define IPV4_DEVCONF_MAX (__IPV4_DEVCONF_MAX - 1)
+
+#endif /* _LINUX_IP_H */
diff --git a/include/uapi/linux/ip6_tunnel.h b/include/uapi/linux/ip6_tunnel.h
new file mode 100644
index 0000000..425926c
--- /dev/null
+++ b/include/uapi/linux/ip6_tunnel.h
@@ -0,0 +1,53 @@
+#ifndef _IP6_TUNNEL_H
+#define _IP6_TUNNEL_H
+
+#include <linux/types.h>
+#include <linux/if.h>		/* For IFNAMSIZ. */
+#include <linux/in6.h>		/* For struct in6_addr. */
+
+#define IPV6_TLV_TNL_ENCAP_LIMIT 4
+#define IPV6_DEFAULT_TNL_ENCAP_LIMIT 4
+
+/* don't add encapsulation limit if one isn't present in inner packet */
+#define IP6_TNL_F_IGN_ENCAP_LIMIT 0x1
+/* copy the traffic class field from the inner packet */
+#define IP6_TNL_F_USE_ORIG_TCLASS 0x2
+/* copy the flowlabel from the inner packet */
+#define IP6_TNL_F_USE_ORIG_FLOWLABEL 0x4
+/* being used for Mobile IPv6 */
+#define IP6_TNL_F_MIP6_DEV 0x8
+/* copy DSCP from the outer packet */
+#define IP6_TNL_F_RCV_DSCP_COPY 0x10
+/* copy fwmark from inner packet */
+#define IP6_TNL_F_USE_ORIG_FWMARK 0x20
+
+struct ip6_tnl_parm {
+	char name[IFNAMSIZ];	/* name of tunnel device */
+	int link;		/* ifindex of underlying L2 interface */
+	__u8 proto;		/* tunnel protocol */
+	__u8 encap_limit;	/* encapsulation limit for tunnel */
+	__u8 hop_limit;		/* hop limit for tunnel */
+	__be32 flowinfo;	/* traffic class and flowlabel for tunnel */
+	__u32 flags;		/* tunnel flags */
+	struct in6_addr laddr;	/* local tunnel end-point address */
+	struct in6_addr raddr;	/* remote tunnel end-point address */
+};
+
+struct ip6_tnl_parm2 {
+	char name[IFNAMSIZ];	/* name of tunnel device */
+	int link;		/* ifindex of underlying L2 interface */
+	__u8 proto;		/* tunnel protocol */
+	__u8 encap_limit;	/* encapsulation limit for tunnel */
+	__u8 hop_limit;		/* hop limit for tunnel */
+	__be32 flowinfo;	/* traffic class and flowlabel for tunnel */
+	__u32 flags;		/* tunnel flags */
+	struct in6_addr laddr;	/* local tunnel end-point address */
+	struct in6_addr raddr;	/* remote tunnel end-point address */
+
+	__be16			i_flags;
+	__be16			o_flags;
+	__be32			i_key;
+	__be32			o_key;
+};
+
+#endif
diff --git a/include/uapi/linux/ipsec.h b/include/uapi/linux/ipsec.h
new file mode 100644
index 0000000..d17a630
--- /dev/null
+++ b/include/uapi/linux/ipsec.h
@@ -0,0 +1,47 @@
+#ifndef _LINUX_IPSEC_H
+#define _LINUX_IPSEC_H
+
+/* The definitions, required to talk to KAME racoon IKE. */
+
+#include <linux/pfkeyv2.h>
+
+#define IPSEC_PORT_ANY		0
+#define IPSEC_ULPROTO_ANY	255
+#define IPSEC_PROTO_ANY		255
+
+enum {
+	IPSEC_MODE_ANY		= 0,	/* We do not support this for SA */
+	IPSEC_MODE_TRANSPORT	= 1,
+	IPSEC_MODE_TUNNEL	= 2,
+	IPSEC_MODE_BEET         = 3
+};
+
+enum {
+	IPSEC_DIR_ANY		= 0,
+	IPSEC_DIR_INBOUND	= 1,
+	IPSEC_DIR_OUTBOUND	= 2,
+	IPSEC_DIR_FWD		= 3,	/* It is our own */
+	IPSEC_DIR_MAX		= 4,
+	IPSEC_DIR_INVALID	= 5
+};
+
+enum {
+	IPSEC_POLICY_DISCARD	= 0,
+	IPSEC_POLICY_NONE	= 1,
+	IPSEC_POLICY_IPSEC	= 2,
+	IPSEC_POLICY_ENTRUST	= 3,
+	IPSEC_POLICY_BYPASS	= 4
+};
+
+enum {
+	IPSEC_LEVEL_DEFAULT	= 0,
+	IPSEC_LEVEL_USE		= 1,
+	IPSEC_LEVEL_REQUIRE	= 2,
+	IPSEC_LEVEL_UNIQUE	= 3
+};
+
+#define IPSEC_MANUAL_REQID_MAX	0x3fff
+
+#define IPSEC_REPLAYWSIZE  32
+
+#endif	/* _LINUX_IPSEC_H */
diff --git a/include/uapi/linux/kernel.h b/include/uapi/linux/kernel.h
new file mode 100644
index 0000000..527549f
--- /dev/null
+++ b/include/uapi/linux/kernel.h
@@ -0,0 +1,14 @@
+#ifndef _LINUX_KERNEL_H
+#define _LINUX_KERNEL_H
+
+#include <linux/sysinfo.h>
+
+/*
+ * 'kernel.h' contains some often-used function prototypes etc
+ */
+#define __ALIGN_KERNEL(x, a)		__ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)
+#define __ALIGN_KERNEL_MASK(x, mask)	(((x) + (mask)) & ~(mask))
+
+#define __KERNEL_DIV_ROUND_UP(n, d) (((n) + (d) - 1) / (d))
+
+#endif /* _LINUX_KERNEL_H */
diff --git a/include/uapi/linux/l2tp.h b/include/uapi/linux/l2tp.h
new file mode 100644
index 0000000..8a80007
--- /dev/null
+++ b/include/uapi/linux/l2tp.h
@@ -0,0 +1,199 @@
+/*
+ * L2TP-over-IP socket for L2TPv3.
+ *
+ * Author: James Chapman <jchapman@katalix.com>
+ */
+
+#ifndef _LINUX_L2TP_H_
+#define _LINUX_L2TP_H_
+
+#include <linux/types.h>
+#include <linux/socket.h>
+#include <linux/in.h>
+#include <linux/in6.h>
+
+#define IPPROTO_L2TP		115
+
+/**
+ * struct sockaddr_l2tpip - the sockaddr structure for L2TP-over-IP sockets
+ * @l2tp_family:  address family number AF_L2TPIP.
+ * @l2tp_addr:    protocol specific address information
+ * @l2tp_conn_id: connection id of tunnel
+ */
+#define __SOCK_SIZE__	16		/* sizeof(struct sockaddr)	*/
+struct sockaddr_l2tpip {
+	/* The first fields must match struct sockaddr_in */
+	__kernel_sa_family_t l2tp_family; /* AF_INET */
+	__be16		l2tp_unused;	/* INET port number (unused) */
+	struct in_addr	l2tp_addr;	/* Internet address */
+
+	__u32		l2tp_conn_id;	/* Connection ID of tunnel */
+
+	/* Pad to size of `struct sockaddr'. */
+	unsigned char	__pad[__SOCK_SIZE__ -
+			      sizeof(__kernel_sa_family_t) -
+			      sizeof(__be16) - sizeof(struct in_addr) -
+			      sizeof(__u32)];
+};
+
+/**
+ * struct sockaddr_l2tpip6 - the sockaddr structure for L2TP-over-IPv6 sockets
+ * @l2tp_family:  address family number AF_L2TPIP.
+ * @l2tp_addr:    protocol specific address information
+ * @l2tp_conn_id: connection id of tunnel
+ */
+struct sockaddr_l2tpip6 {
+	/* The first fields must match struct sockaddr_in6 */
+	__kernel_sa_family_t l2tp_family; /* AF_INET6 */
+	__be16		l2tp_unused;	/* INET port number (unused) */
+	__be32		l2tp_flowinfo;	/* IPv6 flow information */
+	struct in6_addr	l2tp_addr;	/* IPv6 address */
+	__u32		l2tp_scope_id;	/* scope id (new in RFC2553) */
+	__u32		l2tp_conn_id;	/* Connection ID of tunnel */
+};
+
+/*****************************************************************************
+ *  NETLINK_GENERIC netlink family.
+ *****************************************************************************/
+
+/*
+ * Commands.
+ * Valid TLVs of each command are:-
+ * TUNNEL_CREATE	- CONN_ID, pw_type, netns, ifname, ipinfo, udpinfo, udpcsum, vlanid
+ * TUNNEL_DELETE	- CONN_ID
+ * TUNNEL_MODIFY	- CONN_ID, udpcsum
+ * TUNNEL_GETSTATS	- CONN_ID, (stats)
+ * TUNNEL_GET		- CONN_ID, (...)
+ * SESSION_CREATE	- SESSION_ID, PW_TYPE, offset, data_seq, cookie, peer_cookie, offset, l2spec
+ * SESSION_DELETE	- SESSION_ID
+ * SESSION_MODIFY	- SESSION_ID, data_seq
+ * SESSION_GET		- SESSION_ID, (...)
+ * SESSION_GETSTATS	- SESSION_ID, (stats)
+ *
+ */
+enum {
+	L2TP_CMD_NOOP,
+	L2TP_CMD_TUNNEL_CREATE,
+	L2TP_CMD_TUNNEL_DELETE,
+	L2TP_CMD_TUNNEL_MODIFY,
+	L2TP_CMD_TUNNEL_GET,
+	L2TP_CMD_SESSION_CREATE,
+	L2TP_CMD_SESSION_DELETE,
+	L2TP_CMD_SESSION_MODIFY,
+	L2TP_CMD_SESSION_GET,
+	__L2TP_CMD_MAX,
+};
+
+#define L2TP_CMD_MAX			(__L2TP_CMD_MAX - 1)
+
+/*
+ * ATTR types defined for L2TP
+ */
+enum {
+	L2TP_ATTR_NONE,			/* no data */
+	L2TP_ATTR_PW_TYPE,		/* u16, enum l2tp_pwtype */
+	L2TP_ATTR_ENCAP_TYPE,		/* u16, enum l2tp_encap_type */
+	L2TP_ATTR_OFFSET,		/* u16 */
+	L2TP_ATTR_DATA_SEQ,		/* u16 */
+	L2TP_ATTR_L2SPEC_TYPE,		/* u8, enum l2tp_l2spec_type */
+	L2TP_ATTR_L2SPEC_LEN,		/* u8, enum l2tp_l2spec_type */
+	L2TP_ATTR_PROTO_VERSION,	/* u8 */
+	L2TP_ATTR_IFNAME,		/* string */
+	L2TP_ATTR_CONN_ID,		/* u32 */
+	L2TP_ATTR_PEER_CONN_ID,		/* u32 */
+	L2TP_ATTR_SESSION_ID,		/* u32 */
+	L2TP_ATTR_PEER_SESSION_ID,	/* u32 */
+	L2TP_ATTR_UDP_CSUM,		/* u8 */
+	L2TP_ATTR_VLAN_ID,		/* u16 */
+	L2TP_ATTR_COOKIE,		/* 0, 4 or 8 bytes */
+	L2TP_ATTR_PEER_COOKIE,		/* 0, 4 or 8 bytes */
+	L2TP_ATTR_DEBUG,		/* u32, enum l2tp_debug_flags */
+	L2TP_ATTR_RECV_SEQ,		/* u8 */
+	L2TP_ATTR_SEND_SEQ,		/* u8 */
+	L2TP_ATTR_LNS_MODE,		/* u8 */
+	L2TP_ATTR_USING_IPSEC,		/* u8 */
+	L2TP_ATTR_RECV_TIMEOUT,		/* msec */
+	L2TP_ATTR_FD,			/* int */
+	L2TP_ATTR_IP_SADDR,		/* u32 */
+	L2TP_ATTR_IP_DADDR,		/* u32 */
+	L2TP_ATTR_UDP_SPORT,		/* u16 */
+	L2TP_ATTR_UDP_DPORT,		/* u16 */
+	L2TP_ATTR_MTU,			/* u16 */
+	L2TP_ATTR_MRU,			/* u16 */
+	L2TP_ATTR_STATS,		/* nested */
+	L2TP_ATTR_IP6_SADDR,		/* struct in6_addr */
+	L2TP_ATTR_IP6_DADDR,		/* struct in6_addr */
+	L2TP_ATTR_UDP_ZERO_CSUM6_TX,	/* flag */
+	L2TP_ATTR_UDP_ZERO_CSUM6_RX,	/* flag */
+	L2TP_ATTR_PAD,
+	__L2TP_ATTR_MAX,
+};
+
+#define L2TP_ATTR_MAX			(__L2TP_ATTR_MAX - 1)
+
+/* Nested in L2TP_ATTR_STATS */
+enum {
+	L2TP_ATTR_STATS_NONE,		/* no data */
+	L2TP_ATTR_TX_PACKETS,		/* u64 */
+	L2TP_ATTR_TX_BYTES,		/* u64 */
+	L2TP_ATTR_TX_ERRORS,		/* u64 */
+	L2TP_ATTR_RX_PACKETS,		/* u64 */
+	L2TP_ATTR_RX_BYTES,		/* u64 */
+	L2TP_ATTR_RX_SEQ_DISCARDS,	/* u64 */
+	L2TP_ATTR_RX_OOS_PACKETS,	/* u64 */
+	L2TP_ATTR_RX_ERRORS,		/* u64 */
+	L2TP_ATTR_STATS_PAD,
+	__L2TP_ATTR_STATS_MAX,
+};
+
+#define L2TP_ATTR_STATS_MAX		(__L2TP_ATTR_STATS_MAX - 1)
+
+enum l2tp_pwtype {
+	L2TP_PWTYPE_NONE = 0x0000,
+	L2TP_PWTYPE_ETH_VLAN = 0x0004,
+	L2TP_PWTYPE_ETH = 0x0005,
+	L2TP_PWTYPE_PPP = 0x0007,
+	L2TP_PWTYPE_PPP_AC = 0x0008,
+	L2TP_PWTYPE_IP = 0x000b,
+	__L2TP_PWTYPE_MAX
+};
+
+enum l2tp_l2spec_type {
+	L2TP_L2SPECTYPE_NONE,
+	L2TP_L2SPECTYPE_DEFAULT,
+};
+
+enum l2tp_encap_type {
+	L2TP_ENCAPTYPE_UDP,
+	L2TP_ENCAPTYPE_IP,
+};
+
+enum l2tp_seqmode {
+	L2TP_SEQ_NONE = 0,
+	L2TP_SEQ_IP = 1,
+	L2TP_SEQ_ALL = 2,
+};
+
+/**
+ * enum l2tp_debug_flags - debug message categories for L2TP tunnels/sessions
+ *
+ * @L2TP_MSG_DEBUG: verbose debug (if compiled in)
+ * @L2TP_MSG_CONTROL: userspace - kernel interface
+ * @L2TP_MSG_SEQ: sequence numbers
+ * @L2TP_MSG_DATA: data packets
+ */
+enum l2tp_debug_flags {
+	L2TP_MSG_DEBUG		= (1 << 0),
+	L2TP_MSG_CONTROL	= (1 << 1),
+	L2TP_MSG_SEQ		= (1 << 2),
+	L2TP_MSG_DATA		= (1 << 3),
+};
+
+/*
+ * NETLINK_GENERIC related info
+ */
+#define L2TP_GENL_NAME		"l2tp"
+#define L2TP_GENL_VERSION	0x1
+#define L2TP_GENL_MCGROUP       "l2tp"
+
+#endif /* _LINUX_L2TP_H_ */
diff --git a/include/uapi/linux/libc-compat.h b/include/uapi/linux/libc-compat.h
new file mode 100644
index 0000000..f38571d
--- /dev/null
+++ b/include/uapi/linux/libc-compat.h
@@ -0,0 +1,213 @@
+/*
+ * Compatibility interface for userspace libc header coordination:
+ *
+ * Define compatibility macros that are used to control the inclusion or
+ * exclusion of UAPI structures and definitions in coordination with another
+ * userspace C library.
+ *
+ * This header is intended to solve the problem of UAPI definitions that
+ * conflict with userspace definitions. If a UAPI header has such conflicting
+ * definitions then the solution is as follows:
+ *
+ * * Synchronize the UAPI header and the libc headers so either one can be
+ *   used and such that the ABI is preserved. If this is not possible then
+ *   no simple compatibility interface exists (you need to write translating
+ *   wrappers and rename things) and you can't use this interface.
+ *
+ * Then follow this process:
+ *
+ * (a) Include libc-compat.h in the UAPI header.
+ *      e.g. #include <linux/libc-compat.h>
+ *     This include must be as early as possible.
+ *
+ * (b) In libc-compat.h add enough code to detect that the comflicting
+ *     userspace libc header has been included first.
+ *
+ * (c) If the userspace libc header has been included first define a set of
+ *     guard macros of the form __UAPI_DEF_FOO and set their values to 1, else
+ *     set their values to 0.
+ *
+ * (d) Back in the UAPI header with the conflicting definitions, guard the
+ *     definitions with:
+ *     #if __UAPI_DEF_FOO
+ *       ...
+ *     #endif
+ *
+ * This fixes the situation where the linux headers are included *after* the
+ * libc headers. To fix the problem with the inclusion in the other order the
+ * userspace libc headers must be fixed like this:
+ *
+ * * For all definitions that conflict with kernel definitions wrap those
+ *   defines in the following:
+ *   #if !__UAPI_DEF_FOO
+ *     ...
+ *   #endif
+ *
+ * This prevents the redefinition of a construct already defined by the kernel.
+ */
+#ifndef _LIBC_COMPAT_H
+#define _LIBC_COMPAT_H
+
+/* We have included glibc headers... */
+#if defined(__GLIBC__)
+
+/* Coordinate with glibc net/if.h header. */
+#if defined(_NET_IF_H) && defined(__USE_MISC)
+
+/* GLIBC headers included first so don't define anything
+ * that would already be defined. */
+
+#define __UAPI_DEF_IF_IFCONF 0
+#define __UAPI_DEF_IF_IFMAP 0
+#define __UAPI_DEF_IF_IFNAMSIZ 0
+#define __UAPI_DEF_IF_IFREQ 0
+/* Everything up to IFF_DYNAMIC, matches net/if.h until glibc 2.23 */
+#define __UAPI_DEF_IF_NET_DEVICE_FLAGS 0
+/* For the future if glibc adds IFF_LOWER_UP, IFF_DORMANT and IFF_ECHO */
+#ifndef __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO
+#define __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO 1
+#endif /* __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO */
+
+#else /* _NET_IF_H */
+
+/* Linux headers included first, and we must define everything
+ * we need. The expectation is that glibc will check the
+ * __UAPI_DEF_* defines and adjust appropriately. */
+
+#define __UAPI_DEF_IF_IFCONF 1
+#define __UAPI_DEF_IF_IFMAP 1
+#define __UAPI_DEF_IF_IFNAMSIZ 1
+#define __UAPI_DEF_IF_IFREQ 1
+/* Everything up to IFF_DYNAMIC, matches net/if.h until glibc 2.23 */
+#define __UAPI_DEF_IF_NET_DEVICE_FLAGS 1
+/* For the future if glibc adds IFF_LOWER_UP, IFF_DORMANT and IFF_ECHO */
+#define __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO 1
+
+#endif /* _NET_IF_H */
+
+/* Coordinate with glibc netinet/in.h header. */
+#if defined(_NETINET_IN_H)
+
+/* GLIBC headers included first so don't define anything
+ * that would already be defined. */
+#define __UAPI_DEF_IN_ADDR		0
+#define __UAPI_DEF_IN_IPPROTO		0
+#define __UAPI_DEF_IN_PKTINFO		0
+#define __UAPI_DEF_IP_MREQ		0
+#define __UAPI_DEF_SOCKADDR_IN		0
+#define __UAPI_DEF_IN_CLASS		0
+
+#define __UAPI_DEF_IN6_ADDR		0
+/* The exception is the in6_addr macros which must be defined
+ * if the glibc code didn't define them. This guard matches
+ * the guard in glibc/inet/netinet/in.h which defines the
+ * additional in6_addr macros e.g. s6_addr16, and s6_addr32. */
+#if defined(__USE_MISC) || defined (__USE_GNU)
+#define __UAPI_DEF_IN6_ADDR_ALT		0
+#else
+#define __UAPI_DEF_IN6_ADDR_ALT		1
+#endif
+#define __UAPI_DEF_SOCKADDR_IN6		0
+#define __UAPI_DEF_IPV6_MREQ		0
+#define __UAPI_DEF_IPPROTO_V6		0
+#define __UAPI_DEF_IPV6_OPTIONS		0
+#define __UAPI_DEF_IN6_PKTINFO		0
+#define __UAPI_DEF_IP6_MTUINFO		0
+
+#else
+
+/* Linux headers included first, and we must define everything
+ * we need. The expectation is that glibc will check the
+ * __UAPI_DEF_* defines and adjust appropriately. */
+#define __UAPI_DEF_IN_ADDR		1
+#define __UAPI_DEF_IN_IPPROTO		1
+#define __UAPI_DEF_IN_PKTINFO		1
+#define __UAPI_DEF_IP_MREQ		1
+#define __UAPI_DEF_SOCKADDR_IN		1
+#define __UAPI_DEF_IN_CLASS		1
+
+#define __UAPI_DEF_IN6_ADDR		1
+/* We unconditionally define the in6_addr macros and glibc must
+ * coordinate. */
+#define __UAPI_DEF_IN6_ADDR_ALT		1
+#define __UAPI_DEF_SOCKADDR_IN6		1
+#define __UAPI_DEF_IPV6_MREQ		1
+#define __UAPI_DEF_IPPROTO_V6		1
+#define __UAPI_DEF_IPV6_OPTIONS		1
+#define __UAPI_DEF_IN6_PKTINFO		1
+#define __UAPI_DEF_IP6_MTUINFO		1
+
+#endif /* _NETINET_IN_H */
+
+/* Coordinate with glibc netipx/ipx.h header. */
+#if defined(__NETIPX_IPX_H)
+
+#define __UAPI_DEF_SOCKADDR_IPX			0
+#define __UAPI_DEF_IPX_ROUTE_DEFINITION		0
+#define __UAPI_DEF_IPX_INTERFACE_DEFINITION	0
+#define __UAPI_DEF_IPX_CONFIG_DATA		0
+#define __UAPI_DEF_IPX_ROUTE_DEF		0
+
+#else /* defined(__NETIPX_IPX_H) */
+
+#define __UAPI_DEF_SOCKADDR_IPX			1
+#define __UAPI_DEF_IPX_ROUTE_DEFINITION		1
+#define __UAPI_DEF_IPX_INTERFACE_DEFINITION	1
+#define __UAPI_DEF_IPX_CONFIG_DATA		1
+#define __UAPI_DEF_IPX_ROUTE_DEF		1
+
+#endif /* defined(__NETIPX_IPX_H) */
+
+/* Definitions for xattr.h */
+#if defined(_SYS_XATTR_H)
+#define __UAPI_DEF_XATTR		0
+#else
+#define __UAPI_DEF_XATTR		1
+#endif
+
+/* If we did not see any headers from any supported C libraries,
+ * or we are being included in the kernel, then define everything
+ * that we need. */
+#else /* !defined(__GLIBC__) */
+
+/* Definitions for if.h */
+#define __UAPI_DEF_IF_IFCONF 1
+#define __UAPI_DEF_IF_IFMAP 1
+#define __UAPI_DEF_IF_IFNAMSIZ 1
+#define __UAPI_DEF_IF_IFREQ 1
+/* Everything up to IFF_DYNAMIC, matches net/if.h until glibc 2.23 */
+#define __UAPI_DEF_IF_NET_DEVICE_FLAGS 1
+/* For the future if glibc adds IFF_LOWER_UP, IFF_DORMANT and IFF_ECHO */
+#define __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO 1
+
+/* Definitions for in.h */
+#define __UAPI_DEF_IN_ADDR		1
+#define __UAPI_DEF_IN_IPPROTO		1
+#define __UAPI_DEF_IN_PKTINFO		1
+#define __UAPI_DEF_IP_MREQ		1
+#define __UAPI_DEF_SOCKADDR_IN		1
+#define __UAPI_DEF_IN_CLASS		1
+
+/* Definitions for in6.h */
+#define __UAPI_DEF_IN6_ADDR		1
+#define __UAPI_DEF_IN6_ADDR_ALT		1
+#define __UAPI_DEF_SOCKADDR_IN6		1
+#define __UAPI_DEF_IPV6_MREQ		1
+#define __UAPI_DEF_IPPROTO_V6		1
+#define __UAPI_DEF_IPV6_OPTIONS		1
+#define __UAPI_DEF_IN6_PKTINFO		1
+#define __UAPI_DEF_IP6_MTUINFO		1
+
+/* Definitions for ipx.h */
+#define __UAPI_DEF_SOCKADDR_IPX			1
+#define __UAPI_DEF_IPX_ROUTE_DEFINITION		1
+#define __UAPI_DEF_IPX_INTERFACE_DEFINITION	1
+#define __UAPI_DEF_IPX_CONFIG_DATA		1
+#define __UAPI_DEF_IPX_ROUTE_DEF		1
+
+/* Definitions for xattr.h */
+#define __UAPI_DEF_XATTR		1
+
+#endif /* __GLIBC__ */
+
+#endif /* _LIBC_COMPAT_H */
diff --git a/include/uapi/linux/limits.h b/include/uapi/linux/limits.h
new file mode 100644
index 0000000..2d0f941
--- /dev/null
+++ b/include/uapi/linux/limits.h
@@ -0,0 +1,20 @@
+#ifndef _LINUX_LIMITS_H
+#define _LINUX_LIMITS_H
+
+#define NR_OPEN	        1024
+
+#define NGROUPS_MAX    65536	/* supplemental group IDs are available */
+#define ARG_MAX       131072	/* # bytes of args + environ for exec() */
+#define LINK_MAX         127	/* # links a file may have */
+#define MAX_CANON        255	/* size of the canonical input queue */
+#define MAX_INPUT        255	/* size of the type-ahead buffer */
+#define NAME_MAX         255	/* # chars in a file name */
+#define PATH_MAX        4096	/* # chars in a path name including nul */
+#define PIPE_BUF        4096	/* # bytes in atomic write to a pipe */
+#define XATTR_NAME_MAX   255	/* # chars in an extended attribute name */
+#define XATTR_SIZE_MAX 65536	/* size of an extended attribute value (64k) */
+#define XATTR_LIST_MAX 65536	/* size of extended attribute namelist (64k) */
+
+#define RTSIG_MAX	  32
+
+#endif
diff --git a/include/uapi/linux/lwtunnel.h b/include/uapi/linux/lwtunnel.h
new file mode 100644
index 0000000..3298426
--- /dev/null
+++ b/include/uapi/linux/lwtunnel.h
@@ -0,0 +1,70 @@
+#ifndef _LWTUNNEL_H_
+#define _LWTUNNEL_H_
+
+#include <linux/types.h>
+
+enum lwtunnel_encap_types {
+	LWTUNNEL_ENCAP_NONE,
+	LWTUNNEL_ENCAP_MPLS,
+	LWTUNNEL_ENCAP_IP,
+	LWTUNNEL_ENCAP_ILA,
+	LWTUNNEL_ENCAP_IP6,
+	LWTUNNEL_ENCAP_SEG6,
+	LWTUNNEL_ENCAP_BPF,
+	LWTUNNEL_ENCAP_SEG6_LOCAL,
+	__LWTUNNEL_ENCAP_MAX,
+};
+
+#define LWTUNNEL_ENCAP_MAX (__LWTUNNEL_ENCAP_MAX - 1)
+
+enum lwtunnel_ip_t {
+	LWTUNNEL_IP_UNSPEC,
+	LWTUNNEL_IP_ID,
+	LWTUNNEL_IP_DST,
+	LWTUNNEL_IP_SRC,
+	LWTUNNEL_IP_TTL,
+	LWTUNNEL_IP_TOS,
+	LWTUNNEL_IP_FLAGS,
+	LWTUNNEL_IP_PAD,
+	__LWTUNNEL_IP_MAX,
+};
+
+#define LWTUNNEL_IP_MAX (__LWTUNNEL_IP_MAX - 1)
+
+enum lwtunnel_ip6_t {
+	LWTUNNEL_IP6_UNSPEC,
+	LWTUNNEL_IP6_ID,
+	LWTUNNEL_IP6_DST,
+	LWTUNNEL_IP6_SRC,
+	LWTUNNEL_IP6_HOPLIMIT,
+	LWTUNNEL_IP6_TC,
+	LWTUNNEL_IP6_FLAGS,
+	LWTUNNEL_IP6_PAD,
+	__LWTUNNEL_IP6_MAX,
+};
+
+#define LWTUNNEL_IP6_MAX (__LWTUNNEL_IP6_MAX - 1)
+
+enum {
+	LWT_BPF_PROG_UNSPEC,
+	LWT_BPF_PROG_FD,
+	LWT_BPF_PROG_NAME,
+	__LWT_BPF_PROG_MAX,
+};
+
+#define LWT_BPF_PROG_MAX (__LWT_BPF_PROG_MAX - 1)
+
+enum {
+	LWT_BPF_UNSPEC,
+	LWT_BPF_IN,
+	LWT_BPF_OUT,
+	LWT_BPF_XMIT,
+	LWT_BPF_XMIT_HEADROOM,
+	__LWT_BPF_MAX,
+};
+
+#define LWT_BPF_MAX (__LWT_BPF_MAX - 1)
+
+#define LWT_BPF_MAX_HEADROOM 256
+
+#endif /* _LWTUNNEL_H_ */
diff --git a/include/uapi/linux/magic.h b/include/uapi/linux/magic.h
new file mode 100644
index 0000000..e439565
--- /dev/null
+++ b/include/uapi/linux/magic.h
@@ -0,0 +1,91 @@
+#ifndef __LINUX_MAGIC_H__
+#define __LINUX_MAGIC_H__
+
+#define ADFS_SUPER_MAGIC	0xadf5
+#define AFFS_SUPER_MAGIC	0xadff
+#define AFS_SUPER_MAGIC                0x5346414F
+#define AUTOFS_SUPER_MAGIC	0x0187
+#define CODA_SUPER_MAGIC	0x73757245
+#define CRAMFS_MAGIC		0x28cd3d45	/* some random number */
+#define CRAMFS_MAGIC_WEND	0x453dcd28	/* magic number with the wrong endianess */
+#define DEBUGFS_MAGIC          0x64626720
+#define SECURITYFS_MAGIC	0x73636673
+#define SELINUX_MAGIC		0xf97cff8c
+#define SMACK_MAGIC		0x43415d53	/* "SMAC" */
+#define RAMFS_MAGIC		0x858458f6	/* some random number */
+#define TMPFS_MAGIC		0x01021994
+#define HUGETLBFS_MAGIC 	0x958458f6	/* some random number */
+#define SQUASHFS_MAGIC		0x73717368
+#define ECRYPTFS_SUPER_MAGIC	0xf15f
+#define EFS_SUPER_MAGIC		0x414A53
+#define EXT2_SUPER_MAGIC	0xEF53
+#define EXT3_SUPER_MAGIC	0xEF53
+#define XENFS_SUPER_MAGIC	0xabba1974
+#define EXT4_SUPER_MAGIC	0xEF53
+#define BTRFS_SUPER_MAGIC	0x9123683E
+#define NILFS_SUPER_MAGIC	0x3434
+#define F2FS_SUPER_MAGIC	0xF2F52010
+#define HPFS_SUPER_MAGIC	0xf995e849
+#define ISOFS_SUPER_MAGIC	0x9660
+#define JFFS2_SUPER_MAGIC	0x72b6
+#define PSTOREFS_MAGIC		0x6165676C
+#define EFIVARFS_MAGIC		0xde5e81e4
+#define HOSTFS_SUPER_MAGIC	0x00c0ffee
+#define OVERLAYFS_SUPER_MAGIC	0x794c7630
+
+#define MINIX_SUPER_MAGIC	0x137F		/* minix v1 fs, 14 char names */
+#define MINIX_SUPER_MAGIC2	0x138F		/* minix v1 fs, 30 char names */
+#define MINIX2_SUPER_MAGIC	0x2468		/* minix v2 fs, 14 char names */
+#define MINIX2_SUPER_MAGIC2	0x2478		/* minix v2 fs, 30 char names */
+#define MINIX3_SUPER_MAGIC	0x4d5a		/* minix v3 fs, 60 char names */
+
+#define MSDOS_SUPER_MAGIC	0x4d44		/* MD */
+#define NCP_SUPER_MAGIC		0x564c		/* Guess, what 0x564c is :-) */
+#define NFS_SUPER_MAGIC		0x6969
+#define OCFS2_SUPER_MAGIC	0x7461636f
+#define OPENPROM_SUPER_MAGIC	0x9fa1
+#define QNX4_SUPER_MAGIC	0x002f		/* qnx4 fs detection */
+#define QNX6_SUPER_MAGIC	0x68191122	/* qnx6 fs detection */
+
+#define REISERFS_SUPER_MAGIC	0x52654973	/* used by gcc */
+					/* used by file system utilities that
+	                                   look at the superblock, etc.  */
+#define REISERFS_SUPER_MAGIC_STRING	"ReIsErFs"
+#define REISER2FS_SUPER_MAGIC_STRING	"ReIsEr2Fs"
+#define REISER2FS_JR_SUPER_MAGIC_STRING	"ReIsEr3Fs"
+
+#define SMB_SUPER_MAGIC		0x517B
+#define CGROUP_SUPER_MAGIC	0x27e0eb
+#define CGROUP2_SUPER_MAGIC	0x63677270
+
+#define RDTGROUP_SUPER_MAGIC	0x7655821
+
+#define STACK_END_MAGIC		0x57AC6E9D
+
+#define TRACEFS_MAGIC          0x74726163
+
+#define V9FS_MAGIC		0x01021997
+
+#define BDEVFS_MAGIC            0x62646576
+#define DAXFS_MAGIC             0x64646178
+#define BINFMTFS_MAGIC          0x42494e4d
+#define DEVPTS_SUPER_MAGIC	0x1cd1
+#define FUTEXFS_SUPER_MAGIC	0xBAD1DEA
+#define PIPEFS_MAGIC            0x50495045
+#define PROC_SUPER_MAGIC	0x9fa0
+#define SOCKFS_MAGIC		0x534F434B
+#define SYSFS_MAGIC		0x62656572
+#define USBDEVICE_SUPER_MAGIC	0x9fa2
+#define MTD_INODE_FS_MAGIC      0x11307854
+#define ANON_INODE_FS_MAGIC	0x09041934
+#define BTRFS_TEST_MAGIC	0x73727279
+#define NSFS_MAGIC		0x6e736673
+#define BPF_FS_MAGIC		0xcafe4a11
+#define AAFS_MAGIC		0x5a3c69f0
+
+/* Since UDF 2.01 is ISO 13346 based... */
+#define UDF_SUPER_MAGIC		0x15013346
+#define BALLOON_KVM_MAGIC	0x13661366
+#define ZSMALLOC_MAGIC		0x58295829
+
+#endif /* __LINUX_MAGIC_H__ */
diff --git a/include/uapi/linux/mpls.h b/include/uapi/linux/mpls.h
new file mode 100644
index 0000000..bf5b625
--- /dev/null
+++ b/include/uapi/linux/mpls.h
@@ -0,0 +1,76 @@
+#ifndef _MPLS_H
+#define _MPLS_H
+
+#include <linux/types.h>
+#include <asm/byteorder.h>
+
+/* Reference: RFC 5462, RFC 3032
+ *
+ *  0                   1                   2                   3
+ *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |                Label                  | TC  |S|       TTL     |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *
+ *	Label:  Label Value, 20 bits
+ *	TC:     Traffic Class field, 3 bits
+ *	S:      Bottom of Stack, 1 bit
+ *	TTL:    Time to Live, 8 bits
+ */
+
+struct mpls_label {
+	__be32 entry;
+};
+
+#define MPLS_LS_LABEL_MASK      0xFFFFF000
+#define MPLS_LS_LABEL_SHIFT     12
+#define MPLS_LS_TC_MASK         0x00000E00
+#define MPLS_LS_TC_SHIFT        9
+#define MPLS_LS_S_MASK          0x00000100
+#define MPLS_LS_S_SHIFT         8
+#define MPLS_LS_TTL_MASK        0x000000FF
+#define MPLS_LS_TTL_SHIFT       0
+
+/* Reserved labels */
+#define MPLS_LABEL_IPV4NULL		0 /* RFC3032 */
+#define MPLS_LABEL_RTALERT		1 /* RFC3032 */
+#define MPLS_LABEL_IPV6NULL		2 /* RFC3032 */
+#define MPLS_LABEL_IMPLNULL		3 /* RFC3032 */
+#define MPLS_LABEL_ENTROPY		7 /* RFC6790 */
+#define MPLS_LABEL_GAL			13 /* RFC5586 */
+#define MPLS_LABEL_OAMALERT		14 /* RFC3429 */
+#define MPLS_LABEL_EXTENSION		15 /* RFC7274 */
+
+#define MPLS_LABEL_FIRST_UNRESERVED	16 /* RFC3032 */
+
+/* These are embedded into IFLA_STATS_AF_SPEC:
+ * [IFLA_STATS_AF_SPEC]
+ * -> [AF_MPLS]
+ *    -> [MPLS_STATS_xxx]
+ *
+ * Attributes:
+ * [MPLS_STATS_LINK] = {
+ *     struct mpls_link_stats
+ * }
+ */
+enum {
+	MPLS_STATS_UNSPEC, /* also used as 64bit pad attribute */
+	MPLS_STATS_LINK,
+	__MPLS_STATS_MAX,
+};
+
+#define MPLS_STATS_MAX (__MPLS_STATS_MAX - 1)
+
+struct mpls_link_stats {
+	__u64	rx_packets;		/* total packets received	*/
+	__u64	tx_packets;		/* total packets transmitted	*/
+	__u64	rx_bytes;		/* total bytes received		*/
+	__u64	tx_bytes;		/* total bytes transmitted	*/
+	__u64	rx_errors;		/* bad packets received		*/
+	__u64	tx_errors;		/* packet transmit problems	*/
+	__u64	rx_dropped;		/* packet dropped on receive	*/
+	__u64	tx_dropped;		/* packet dropped on transmit	*/
+	__u64	rx_noroute;		/* no route for packet dest	*/
+};
+
+#endif /* _MPLS_H */
diff --git a/include/uapi/linux/mpls_iptunnel.h b/include/uapi/linux/mpls_iptunnel.h
new file mode 100644
index 0000000..1a0e57b
--- /dev/null
+++ b/include/uapi/linux/mpls_iptunnel.h
@@ -0,0 +1,30 @@
+/*
+ *	mpls tunnel api
+ *
+ *	Authors:
+ *		Roopa Prabhu <roopa@cumulusnetworks.com>
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _LINUX_MPLS_IPTUNNEL_H
+#define _LINUX_MPLS_IPTUNNEL_H
+
+/* MPLS tunnel attributes
+ * [RTA_ENCAP] = {
+ *     [MPLS_IPTUNNEL_DST]
+ *     [MPLS_IPTUNNEL_TTL]
+ * }
+ */
+enum {
+	MPLS_IPTUNNEL_UNSPEC,
+	MPLS_IPTUNNEL_DST,
+	MPLS_IPTUNNEL_TTL,
+	__MPLS_IPTUNNEL_MAX,
+};
+#define MPLS_IPTUNNEL_MAX (__MPLS_IPTUNNEL_MAX - 1)
+
+#endif /* _LINUX_MPLS_IPTUNNEL_H */
diff --git a/include/uapi/linux/neighbour.h b/include/uapi/linux/neighbour.h
new file mode 100644
index 0000000..3199d28
--- /dev/null
+++ b/include/uapi/linux/neighbour.h
@@ -0,0 +1,171 @@
+#ifndef __LINUX_NEIGHBOUR_H
+#define __LINUX_NEIGHBOUR_H
+
+#include <linux/types.h>
+#include <linux/netlink.h>
+
+struct ndmsg {
+	__u8		ndm_family;
+	__u8		ndm_pad1;
+	__u16		ndm_pad2;
+	__s32		ndm_ifindex;
+	__u16		ndm_state;
+	__u8		ndm_flags;
+	__u8		ndm_type;
+};
+
+enum {
+	NDA_UNSPEC,
+	NDA_DST,
+	NDA_LLADDR,
+	NDA_CACHEINFO,
+	NDA_PROBES,
+	NDA_VLAN,
+	NDA_PORT,
+	NDA_VNI,
+	NDA_IFINDEX,
+	NDA_MASTER,
+	NDA_LINK_NETNSID,
+	NDA_SRC_VNI,
+	__NDA_MAX
+};
+
+#define NDA_MAX (__NDA_MAX - 1)
+
+/*
+ *	Neighbor Cache Entry Flags
+ */
+
+#define NTF_USE		0x01
+#define NTF_SELF	0x02
+#define NTF_MASTER	0x04
+#define NTF_PROXY	0x08	/* == ATF_PUBL */
+#define NTF_EXT_LEARNED	0x10
+#define NTF_OFFLOADED   0x20
+#define NTF_ROUTER	0x80
+
+/*
+ *	Neighbor Cache Entry States.
+ */
+
+#define NUD_INCOMPLETE	0x01
+#define NUD_REACHABLE	0x02
+#define NUD_STALE	0x04
+#define NUD_DELAY	0x08
+#define NUD_PROBE	0x10
+#define NUD_FAILED	0x20
+
+/* Dummy states */
+#define NUD_NOARP	0x40
+#define NUD_PERMANENT	0x80
+#define NUD_NONE	0x00
+
+/* NUD_NOARP & NUD_PERMANENT are pseudostates, they never change
+   and make no address resolution or NUD.
+   NUD_PERMANENT also cannot be deleted by garbage collectors.
+ */
+
+struct nda_cacheinfo {
+	__u32		ndm_confirmed;
+	__u32		ndm_used;
+	__u32		ndm_updated;
+	__u32		ndm_refcnt;
+};
+
+/*****************************************************************
+ *		Neighbour tables specific messages.
+ *
+ * To retrieve the neighbour tables send RTM_GETNEIGHTBL with the
+ * NLM_F_DUMP flag set. Every neighbour table configuration is
+ * spread over multiple messages to avoid running into message
+ * size limits on systems with many interfaces. The first message
+ * in the sequence transports all not device specific data such as
+ * statistics, configuration, and the default parameter set.
+ * This message is followed by 0..n messages carrying device
+ * specific parameter sets.
+ * Although the ordering should be sufficient, NDTA_NAME can be
+ * used to identify sequences. The initial message can be identified
+ * by checking for NDTA_CONFIG. The device specific messages do
+ * not contain this TLV but have NDTPA_IFINDEX set to the
+ * corresponding interface index.
+ *
+ * To change neighbour table attributes, send RTM_SETNEIGHTBL
+ * with NDTA_NAME set. Changeable attribute include NDTA_THRESH[1-3],
+ * NDTA_GC_INTERVAL, and all TLVs in NDTA_PARMS unless marked
+ * otherwise. Device specific parameter sets can be changed by
+ * setting NDTPA_IFINDEX to the interface index of the corresponding
+ * device.
+ ****/
+
+struct ndt_stats {
+	__u64		ndts_allocs;
+	__u64		ndts_destroys;
+	__u64		ndts_hash_grows;
+	__u64		ndts_res_failed;
+	__u64		ndts_lookups;
+	__u64		ndts_hits;
+	__u64		ndts_rcv_probes_mcast;
+	__u64		ndts_rcv_probes_ucast;
+	__u64		ndts_periodic_gc_runs;
+	__u64		ndts_forced_gc_runs;
+	__u64		ndts_table_fulls;
+};
+
+enum {
+	NDTPA_UNSPEC,
+	NDTPA_IFINDEX,			/* u32, unchangeable */
+	NDTPA_REFCNT,			/* u32, read-only */
+	NDTPA_REACHABLE_TIME,		/* u64, read-only, msecs */
+	NDTPA_BASE_REACHABLE_TIME,	/* u64, msecs */
+	NDTPA_RETRANS_TIME,		/* u64, msecs */
+	NDTPA_GC_STALETIME,		/* u64, msecs */
+	NDTPA_DELAY_PROBE_TIME,		/* u64, msecs */
+	NDTPA_QUEUE_LEN,		/* u32 */
+	NDTPA_APP_PROBES,		/* u32 */
+	NDTPA_UCAST_PROBES,		/* u32 */
+	NDTPA_MCAST_PROBES,		/* u32 */
+	NDTPA_ANYCAST_DELAY,		/* u64, msecs */
+	NDTPA_PROXY_DELAY,		/* u64, msecs */
+	NDTPA_PROXY_QLEN,		/* u32 */
+	NDTPA_LOCKTIME,			/* u64, msecs */
+	NDTPA_QUEUE_LENBYTES,		/* u32 */
+	NDTPA_MCAST_REPROBES,		/* u32 */
+	NDTPA_PAD,
+	__NDTPA_MAX
+};
+#define NDTPA_MAX (__NDTPA_MAX - 1)
+
+struct ndtmsg {
+	__u8		ndtm_family;
+	__u8		ndtm_pad1;
+	__u16		ndtm_pad2;
+};
+
+struct ndt_config {
+	__u16		ndtc_key_len;
+	__u16		ndtc_entry_size;
+	__u32		ndtc_entries;
+	__u32		ndtc_last_flush;	/* delta to now in msecs */
+	__u32		ndtc_last_rand;		/* delta to now in msecs */
+	__u32		ndtc_hash_rnd;
+	__u32		ndtc_hash_mask;
+	__u32		ndtc_hash_chain_gc;
+	__u32		ndtc_proxy_qlen;
+};
+
+enum {
+	NDTA_UNSPEC,
+	NDTA_NAME,			/* char *, unchangeable */
+	NDTA_THRESH1,			/* u32 */
+	NDTA_THRESH2,			/* u32 */
+	NDTA_THRESH3,			/* u32 */
+	NDTA_CONFIG,			/* struct ndt_config, read-only */
+	NDTA_PARMS,			/* nested TLV NDTPA_* */
+	NDTA_STATS,			/* struct ndt_stats, read-only */
+	NDTA_GC_INTERVAL,		/* u64, msecs */
+	NDTA_PAD,
+	__NDTA_MAX
+};
+#define NDTA_MAX (__NDTA_MAX - 1)
+
+#endif
diff --git a/include/uapi/linux/net_namespace.h b/include/uapi/linux/net_namespace.h
new file mode 100644
index 0000000..9a92b7e
--- /dev/null
+++ b/include/uapi/linux/net_namespace.h
@@ -0,0 +1,23 @@
+/* Copyright (c) 2015 6WIND S.A.
+ * Author: Nicolas Dichtel <nicolas.dichtel@6wind.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+#ifndef _LINUX_NET_NAMESPACE_H_
+#define _LINUX_NET_NAMESPACE_H_
+
+/* Attributes of RTM_NEWNSID/RTM_GETNSID messages */
+enum {
+	NETNSA_NONE,
+#define NETNSA_NSID_NOT_ASSIGNED -1
+	NETNSA_NSID,
+	NETNSA_PID,
+	NETNSA_FD,
+	__NETNSA_MAX,
+};
+
+#define NETNSA_MAX		(__NETNSA_MAX - 1)
+
+#endif /* _LINUX_NET_NAMESPACE_H_ */
diff --git a/include/uapi/linux/netconf.h b/include/uapi/linux/netconf.h
new file mode 100644
index 0000000..4afbd7d
--- /dev/null
+++ b/include/uapi/linux/netconf.h
@@ -0,0 +1,28 @@
+#ifndef _LINUX_NETCONF_H_
+#define _LINUX_NETCONF_H_
+
+#include <linux/types.h>
+#include <linux/netlink.h>
+
+struct netconfmsg {
+	__u8	ncm_family;
+};
+
+enum {
+	NETCONFA_UNSPEC,
+	NETCONFA_IFINDEX,
+	NETCONFA_FORWARDING,
+	NETCONFA_RP_FILTER,
+	NETCONFA_MC_FORWARDING,
+	NETCONFA_PROXY_NEIGH,
+	NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN,
+	NETCONFA_INPUT,
+	__NETCONFA_MAX
+};
+#define NETCONFA_MAX	(__NETCONFA_MAX - 1)
+#define NETCONFA_ALL	-1
+
+#define NETCONFA_IFINDEX_ALL		-1
+#define NETCONFA_IFINDEX_DEFAULT	-2
+
+#endif /* _LINUX_NETCONF_H_ */
diff --git a/include/uapi/linux/netdevice.h b/include/uapi/linux/netdevice.h
new file mode 100644
index 0000000..66fceb4
--- /dev/null
+++ b/include/uapi/linux/netdevice.h
@@ -0,0 +1,65 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Definitions for the Interfaces handler.
+ *
+ * Version:	@(#)dev.h	1.0.10	08/12/93
+ *
+ * Authors:	Ross Biro
+ *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *		Corey Minyard <wf-rch!minyard@relay.EU.net>
+ *		Donald J. Becker, <becker@cesdis.gsfc.nasa.gov>
+ *		Alan Cox, <alan@lxorguk.ukuu.org.uk>
+ *		Bjorn Ekwall. <bj0rn@blox.se>
+ *              Pekka Riikonen <priikone@poseidon.pspt.fi>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ *		Moved to /usr/include/linux for NET3
+ */
+#ifndef _LINUX_NETDEVICE_H
+#define _LINUX_NETDEVICE_H
+
+#include <linux/if.h>
+#include <linux/if_ether.h>
+#include <linux/if_packet.h>
+#include <linux/if_link.h>
+
+
+#define MAX_ADDR_LEN	32		/* Largest hardware address length */
+
+/* Initial net device group. All devices belong to group 0 by default. */
+#define INIT_NETDEV_GROUP	0
+
+
+/* interface name assignment types (sysfs name_assign_type attribute) */
+#define NET_NAME_UNKNOWN	0	/* unknown origin (not exposed to userspace) */
+#define NET_NAME_ENUM		1	/* enumerated by kernel */
+#define NET_NAME_PREDICTABLE	2	/* predictably named by the kernel */
+#define NET_NAME_USER		3	/* provided by user-space */
+#define NET_NAME_RENAMED	4	/* renamed by user-space */
+
+/* Media selection options. */
+enum {
+        IF_PORT_UNKNOWN = 0,
+        IF_PORT_10BASE2,
+        IF_PORT_10BASET,
+        IF_PORT_AUI,
+        IF_PORT_100BASET,
+        IF_PORT_100BASETX,
+        IF_PORT_100BASEFX
+};
+
+/* hardware address assignment types */
+#define NET_ADDR_PERM		0	/* address is permanent (default) */
+#define NET_ADDR_RANDOM		1	/* address is generated randomly */
+#define NET_ADDR_STOLEN		2	/* address is stolen from other device */
+#define NET_ADDR_SET		3	/* address is set using
+					 * dev_set_mac_address() */
+
+#endif /* _LINUX_NETDEVICE_H */
diff --git a/include/uapi/linux/netfilter.h b/include/uapi/linux/netfilter.h
new file mode 100644
index 0000000..ff4a4a5
--- /dev/null
+++ b/include/uapi/linux/netfilter.h
@@ -0,0 +1,77 @@
+#ifndef __LINUX_NETFILTER_H
+#define __LINUX_NETFILTER_H
+
+#include <linux/types.h>
+
+#include <linux/in.h>
+#include <linux/in6.h>
+
+/* Responses from hook functions. */
+#define NF_DROP 0
+#define NF_ACCEPT 1
+#define NF_STOLEN 2
+#define NF_QUEUE 3
+#define NF_REPEAT 4
+#define NF_STOP 5	/* Deprecated, for userspace nf_queue compatibility. */
+#define NF_MAX_VERDICT NF_STOP
+
+/* we overload the higher bits for encoding auxiliary data such as the queue
+ * number or errno values. Not nice, but better than additional function
+ * arguments. */
+#define NF_VERDICT_MASK 0x000000ff
+
+/* extra verdict flags have mask 0x0000ff00 */
+#define NF_VERDICT_FLAG_QUEUE_BYPASS	0x00008000
+
+/* queue number (NF_QUEUE) or errno (NF_DROP) */
+#define NF_VERDICT_QMASK 0xffff0000
+#define NF_VERDICT_QBITS 16
+
+#define NF_QUEUE_NR(x) ((((x) << 16) & NF_VERDICT_QMASK) | NF_QUEUE)
+
+#define NF_DROP_ERR(x) (((-x) << 16) | NF_DROP)
+
+/* only for userspace compatibility */
+/* Generic cache responses from hook functions.
+   <= 0x2000 is used for protocol-flags. */
+#define NFC_UNKNOWN 0x4000
+#define NFC_ALTERED 0x8000
+
+/* NF_VERDICT_BITS should be 8 now, but userspace might break if this changes */
+#define NF_VERDICT_BITS 16
+
+enum nf_inet_hooks {
+	NF_INET_PRE_ROUTING,
+	NF_INET_LOCAL_IN,
+	NF_INET_FORWARD,
+	NF_INET_LOCAL_OUT,
+	NF_INET_POST_ROUTING,
+	NF_INET_NUMHOOKS
+};
+
+enum nf_dev_hooks {
+	NF_NETDEV_INGRESS,
+	NF_NETDEV_NUMHOOKS
+};
+
+enum {
+	NFPROTO_UNSPEC =  0,
+	NFPROTO_INET   =  1,
+	NFPROTO_IPV4   =  2,
+	NFPROTO_ARP    =  3,
+	NFPROTO_NETDEV =  5,
+	NFPROTO_BRIDGE =  7,
+	NFPROTO_IPV6   = 10,
+	NFPROTO_DECNET = 12,
+	NFPROTO_NUMPROTO,
+};
+
+union nf_inet_addr {
+	__u32		all[4];
+	__be32		ip;
+	__be32		ip6[4];
+	struct in_addr	in;
+	struct in6_addr	in6;
+};
+
+#endif /* __LINUX_NETFILTER_H */
diff --git a/include/uapi/linux/netfilter/ipset/ip_set.h b/include/uapi/linux/netfilter/ipset/ip_set.h
new file mode 100644
index 0000000..a6c96b0
--- /dev/null
+++ b/include/uapi/linux/netfilter/ipset/ip_set.h
@@ -0,0 +1,304 @@
+/* Copyright (C) 2000-2002 Joakim Axelsson <gozem@linux.nu>
+ *                         Patrick Schaaf <bof@bof.de>
+ *                         Martin Josefsson <gandalf@wlug.westbo.se>
+ * Copyright (C) 2003-2011 Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _IP_SET_H
+#define _IP_SET_H
+
+#include <linux/types.h>
+
+/* The protocol version */
+#define IPSET_PROTOCOL		6
+
+/* The max length of strings including NUL: set and type identifiers */
+#define IPSET_MAXNAMELEN	32
+
+/* The maximum permissible comment length we will accept over netlink */
+#define IPSET_MAX_COMMENT_SIZE	255
+
+/* Message types and commands */
+enum ipset_cmd {
+	IPSET_CMD_NONE,
+	IPSET_CMD_PROTOCOL,	/* 1: Return protocol version */
+	IPSET_CMD_CREATE,	/* 2: Create a new (empty) set */
+	IPSET_CMD_DESTROY,	/* 3: Destroy a (empty) set */
+	IPSET_CMD_FLUSH,	/* 4: Remove all elements from a set */
+	IPSET_CMD_RENAME,	/* 5: Rename a set */
+	IPSET_CMD_SWAP,		/* 6: Swap two sets */
+	IPSET_CMD_LIST,		/* 7: List sets */
+	IPSET_CMD_SAVE,		/* 8: Save sets */
+	IPSET_CMD_ADD,		/* 9: Add an element to a set */
+	IPSET_CMD_DEL,		/* 10: Delete an element from a set */
+	IPSET_CMD_TEST,		/* 11: Test an element in a set */
+	IPSET_CMD_HEADER,	/* 12: Get set header data only */
+	IPSET_CMD_TYPE,		/* 13: Get set type */
+	IPSET_MSG_MAX,		/* Netlink message commands */
+
+	/* Commands in userspace: */
+	IPSET_CMD_RESTORE = IPSET_MSG_MAX, /* 14: Enter restore mode */
+	IPSET_CMD_HELP,		/* 15: Get help */
+	IPSET_CMD_VERSION,	/* 16: Get program version */
+	IPSET_CMD_QUIT,		/* 17: Quit from interactive mode */
+
+	IPSET_CMD_MAX,
+
+	IPSET_CMD_COMMIT = IPSET_CMD_MAX, /* 18: Commit buffered commands */
+};
+
+/* Attributes at command level */
+enum {
+	IPSET_ATTR_UNSPEC,
+	IPSET_ATTR_PROTOCOL,	/* 1: Protocol version */
+	IPSET_ATTR_SETNAME,	/* 2: Name of the set */
+	IPSET_ATTR_TYPENAME,	/* 3: Typename */
+	IPSET_ATTR_SETNAME2 = IPSET_ATTR_TYPENAME, /* Setname at rename/swap */
+	IPSET_ATTR_REVISION,	/* 4: Settype revision */
+	IPSET_ATTR_FAMILY,	/* 5: Settype family */
+	IPSET_ATTR_FLAGS,	/* 6: Flags at command level */
+	IPSET_ATTR_DATA,	/* 7: Nested attributes */
+	IPSET_ATTR_ADT,		/* 8: Multiple data containers */
+	IPSET_ATTR_LINENO,	/* 9: Restore lineno */
+	IPSET_ATTR_PROTOCOL_MIN, /* 10: Minimal supported version number */
+	IPSET_ATTR_REVISION_MIN	= IPSET_ATTR_PROTOCOL_MIN, /* type rev min */
+	__IPSET_ATTR_CMD_MAX,
+};
+#define IPSET_ATTR_CMD_MAX	(__IPSET_ATTR_CMD_MAX - 1)
+
+/* CADT specific attributes */
+enum {
+	IPSET_ATTR_IP = IPSET_ATTR_UNSPEC + 1,
+	IPSET_ATTR_IP_FROM = IPSET_ATTR_IP,
+	IPSET_ATTR_IP_TO,	/* 2 */
+	IPSET_ATTR_CIDR,	/* 3 */
+	IPSET_ATTR_PORT,	/* 4 */
+	IPSET_ATTR_PORT_FROM = IPSET_ATTR_PORT,
+	IPSET_ATTR_PORT_TO,	/* 5 */
+	IPSET_ATTR_TIMEOUT,	/* 6 */
+	IPSET_ATTR_PROTO,	/* 7 */
+	IPSET_ATTR_CADT_FLAGS,	/* 8 */
+	IPSET_ATTR_CADT_LINENO = IPSET_ATTR_LINENO,	/* 9 */
+	IPSET_ATTR_MARK,	/* 10 */
+	IPSET_ATTR_MARKMASK,	/* 11 */
+	/* Reserve empty slots */
+	IPSET_ATTR_CADT_MAX = 16,
+	/* Create-only specific attributes */
+	IPSET_ATTR_GC,
+	IPSET_ATTR_HASHSIZE,
+	IPSET_ATTR_MAXELEM,
+	IPSET_ATTR_NETMASK,
+	IPSET_ATTR_PROBES,
+	IPSET_ATTR_RESIZE,
+	IPSET_ATTR_SIZE,
+	/* Kernel-only */
+	IPSET_ATTR_ELEMENTS,
+	IPSET_ATTR_REFERENCES,
+	IPSET_ATTR_MEMSIZE,
+
+	__IPSET_ATTR_CREATE_MAX,
+};
+#define IPSET_ATTR_CREATE_MAX	(__IPSET_ATTR_CREATE_MAX - 1)
+
+/* ADT specific attributes */
+enum {
+	IPSET_ATTR_ETHER = IPSET_ATTR_CADT_MAX + 1,
+	IPSET_ATTR_NAME,
+	IPSET_ATTR_NAMEREF,
+	IPSET_ATTR_IP2,
+	IPSET_ATTR_CIDR2,
+	IPSET_ATTR_IP2_TO,
+	IPSET_ATTR_IFACE,
+	IPSET_ATTR_BYTES,
+	IPSET_ATTR_PACKETS,
+	IPSET_ATTR_COMMENT,
+	IPSET_ATTR_SKBMARK,
+	IPSET_ATTR_SKBPRIO,
+	IPSET_ATTR_SKBQUEUE,
+	IPSET_ATTR_PAD,
+	__IPSET_ATTR_ADT_MAX,
+};
+#define IPSET_ATTR_ADT_MAX	(__IPSET_ATTR_ADT_MAX - 1)
+
+/* IP specific attributes */
+enum {
+	IPSET_ATTR_IPADDR_IPV4 = IPSET_ATTR_UNSPEC + 1,
+	IPSET_ATTR_IPADDR_IPV6,
+	__IPSET_ATTR_IPADDR_MAX,
+};
+#define IPSET_ATTR_IPADDR_MAX	(__IPSET_ATTR_IPADDR_MAX - 1)
+
+/* Error codes */
+enum ipset_errno {
+	IPSET_ERR_PRIVATE = 4096,
+	IPSET_ERR_PROTOCOL,
+	IPSET_ERR_FIND_TYPE,
+	IPSET_ERR_MAX_SETS,
+	IPSET_ERR_BUSY,
+	IPSET_ERR_EXIST_SETNAME2,
+	IPSET_ERR_TYPE_MISMATCH,
+	IPSET_ERR_EXIST,
+	IPSET_ERR_INVALID_CIDR,
+	IPSET_ERR_INVALID_NETMASK,
+	IPSET_ERR_INVALID_FAMILY,
+	IPSET_ERR_TIMEOUT,
+	IPSET_ERR_REFERENCED,
+	IPSET_ERR_IPADDR_IPV4,
+	IPSET_ERR_IPADDR_IPV6,
+	IPSET_ERR_COUNTER,
+	IPSET_ERR_COMMENT,
+	IPSET_ERR_INVALID_MARKMASK,
+	IPSET_ERR_SKBINFO,
+
+	/* Type specific error codes */
+	IPSET_ERR_TYPE_SPECIFIC = 4352,
+};
+
+/* Flags at command level or match/target flags, lower half of cmdattrs*/
+enum ipset_cmd_flags {
+	IPSET_FLAG_BIT_EXIST	= 0,
+	IPSET_FLAG_EXIST	= (1 << IPSET_FLAG_BIT_EXIST),
+	IPSET_FLAG_BIT_LIST_SETNAME = 1,
+	IPSET_FLAG_LIST_SETNAME	= (1 << IPSET_FLAG_BIT_LIST_SETNAME),
+	IPSET_FLAG_BIT_LIST_HEADER = 2,
+	IPSET_FLAG_LIST_HEADER	= (1 << IPSET_FLAG_BIT_LIST_HEADER),
+	IPSET_FLAG_BIT_SKIP_COUNTER_UPDATE = 3,
+	IPSET_FLAG_SKIP_COUNTER_UPDATE =
+		(1 << IPSET_FLAG_BIT_SKIP_COUNTER_UPDATE),
+	IPSET_FLAG_BIT_SKIP_SUBCOUNTER_UPDATE = 4,
+	IPSET_FLAG_SKIP_SUBCOUNTER_UPDATE =
+		(1 << IPSET_FLAG_BIT_SKIP_SUBCOUNTER_UPDATE),
+	IPSET_FLAG_BIT_MATCH_COUNTERS = 5,
+	IPSET_FLAG_MATCH_COUNTERS = (1 << IPSET_FLAG_BIT_MATCH_COUNTERS),
+	IPSET_FLAG_BIT_RETURN_NOMATCH = 7,
+	IPSET_FLAG_RETURN_NOMATCH = (1 << IPSET_FLAG_BIT_RETURN_NOMATCH),
+	IPSET_FLAG_BIT_MAP_SKBMARK = 8,
+	IPSET_FLAG_MAP_SKBMARK = (1 << IPSET_FLAG_BIT_MAP_SKBMARK),
+	IPSET_FLAG_BIT_MAP_SKBPRIO = 9,
+	IPSET_FLAG_MAP_SKBPRIO = (1 << IPSET_FLAG_BIT_MAP_SKBPRIO),
+	IPSET_FLAG_BIT_MAP_SKBQUEUE = 10,
+	IPSET_FLAG_MAP_SKBQUEUE = (1 << IPSET_FLAG_BIT_MAP_SKBQUEUE),
+	IPSET_FLAG_CMD_MAX = 15,
+};
+
+/* Flags at CADT attribute level, upper half of cmdattrs */
+enum ipset_cadt_flags {
+	IPSET_FLAG_BIT_BEFORE	= 0,
+	IPSET_FLAG_BEFORE	= (1 << IPSET_FLAG_BIT_BEFORE),
+	IPSET_FLAG_BIT_PHYSDEV	= 1,
+	IPSET_FLAG_PHYSDEV	= (1 << IPSET_FLAG_BIT_PHYSDEV),
+	IPSET_FLAG_BIT_NOMATCH	= 2,
+	IPSET_FLAG_NOMATCH	= (1 << IPSET_FLAG_BIT_NOMATCH),
+	IPSET_FLAG_BIT_WITH_COUNTERS = 3,
+	IPSET_FLAG_WITH_COUNTERS = (1 << IPSET_FLAG_BIT_WITH_COUNTERS),
+	IPSET_FLAG_BIT_WITH_COMMENT = 4,
+	IPSET_FLAG_WITH_COMMENT = (1 << IPSET_FLAG_BIT_WITH_COMMENT),
+	IPSET_FLAG_BIT_WITH_FORCEADD = 5,
+	IPSET_FLAG_WITH_FORCEADD = (1 << IPSET_FLAG_BIT_WITH_FORCEADD),
+	IPSET_FLAG_BIT_WITH_SKBINFO = 6,
+	IPSET_FLAG_WITH_SKBINFO = (1 << IPSET_FLAG_BIT_WITH_SKBINFO),
+	IPSET_FLAG_CADT_MAX	= 15,
+};
+
+/* The flag bits which correspond to the non-extension create flags */
+enum ipset_create_flags {
+	IPSET_CREATE_FLAG_BIT_FORCEADD = 0,
+	IPSET_CREATE_FLAG_FORCEADD = (1 << IPSET_CREATE_FLAG_BIT_FORCEADD),
+	IPSET_CREATE_FLAG_BIT_MAX = 7,
+};
+
+/* Commands with settype-specific attributes */
+enum ipset_adt {
+	IPSET_ADD,
+	IPSET_DEL,
+	IPSET_TEST,
+	IPSET_ADT_MAX,
+	IPSET_CREATE = IPSET_ADT_MAX,
+	IPSET_CADT_MAX,
+};
+
+/* Sets are identified by an index in kernel space. Tweak with ip_set_id_t
+ * and IPSET_INVALID_ID if you want to increase the max number of sets.
+ */
+typedef __u16 ip_set_id_t;
+
+#define IPSET_INVALID_ID		65535
+
+enum ip_set_dim {
+	IPSET_DIM_ZERO = 0,
+	IPSET_DIM_ONE,
+	IPSET_DIM_TWO,
+	IPSET_DIM_THREE,
+	/* Max dimension in elements.
+	 * If changed, new revision of iptables match/target is required.
+	 */
+	IPSET_DIM_MAX = 6,
+	/* Backward compatibility: set match revision 2 */
+	IPSET_BIT_RETURN_NOMATCH = 7,
+};
+
+/* Option flags for kernel operations */
+enum ip_set_kopt {
+	IPSET_INV_MATCH = (1 << IPSET_DIM_ZERO),
+	IPSET_DIM_ONE_SRC = (1 << IPSET_DIM_ONE),
+	IPSET_DIM_TWO_SRC = (1 << IPSET_DIM_TWO),
+	IPSET_DIM_THREE_SRC = (1 << IPSET_DIM_THREE),
+	IPSET_RETURN_NOMATCH = (1 << IPSET_BIT_RETURN_NOMATCH),
+};
+
+enum {
+	IPSET_COUNTER_NONE = 0,
+	IPSET_COUNTER_EQ,
+	IPSET_COUNTER_NE,
+	IPSET_COUNTER_LT,
+	IPSET_COUNTER_GT,
+};
+
+/* Backward compatibility for set match v3 */
+struct ip_set_counter_match0 {
+	__u8 op;
+	__u64 value;
+};
+
+struct ip_set_counter_match {
+	__aligned_u64 value;
+	__u8 op;
+};
+
+/* Interface to iptables/ip6tables */
+
+#define SO_IP_SET		83
+
+union ip_set_name_index {
+	char name[IPSET_MAXNAMELEN];
+	ip_set_id_t index;
+};
+
+#define IP_SET_OP_GET_BYNAME	0x00000006	/* Get set index by name */
+struct ip_set_req_get_set {
+	unsigned int op;
+	unsigned int version;
+	union ip_set_name_index set;
+};
+
+#define IP_SET_OP_GET_BYINDEX	0x00000007	/* Get set name by index */
+/* Uses ip_set_req_get_set */
+
+#define IP_SET_OP_GET_FNAME	0x00000008	/* Get set index and family */
+struct ip_set_req_get_set_family {
+	unsigned int op;
+	unsigned int version;
+	unsigned int family;
+	union ip_set_name_index set;
+};
+
+#define IP_SET_OP_VERSION	0x00000100	/* Ask kernel version */
+struct ip_set_req_version {
+	unsigned int op;
+	unsigned int version;
+};
+
+#endif /* _IP_SET_H */
diff --git a/include/uapi/linux/netfilter/x_tables.h b/include/uapi/linux/netfilter/x_tables.h
new file mode 100644
index 0000000..4120970
--- /dev/null
+++ b/include/uapi/linux/netfilter/x_tables.h
@@ -0,0 +1,185 @@
+#ifndef _X_TABLES_H
+#define _X_TABLES_H
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+#define XT_FUNCTION_MAXNAMELEN 30
+#define XT_EXTENSION_MAXNAMELEN 29
+#define XT_TABLE_MAXNAMELEN 32
+
+struct xt_entry_match {
+	union {
+		struct {
+			__u16 match_size;
+
+			/* Used by userspace */
+			char name[XT_EXTENSION_MAXNAMELEN];
+			__u8 revision;
+		} user;
+		struct {
+			__u16 match_size;
+
+			/* Used inside the kernel */
+			struct xt_match *match;
+		} kernel;
+
+		/* Total length */
+		__u16 match_size;
+	} u;
+
+	unsigned char data[0];
+};
+
+struct xt_entry_target {
+	union {
+		struct {
+			__u16 target_size;
+
+			/* Used by userspace */
+			char name[XT_EXTENSION_MAXNAMELEN];
+			__u8 revision;
+		} user;
+		struct {
+			__u16 target_size;
+
+			/* Used inside the kernel */
+			struct xt_target *target;
+		} kernel;
+
+		/* Total length */
+		__u16 target_size;
+	} u;
+
+	unsigned char data[0];
+};
+
+#define XT_TARGET_INIT(__name, __size)					       \
+{									       \
+	.target.u.user = {						       \
+		.target_size	= XT_ALIGN(__size),			       \
+		.name		= __name,				       \
+	},								       \
+}
+
+struct xt_standard_target {
+	struct xt_entry_target target;
+	int verdict;
+};
+
+struct xt_error_target {
+	struct xt_entry_target target;
+	char errorname[XT_FUNCTION_MAXNAMELEN];
+};
+
+/* The argument to IPT_SO_GET_REVISION_*.  Returns highest revision
+ * kernel supports, if >= revision. */
+struct xt_get_revision {
+	char name[XT_EXTENSION_MAXNAMELEN];
+	__u8 revision;
+};
+
+/* CONTINUE verdict for targets */
+#define XT_CONTINUE 0xFFFFFFFF
+
+/* For standard target */
+#define XT_RETURN (-NF_REPEAT - 1)
+
+/* this is a dummy structure to find out the alignment requirement for a struct
+ * containing all the fundamental data types that are used in ipt_entry,
+ * ip6t_entry and arpt_entry.  This sucks, and it is a hack.  It will be my
+ * personal pleasure to remove it -HW
+ */
+struct _xt_align {
+	__u8 u8;
+	__u16 u16;
+	__u32 u32;
+	__u64 u64;
+};
+
+#define XT_ALIGN(s) __ALIGN_KERNEL((s), __alignof__(struct _xt_align))
+
+/* Standard return verdict, or do jump. */
+#define XT_STANDARD_TARGET ""
+/* Error verdict. */
+#define XT_ERROR_TARGET "ERROR"
+
+#define SET_COUNTER(c,b,p) do { (c).bcnt = (b); (c).pcnt = (p); } while(0)
+#define ADD_COUNTER(c,b,p) do { (c).bcnt += (b); (c).pcnt += (p); } while(0)
+
+struct xt_counters {
+	__u64 pcnt, bcnt;			/* Packet and byte counters */
+};
+
+/* The argument to IPT_SO_ADD_COUNTERS. */
+struct xt_counters_info {
+	/* Which table. */
+	char name[XT_TABLE_MAXNAMELEN];
+
+	unsigned int num_counters;
+
+	/* The counters (actually `number' of these). */
+	struct xt_counters counters[0];
+};
+
+#define XT_INV_PROTO		0x40	/* Invert the sense of PROTO. */
+
+/* fn returns 0 to continue iteration */
+#define XT_MATCH_ITERATE(type, e, fn, args...)			\
+({								\
+	unsigned int __i;					\
+	int __ret = 0;						\
+	struct xt_entry_match *__m;				\
+								\
+	for (__i = sizeof(type);				\
+	     __i < (e)->target_offset;				\
+	     __i += __m->u.match_size) {			\
+		__m = (void *)e + __i;				\
+								\
+		__ret = fn(__m , ## args);			\
+		if (__ret != 0)					\
+			break;					\
+	}							\
+	__ret;							\
+})
+
+/* fn returns 0 to continue iteration */
+#define XT_ENTRY_ITERATE_CONTINUE(type, entries, size, n, fn, args...) \
+({								\
+	unsigned int __i, __n;					\
+	int __ret = 0;						\
+	type *__entry;						\
+								\
+	for (__i = 0, __n = 0; __i < (size);			\
+	     __i += __entry->next_offset, __n++) { 		\
+		__entry = (void *)(entries) + __i;		\
+		if (__n < n)					\
+			continue;				\
+								\
+		__ret = fn(__entry , ## args);			\
+		if (__ret != 0)					\
+			break;					\
+	}							\
+	__ret;							\
+})
+
+/* fn returns 0 to continue iteration */
+#define XT_ENTRY_ITERATE(type, entries, size, fn, args...) \
+	XT_ENTRY_ITERATE_CONTINUE(type, entries, size, 0, fn, args)
+
+
+/* pos is normally a struct ipt_entry/ip6t_entry/etc. */
+#define xt_entry_foreach(pos, ehead, esize) \
+	for ((pos) = (typeof(pos))(ehead); \
+	     (pos) < (typeof(pos))((char *)(ehead) + (esize)); \
+	     (pos) = (typeof(pos))((char *)(pos) + (pos)->next_offset))
+
+/* can only be xt_entry_match, so no use of typeof here */
+#define xt_ematch_foreach(pos, entry) \
+	for ((pos) = (struct xt_entry_match *)entry->elems; \
+	     (pos) < (struct xt_entry_match *)((char *)(entry) + \
+	             (entry)->target_offset); \
+	     (pos) = (struct xt_entry_match *)((char *)(pos) + \
+	             (pos)->u.match_size))
+
+
+#endif /* _X_TABLES_H */
diff --git a/include/uapi/linux/netfilter/xt_set.h b/include/uapi/linux/netfilter/xt_set.h
new file mode 100644
index 0000000..d4e0234
--- /dev/null
+++ b/include/uapi/linux/netfilter/xt_set.h
@@ -0,0 +1,93 @@
+#ifndef _XT_SET_H
+#define _XT_SET_H
+
+#include <linux/types.h>
+#include <linux/netfilter/ipset/ip_set.h>
+
+/* Revision 0 interface: backward compatible with netfilter/iptables */
+
+/*
+ * Option flags for kernel operations (xt_set_info_v0)
+ */
+#define IPSET_SRC		0x01	/* Source match/add */
+#define IPSET_DST		0x02	/* Destination match/add */
+#define IPSET_MATCH_INV		0x04	/* Inverse matching */
+
+struct xt_set_info_v0 {
+	ip_set_id_t index;
+	union {
+		__u32 flags[IPSET_DIM_MAX + 1];
+		struct {
+			__u32 __flags[IPSET_DIM_MAX];
+			__u8 dim;
+			__u8 flags;
+		} compat;
+	} u;
+};
+
+/* match and target infos */
+struct xt_set_info_match_v0 {
+	struct xt_set_info_v0 match_set;
+};
+
+struct xt_set_info_target_v0 {
+	struct xt_set_info_v0 add_set;
+	struct xt_set_info_v0 del_set;
+};
+
+/* Revision 1  match and target */
+
+struct xt_set_info {
+	ip_set_id_t index;
+	__u8 dim;
+	__u8 flags;
+};
+
+/* match and target infos */
+struct xt_set_info_match_v1 {
+	struct xt_set_info match_set;
+};
+
+struct xt_set_info_target_v1 {
+	struct xt_set_info add_set;
+	struct xt_set_info del_set;
+};
+
+/* Revision 2 target */
+
+struct xt_set_info_target_v2 {
+	struct xt_set_info add_set;
+	struct xt_set_info del_set;
+	__u32 flags;
+	__u32 timeout;
+};
+
+/* Revision 3 match */
+
+struct xt_set_info_match_v3 {
+	struct xt_set_info match_set;
+	struct ip_set_counter_match0 packets;
+	struct ip_set_counter_match0 bytes;
+	__u32 flags;
+};
+
+/* Revision 3 target */
+
+struct xt_set_info_target_v3 {
+	struct xt_set_info add_set;
+	struct xt_set_info del_set;
+	struct xt_set_info map_set;
+	__u32 flags;
+	__u32 timeout;
+};
+
+/* Revision 4 match */
+
+struct xt_set_info_match_v4 {
+	struct xt_set_info match_set;
+	struct ip_set_counter_match packets;
+	struct ip_set_counter_match bytes;
+	__u32 flags;
+};
+
+#endif /*_XT_SET_H*/
diff --git a/include/uapi/linux/netfilter/xt_tcpudp.h b/include/uapi/linux/netfilter/xt_tcpudp.h
new file mode 100644
index 0000000..38aa7b3
--- /dev/null
+++ b/include/uapi/linux/netfilter/xt_tcpudp.h
@@ -0,0 +1,36 @@
+#ifndef _XT_TCPUDP_H
+#define _XT_TCPUDP_H
+
+#include <linux/types.h>
+
+/* TCP matching stuff */
+struct xt_tcp {
+	__u16 spts[2];			/* Source port range. */
+	__u16 dpts[2];			/* Destination port range. */
+	__u8 option;			/* TCP Option iff non-zero*/
+	__u8 flg_mask;			/* TCP flags mask byte */
+	__u8 flg_cmp;			/* TCP flags compare byte */
+	__u8 invflags;			/* Inverse flags */
+};
+
+/* Values for "inv" field in struct ipt_tcp. */
+#define XT_TCP_INV_SRCPT	0x01	/* Invert the sense of source ports. */
+#define XT_TCP_INV_DSTPT	0x02	/* Invert the sense of dest ports. */
+#define XT_TCP_INV_FLAGS	0x04	/* Invert the sense of TCP flags. */
+#define XT_TCP_INV_OPTION	0x08	/* Invert the sense of option test. */
+#define XT_TCP_INV_MASK		0x0F	/* All possible flags. */
+
+/* UDP matching stuff */
+struct xt_udp {
+	__u16 spts[2];			/* Source port range. */
+	__u16 dpts[2];			/* Destination port range. */
+	__u8 invflags;			/* Inverse flags */
+};
+
+/* Values for "invflags" field in struct ipt_udp. */
+#define XT_UDP_INV_SRCPT	0x01	/* Invert the sense of source ports. */
+#define XT_UDP_INV_DSTPT	0x02	/* Invert the sense of dest ports. */
+#define XT_UDP_INV_MASK	0x03	/* All possible flags. */
+
+
+#endif
diff --git a/include/uapi/linux/netfilter_ipv4.h b/include/uapi/linux/netfilter_ipv4.h
new file mode 100644
index 0000000..a5f4dc7
--- /dev/null
+++ b/include/uapi/linux/netfilter_ipv4.h
@@ -0,0 +1,79 @@
+/* IPv4-specific defines for netfilter. 
+ * (C)1998 Rusty Russell -- This code is GPL.
+ */
+#ifndef __LINUX_IP_NETFILTER_H
+#define __LINUX_IP_NETFILTER_H
+
+
+#include <linux/netfilter.h>
+
+/* only for userspace compatibility */
+
+#include <limits.h> /* for INT_MIN, INT_MAX */
+
+/* IP Cache bits. */
+/* Src IP address. */
+#define NFC_IP_SRC		0x0001
+/* Dest IP address. */
+#define NFC_IP_DST		0x0002
+/* Input device. */
+#define NFC_IP_IF_IN		0x0004
+/* Output device. */
+#define NFC_IP_IF_OUT		0x0008
+/* TOS. */
+#define NFC_IP_TOS		0x0010
+/* Protocol. */
+#define NFC_IP_PROTO		0x0020
+/* IP options. */
+#define NFC_IP_OPTIONS		0x0040
+/* Frag & flags. */
+#define NFC_IP_FRAG		0x0080
+
+/* Per-protocol information: only matters if proto match. */
+/* TCP flags. */
+#define NFC_IP_TCPFLAGS		0x0100
+/* Source port. */
+#define NFC_IP_SRC_PT		0x0200
+/* Dest port. */
+#define NFC_IP_DST_PT		0x0400
+/* Something else about the proto */
+#define NFC_IP_PROTO_UNKNOWN	0x2000
+
+/* IP Hooks */
+/* After promisc drops, checksum checks. */
+#define NF_IP_PRE_ROUTING	0
+/* If the packet is destined for this box. */
+#define NF_IP_LOCAL_IN		1
+/* If the packet is destined for another interface. */
+#define NF_IP_FORWARD		2
+/* Packets coming from a local process. */
+#define NF_IP_LOCAL_OUT		3
+/* Packets about to hit the wire. */
+#define NF_IP_POST_ROUTING	4
+#define NF_IP_NUMHOOKS		5
+
+enum nf_ip_hook_priorities {
+	NF_IP_PRI_FIRST = INT_MIN,
+	NF_IP_PRI_CONNTRACK_DEFRAG = -400,
+	NF_IP_PRI_RAW = -300,
+	NF_IP_PRI_SELINUX_FIRST = -225,
+	NF_IP_PRI_CONNTRACK = -200,
+	NF_IP_PRI_MANGLE = -150,
+	NF_IP_PRI_NAT_DST = -100,
+	NF_IP_PRI_FILTER = 0,
+	NF_IP_PRI_SECURITY = 50,
+	NF_IP_PRI_NAT_SRC = 100,
+	NF_IP_PRI_SELINUX_LAST = 225,
+	NF_IP_PRI_CONNTRACK_HELPER = 300,
+	NF_IP_PRI_CONNTRACK_CONFIRM = INT_MAX,
+	NF_IP_PRI_LAST = INT_MAX,
+};
+
+/* Arguments for setsockopt SOL_IP: */
+/* 2.0 firewalling went from 64 through 71 (and +256, +512, etc). */
+/* 2.2 firewalling (+ masq) went from 64 through 76 */
+/* 2.4 firewalling went 64 through 67. */
+#define SO_ORIGINAL_DST 80
+
+
+#endif /* __LINUX_IP_NETFILTER_H */
diff --git a/include/uapi/linux/netfilter_ipv4/ip_tables.h b/include/uapi/linux/netfilter_ipv4/ip_tables.h
new file mode 100644
index 0000000..456fb86
--- /dev/null
+++ b/include/uapi/linux/netfilter_ipv4/ip_tables.h
@@ -0,0 +1,228 @@
+/*
+ * 25-Jul-1998 Major changes to allow for ip chain table
+ *
+ * 3-Jan-2000 Named tables to allow packet selection for different uses.
+ */
+
+/*
+ * 	Format of an IP firewall descriptor
+ *
+ * 	src, dst, src_mask, dst_mask are always stored in network byte order.
+ * 	flags are stored in host byte order (of course).
+ * 	Port numbers are stored in HOST byte order.
+ */
+
+#ifndef _IPTABLES_H
+#define _IPTABLES_H
+
+#include <linux/types.h>
+
+#include <linux/if.h>
+#include <linux/netfilter_ipv4.h>
+
+#include <linux/netfilter/x_tables.h>
+
+#define IPT_FUNCTION_MAXNAMELEN XT_FUNCTION_MAXNAMELEN
+#define IPT_TABLE_MAXNAMELEN XT_TABLE_MAXNAMELEN
+#define ipt_match xt_match
+#define ipt_target xt_target
+#define ipt_table xt_table
+#define ipt_get_revision xt_get_revision
+#define ipt_entry_match xt_entry_match
+#define ipt_entry_target xt_entry_target
+#define ipt_standard_target xt_standard_target
+#define ipt_error_target xt_error_target
+#define ipt_counters xt_counters
+#define IPT_CONTINUE XT_CONTINUE
+#define IPT_RETURN XT_RETURN
+
+/* This group is older than old (iptables < v1.4.0-rc1~89) */
+#include <linux/netfilter/xt_tcpudp.h>
+#define ipt_udp xt_udp
+#define ipt_tcp xt_tcp
+#define IPT_TCP_INV_SRCPT	XT_TCP_INV_SRCPT
+#define IPT_TCP_INV_DSTPT	XT_TCP_INV_DSTPT
+#define IPT_TCP_INV_FLAGS	XT_TCP_INV_FLAGS
+#define IPT_TCP_INV_OPTION	XT_TCP_INV_OPTION
+#define IPT_TCP_INV_MASK	XT_TCP_INV_MASK
+#define IPT_UDP_INV_SRCPT	XT_UDP_INV_SRCPT
+#define IPT_UDP_INV_DSTPT	XT_UDP_INV_DSTPT
+#define IPT_UDP_INV_MASK	XT_UDP_INV_MASK
+
+/* The argument to IPT_SO_ADD_COUNTERS. */
+#define ipt_counters_info xt_counters_info
+/* Standard return verdict, or do jump. */
+#define IPT_STANDARD_TARGET XT_STANDARD_TARGET
+/* Error verdict. */
+#define IPT_ERROR_TARGET XT_ERROR_TARGET
+
+/* fn returns 0 to continue iteration */
+#define IPT_MATCH_ITERATE(e, fn, args...) \
+	XT_MATCH_ITERATE(struct ipt_entry, e, fn, ## args)
+
+/* fn returns 0 to continue iteration */
+#define IPT_ENTRY_ITERATE(entries, size, fn, args...) \
+	XT_ENTRY_ITERATE(struct ipt_entry, entries, size, fn, ## args)
+
+/* Yes, Virginia, you have to zero the padding. */
+struct ipt_ip {
+	/* Source and destination IP addr */
+	struct in_addr src, dst;
+	/* Mask for src and dest IP addr */
+	struct in_addr smsk, dmsk;
+	char iniface[IFNAMSIZ], outiface[IFNAMSIZ];
+	unsigned char iniface_mask[IFNAMSIZ], outiface_mask[IFNAMSIZ];
+
+	/* Protocol, 0 = ANY */
+	__u16 proto;
+
+	/* Flags word */
+	__u8 flags;
+	/* Inverse flags */
+	__u8 invflags;
+};
+
+/* Values for "flag" field in struct ipt_ip (general ip structure). */
+#define IPT_F_FRAG		0x01	/* Set if rule is a fragment rule */
+#define IPT_F_GOTO		0x02	/* Set if jump is a goto */
+#define IPT_F_MASK		0x03	/* All possible flag bits mask. */
+
+/* Values for "inv" field in struct ipt_ip. */
+#define IPT_INV_VIA_IN		0x01	/* Invert the sense of IN IFACE. */
+#define IPT_INV_VIA_OUT		0x02	/* Invert the sense of OUT IFACE */
+#define IPT_INV_TOS		0x04	/* Invert the sense of TOS. */
+#define IPT_INV_SRCIP		0x08	/* Invert the sense of SRC IP. */
+#define IPT_INV_DSTIP		0x10	/* Invert the sense of DST OP. */
+#define IPT_INV_FRAG		0x20	/* Invert the sense of FRAG. */
+#define IPT_INV_PROTO		XT_INV_PROTO
+#define IPT_INV_MASK		0x7F	/* All possible flag bits mask. */
+
+/* This structure defines each of the firewall rules.  Consists of 3
+   parts which are 1) general IP header stuff 2) match specific
+   stuff 3) the target to perform if the rule matches */
+struct ipt_entry {
+	struct ipt_ip ip;
+
+	/* Mark with fields that we care about. */
+	unsigned int nfcache;
+
+	/* Size of ipt_entry + matches */
+	__u16 target_offset;
+	/* Size of ipt_entry + matches + target */
+	__u16 next_offset;
+
+	/* Back pointer */
+	unsigned int comefrom;
+
+	/* Packet and byte counters. */
+	struct xt_counters counters;
+
+	/* The matches (if any), then the target. */
+	unsigned char elems[0];
+};
+
+/*
+ * New IP firewall options for [gs]etsockopt at the RAW IP level.
+ * Unlike BSD Linux inherits IP options so you don't have to use a raw
+ * socket for this. Instead we check rights in the calls.
+ *
+ * ATTENTION: check linux/in.h before adding new number here.
+ */
+#define IPT_BASE_CTL		64
+
+#define IPT_SO_SET_REPLACE	(IPT_BASE_CTL)
+#define IPT_SO_SET_ADD_COUNTERS	(IPT_BASE_CTL + 1)
+#define IPT_SO_SET_MAX		IPT_SO_SET_ADD_COUNTERS
+
+#define IPT_SO_GET_INFO			(IPT_BASE_CTL)
+#define IPT_SO_GET_ENTRIES		(IPT_BASE_CTL + 1)
+#define IPT_SO_GET_REVISION_MATCH	(IPT_BASE_CTL + 2)
+#define IPT_SO_GET_REVISION_TARGET	(IPT_BASE_CTL + 3)
+#define IPT_SO_GET_MAX			IPT_SO_GET_REVISION_TARGET
+
+/* ICMP matching stuff */
+struct ipt_icmp {
+	__u8 type;				/* type to match */
+	__u8 code[2];				/* range of code */
+	__u8 invflags;				/* Inverse flags */
+};
+
+/* Values for "inv" field for struct ipt_icmp. */
+#define IPT_ICMP_INV	0x01	/* Invert the sense of type/code test */
+
+/* The argument to IPT_SO_GET_INFO */
+struct ipt_getinfo {
+	/* Which table: caller fills this in. */
+	char name[XT_TABLE_MAXNAMELEN];
+
+	/* Kernel fills these in. */
+	/* Which hook entry points are valid: bitmask */
+	unsigned int valid_hooks;
+
+	/* Hook entry points: one per netfilter hook. */
+	unsigned int hook_entry[NF_INET_NUMHOOKS];
+
+	/* Underflow points. */
+	unsigned int underflow[NF_INET_NUMHOOKS];
+
+	/* Number of entries */
+	unsigned int num_entries;
+
+	/* Size of entries. */
+	unsigned int size;
+};
+
+/* The argument to IPT_SO_SET_REPLACE. */
+struct ipt_replace {
+	/* Which table. */
+	char name[XT_TABLE_MAXNAMELEN];
+
+	/* Which hook entry points are valid: bitmask.  You can't
+           change this. */
+	unsigned int valid_hooks;
+
+	/* Number of entries */
+	unsigned int num_entries;
+
+	/* Total size of new entries */
+	unsigned int size;
+
+	/* Hook entry points. */
+	unsigned int hook_entry[NF_INET_NUMHOOKS];
+
+	/* Underflow points. */
+	unsigned int underflow[NF_INET_NUMHOOKS];
+
+	/* Information about old entries: */
+	/* Number of counters (must be equal to current number of entries). */
+	unsigned int num_counters;
+	/* The old entries' counters. */
+	struct xt_counters *counters;
+
+	/* The entries (hang off end: not really an array). */
+	struct ipt_entry entries[0];
+};
+
+/* The argument to IPT_SO_GET_ENTRIES. */
+struct ipt_get_entries {
+	/* Which table: user fills this in. */
+	char name[XT_TABLE_MAXNAMELEN];
+
+	/* User fills this in: total entry size. */
+	unsigned int size;
+
+	/* The entries. */
+	struct ipt_entry entrytable[0];
+};
+
+/* Helper functions */
+static __inline__ struct xt_entry_target *
+ipt_get_target(struct ipt_entry *e)
+{
+	return (void *)e + e->target_offset;
+}
+
+/*
+ *	Main firewall chains definitions and global var's definitions.
+ */
+#endif /* _IPTABLES_H */
diff --git a/include/uapi/linux/netfilter_ipv6.h b/include/uapi/linux/netfilter_ipv6.h
new file mode 100644
index 0000000..8483d1d
--- /dev/null
+++ b/include/uapi/linux/netfilter_ipv6.h
@@ -0,0 +1,77 @@
+/* IPv6-specific defines for netfilter. 
+ * (C)1998 Rusty Russell -- This code is GPL.
+ * (C)1999 David Jeffery
+ *   this header was blatantly ripped from netfilter_ipv4.h 
+ *   it's amazing what adding a bunch of 6s can do =8^)
+ */
+#ifndef __LINUX_IP6_NETFILTER_H
+#define __LINUX_IP6_NETFILTER_H
+
+
+#include <linux/netfilter.h>
+
+/* only for userspace compatibility */
+
+#include <limits.h> /* for INT_MIN, INT_MAX */
+
+/* IP Cache bits. */
+/* Src IP address. */
+#define NFC_IP6_SRC              0x0001
+/* Dest IP address. */
+#define NFC_IP6_DST              0x0002
+/* Input device. */
+#define NFC_IP6_IF_IN            0x0004
+/* Output device. */
+#define NFC_IP6_IF_OUT           0x0008
+/* TOS. */
+#define NFC_IP6_TOS              0x0010
+/* Protocol. */
+#define NFC_IP6_PROTO            0x0020
+/* IP options. */
+#define NFC_IP6_OPTIONS          0x0040
+/* Frag & flags. */
+#define NFC_IP6_FRAG             0x0080
+
+
+/* Per-protocol information: only matters if proto match. */
+/* TCP flags. */
+#define NFC_IP6_TCPFLAGS         0x0100
+/* Source port. */
+#define NFC_IP6_SRC_PT           0x0200
+/* Dest port. */
+#define NFC_IP6_DST_PT           0x0400
+/* Something else about the proto */
+#define NFC_IP6_PROTO_UNKNOWN    0x2000
+
+/* IP6 Hooks */
+/* After promisc drops, checksum checks. */
+#define NF_IP6_PRE_ROUTING	0
+/* If the packet is destined for this box. */
+#define NF_IP6_LOCAL_IN		1
+/* If the packet is destined for another interface. */
+#define NF_IP6_FORWARD		2
+/* Packets coming from a local process. */
+#define NF_IP6_LOCAL_OUT		3
+/* Packets about to hit the wire. */
+#define NF_IP6_POST_ROUTING	4
+#define NF_IP6_NUMHOOKS		5
+
+
+enum nf_ip6_hook_priorities {
+	NF_IP6_PRI_FIRST = INT_MIN,
+	NF_IP6_PRI_CONNTRACK_DEFRAG = -400,
+	NF_IP6_PRI_RAW = -300,
+	NF_IP6_PRI_SELINUX_FIRST = -225,
+	NF_IP6_PRI_CONNTRACK = -200,
+	NF_IP6_PRI_MANGLE = -150,
+	NF_IP6_PRI_NAT_DST = -100,
+	NF_IP6_PRI_FILTER = 0,
+	NF_IP6_PRI_SECURITY = 50,
+	NF_IP6_PRI_NAT_SRC = 100,
+	NF_IP6_PRI_SELINUX_LAST = 225,
+	NF_IP6_PRI_CONNTRACK_HELPER = 300,
+	NF_IP6_PRI_LAST = INT_MAX,
+};
+
+
+#endif /* __LINUX_IP6_NETFILTER_H */
diff --git a/include/uapi/linux/netfilter_ipv6/ip6_tables.h b/include/uapi/linux/netfilter_ipv6/ip6_tables.h
new file mode 100644
index 0000000..fcc8cca
--- /dev/null
+++ b/include/uapi/linux/netfilter_ipv6/ip6_tables.h
@@ -0,0 +1,269 @@
+/*
+ * 25-Jul-1998 Major changes to allow for ip chain table
+ *
+ * 3-Jan-2000 Named tables to allow packet selection for different uses.
+ */
+
+/*
+ * 	Format of an IP6 firewall descriptor
+ *
+ * 	src, dst, src_mask, dst_mask are always stored in network byte order.
+ * 	flags are stored in host byte order (of course).
+ * 	Port numbers are stored in HOST byte order.
+ */
+
+#ifndef _IP6_TABLES_H
+#define _IP6_TABLES_H
+
+#include <linux/types.h>
+
+#include <linux/if.h>
+#include <linux/netfilter_ipv6.h>
+
+#include <linux/netfilter/x_tables.h>
+
+#define IP6T_FUNCTION_MAXNAMELEN XT_FUNCTION_MAXNAMELEN
+#define IP6T_TABLE_MAXNAMELEN XT_TABLE_MAXNAMELEN
+#define ip6t_match xt_match
+#define ip6t_target xt_target
+#define ip6t_table xt_table
+#define ip6t_get_revision xt_get_revision
+#define ip6t_entry_match xt_entry_match
+#define ip6t_entry_target xt_entry_target
+#define ip6t_standard_target xt_standard_target
+#define ip6t_error_target xt_error_target
+#define ip6t_counters xt_counters
+#define IP6T_CONTINUE XT_CONTINUE
+#define IP6T_RETURN XT_RETURN
+
+/* Pre-iptables-1.4.0 */
+#include <linux/netfilter/xt_tcpudp.h>
+#define ip6t_tcp xt_tcp
+#define ip6t_udp xt_udp
+#define IP6T_TCP_INV_SRCPT	XT_TCP_INV_SRCPT
+#define IP6T_TCP_INV_DSTPT	XT_TCP_INV_DSTPT
+#define IP6T_TCP_INV_FLAGS	XT_TCP_INV_FLAGS
+#define IP6T_TCP_INV_OPTION	XT_TCP_INV_OPTION
+#define IP6T_TCP_INV_MASK	XT_TCP_INV_MASK
+#define IP6T_UDP_INV_SRCPT	XT_UDP_INV_SRCPT
+#define IP6T_UDP_INV_DSTPT	XT_UDP_INV_DSTPT
+#define IP6T_UDP_INV_MASK	XT_UDP_INV_MASK
+
+#define ip6t_counters_info xt_counters_info
+#define IP6T_STANDARD_TARGET XT_STANDARD_TARGET
+#define IP6T_ERROR_TARGET XT_ERROR_TARGET
+#define IP6T_MATCH_ITERATE(e, fn, args...) \
+	XT_MATCH_ITERATE(struct ip6t_entry, e, fn, ## args)
+#define IP6T_ENTRY_ITERATE(entries, size, fn, args...) \
+	XT_ENTRY_ITERATE(struct ip6t_entry, entries, size, fn, ## args)
+
+/* Yes, Virginia, you have to zero the padding. */
+struct ip6t_ip6 {
+	/* Source and destination IP6 addr */
+	struct in6_addr src, dst;		
+	/* Mask for src and dest IP6 addr */
+	struct in6_addr smsk, dmsk;
+	char iniface[IFNAMSIZ], outiface[IFNAMSIZ];
+	unsigned char iniface_mask[IFNAMSIZ], outiface_mask[IFNAMSIZ];
+
+	/* Upper protocol number
+	 * - The allowed value is 0 (any) or protocol number of last parsable
+	 *   header, which is 50 (ESP), 59 (No Next Header), 135 (MH), or
+	 *   the non IPv6 extension headers.
+	 * - The protocol numbers of IPv6 extension headers except of ESP and
+	 *   MH do not match any packets.
+	 * - You also need to set IP6T_FLAGS_PROTO to "flags" to check protocol.
+	 */
+	__u16 proto;
+	/* TOS to match iff flags & IP6T_F_TOS */
+	__u8 tos;
+
+	/* Flags word */
+	__u8 flags;
+	/* Inverse flags */
+	__u8 invflags;
+};
+
+/* Values for "flag" field in struct ip6t_ip6 (general ip6 structure). */
+#define IP6T_F_PROTO		0x01	/* Set if rule cares about upper 
+					   protocols */
+#define IP6T_F_TOS		0x02	/* Match the TOS. */
+#define IP6T_F_GOTO		0x04	/* Set if jump is a goto */
+#define IP6T_F_MASK		0x07	/* All possible flag bits mask. */
+
+/* Values for "inv" field in struct ip6t_ip6. */
+#define IP6T_INV_VIA_IN		0x01	/* Invert the sense of IN IFACE. */
+#define IP6T_INV_VIA_OUT		0x02	/* Invert the sense of OUT IFACE */
+#define IP6T_INV_TOS		0x04	/* Invert the sense of TOS. */
+#define IP6T_INV_SRCIP		0x08	/* Invert the sense of SRC IP. */
+#define IP6T_INV_DSTIP		0x10	/* Invert the sense of DST OP. */
+#define IP6T_INV_FRAG		0x20	/* Invert the sense of FRAG. */
+#define IP6T_INV_PROTO		XT_INV_PROTO
+#define IP6T_INV_MASK		0x7F	/* All possible flag bits mask. */
+
+/* This structure defines each of the firewall rules.  Consists of 3
+   parts which are 1) general IP header stuff 2) match specific
+   stuff 3) the target to perform if the rule matches */
+struct ip6t_entry {
+	struct ip6t_ip6 ipv6;
+
+	/* Mark with fields that we care about. */
+	unsigned int nfcache;
+
+	/* Size of ipt_entry + matches */
+	__u16 target_offset;
+	/* Size of ipt_entry + matches + target */
+	__u16 next_offset;
+
+	/* Back pointer */
+	unsigned int comefrom;
+
+	/* Packet and byte counters. */
+	struct xt_counters counters;
+
+	/* The matches (if any), then the target. */
+	unsigned char elems[0];
+};
+
+/* Standard entry */
+struct ip6t_standard {
+	struct ip6t_entry entry;
+	struct xt_standard_target target;
+};
+
+struct ip6t_error {
+	struct ip6t_entry entry;
+	struct xt_error_target target;
+};
+
+#define IP6T_ENTRY_INIT(__size)						       \
+{									       \
+	.target_offset	= sizeof(struct ip6t_entry),			       \
+	.next_offset	= (__size),					       \
+}
+
+#define IP6T_STANDARD_INIT(__verdict)					       \
+{									       \
+	.entry		= IP6T_ENTRY_INIT(sizeof(struct ip6t_standard)),       \
+	.target		= XT_TARGET_INIT(XT_STANDARD_TARGET,		       \
+					 sizeof(struct xt_standard_target)),   \
+	.target.verdict	= -(__verdict) - 1,				       \
+}
+
+#define IP6T_ERROR_INIT							       \
+{									       \
+	.entry		= IP6T_ENTRY_INIT(sizeof(struct ip6t_error)),	       \
+	.target		= XT_TARGET_INIT(XT_ERROR_TARGET,		       \
+					 sizeof(struct xt_error_target)),      \
+	.target.errorname = "ERROR",					       \
+}
+
+/*
+ * New IP firewall options for [gs]etsockopt at the RAW IP level.
+ * Unlike BSD Linux inherits IP options so you don't have to use
+ * a raw socket for this. Instead we check rights in the calls.
+ *
+ * ATTENTION: check linux/in6.h before adding new number here.
+ */
+#define IP6T_BASE_CTL			64
+
+#define IP6T_SO_SET_REPLACE		(IP6T_BASE_CTL)
+#define IP6T_SO_SET_ADD_COUNTERS	(IP6T_BASE_CTL + 1)
+#define IP6T_SO_SET_MAX			IP6T_SO_SET_ADD_COUNTERS
+
+#define IP6T_SO_GET_INFO		(IP6T_BASE_CTL)
+#define IP6T_SO_GET_ENTRIES		(IP6T_BASE_CTL + 1)
+#define IP6T_SO_GET_REVISION_MATCH	(IP6T_BASE_CTL + 4)
+#define IP6T_SO_GET_REVISION_TARGET	(IP6T_BASE_CTL + 5)
+#define IP6T_SO_GET_MAX			IP6T_SO_GET_REVISION_TARGET
+
+/* obtain original address if REDIRECT'd connection */
+#define IP6T_SO_ORIGINAL_DST            80
+
+/* ICMP matching stuff */
+struct ip6t_icmp {
+	__u8 type;				/* type to match */
+	__u8 code[2];				/* range of code */
+	__u8 invflags;				/* Inverse flags */
+};
+
+/* Values for "inv" field for struct ipt_icmp. */
+#define IP6T_ICMP_INV	0x01	/* Invert the sense of type/code test */
+
+/* The argument to IP6T_SO_GET_INFO */
+struct ip6t_getinfo {
+	/* Which table: caller fills this in. */
+	char name[XT_TABLE_MAXNAMELEN];
+
+	/* Kernel fills these in. */
+	/* Which hook entry points are valid: bitmask */
+	unsigned int valid_hooks;
+
+	/* Hook entry points: one per netfilter hook. */
+	unsigned int hook_entry[NF_INET_NUMHOOKS];
+
+	/* Underflow points. */
+	unsigned int underflow[NF_INET_NUMHOOKS];
+
+	/* Number of entries */
+	unsigned int num_entries;
+
+	/* Size of entries. */
+	unsigned int size;
+};
+
+/* The argument to IP6T_SO_SET_REPLACE. */
+struct ip6t_replace {
+	/* Which table. */
+	char name[XT_TABLE_MAXNAMELEN];
+
+	/* Which hook entry points are valid: bitmask.  You can't
+           change this. */
+	unsigned int valid_hooks;
+
+	/* Number of entries */
+	unsigned int num_entries;
+
+	/* Total size of new entries */
+	unsigned int size;
+
+	/* Hook entry points. */
+	unsigned int hook_entry[NF_INET_NUMHOOKS];
+
+	/* Underflow points. */
+	unsigned int underflow[NF_INET_NUMHOOKS];
+
+	/* Information about old entries: */
+	/* Number of counters (must be equal to current number of entries). */
+	unsigned int num_counters;
+	/* The old entries' counters. */
+	struct xt_counters *counters;
+
+	/* The entries (hang off end: not really an array). */
+	struct ip6t_entry entries[0];
+};
+
+/* The argument to IP6T_SO_GET_ENTRIES. */
+struct ip6t_get_entries {
+	/* Which table: user fills this in. */
+	char name[XT_TABLE_MAXNAMELEN];
+
+	/* User fills this in: total entry size. */
+	unsigned int size;
+
+	/* The entries. */
+	struct ip6t_entry entrytable[0];
+};
+
+/* Helper functions */
+static __inline__ struct xt_entry_target *
+ip6t_get_target(struct ip6t_entry *e)
+{
+	return (void *)e + e->target_offset;
+}
+
+/*
+ *	Main firewall chains definitions and global var's definitions.
+ */
+
+#endif /* _IP6_TABLES_H */
diff --git a/include/uapi/linux/netlink.h b/include/uapi/linux/netlink.h
new file mode 100644
index 0000000..ec0690b
--- /dev/null
+++ b/include/uapi/linux/netlink.h
@@ -0,0 +1,246 @@
+#ifndef __LINUX_NETLINK_H
+#define __LINUX_NETLINK_H
+
+#include <linux/kernel.h>
+#include <linux/socket.h> /* for __kernel_sa_family_t */
+#include <linux/types.h>
+
+#define NETLINK_ROUTE		0	/* Routing/device hook				*/
+#define NETLINK_UNUSED		1	/* Unused number				*/
+#define NETLINK_USERSOCK	2	/* Reserved for user mode socket protocols 	*/
+#define NETLINK_FIREWALL	3	/* Unused number, formerly ip_queue		*/
+#define NETLINK_SOCK_DIAG	4	/* socket monitoring				*/
+#define NETLINK_NFLOG		5	/* netfilter/iptables ULOG */
+#define NETLINK_XFRM		6	/* ipsec */
+#define NETLINK_SELINUX		7	/* SELinux event notifications */
+#define NETLINK_ISCSI		8	/* Open-iSCSI */
+#define NETLINK_AUDIT		9	/* auditing */
+#define NETLINK_FIB_LOOKUP	10	
+#define NETLINK_CONNECTOR	11
+#define NETLINK_NETFILTER	12	/* netfilter subsystem */
+#define NETLINK_IP6_FW		13
+#define NETLINK_DNRTMSG		14	/* DECnet routing messages */
+#define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
+#define NETLINK_GENERIC		16
+/* leave room for NETLINK_DM (DM Events) */
+#define NETLINK_SCSITRANSPORT	18	/* SCSI Transports */
+#define NETLINK_ECRYPTFS	19
+#define NETLINK_RDMA		20
+#define NETLINK_CRYPTO		21	/* Crypto layer */
+#define NETLINK_SMC		22	/* SMC monitoring */
+
+#define NETLINK_INET_DIAG	NETLINK_SOCK_DIAG
+
+#define MAX_LINKS 32		
+
+struct sockaddr_nl {
+	__kernel_sa_family_t	nl_family;	/* AF_NETLINK	*/
+	unsigned short	nl_pad;		/* zero		*/
+	__u32		nl_pid;		/* port ID	*/
+       	__u32		nl_groups;	/* multicast groups mask */
+};
+
+struct nlmsghdr {
+	__u32		nlmsg_len;	/* Length of message including header */
+	__u16		nlmsg_type;	/* Message content */
+	__u16		nlmsg_flags;	/* Additional flags */
+	__u32		nlmsg_seq;	/* Sequence number */
+	__u32		nlmsg_pid;	/* Sending process port ID */
+};
+
+/* Flags values */
+
+#define NLM_F_REQUEST		0x01	/* It is request message. 	*/
+#define NLM_F_MULTI		0x02	/* Multipart message, terminated by NLMSG_DONE */
+#define NLM_F_ACK		0x04	/* Reply with ack, with zero or error code */
+#define NLM_F_ECHO		0x08	/* Echo this request 		*/
+#define NLM_F_DUMP_INTR		0x10	/* Dump was inconsistent due to sequence change */
+#define NLM_F_DUMP_FILTERED	0x20	/* Dump was filtered as requested */
+
+/* Modifiers to GET request */
+#define NLM_F_ROOT	0x100	/* specify tree	root	*/
+#define NLM_F_MATCH	0x200	/* return all matching	*/
+#define NLM_F_ATOMIC	0x400	/* atomic GET		*/
+#define NLM_F_DUMP	(NLM_F_ROOT|NLM_F_MATCH)
+
+/* Modifiers to NEW request */
+#define NLM_F_REPLACE	0x100	/* Override existing		*/
+#define NLM_F_EXCL	0x200	/* Do not touch, if it exists	*/
+#define NLM_F_CREATE	0x400	/* Create, if it does not exist	*/
+#define NLM_F_APPEND	0x800	/* Add to end of list		*/
+
+/* Modifiers to DELETE request */
+#define NLM_F_NONREC	0x100	/* Do not delete recursively	*/
+
+/* Flags for ACK message */
+#define NLM_F_CAPPED	0x100	/* request was capped */
+#define NLM_F_ACK_TLVS	0x200	/* extended ACK TVLs were included */
+
+/*
+   4.4BSD ADD		NLM_F_CREATE|NLM_F_EXCL
+   4.4BSD CHANGE	NLM_F_REPLACE
+
+   True CHANGE		NLM_F_CREATE|NLM_F_REPLACE
+   Append		NLM_F_CREATE
+   Check		NLM_F_EXCL
+ */
+
+#define NLMSG_ALIGNTO	4U
+#define NLMSG_ALIGN(len) ( ((len)+NLMSG_ALIGNTO-1) & ~(NLMSG_ALIGNTO-1) )
+#define NLMSG_HDRLEN	 ((int) NLMSG_ALIGN(sizeof(struct nlmsghdr)))
+#define NLMSG_LENGTH(len) ((len) + NLMSG_HDRLEN)
+#define NLMSG_SPACE(len) NLMSG_ALIGN(NLMSG_LENGTH(len))
+#define NLMSG_DATA(nlh)  ((void*)(((char*)nlh) + NLMSG_LENGTH(0)))
+#define NLMSG_NEXT(nlh,len)	 ((len) -= NLMSG_ALIGN((nlh)->nlmsg_len), \
+				  (struct nlmsghdr*)(((char*)(nlh)) + NLMSG_ALIGN((nlh)->nlmsg_len)))
+#define NLMSG_OK(nlh,len) ((len) >= (int)sizeof(struct nlmsghdr) && \
+			   (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && \
+			   (nlh)->nlmsg_len <= (len))
+#define NLMSG_PAYLOAD(nlh,len) ((nlh)->nlmsg_len - NLMSG_SPACE((len)))
+
+#define NLMSG_NOOP		0x1	/* Nothing.		*/
+#define NLMSG_ERROR		0x2	/* Error		*/
+#define NLMSG_DONE		0x3	/* End of a dump	*/
+#define NLMSG_OVERRUN		0x4	/* Data lost		*/
+
+#define NLMSG_MIN_TYPE		0x10	/* < 0x10: reserved control messages */
+
+struct nlmsgerr {
+	int		error;
+	struct nlmsghdr msg;
+	/*
+	 * followed by the message contents unless NETLINK_CAP_ACK was set
+	 * or the ACK indicates success (error == 0)
+	 * message length is aligned with NLMSG_ALIGN()
+	 */
+	/*
+	 * followed by TLVs defined in enum nlmsgerr_attrs
+	 * if NETLINK_EXT_ACK was set
+	 */
+};
+
+/**
+ * enum nlmsgerr_attrs - nlmsgerr attributes
+ * @NLMSGERR_ATTR_UNUSED: unused
+ * @NLMSGERR_ATTR_MSG: error message string (string)
+ * @NLMSGERR_ATTR_OFFS: offset of the invalid attribute in the original
+ *	 message, counting from the beginning of the header (u32)
+ * @NLMSGERR_ATTR_COOKIE: arbitrary subsystem specific cookie to
+ *	be used - in the success case - to identify a created
+ *	object or operation or similar (binary)
+ * @__NLMSGERR_ATTR_MAX: number of attributes
+ * @NLMSGERR_ATTR_MAX: highest attribute number
+ */
+enum nlmsgerr_attrs {
+	NLMSGERR_ATTR_UNUSED,
+	NLMSGERR_ATTR_MSG,
+	NLMSGERR_ATTR_OFFS,
+	NLMSGERR_ATTR_COOKIE,
+
+	__NLMSGERR_ATTR_MAX,
+	NLMSGERR_ATTR_MAX = __NLMSGERR_ATTR_MAX - 1
+};
+
+#define NETLINK_ADD_MEMBERSHIP		1
+#define NETLINK_DROP_MEMBERSHIP		2
+#define NETLINK_PKTINFO			3
+#define NETLINK_BROADCAST_ERROR		4
+#define NETLINK_NO_ENOBUFS		5
+#define NETLINK_RX_RING			6
+#define NETLINK_TX_RING			7
+#define NETLINK_LISTEN_ALL_NSID		8
+#define NETLINK_LIST_MEMBERSHIPS	9
+#define NETLINK_CAP_ACK			10
+#define NETLINK_EXT_ACK			11
+
+struct nl_pktinfo {
+	__u32	group;
+};
+
+struct nl_mmap_req {
+	unsigned int	nm_block_size;
+	unsigned int	nm_block_nr;
+	unsigned int	nm_frame_size;
+	unsigned int	nm_frame_nr;
+};
+
+struct nl_mmap_hdr {
+	unsigned int	nm_status;
+	unsigned int	nm_len;
+	__u32		nm_group;
+	/* credentials */
+	__u32		nm_pid;
+	__u32		nm_uid;
+	__u32		nm_gid;
+};
+
+enum nl_mmap_status {
+	NL_MMAP_STATUS_UNUSED,
+	NL_MMAP_STATUS_RESERVED,
+	NL_MMAP_STATUS_VALID,
+	NL_MMAP_STATUS_COPY,
+	NL_MMAP_STATUS_SKIP,
+};
+
+#define NL_MMAP_MSG_ALIGNMENT		NLMSG_ALIGNTO
+#define NL_MMAP_MSG_ALIGN(sz)		__ALIGN_KERNEL(sz, NL_MMAP_MSG_ALIGNMENT)
+#define NL_MMAP_HDRLEN			NL_MMAP_MSG_ALIGN(sizeof(struct nl_mmap_hdr))
+
+#define NET_MAJOR 36		/* Major 36 is reserved for networking 						*/
+
+enum {
+	NETLINK_UNCONNECTED = 0,
+	NETLINK_CONNECTED,
+};
+
+/*
+ *  <------- NLA_HDRLEN ------> <-- NLA_ALIGN(payload)-->
+ * +---------------------+- - -+- - - - - - - - - -+- - -+
+ * |        Header       | Pad |     Payload       | Pad |
+ * |   (struct nlattr)   | ing |                   | ing |
+ * +---------------------+- - -+- - - - - - - - - -+- - -+
+ *  <-------------- nlattr->nla_len -------------->
+ */
+
+struct nlattr {
+	__u16           nla_len;
+	__u16           nla_type;
+};
+
+/*
+ * nla_type (16 bits)
+ * +---+---+-------------------------------+
+ * | N | O | Attribute Type                |
+ * +---+---+-------------------------------+
+ * N := Carries nested attributes
+ * O := Payload stored in network byte order
+ *
+ * Note: The N and O flag are mutually exclusive.
+ */
+#define NLA_F_NESTED		(1 << 15)
+#define NLA_F_NET_BYTEORDER	(1 << 14)
+#define NLA_TYPE_MASK		~(NLA_F_NESTED | NLA_F_NET_BYTEORDER)
+
+#define NLA_ALIGNTO		4
+#define NLA_ALIGN(len)		(((len) + NLA_ALIGNTO - 1) & ~(NLA_ALIGNTO - 1))
+#define NLA_HDRLEN		((int) NLA_ALIGN(sizeof(struct nlattr)))
+
+/* Generic 32 bitflags attribute content sent to the kernel.
+ *
+ * The value is a bitmap that defines the values being set
+ * The selector is a bitmask that defines which value is legit
+ *
+ * Examples:
+ *  value = 0x0, and selector = 0x1
+ *  implies we are selecting bit 1 and we want to set its value to 0.
+ *
+ *  value = 0x2, and selector = 0x2
+ *  implies we are selecting bit 2 and we want to set its value to 1.
+ *
+ */
+struct nla_bitfield32 {
+	__u32 value;
+	__u32 selector;
+};
+
+#endif /* __LINUX_NETLINK_H */
diff --git a/include/uapi/linux/netlink_diag.h b/include/uapi/linux/netlink_diag.h
new file mode 100644
index 0000000..c8c8c7d
--- /dev/null
+++ b/include/uapi/linux/netlink_diag.h
@@ -0,0 +1,64 @@
+#ifndef __NETLINK_DIAG_H__
+#define __NETLINK_DIAG_H__
+
+#include <linux/types.h>
+
+struct netlink_diag_req {
+	__u8	sdiag_family;
+	__u8	sdiag_protocol;
+	__u16	pad;
+	__u32	ndiag_ino;
+	__u32	ndiag_show;
+	__u32	ndiag_cookie[2];
+};
+
+struct netlink_diag_msg {
+	__u8	ndiag_family;
+	__u8	ndiag_type;
+	__u8	ndiag_protocol;
+	__u8	ndiag_state;
+
+	__u32	ndiag_portid;
+	__u32	ndiag_dst_portid;
+	__u32	ndiag_dst_group;
+	__u32	ndiag_ino;
+	__u32	ndiag_cookie[2];
+};
+
+struct netlink_diag_ring {
+	__u32	ndr_block_size;
+	__u32	ndr_block_nr;
+	__u32	ndr_frame_size;
+	__u32	ndr_frame_nr;
+};
+
+enum {
+	/* NETLINK_DIAG_NONE, standard nl API requires this attribute!  */
+	NETLINK_DIAG_MEMINFO,
+	NETLINK_DIAG_GROUPS,
+	NETLINK_DIAG_RX_RING,
+	NETLINK_DIAG_TX_RING,
+	NETLINK_DIAG_FLAGS,
+
+	__NETLINK_DIAG_MAX,
+};
+
+#define NETLINK_DIAG_MAX (__NETLINK_DIAG_MAX - 1)
+
+#define NDIAG_PROTO_ALL		((__u8) ~0)
+
+#define NDIAG_SHOW_MEMINFO	0x00000001 /* show memory info of a socket */
+#define NDIAG_SHOW_GROUPS	0x00000002 /* show groups of a netlink socket */
+/* deprecated since 4.6 */
+#define NDIAG_SHOW_RING_CFG	0x00000004 /* show ring configuration */
+#define NDIAG_SHOW_FLAGS	0x00000008 /* show flags of a netlink socket */
+
+/* flags */
+#define NDIAG_FLAG_CB_RUNNING		0x00000001
+#define NDIAG_FLAG_PKTINFO		0x00000002
+#define NDIAG_FLAG_BROADCAST_ERROR	0x00000004
+#define NDIAG_FLAG_NO_ENOBUFS		0x00000008
+#define NDIAG_FLAG_LISTEN_ALL_NSID	0x00000010
+#define NDIAG_FLAG_CAP_ACK		0x00000020
+
+#endif
diff --git a/include/uapi/linux/packet_diag.h b/include/uapi/linux/packet_diag.h
new file mode 100644
index 0000000..0c5d5dd
--- /dev/null
+++ b/include/uapi/linux/packet_diag.h
@@ -0,0 +1,80 @@
+#ifndef __PACKET_DIAG_H__
+#define __PACKET_DIAG_H__
+
+#include <linux/types.h>
+
+struct packet_diag_req {
+	__u8	sdiag_family;
+	__u8	sdiag_protocol;
+	__u16	pad;
+	__u32	pdiag_ino;
+	__u32	pdiag_show;
+	__u32	pdiag_cookie[2];
+};
+
+#define PACKET_SHOW_INFO	0x00000001 /* Basic packet_sk information */
+#define PACKET_SHOW_MCLIST	0x00000002 /* A set of packet_diag_mclist-s */
+#define PACKET_SHOW_RING_CFG	0x00000004 /* Rings configuration parameters */
+#define PACKET_SHOW_FANOUT	0x00000008
+#define PACKET_SHOW_MEMINFO	0x00000010
+#define PACKET_SHOW_FILTER	0x00000020
+
+struct packet_diag_msg {
+	__u8	pdiag_family;
+	__u8	pdiag_type;
+	__u16	pdiag_num;
+
+	__u32	pdiag_ino;
+	__u32	pdiag_cookie[2];
+};
+
+enum {
+	/* PACKET_DIAG_NONE, standard nl API requires this attribute!  */
+	PACKET_DIAG_INFO,
+	PACKET_DIAG_MCLIST,
+	PACKET_DIAG_RX_RING,
+	PACKET_DIAG_TX_RING,
+	PACKET_DIAG_FANOUT,
+	PACKET_DIAG_UID,
+	PACKET_DIAG_MEMINFO,
+	PACKET_DIAG_FILTER,
+
+	__PACKET_DIAG_MAX,
+};
+
+#define PACKET_DIAG_MAX (__PACKET_DIAG_MAX - 1)
+
+struct packet_diag_info {
+	__u32	pdi_index;
+	__u32	pdi_version;
+	__u32	pdi_reserve;
+	__u32	pdi_copy_thresh;
+	__u32	pdi_tstamp;
+	__u32	pdi_flags;
+
+#define PDI_RUNNING	0x1
+#define PDI_AUXDATA	0x2
+#define PDI_ORIGDEV	0x4
+#define PDI_VNETHDR	0x8
+#define PDI_LOSS	0x10
+};
+
+struct packet_diag_mclist {
+	__u32	pdmc_index;
+	__u32	pdmc_count;
+	__u16	pdmc_type;
+	__u16	pdmc_alen;
+	__u8	pdmc_addr[32]; /* MAX_ADDR_LEN */
+};
+
+struct packet_diag_ring {
+	__u32	pdr_block_size;
+	__u32	pdr_block_nr;
+	__u32	pdr_frame_size;
+	__u32	pdr_frame_nr;
+	__u32	pdr_retire_tmo;
+	__u32	pdr_sizeof_priv;
+	__u32	pdr_features;
+};
+
+#endif
diff --git a/include/uapi/linux/param.h b/include/uapi/linux/param.h
new file mode 100644
index 0000000..092e92f
--- /dev/null
+++ b/include/uapi/linux/param.h
@@ -0,0 +1,6 @@
+#ifndef _LINUX_PARAM_H
+#define _LINUX_PARAM_H
+
+#include <asm/param.h>
+
+#endif
diff --git a/include/uapi/linux/pfkeyv2.h b/include/uapi/linux/pfkeyv2.h
new file mode 100644
index 0000000..ada7f01
--- /dev/null
+++ b/include/uapi/linux/pfkeyv2.h
@@ -0,0 +1,383 @@
+/* PF_KEY user interface, this is defined by rfc2367 so
+ * do not make arbitrary modifications or else this header
+ * file will not be compliant.
+ */
+
+#ifndef _LINUX_PFKEY2_H
+#define _LINUX_PFKEY2_H
+
+#include <linux/types.h>
+
+#define PF_KEY_V2		2
+#define PFKEYV2_REVISION	199806L
+
+struct sadb_msg {
+	__u8		sadb_msg_version;
+	__u8		sadb_msg_type;
+	__u8		sadb_msg_errno;
+	__u8		sadb_msg_satype;
+	__u16	sadb_msg_len;
+	__u16	sadb_msg_reserved;
+	__u32	sadb_msg_seq;
+	__u32	sadb_msg_pid;
+} __attribute__((packed));
+/* sizeof(struct sadb_msg) == 16 */
+
+struct sadb_ext {
+	__u16	sadb_ext_len;
+	__u16	sadb_ext_type;
+} __attribute__((packed));
+/* sizeof(struct sadb_ext) == 4 */
+
+struct sadb_sa {
+	__u16	sadb_sa_len;
+	__u16	sadb_sa_exttype;
+	__be32		sadb_sa_spi;
+	__u8		sadb_sa_replay;
+	__u8		sadb_sa_state;
+	__u8		sadb_sa_auth;
+	__u8		sadb_sa_encrypt;
+	__u32	sadb_sa_flags;
+} __attribute__((packed));
+/* sizeof(struct sadb_sa) == 16 */
+
+struct sadb_lifetime {
+	__u16	sadb_lifetime_len;
+	__u16	sadb_lifetime_exttype;
+	__u32	sadb_lifetime_allocations;
+	__u64	sadb_lifetime_bytes;
+	__u64	sadb_lifetime_addtime;
+	__u64	sadb_lifetime_usetime;
+} __attribute__((packed));
+/* sizeof(struct sadb_lifetime) == 32 */
+
+struct sadb_address {
+	__u16	sadb_address_len;
+	__u16	sadb_address_exttype;
+	__u8		sadb_address_proto;
+	__u8		sadb_address_prefixlen;
+	__u16	sadb_address_reserved;
+} __attribute__((packed));
+/* sizeof(struct sadb_address) == 8 */
+
+struct sadb_key {
+	__u16	sadb_key_len;
+	__u16	sadb_key_exttype;
+	__u16	sadb_key_bits;
+	__u16	sadb_key_reserved;
+} __attribute__((packed));
+/* sizeof(struct sadb_key) == 8 */
+
+struct sadb_ident {
+	__u16	sadb_ident_len;
+	__u16	sadb_ident_exttype;
+	__u16	sadb_ident_type;
+	__u16	sadb_ident_reserved;
+	__u64	sadb_ident_id;
+} __attribute__((packed));
+/* sizeof(struct sadb_ident) == 16 */
+
+struct sadb_sens {
+	__u16	sadb_sens_len;
+	__u16	sadb_sens_exttype;
+	__u32	sadb_sens_dpd;
+	__u8		sadb_sens_sens_level;
+	__u8		sadb_sens_sens_len;
+	__u8		sadb_sens_integ_level;
+	__u8		sadb_sens_integ_len;
+	__u32	sadb_sens_reserved;
+} __attribute__((packed));
+/* sizeof(struct sadb_sens) == 16 */
+
+/* followed by:
+	__u64	sadb_sens_bitmap[sens_len];
+	__u64	sadb_integ_bitmap[integ_len];  */
+
+struct sadb_prop {
+	__u16	sadb_prop_len;
+	__u16	sadb_prop_exttype;
+	__u8		sadb_prop_replay;
+	__u8		sadb_prop_reserved[3];
+} __attribute__((packed));
+/* sizeof(struct sadb_prop) == 8 */
+
+/* followed by:
+	struct sadb_comb sadb_combs[(sadb_prop_len +
+		sizeof(__u64) - sizeof(struct sadb_prop)) /
+		sizeof(struct sadb_comb)]; */
+
+struct sadb_comb {
+	__u8		sadb_comb_auth;
+	__u8		sadb_comb_encrypt;
+	__u16	sadb_comb_flags;
+	__u16	sadb_comb_auth_minbits;
+	__u16	sadb_comb_auth_maxbits;
+	__u16	sadb_comb_encrypt_minbits;
+	__u16	sadb_comb_encrypt_maxbits;
+	__u32	sadb_comb_reserved;
+	__u32	sadb_comb_soft_allocations;
+	__u32	sadb_comb_hard_allocations;
+	__u64	sadb_comb_soft_bytes;
+	__u64	sadb_comb_hard_bytes;
+	__u64	sadb_comb_soft_addtime;
+	__u64	sadb_comb_hard_addtime;
+	__u64	sadb_comb_soft_usetime;
+	__u64	sadb_comb_hard_usetime;
+} __attribute__((packed));
+/* sizeof(struct sadb_comb) == 72 */
+
+struct sadb_supported {
+	__u16	sadb_supported_len;
+	__u16	sadb_supported_exttype;
+	__u32	sadb_supported_reserved;
+} __attribute__((packed));
+/* sizeof(struct sadb_supported) == 8 */
+
+/* followed by:
+	struct sadb_alg sadb_algs[(sadb_supported_len +
+		sizeof(__u64) - sizeof(struct sadb_supported)) /
+		sizeof(struct sadb_alg)]; */
+
+struct sadb_alg {
+	__u8		sadb_alg_id;
+	__u8		sadb_alg_ivlen;
+	__u16	sadb_alg_minbits;
+	__u16	sadb_alg_maxbits;
+	__u16	sadb_alg_reserved;
+} __attribute__((packed));
+/* sizeof(struct sadb_alg) == 8 */
+
+struct sadb_spirange {
+	__u16	sadb_spirange_len;
+	__u16	sadb_spirange_exttype;
+	__u32	sadb_spirange_min;
+	__u32	sadb_spirange_max;
+	__u32	sadb_spirange_reserved;
+} __attribute__((packed));
+/* sizeof(struct sadb_spirange) == 16 */
+
+struct sadb_x_kmprivate {
+	__u16	sadb_x_kmprivate_len;
+	__u16	sadb_x_kmprivate_exttype;
+	__u32	sadb_x_kmprivate_reserved;
+} __attribute__((packed));
+/* sizeof(struct sadb_x_kmprivate) == 8 */
+
+struct sadb_x_sa2 {
+	__u16	sadb_x_sa2_len;
+	__u16	sadb_x_sa2_exttype;
+	__u8		sadb_x_sa2_mode;
+	__u8		sadb_x_sa2_reserved1;
+	__u16	sadb_x_sa2_reserved2;
+	__u32	sadb_x_sa2_sequence;
+	__u32	sadb_x_sa2_reqid;
+} __attribute__((packed));
+/* sizeof(struct sadb_x_sa2) == 16 */
+
+struct sadb_x_policy {
+	__u16	sadb_x_policy_len;
+	__u16	sadb_x_policy_exttype;
+	__u16	sadb_x_policy_type;
+	__u8		sadb_x_policy_dir;
+	__u8		sadb_x_policy_reserved;
+	__u32	sadb_x_policy_id;
+	__u32	sadb_x_policy_priority;
+} __attribute__((packed));
+/* sizeof(struct sadb_x_policy) == 16 */
+
+struct sadb_x_ipsecrequest {
+	__u16	sadb_x_ipsecrequest_len;
+	__u16	sadb_x_ipsecrequest_proto;
+	__u8		sadb_x_ipsecrequest_mode;
+	__u8		sadb_x_ipsecrequest_level;
+	__u16	sadb_x_ipsecrequest_reserved1;
+	__u32	sadb_x_ipsecrequest_reqid;
+	__u32	sadb_x_ipsecrequest_reserved2;
+} __attribute__((packed));
+/* sizeof(struct sadb_x_ipsecrequest) == 16 */
+
+/* This defines the TYPE of Nat Traversal in use.  Currently only one
+ * type of NAT-T is supported, draft-ietf-ipsec-udp-encaps-06
+ */
+struct sadb_x_nat_t_type {
+	__u16	sadb_x_nat_t_type_len;
+	__u16	sadb_x_nat_t_type_exttype;
+	__u8		sadb_x_nat_t_type_type;
+	__u8		sadb_x_nat_t_type_reserved[3];
+} __attribute__((packed));
+/* sizeof(struct sadb_x_nat_t_type) == 8 */
+
+/* Pass a NAT Traversal port (Source or Dest port) */
+struct sadb_x_nat_t_port {
+	__u16	sadb_x_nat_t_port_len;
+	__u16	sadb_x_nat_t_port_exttype;
+	__be16		sadb_x_nat_t_port_port;
+	__u16	sadb_x_nat_t_port_reserved;
+} __attribute__((packed));
+/* sizeof(struct sadb_x_nat_t_port) == 8 */
+
+/* Generic LSM security context */
+struct sadb_x_sec_ctx {
+	__u16	sadb_x_sec_len;
+	__u16	sadb_x_sec_exttype;
+	__u8		sadb_x_ctx_alg;  /* LSMs: e.g., selinux == 1 */
+	__u8		sadb_x_ctx_doi;
+	__u16	sadb_x_ctx_len;
+} __attribute__((packed));
+/* sizeof(struct sadb_sec_ctx) = 8 */
+
+/* Used by MIGRATE to pass addresses IKE will use to perform
+ * negotiation with the peer */
+struct sadb_x_kmaddress {
+	__u16	sadb_x_kmaddress_len;
+	__u16	sadb_x_kmaddress_exttype;
+	__u32	sadb_x_kmaddress_reserved;
+} __attribute__((packed));
+/* sizeof(struct sadb_x_kmaddress) == 8 */
+
+/* To specify the SA dump filter */
+struct sadb_x_filter {
+	__u16	sadb_x_filter_len;
+	__u16	sadb_x_filter_exttype;
+	__u32	sadb_x_filter_saddr[4];
+	__u32	sadb_x_filter_daddr[4];
+	__u16	sadb_x_filter_family;
+	__u8	sadb_x_filter_splen;
+	__u8	sadb_x_filter_dplen;
+} __attribute__((packed));
+/* sizeof(struct sadb_x_filter) == 40 */
+
+/* Message types */
+#define SADB_RESERVED		0
+#define SADB_GETSPI		1
+#define SADB_UPDATE		2
+#define SADB_ADD		3
+#define SADB_DELETE		4
+#define SADB_GET		5
+#define SADB_ACQUIRE		6
+#define SADB_REGISTER		7
+#define SADB_EXPIRE		8
+#define SADB_FLUSH		9
+#define SADB_DUMP		10
+#define SADB_X_PROMISC		11
+#define SADB_X_PCHANGE		12
+#define SADB_X_SPDUPDATE	13
+#define SADB_X_SPDADD		14
+#define SADB_X_SPDDELETE	15
+#define SADB_X_SPDGET		16
+#define SADB_X_SPDACQUIRE	17
+#define SADB_X_SPDDUMP		18
+#define SADB_X_SPDFLUSH		19
+#define SADB_X_SPDSETIDX	20
+#define SADB_X_SPDEXPIRE	21
+#define SADB_X_SPDDELETE2	22
+#define SADB_X_NAT_T_NEW_MAPPING	23
+#define SADB_X_MIGRATE		24
+#define SADB_MAX		24
+
+/* Security Association flags */
+#define SADB_SAFLAGS_PFS	1
+#define SADB_SAFLAGS_NOPMTUDISC	0x20000000
+#define SADB_SAFLAGS_DECAP_DSCP	0x40000000
+#define SADB_SAFLAGS_NOECN	0x80000000
+
+/* Security Association states */
+#define SADB_SASTATE_LARVAL	0
+#define SADB_SASTATE_MATURE	1
+#define SADB_SASTATE_DYING	2
+#define SADB_SASTATE_DEAD	3
+#define SADB_SASTATE_MAX	3
+
+/* Security Association types */
+#define SADB_SATYPE_UNSPEC	0
+#define SADB_SATYPE_AH		2
+#define SADB_SATYPE_ESP		3
+#define SADB_SATYPE_RSVP	5
+#define SADB_SATYPE_OSPFV2	6
+#define SADB_SATYPE_RIPV2	7
+#define SADB_SATYPE_MIP		8
+#define SADB_X_SATYPE_IPCOMP	9
+#define SADB_SATYPE_MAX		9
+
+/* Authentication algorithms */
+#define SADB_AALG_NONE			0
+#define SADB_AALG_MD5HMAC		2
+#define SADB_AALG_SHA1HMAC		3
+#define SADB_X_AALG_SHA2_256HMAC	5
+#define SADB_X_AALG_SHA2_384HMAC	6
+#define SADB_X_AALG_SHA2_512HMAC	7
+#define SADB_X_AALG_RIPEMD160HMAC	8
+#define SADB_X_AALG_AES_XCBC_MAC	9
+#define SADB_X_AALG_NULL		251	/* kame */
+#define SADB_AALG_MAX			251
+
+/* Encryption algorithms */
+#define SADB_EALG_NONE			0
+#define SADB_EALG_DESCBC		2
+#define SADB_EALG_3DESCBC		3
+#define SADB_X_EALG_CASTCBC		6
+#define SADB_X_EALG_BLOWFISHCBC		7
+#define SADB_EALG_NULL			11
+#define SADB_X_EALG_AESCBC		12
+#define SADB_X_EALG_AESCTR		13
+#define SADB_X_EALG_AES_CCM_ICV8	14
+#define SADB_X_EALG_AES_CCM_ICV12	15
+#define SADB_X_EALG_AES_CCM_ICV16	16
+#define SADB_X_EALG_AES_GCM_ICV8	18
+#define SADB_X_EALG_AES_GCM_ICV12	19
+#define SADB_X_EALG_AES_GCM_ICV16	20
+#define SADB_X_EALG_CAMELLIACBC		22
+#define SADB_X_EALG_NULL_AES_GMAC	23
+#define SADB_EALG_MAX                   253 /* last EALG */
+/* private allocations should use 249-255 (RFC2407) */
+#define SADB_X_EALG_SERPENTCBC  252     /* draft-ietf-ipsec-ciph-aes-cbc-00 */
+#define SADB_X_EALG_TWOFISHCBC  253     /* draft-ietf-ipsec-ciph-aes-cbc-00 */
+
+/* Compression algorithms */
+#define SADB_X_CALG_NONE		0
+#define SADB_X_CALG_OUI			1
+#define SADB_X_CALG_DEFLATE		2
+#define SADB_X_CALG_LZS			3
+#define SADB_X_CALG_LZJH		4
+#define SADB_X_CALG_MAX			4
+
+/* Extension Header values */
+#define SADB_EXT_RESERVED		0
+#define SADB_EXT_SA			1
+#define SADB_EXT_LIFETIME_CURRENT	2
+#define SADB_EXT_LIFETIME_HARD		3
+#define SADB_EXT_LIFETIME_SOFT		4
+#define SADB_EXT_ADDRESS_SRC		5
+#define SADB_EXT_ADDRESS_DST		6
+#define SADB_EXT_ADDRESS_PROXY		7
+#define SADB_EXT_KEY_AUTH		8
+#define SADB_EXT_KEY_ENCRYPT		9
+#define SADB_EXT_IDENTITY_SRC		10
+#define SADB_EXT_IDENTITY_DST		11
+#define SADB_EXT_SENSITIVITY		12
+#define SADB_EXT_PROPOSAL		13
+#define SADB_EXT_SUPPORTED_AUTH		14
+#define SADB_EXT_SUPPORTED_ENCRYPT	15
+#define SADB_EXT_SPIRANGE		16
+#define SADB_X_EXT_KMPRIVATE		17
+#define SADB_X_EXT_POLICY		18
+#define SADB_X_EXT_SA2			19
+/* The next four entries are for setting up NAT Traversal */
+#define SADB_X_EXT_NAT_T_TYPE		20
+#define SADB_X_EXT_NAT_T_SPORT		21
+#define SADB_X_EXT_NAT_T_DPORT		22
+#define SADB_X_EXT_NAT_T_OA		23
+#define SADB_X_EXT_SEC_CTX		24
+/* Used with MIGRATE to pass @ to IKE for negotiation */
+#define SADB_X_EXT_KMADDRESS		25
+#define SADB_X_EXT_FILTER		26
+#define SADB_EXT_MAX			26
+
+/* Identity Extension values */
+#define SADB_IDENTTYPE_RESERVED	0
+#define SADB_IDENTTYPE_PREFIX	1
+#define SADB_IDENTTYPE_FQDN	2
+#define SADB_IDENTTYPE_USERFQDN	3
+#define SADB_IDENTTYPE_MAX	3
+
+#endif /* !(_LINUX_PFKEY2_H) */
diff --git a/include/uapi/linux/pkt_cls.h b/include/uapi/linux/pkt_cls.h
new file mode 100644
index 0000000..d5e2bf6
--- /dev/null
+++ b/include/uapi/linux/pkt_cls.h
@@ -0,0 +1,569 @@
+#ifndef __LINUX_PKT_CLS_H
+#define __LINUX_PKT_CLS_H
+
+#include <linux/types.h>
+#include <linux/pkt_sched.h>
+
+#define TC_COOKIE_MAX_SIZE 16
+
+/* Action attributes */
+enum {
+	TCA_ACT_UNSPEC,
+	TCA_ACT_KIND,
+	TCA_ACT_OPTIONS,
+	TCA_ACT_INDEX,
+	TCA_ACT_STATS,
+	TCA_ACT_PAD,
+	TCA_ACT_COOKIE,
+	__TCA_ACT_MAX
+};
+
+#define TCA_ACT_MAX __TCA_ACT_MAX
+#define TCA_OLD_COMPAT (TCA_ACT_MAX+1)
+#define TCA_ACT_MAX_PRIO 32
+#define TCA_ACT_BIND	1
+#define TCA_ACT_NOBIND	0
+#define TCA_ACT_UNBIND	1
+#define TCA_ACT_NOUNBIND	0
+#define TCA_ACT_REPLACE		1
+#define TCA_ACT_NOREPLACE	0
+
+#define TC_ACT_UNSPEC	(-1)
+#define TC_ACT_OK		0
+#define TC_ACT_RECLASSIFY	1
+#define TC_ACT_SHOT		2
+#define TC_ACT_PIPE		3
+#define TC_ACT_STOLEN		4
+#define TC_ACT_QUEUED		5
+#define TC_ACT_REPEAT		6
+#define TC_ACT_REDIRECT		7
+#define TC_ACT_TRAP		8 /* For hw path, this means "trap to cpu"
+				   * and don't further process the frame
+				   * in hardware. For sw path, this is
+				   * equivalent of TC_ACT_STOLEN - drop
+				   * the skb and act like everything
+				   * is alright.
+				   */
+
+/* There is a special kind of actions called "extended actions",
+ * which need a value parameter. These have a local opcode located in
+ * the highest nibble, starting from 1. The rest of the bits
+ * are used to carry the value. These two parts together make
+ * a combined opcode.
+ */
+#define __TC_ACT_EXT_SHIFT 28
+#define __TC_ACT_EXT(local) ((local) << __TC_ACT_EXT_SHIFT)
+#define TC_ACT_EXT_VAL_MASK ((1 << __TC_ACT_EXT_SHIFT) - 1)
+#define TC_ACT_EXT_CMP(combined, opcode) \
+	(((combined) & (~TC_ACT_EXT_VAL_MASK)) == opcode)
+
+#define TC_ACT_JUMP __TC_ACT_EXT(1)
+#define TC_ACT_GOTO_CHAIN __TC_ACT_EXT(2)
+
+/* Action type identifiers*/
+enum {
+	TCA_ID_UNSPEC=0,
+	TCA_ID_POLICE=1,
+	/* other actions go here */
+	__TCA_ID_MAX=255
+};
+
+#define TCA_ID_MAX __TCA_ID_MAX
+
+struct tc_police {
+	__u32			index;
+	int			action;
+#define TC_POLICE_UNSPEC	TC_ACT_UNSPEC
+#define TC_POLICE_OK		TC_ACT_OK
+#define TC_POLICE_RECLASSIFY	TC_ACT_RECLASSIFY
+#define TC_POLICE_SHOT		TC_ACT_SHOT
+#define TC_POLICE_PIPE		TC_ACT_PIPE
+
+	__u32			limit;
+	__u32			burst;
+	__u32			mtu;
+	struct tc_ratespec	rate;
+	struct tc_ratespec	peakrate;
+	int			refcnt;
+	int			bindcnt;
+	__u32			capab;
+};
+
+struct tcf_t {
+	__u64   install;
+	__u64   lastuse;
+	__u64   expires;
+	__u64   firstuse;
+};
+
+struct tc_cnt {
+	int                   refcnt;
+	int                   bindcnt;
+};
+
+#define tc_gen \
+	__u32                 index; \
+	__u32                 capab; \
+	int                   action; \
+	int                   refcnt; \
+	int                   bindcnt
+
+enum {
+	TCA_POLICE_UNSPEC,
+	TCA_POLICE_TBF,
+	TCA_POLICE_RATE,
+	TCA_POLICE_PEAKRATE,
+	TCA_POLICE_AVRATE,
+	TCA_POLICE_RESULT,
+	TCA_POLICE_TM,
+	TCA_POLICE_PAD,
+	__TCA_POLICE_MAX
+#define TCA_POLICE_RESULT TCA_POLICE_RESULT
+};
+
+#define TCA_POLICE_MAX (__TCA_POLICE_MAX - 1)
+
+/* tca flags definitions */
+#define TCA_CLS_FLAGS_SKIP_HW	(1 << 0) /* don't offload filter to HW */
+#define TCA_CLS_FLAGS_SKIP_SW	(1 << 1) /* don't use filter in SW */
+#define TCA_CLS_FLAGS_IN_HW	(1 << 2) /* filter is offloaded to HW */
+#define TCA_CLS_FLAGS_NOT_IN_HW (1 << 3) /* filter isn't offloaded to HW */
+
+/* U32 filters */
+
+#define TC_U32_HTID(h) ((h)&0xFFF00000)
+#define TC_U32_USERHTID(h) (TC_U32_HTID(h)>>20)
+#define TC_U32_HASH(h) (((h)>>12)&0xFF)
+#define TC_U32_NODE(h) ((h)&0xFFF)
+#define TC_U32_KEY(h) ((h)&0xFFFFF)
+#define TC_U32_UNSPEC	0
+#define TC_U32_ROOT	(0xFFF00000)
+
+enum {
+	TCA_U32_UNSPEC,
+	TCA_U32_CLASSID,
+	TCA_U32_HASH,
+	TCA_U32_LINK,
+	TCA_U32_DIVISOR,
+	TCA_U32_SEL,
+	TCA_U32_POLICE,
+	TCA_U32_ACT,
+	TCA_U32_INDEV,
+	TCA_U32_PCNT,
+	TCA_U32_MARK,
+	TCA_U32_FLAGS,
+	TCA_U32_PAD,
+	__TCA_U32_MAX
+};
+
+#define TCA_U32_MAX (__TCA_U32_MAX - 1)
+
+struct tc_u32_key {
+	__be32		mask;
+	__be32		val;
+	int		off;
+	int		offmask;
+};
+
+struct tc_u32_sel {
+	unsigned char		flags;
+	unsigned char		offshift;
+	unsigned char		nkeys;
+
+	__be16			offmask;
+	__u16			off;
+	short			offoff;
+
+	short			hoff;
+	__be32			hmask;
+	struct tc_u32_key	keys[0];
+};
+
+struct tc_u32_mark {
+	__u32		val;
+	__u32		mask;
+	__u32		success;
+};
+
+struct tc_u32_pcnt {
+	__u64 rcnt;
+	__u64 rhit;
+	__u64 kcnts[0];
+};
+
+/* Flags */
+
+#define TC_U32_TERMINAL		1
+#define TC_U32_OFFSET		2
+#define TC_U32_VAROFFSET	4
+#define TC_U32_EAT		8
+
+#define TC_U32_MAXDEPTH 8
+
+
+/* RSVP filter */
+
+enum {
+	TCA_RSVP_UNSPEC,
+	TCA_RSVP_CLASSID,
+	TCA_RSVP_DST,
+	TCA_RSVP_SRC,
+	TCA_RSVP_PINFO,
+	TCA_RSVP_POLICE,
+	TCA_RSVP_ACT,
+	__TCA_RSVP_MAX
+};
+
+#define TCA_RSVP_MAX (__TCA_RSVP_MAX - 1 )
+
+struct tc_rsvp_gpi {
+	__u32	key;
+	__u32	mask;
+	int	offset;
+};
+
+struct tc_rsvp_pinfo {
+	struct tc_rsvp_gpi dpi;
+	struct tc_rsvp_gpi spi;
+	__u8	protocol;
+	__u8	tunnelid;
+	__u8	tunnelhdr;
+	__u8	pad;
+};
+
+/* ROUTE filter */
+
+enum {
+	TCA_ROUTE4_UNSPEC,
+	TCA_ROUTE4_CLASSID,
+	TCA_ROUTE4_TO,
+	TCA_ROUTE4_FROM,
+	TCA_ROUTE4_IIF,
+	TCA_ROUTE4_POLICE,
+	TCA_ROUTE4_ACT,
+	__TCA_ROUTE4_MAX
+};
+
+#define TCA_ROUTE4_MAX (__TCA_ROUTE4_MAX - 1)
+
+
+/* FW filter */
+
+enum {
+	TCA_FW_UNSPEC,
+	TCA_FW_CLASSID,
+	TCA_FW_POLICE,
+	TCA_FW_INDEV, /*  used by CONFIG_NET_CLS_IND */
+	TCA_FW_ACT, /* used by CONFIG_NET_CLS_ACT */
+	TCA_FW_MASK,
+	__TCA_FW_MAX
+};
+
+#define TCA_FW_MAX (__TCA_FW_MAX - 1)
+
+/* TC index filter */
+
+enum {
+	TCA_TCINDEX_UNSPEC,
+	TCA_TCINDEX_HASH,
+	TCA_TCINDEX_MASK,
+	TCA_TCINDEX_SHIFT,
+	TCA_TCINDEX_FALL_THROUGH,
+	TCA_TCINDEX_CLASSID,
+	TCA_TCINDEX_POLICE,
+	TCA_TCINDEX_ACT,
+	__TCA_TCINDEX_MAX
+};
+
+#define TCA_TCINDEX_MAX     (__TCA_TCINDEX_MAX - 1)
+
+/* Flow filter */
+
+enum {
+	FLOW_KEY_SRC,
+	FLOW_KEY_DST,
+	FLOW_KEY_PROTO,
+	FLOW_KEY_PROTO_SRC,
+	FLOW_KEY_PROTO_DST,
+	FLOW_KEY_IIF,
+	FLOW_KEY_PRIORITY,
+	FLOW_KEY_MARK,
+	FLOW_KEY_NFCT,
+	FLOW_KEY_NFCT_SRC,
+	FLOW_KEY_NFCT_DST,
+	FLOW_KEY_NFCT_PROTO_SRC,
+	FLOW_KEY_NFCT_PROTO_DST,
+	FLOW_KEY_RTCLASSID,
+	FLOW_KEY_SKUID,
+	FLOW_KEY_SKGID,
+	FLOW_KEY_VLAN_TAG,
+	FLOW_KEY_RXHASH,
+	__FLOW_KEY_MAX,
+};
+
+#define FLOW_KEY_MAX	(__FLOW_KEY_MAX - 1)
+
+enum {
+	FLOW_MODE_MAP,
+	FLOW_MODE_HASH,
+};
+
+enum {
+	TCA_FLOW_UNSPEC,
+	TCA_FLOW_KEYS,
+	TCA_FLOW_MODE,
+	TCA_FLOW_BASECLASS,
+	TCA_FLOW_RSHIFT,
+	TCA_FLOW_ADDEND,
+	TCA_FLOW_MASK,
+	TCA_FLOW_XOR,
+	TCA_FLOW_DIVISOR,
+	TCA_FLOW_ACT,
+	TCA_FLOW_POLICE,
+	TCA_FLOW_EMATCHES,
+	TCA_FLOW_PERTURB,
+	__TCA_FLOW_MAX
+};
+
+#define TCA_FLOW_MAX	(__TCA_FLOW_MAX - 1)
+
+/* Basic filter */
+
+enum {
+	TCA_BASIC_UNSPEC,
+	TCA_BASIC_CLASSID,
+	TCA_BASIC_EMATCHES,
+	TCA_BASIC_ACT,
+	TCA_BASIC_POLICE,
+	__TCA_BASIC_MAX
+};
+
+#define TCA_BASIC_MAX (__TCA_BASIC_MAX - 1)
+
+
+/* Cgroup classifier */
+
+enum {
+	TCA_CGROUP_UNSPEC,
+	TCA_CGROUP_ACT,
+	TCA_CGROUP_POLICE,
+	TCA_CGROUP_EMATCHES,
+	__TCA_CGROUP_MAX,
+};
+
+#define TCA_CGROUP_MAX (__TCA_CGROUP_MAX - 1)
+
+/* BPF classifier */
+
+#define TCA_BPF_FLAG_ACT_DIRECT		(1 << 0)
+
+enum {
+	TCA_BPF_UNSPEC,
+	TCA_BPF_ACT,
+	TCA_BPF_POLICE,
+	TCA_BPF_CLASSID,
+	TCA_BPF_OPS_LEN,
+	TCA_BPF_OPS,
+	TCA_BPF_FD,
+	TCA_BPF_NAME,
+	TCA_BPF_FLAGS,
+	TCA_BPF_FLAGS_GEN,
+	TCA_BPF_TAG,
+	TCA_BPF_ID,
+	__TCA_BPF_MAX,
+};
+
+#define TCA_BPF_MAX (__TCA_BPF_MAX - 1)
+
+/* Flower classifier */
+
+enum {
+	TCA_FLOWER_UNSPEC,
+	TCA_FLOWER_CLASSID,
+	TCA_FLOWER_INDEV,
+	TCA_FLOWER_ACT,
+	TCA_FLOWER_KEY_ETH_DST,		/* ETH_ALEN */
+	TCA_FLOWER_KEY_ETH_DST_MASK,	/* ETH_ALEN */
+	TCA_FLOWER_KEY_ETH_SRC,		/* ETH_ALEN */
+	TCA_FLOWER_KEY_ETH_SRC_MASK,	/* ETH_ALEN */
+	TCA_FLOWER_KEY_ETH_TYPE,	/* be16 */
+	TCA_FLOWER_KEY_IP_PROTO,	/* u8 */
+	TCA_FLOWER_KEY_IPV4_SRC,	/* be32 */
+	TCA_FLOWER_KEY_IPV4_SRC_MASK,	/* be32 */
+	TCA_FLOWER_KEY_IPV4_DST,	/* be32 */
+	TCA_FLOWER_KEY_IPV4_DST_MASK,	/* be32 */
+	TCA_FLOWER_KEY_IPV6_SRC,	/* struct in6_addr */
+	TCA_FLOWER_KEY_IPV6_SRC_MASK,	/* struct in6_addr */
+	TCA_FLOWER_KEY_IPV6_DST,	/* struct in6_addr */
+	TCA_FLOWER_KEY_IPV6_DST_MASK,	/* struct in6_addr */
+	TCA_FLOWER_KEY_TCP_SRC,		/* be16 */
+	TCA_FLOWER_KEY_TCP_DST,		/* be16 */
+	TCA_FLOWER_KEY_UDP_SRC,		/* be16 */
+	TCA_FLOWER_KEY_UDP_DST,		/* be16 */
+
+	TCA_FLOWER_FLAGS,
+	TCA_FLOWER_KEY_VLAN_ID,		/* be16 */
+	TCA_FLOWER_KEY_VLAN_PRIO,	/* u8   */
+	TCA_FLOWER_KEY_VLAN_ETH_TYPE,	/* be16 */
+
+	TCA_FLOWER_KEY_ENC_KEY_ID,	/* be32 */
+	TCA_FLOWER_KEY_ENC_IPV4_SRC,	/* be32 */
+	TCA_FLOWER_KEY_ENC_IPV4_SRC_MASK,/* be32 */
+	TCA_FLOWER_KEY_ENC_IPV4_DST,	/* be32 */
+	TCA_FLOWER_KEY_ENC_IPV4_DST_MASK,/* be32 */
+	TCA_FLOWER_KEY_ENC_IPV6_SRC,	/* struct in6_addr */
+	TCA_FLOWER_KEY_ENC_IPV6_SRC_MASK,/* struct in6_addr */
+	TCA_FLOWER_KEY_ENC_IPV6_DST,	/* struct in6_addr */
+	TCA_FLOWER_KEY_ENC_IPV6_DST_MASK,/* struct in6_addr */
+
+	TCA_FLOWER_KEY_TCP_SRC_MASK,	/* be16 */
+	TCA_FLOWER_KEY_TCP_DST_MASK,	/* be16 */
+	TCA_FLOWER_KEY_UDP_SRC_MASK,	/* be16 */
+	TCA_FLOWER_KEY_UDP_DST_MASK,	/* be16 */
+	TCA_FLOWER_KEY_SCTP_SRC_MASK,	/* be16 */
+	TCA_FLOWER_KEY_SCTP_DST_MASK,	/* be16 */
+
+	TCA_FLOWER_KEY_SCTP_SRC,	/* be16 */
+	TCA_FLOWER_KEY_SCTP_DST,	/* be16 */
+
+	TCA_FLOWER_KEY_ENC_UDP_SRC_PORT,	/* be16 */
+	TCA_FLOWER_KEY_ENC_UDP_SRC_PORT_MASK,	/* be16 */
+	TCA_FLOWER_KEY_ENC_UDP_DST_PORT,	/* be16 */
+	TCA_FLOWER_KEY_ENC_UDP_DST_PORT_MASK,	/* be16 */
+
+	TCA_FLOWER_KEY_FLAGS,		/* be32 */
+	TCA_FLOWER_KEY_FLAGS_MASK,	/* be32 */
+
+	TCA_FLOWER_KEY_ICMPV4_CODE,	/* u8 */
+	TCA_FLOWER_KEY_ICMPV4_CODE_MASK,/* u8 */
+	TCA_FLOWER_KEY_ICMPV4_TYPE,	/* u8 */
+	TCA_FLOWER_KEY_ICMPV4_TYPE_MASK,/* u8 */
+	TCA_FLOWER_KEY_ICMPV6_CODE,	/* u8 */
+	TCA_FLOWER_KEY_ICMPV6_CODE_MASK,/* u8 */
+	TCA_FLOWER_KEY_ICMPV6_TYPE,	/* u8 */
+	TCA_FLOWER_KEY_ICMPV6_TYPE_MASK,/* u8 */
+
+	TCA_FLOWER_KEY_ARP_SIP,		/* be32 */
+	TCA_FLOWER_KEY_ARP_SIP_MASK,	/* be32 */
+	TCA_FLOWER_KEY_ARP_TIP,		/* be32 */
+	TCA_FLOWER_KEY_ARP_TIP_MASK,	/* be32 */
+	TCA_FLOWER_KEY_ARP_OP,		/* u8 */
+	TCA_FLOWER_KEY_ARP_OP_MASK,	/* u8 */
+	TCA_FLOWER_KEY_ARP_SHA,		/* ETH_ALEN */
+	TCA_FLOWER_KEY_ARP_SHA_MASK,	/* ETH_ALEN */
+	TCA_FLOWER_KEY_ARP_THA,		/* ETH_ALEN */
+	TCA_FLOWER_KEY_ARP_THA_MASK,	/* ETH_ALEN */
+
+	TCA_FLOWER_KEY_MPLS_TTL,	/* u8 - 8 bits */
+	TCA_FLOWER_KEY_MPLS_BOS,	/* u8 - 1 bit */
+	TCA_FLOWER_KEY_MPLS_TC,		/* u8 - 3 bits */
+	TCA_FLOWER_KEY_MPLS_LABEL,	/* be32 - 20 bits */
+
+	TCA_FLOWER_KEY_TCP_FLAGS,	/* be16 */
+	TCA_FLOWER_KEY_TCP_FLAGS_MASK,	/* be16 */
+
+	TCA_FLOWER_KEY_IP_TOS,		/* u8 */
+	TCA_FLOWER_KEY_IP_TOS_MASK,	/* u8 */
+	TCA_FLOWER_KEY_IP_TTL,		/* u8 */
+	TCA_FLOWER_KEY_IP_TTL_MASK,	/* u8 */
+
+	__TCA_FLOWER_MAX,
+};
+
+#define TCA_FLOWER_MAX (__TCA_FLOWER_MAX - 1)
+
+enum {
+	TCA_FLOWER_KEY_FLAGS_IS_FRAGMENT = (1 << 0),
+};
+
+/* Match-all classifier */
+
+enum {
+	TCA_MATCHALL_UNSPEC,
+	TCA_MATCHALL_CLASSID,
+	TCA_MATCHALL_ACT,
+	TCA_MATCHALL_FLAGS,
+	__TCA_MATCHALL_MAX,
+};
+
+#define TCA_MATCHALL_MAX (__TCA_MATCHALL_MAX - 1)
+
+/* Extended Matches */
+
+struct tcf_ematch_tree_hdr {
+	__u16		nmatches;
+	__u16		progid;
+};
+
+enum {
+	TCA_EMATCH_TREE_UNSPEC,
+	TCA_EMATCH_TREE_HDR,
+	TCA_EMATCH_TREE_LIST,
+	__TCA_EMATCH_TREE_MAX
+};
+#define TCA_EMATCH_TREE_MAX (__TCA_EMATCH_TREE_MAX - 1)
+
+struct tcf_ematch_hdr {
+	__u16		matchid;
+	__u16		kind;
+	__u16		flags;
+	__u16		pad; /* currently unused */
+};
+
+/*  0                   1
+ *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 
+ * +-----------------------+-+-+---+
+ * |         Unused        |S|I| R |
+ * +-----------------------+-+-+---+
+ *
+ * R(2) ::= relation to next ematch
+ *          where: 0 0 END (last ematch)
+ *                 0 1 AND
+ *                 1 0 OR
+ *                 1 1 Unused (invalid)
+ * I(1) ::= invert result
+ * S(1) ::= simple payload
+ */
+#define TCF_EM_REL_END	0
+#define TCF_EM_REL_AND	(1<<0)
+#define TCF_EM_REL_OR	(1<<1)
+#define TCF_EM_INVERT	(1<<2)
+#define TCF_EM_SIMPLE	(1<<3)
+
+#define TCF_EM_REL_MASK	3
+#define TCF_EM_REL_VALID(v) (((v) & TCF_EM_REL_MASK) != TCF_EM_REL_MASK)
+
+enum {
+	TCF_LAYER_LINK,
+	TCF_LAYER_NETWORK,
+	TCF_LAYER_TRANSPORT,
+	__TCF_LAYER_MAX
+};
+#define TCF_LAYER_MAX (__TCF_LAYER_MAX - 1)
+
+/* Ematch type assignments
+ *   1..32767		Reserved for ematches inside kernel tree
+ *   32768..65535	Free to use, not reliable
+ */
+#define	TCF_EM_CONTAINER	0
+#define	TCF_EM_CMP		1
+#define	TCF_EM_NBYTE		2
+#define	TCF_EM_U32		3
+#define	TCF_EM_META		4
+#define	TCF_EM_TEXT		5
+#define	TCF_EM_VLAN		6
+#define	TCF_EM_CANID		7
+#define	TCF_EM_IPSET		8
+#define	TCF_EM_MAX		8
+
+enum {
+	TCF_EM_PROG_TC
+};
+
+enum {
+	TCF_EM_OPND_EQ,
+	TCF_EM_OPND_GT,
+	TCF_EM_OPND_LT
+};
+
+#endif
diff --git a/include/uapi/linux/pkt_sched.h b/include/uapi/linux/pkt_sched.h
new file mode 100644
index 0000000..099bf55
--- /dev/null
+++ b/include/uapi/linux/pkt_sched.h
@@ -0,0 +1,874 @@
+#ifndef __LINUX_PKT_SCHED_H
+#define __LINUX_PKT_SCHED_H
+
+#include <linux/types.h>
+
+/* Logical priority bands not depending on specific packet scheduler.
+   Every scheduler will map them to real traffic classes, if it has
+   no more precise mechanism to classify packets.
+
+   These numbers have no special meaning, though their coincidence
+   with obsolete IPv6 values is not occasional :-). New IPv6 drafts
+   preferred full anarchy inspired by diffserv group.
+
+   Note: TC_PRIO_BESTEFFORT does not mean that it is the most unhappy
+   class, actually, as rule it will be handled with more care than
+   filler or even bulk.
+ */
+
+#define TC_PRIO_BESTEFFORT		0
+#define TC_PRIO_FILLER			1
+#define TC_PRIO_BULK			2
+#define TC_PRIO_INTERACTIVE_BULK	4
+#define TC_PRIO_INTERACTIVE		6
+#define TC_PRIO_CONTROL			7
+
+#define TC_PRIO_MAX			15
+
+/* Generic queue statistics, available for all the elements.
+   Particular schedulers may have also their private records.
+ */
+
+struct tc_stats {
+	__u64	bytes;			/* Number of enqueued bytes */
+	__u32	packets;		/* Number of enqueued packets	*/
+	__u32	drops;			/* Packets dropped because of lack of resources */
+	__u32	overlimits;		/* Number of throttle events when this
+					 * flow goes out of allocated bandwidth */
+	__u32	bps;			/* Current flow byte rate */
+	__u32	pps;			/* Current flow packet rate */
+	__u32	qlen;
+	__u32	backlog;
+};
+
+struct tc_estimator {
+	signed char	interval;
+	unsigned char	ewma_log;
+};
+
+/* "Handles"
+   ---------
+
+    All the traffic control objects have 32bit identifiers, or "handles".
+
+    They can be considered as opaque numbers from user API viewpoint,
+    but actually they always consist of two fields: major and
+    minor numbers, which are interpreted by kernel specially,
+    that may be used by applications, though not recommended.
+
+    F.e. qdisc handles always have minor number equal to zero,
+    classes (or flows) have major equal to parent qdisc major, and
+    minor uniquely identifying class inside qdisc.
+
+    Macros to manipulate handles:
+ */
+
+#define TC_H_MAJ_MASK (0xFFFF0000U)
+#define TC_H_MIN_MASK (0x0000FFFFU)
+#define TC_H_MAJ(h) ((h)&TC_H_MAJ_MASK)
+#define TC_H_MIN(h) ((h)&TC_H_MIN_MASK)
+#define TC_H_MAKE(maj,min) (((maj)&TC_H_MAJ_MASK)|((min)&TC_H_MIN_MASK))
+
+#define TC_H_UNSPEC	(0U)
+#define TC_H_ROOT	(0xFFFFFFFFU)
+#define TC_H_INGRESS    (0xFFFFFFF1U)
+#define TC_H_CLSACT	TC_H_INGRESS
+
+#define TC_H_MIN_INGRESS	0xFFF2U
+#define TC_H_MIN_EGRESS		0xFFF3U
+
+/* Need to corrospond to iproute2 tc/tc_core.h "enum link_layer" */
+enum tc_link_layer {
+	TC_LINKLAYER_UNAWARE, /* Indicate unaware old iproute2 util */
+	TC_LINKLAYER_ETHERNET,
+	TC_LINKLAYER_ATM,
+};
+#define TC_LINKLAYER_MASK 0x0F /* limit use to lower 4 bits */
+
+struct tc_ratespec {
+	unsigned char	cell_log;
+	__u8		linklayer; /* lower 4 bits */
+	unsigned short	overhead;
+	short		cell_align;
+	unsigned short	mpu;
+	__u32		rate;
+};
+
+#define TC_RTAB_SIZE	1024
+
+struct tc_sizespec {
+	unsigned char	cell_log;
+	unsigned char	size_log;
+	short		cell_align;
+	int		overhead;
+	unsigned int	linklayer;
+	unsigned int	mpu;
+	unsigned int	mtu;
+	unsigned int	tsize;
+};
+
+enum {
+	TCA_STAB_UNSPEC,
+	TCA_STAB_BASE,
+	TCA_STAB_DATA,
+	__TCA_STAB_MAX
+};
+
+#define TCA_STAB_MAX (__TCA_STAB_MAX - 1)
+
+/* FIFO section */
+
+struct tc_fifo_qopt {
+	__u32	limit;	/* Queue length: bytes for bfifo, packets for pfifo */
+};
+
+/* PRIO section */
+
+#define TCQ_PRIO_BANDS	16
+#define TCQ_MIN_PRIO_BANDS 2
+
+struct tc_prio_qopt {
+	int	bands;			/* Number of bands */
+	__u8	priomap[TC_PRIO_MAX+1];	/* Map: logical priority -> PRIO band */
+};
+
+/* MULTIQ section */
+
+struct tc_multiq_qopt {
+	__u16	bands;			/* Number of bands */
+	__u16	max_bands;		/* Maximum number of queues */
+};
+
+/* PLUG section */
+
+#define TCQ_PLUG_BUFFER                0
+#define TCQ_PLUG_RELEASE_ONE           1
+#define TCQ_PLUG_RELEASE_INDEFINITE    2
+#define TCQ_PLUG_LIMIT                 3
+
+struct tc_plug_qopt {
+	/* TCQ_PLUG_BUFFER: Inset a plug into the queue and
+	 *  buffer any incoming packets
+	 * TCQ_PLUG_RELEASE_ONE: Dequeue packets from queue head
+	 *   to beginning of the next plug.
+	 * TCQ_PLUG_RELEASE_INDEFINITE: Dequeue all packets from queue.
+	 *   Stop buffering packets until the next TCQ_PLUG_BUFFER
+	 *   command is received (just act as a pass-thru queue).
+	 * TCQ_PLUG_LIMIT: Increase/decrease queue size
+	 */
+	int             action;
+	__u32           limit;
+};
+
+/* TBF section */
+
+struct tc_tbf_qopt {
+	struct tc_ratespec rate;
+	struct tc_ratespec peakrate;
+	__u32		limit;
+	__u32		buffer;
+	__u32		mtu;
+};
+
+enum {
+	TCA_TBF_UNSPEC,
+	TCA_TBF_PARMS,
+	TCA_TBF_RTAB,
+	TCA_TBF_PTAB,
+	TCA_TBF_RATE64,
+	TCA_TBF_PRATE64,
+	TCA_TBF_BURST,
+	TCA_TBF_PBURST,
+	TCA_TBF_PAD,
+	__TCA_TBF_MAX,
+};
+
+#define TCA_TBF_MAX (__TCA_TBF_MAX - 1)
+
+
+/* TEQL section */
+
+/* TEQL does not require any parameters */
+
+/* SFQ section */
+
+struct tc_sfq_qopt {
+	unsigned	quantum;	/* Bytes per round allocated to flow */
+	int		perturb_period;	/* Period of hash perturbation */
+	__u32		limit;		/* Maximal packets in queue */
+	unsigned	divisor;	/* Hash divisor  */
+	unsigned	flows;		/* Maximal number of flows  */
+};
+
+struct tc_sfqred_stats {
+	__u32           prob_drop;      /* Early drops, below max threshold */
+	__u32           forced_drop;	/* Early drops, after max threshold */
+	__u32           prob_mark;      /* Marked packets, below max threshold */
+	__u32           forced_mark;    /* Marked packets, after max threshold */
+	__u32           prob_mark_head; /* Marked packets, below max threshold */
+	__u32           forced_mark_head;/* Marked packets, after max threshold */
+};
+
+struct tc_sfq_qopt_v1 {
+	struct tc_sfq_qopt v0;
+	unsigned int	depth;		/* max number of packets per flow */
+	unsigned int	headdrop;
+/* SFQRED parameters */
+	__u32		limit;		/* HARD maximal flow queue length (bytes) */
+	__u32		qth_min;	/* Min average length threshold (bytes) */
+	__u32		qth_max;	/* Max average length threshold (bytes) */
+	unsigned char   Wlog;		/* log(W)		*/
+	unsigned char   Plog;		/* log(P_max/(qth_max-qth_min))	*/
+	unsigned char   Scell_log;	/* cell size for idle damping */
+	unsigned char	flags;
+	__u32		max_P;		/* probability, high resolution */
+/* SFQRED stats */
+	struct tc_sfqred_stats stats;
+};
+
+
+struct tc_sfq_xstats {
+	__s32		allot;
+};
+
+/* RED section */
+
+enum {
+	TCA_RED_UNSPEC,
+	TCA_RED_PARMS,
+	TCA_RED_STAB,
+	TCA_RED_MAX_P,
+	__TCA_RED_MAX,
+};
+
+#define TCA_RED_MAX (__TCA_RED_MAX - 1)
+
+struct tc_red_qopt {
+	__u32		limit;		/* HARD maximal queue length (bytes)	*/
+	__u32		qth_min;	/* Min average length threshold (bytes) */
+	__u32		qth_max;	/* Max average length threshold (bytes) */
+	unsigned char   Wlog;		/* log(W)		*/
+	unsigned char   Plog;		/* log(P_max/(qth_max-qth_min))	*/
+	unsigned char   Scell_log;	/* cell size for idle damping */
+	unsigned char	flags;
+#define TC_RED_ECN		1
+#define TC_RED_HARDDROP		2
+#define TC_RED_ADAPTATIVE	4
+};
+
+struct tc_red_xstats {
+	__u32           early;          /* Early drops */
+	__u32           pdrop;          /* Drops due to queue limits */
+	__u32           other;          /* Drops due to drop() calls */
+	__u32           marked;         /* Marked packets */
+};
+
+/* GRED section */
+
+#define MAX_DPs 16
+
+enum {
+       TCA_GRED_UNSPEC,
+       TCA_GRED_PARMS,
+       TCA_GRED_STAB,
+       TCA_GRED_DPS,
+       TCA_GRED_MAX_P,
+       TCA_GRED_LIMIT,
+       __TCA_GRED_MAX,
+};
+
+#define TCA_GRED_MAX (__TCA_GRED_MAX - 1)
+
+struct tc_gred_qopt {
+	__u32		limit;        /* HARD maximal queue length (bytes)    */
+	__u32		qth_min;      /* Min average length threshold (bytes) */
+	__u32		qth_max;      /* Max average length threshold (bytes) */
+	__u32		DP;           /* up to 2^32 DPs */
+	__u32		backlog;
+	__u32		qave;
+	__u32		forced;
+	__u32		early;
+	__u32		other;
+	__u32		pdrop;
+	__u8		Wlog;         /* log(W)               */
+	__u8		Plog;         /* log(P_max/(qth_max-qth_min)) */
+	__u8		Scell_log;    /* cell size for idle damping */
+	__u8		prio;         /* prio of this VQ */
+	__u32		packets;
+	__u32		bytesin;
+};
+
+/* gred setup */
+struct tc_gred_sopt {
+	__u32		DPs;
+	__u32		def_DP;
+	__u8		grio;
+	__u8		flags;
+	__u16		pad1;
+};
+
+/* CHOKe section */
+
+enum {
+	TCA_CHOKE_UNSPEC,
+	TCA_CHOKE_PARMS,
+	TCA_CHOKE_STAB,
+	TCA_CHOKE_MAX_P,
+	__TCA_CHOKE_MAX,
+};
+
+#define TCA_CHOKE_MAX (__TCA_CHOKE_MAX - 1)
+
+struct tc_choke_qopt {
+	__u32		limit;		/* Hard queue length (packets)	*/
+	__u32		qth_min;	/* Min average threshold (packets) */
+	__u32		qth_max;	/* Max average threshold (packets) */
+	unsigned char   Wlog;		/* log(W)		*/
+	unsigned char   Plog;		/* log(P_max/(qth_max-qth_min))	*/
+	unsigned char   Scell_log;	/* cell size for idle damping */
+	unsigned char	flags;		/* see RED flags */
+};
+
+struct tc_choke_xstats {
+	__u32		early;          /* Early drops */
+	__u32		pdrop;          /* Drops due to queue limits */
+	__u32		other;          /* Drops due to drop() calls */
+	__u32		marked;         /* Marked packets */
+	__u32		matched;	/* Drops due to flow match */
+};
+
+/* HTB section */
+#define TC_HTB_NUMPRIO		8
+#define TC_HTB_MAXDEPTH		8
+#define TC_HTB_PROTOVER		3 /* the same as HTB and TC's major */
+
+struct tc_htb_opt {
+	struct tc_ratespec 	rate;
+	struct tc_ratespec 	ceil;
+	__u32	buffer;
+	__u32	cbuffer;
+	__u32	quantum;
+	__u32	level;		/* out only */
+	__u32	prio;
+};
+struct tc_htb_glob {
+	__u32 version;		/* to match HTB/TC */
+    	__u32 rate2quantum;	/* bps->quantum divisor */
+    	__u32 defcls;		/* default class number */
+	__u32 debug;		/* debug flags */
+
+	/* stats */
+	__u32 direct_pkts; /* count of non shaped packets */
+};
+enum {
+	TCA_HTB_UNSPEC,
+	TCA_HTB_PARMS,
+	TCA_HTB_INIT,
+	TCA_HTB_CTAB,
+	TCA_HTB_RTAB,
+	TCA_HTB_DIRECT_QLEN,
+	TCA_HTB_RATE64,
+	TCA_HTB_CEIL64,
+	TCA_HTB_PAD,
+	__TCA_HTB_MAX,
+};
+
+#define TCA_HTB_MAX (__TCA_HTB_MAX - 1)
+
+struct tc_htb_xstats {
+	__u32 lends;
+	__u32 borrows;
+	__u32 giants;	/* too big packets (rate will not be accurate) */
+	__u32 tokens;
+	__u32 ctokens;
+};
+
+/* HFSC section */
+
+struct tc_hfsc_qopt {
+	__u16	defcls;		/* default class */
+};
+
+struct tc_service_curve {
+	__u32	m1;		/* slope of the first segment in bps */
+	__u32	d;		/* x-projection of the first segment in us */
+	__u32	m2;		/* slope of the second segment in bps */
+};
+
+struct tc_hfsc_stats {
+	__u64	work;		/* total work done */
+	__u64	rtwork;		/* work done by real-time criteria */
+	__u32	period;		/* current period */
+	__u32	level;		/* class level in hierarchy */
+};
+
+enum {
+	TCA_HFSC_UNSPEC,
+	TCA_HFSC_RSC,
+	TCA_HFSC_FSC,
+	TCA_HFSC_USC,
+	__TCA_HFSC_MAX,
+};
+
+#define TCA_HFSC_MAX (__TCA_HFSC_MAX - 1)
+
+
+/* CBQ section */
+
+#define TC_CBQ_MAXPRIO		8
+#define TC_CBQ_MAXLEVEL		8
+#define TC_CBQ_DEF_EWMA		5
+
+struct tc_cbq_lssopt {
+	unsigned char	change;
+	unsigned char	flags;
+#define TCF_CBQ_LSS_BOUNDED	1
+#define TCF_CBQ_LSS_ISOLATED	2
+	unsigned char  	ewma_log;
+	unsigned char  	level;
+#define TCF_CBQ_LSS_FLAGS	1
+#define TCF_CBQ_LSS_EWMA	2
+#define TCF_CBQ_LSS_MAXIDLE	4
+#define TCF_CBQ_LSS_MINIDLE	8
+#define TCF_CBQ_LSS_OFFTIME	0x10
+#define TCF_CBQ_LSS_AVPKT	0x20
+	__u32		maxidle;
+	__u32		minidle;
+	__u32		offtime;
+	__u32		avpkt;
+};
+
+struct tc_cbq_wrropt {
+	unsigned char	flags;
+	unsigned char	priority;
+	unsigned char	cpriority;
+	unsigned char	__reserved;
+	__u32		allot;
+	__u32		weight;
+};
+
+struct tc_cbq_ovl {
+	unsigned char	strategy;
+#define	TC_CBQ_OVL_CLASSIC	0
+#define	TC_CBQ_OVL_DELAY	1
+#define	TC_CBQ_OVL_LOWPRIO	2
+#define	TC_CBQ_OVL_DROP		3
+#define	TC_CBQ_OVL_RCLASSIC	4
+	unsigned char	priority2;
+	__u16		pad;
+	__u32		penalty;
+};
+
+struct tc_cbq_police {
+	unsigned char	police;
+	unsigned char	__res1;
+	unsigned short	__res2;
+};
+
+struct tc_cbq_fopt {
+	__u32		split;
+	__u32		defmap;
+	__u32		defchange;
+};
+
+struct tc_cbq_xstats {
+	__u32		borrows;
+	__u32		overactions;
+	__s32		avgidle;
+	__s32		undertime;
+};
+
+enum {
+	TCA_CBQ_UNSPEC,
+	TCA_CBQ_LSSOPT,
+	TCA_CBQ_WRROPT,
+	TCA_CBQ_FOPT,
+	TCA_CBQ_OVL_STRATEGY,
+	TCA_CBQ_RATE,
+	TCA_CBQ_RTAB,
+	TCA_CBQ_POLICE,
+	__TCA_CBQ_MAX,
+};
+
+#define TCA_CBQ_MAX	(__TCA_CBQ_MAX - 1)
+
+/* dsmark section */
+
+enum {
+	TCA_DSMARK_UNSPEC,
+	TCA_DSMARK_INDICES,
+	TCA_DSMARK_DEFAULT_INDEX,
+	TCA_DSMARK_SET_TC_INDEX,
+	TCA_DSMARK_MASK,
+	TCA_DSMARK_VALUE,
+	__TCA_DSMARK_MAX,
+};
+
+#define TCA_DSMARK_MAX (__TCA_DSMARK_MAX - 1)
+
+/* ATM  section */
+
+enum {
+	TCA_ATM_UNSPEC,
+	TCA_ATM_FD,		/* file/socket descriptor */
+	TCA_ATM_PTR,		/* pointer to descriptor - later */
+	TCA_ATM_HDR,		/* LL header */
+	TCA_ATM_EXCESS,		/* excess traffic class (0 for CLP)  */
+	TCA_ATM_ADDR,		/* PVC address (for output only) */
+	TCA_ATM_STATE,		/* VC state (ATM_VS_*; for output only) */
+	__TCA_ATM_MAX,
+};
+
+#define TCA_ATM_MAX	(__TCA_ATM_MAX - 1)
+
+/* Network emulator */
+
+enum {
+	TCA_NETEM_UNSPEC,
+	TCA_NETEM_CORR,
+	TCA_NETEM_DELAY_DIST,
+	TCA_NETEM_REORDER,
+	TCA_NETEM_CORRUPT,
+	TCA_NETEM_LOSS,
+	TCA_NETEM_RATE,
+	TCA_NETEM_ECN,
+	TCA_NETEM_RATE64,
+	TCA_NETEM_PAD,
+	__TCA_NETEM_MAX,
+};
+
+#define TCA_NETEM_MAX (__TCA_NETEM_MAX - 1)
+
+struct tc_netem_qopt {
+	__u32	latency;	/* added delay (us) */
+	__u32   limit;		/* fifo limit (packets) */
+	__u32	loss;		/* random packet loss (0=none ~0=100%) */
+	__u32	gap;		/* re-ordering gap (0 for none) */
+	__u32   duplicate;	/* random packet dup  (0=none ~0=100%) */
+	__u32	jitter;		/* random jitter in latency (us) */
+};
+
+struct tc_netem_corr {
+	__u32	delay_corr;	/* delay correlation */
+	__u32	loss_corr;	/* packet loss correlation */
+	__u32	dup_corr;	/* duplicate correlation  */
+};
+
+struct tc_netem_reorder {
+	__u32	probability;
+	__u32	correlation;
+};
+
+struct tc_netem_corrupt {
+	__u32	probability;
+	__u32	correlation;
+};
+
+struct tc_netem_rate {
+	__u32	rate;	/* byte/s */
+	__s32	packet_overhead;
+	__u32	cell_size;
+	__s32	cell_overhead;
+};
+
+enum {
+	NETEM_LOSS_UNSPEC,
+	NETEM_LOSS_GI,		/* General Intuitive - 4 state model */
+	NETEM_LOSS_GE,		/* Gilbert Elliot models */
+	__NETEM_LOSS_MAX
+};
+#define NETEM_LOSS_MAX (__NETEM_LOSS_MAX - 1)
+
+/* State transition probabilities for 4 state model */
+struct tc_netem_gimodel {
+	__u32	p13;
+	__u32	p31;
+	__u32	p32;
+	__u32	p14;
+	__u32	p23;
+};
+
+/* Gilbert-Elliot models */
+struct tc_netem_gemodel {
+	__u32 p;
+	__u32 r;
+	__u32 h;
+	__u32 k1;
+};
+
+#define NETEM_DIST_SCALE	8192
+#define NETEM_DIST_MAX		16384
+
+/* DRR */
+
+enum {
+	TCA_DRR_UNSPEC,
+	TCA_DRR_QUANTUM,
+	__TCA_DRR_MAX
+};
+
+#define TCA_DRR_MAX	(__TCA_DRR_MAX - 1)
+
+struct tc_drr_stats {
+	__u32	deficit;
+};
+
+/* MQPRIO */
+#define TC_QOPT_BITMASK 15
+#define TC_QOPT_MAX_QUEUE 16
+
+enum {
+	TC_MQPRIO_HW_OFFLOAD_NONE,	/* no offload requested */
+	TC_MQPRIO_HW_OFFLOAD_TCS,	/* offload TCs, no queue counts */
+	__TC_MQPRIO_HW_OFFLOAD_MAX
+};
+
+#define TC_MQPRIO_HW_OFFLOAD_MAX (__TC_MQPRIO_HW_OFFLOAD_MAX - 1)
+
+struct tc_mqprio_qopt {
+	__u8	num_tc;
+	__u8	prio_tc_map[TC_QOPT_BITMASK + 1];
+	__u8	hw;
+	__u16	count[TC_QOPT_MAX_QUEUE];
+	__u16	offset[TC_QOPT_MAX_QUEUE];
+};
+
+/* SFB */
+
+enum {
+	TCA_SFB_UNSPEC,
+	TCA_SFB_PARMS,
+	__TCA_SFB_MAX,
+};
+
+#define TCA_SFB_MAX (__TCA_SFB_MAX - 1)
+
+/*
+ * Note: increment, decrement are Q0.16 fixed-point values.
+ */
+struct tc_sfb_qopt {
+	__u32 rehash_interval;	/* delay between hash move, in ms */
+	__u32 warmup_time;	/* double buffering warmup time in ms (warmup_time < rehash_interval) */
+	__u32 max;		/* max len of qlen_min */
+	__u32 bin_size;		/* maximum queue length per bin */
+	__u32 increment;	/* probability increment, (d1 in Blue) */
+	__u32 decrement;	/* probability decrement, (d2 in Blue) */
+	__u32 limit;		/* max SFB queue length */
+	__u32 penalty_rate;	/* inelastic flows are rate limited to 'rate' pps */
+	__u32 penalty_burst;
+};
+
+struct tc_sfb_xstats {
+	__u32 earlydrop;
+	__u32 penaltydrop;
+	__u32 bucketdrop;
+	__u32 queuedrop;
+	__u32 childdrop; /* drops in child qdisc */
+	__u32 marked;
+	__u32 maxqlen;
+	__u32 maxprob;
+	__u32 avgprob;
+};
+
+#define SFB_MAX_PROB 0xFFFF
+
+/* QFQ */
+enum {
+	TCA_QFQ_UNSPEC,
+	TCA_QFQ_WEIGHT,
+	TCA_QFQ_LMAX,
+	__TCA_QFQ_MAX
+};
+
+#define TCA_QFQ_MAX	(__TCA_QFQ_MAX - 1)
+
+struct tc_qfq_stats {
+	__u32 weight;
+	__u32 lmax;
+};
+
+/* CODEL */
+
+enum {
+	TCA_CODEL_UNSPEC,
+	TCA_CODEL_TARGET,
+	TCA_CODEL_LIMIT,
+	TCA_CODEL_INTERVAL,
+	TCA_CODEL_ECN,
+	TCA_CODEL_CE_THRESHOLD,
+	__TCA_CODEL_MAX
+};
+
+#define TCA_CODEL_MAX	(__TCA_CODEL_MAX - 1)
+
+struct tc_codel_xstats {
+	__u32	maxpacket; /* largest packet we've seen so far */
+	__u32	count;	   /* how many drops we've done since the last time we
+			    * entered dropping state
+			    */
+	__u32	lastcount; /* count at entry to dropping state */
+	__u32	ldelay;    /* in-queue delay seen by most recently dequeued packet */
+	__s32	drop_next; /* time to drop next packet */
+	__u32	drop_overlimit; /* number of time max qdisc packet limit was hit */
+	__u32	ecn_mark;  /* number of packets we ECN marked instead of dropped */
+	__u32	dropping;  /* are we in dropping state ? */
+	__u32	ce_mark;   /* number of CE marked packets because of ce_threshold */
+};
+
+/* FQ_CODEL */
+
+enum {
+	TCA_FQ_CODEL_UNSPEC,
+	TCA_FQ_CODEL_TARGET,
+	TCA_FQ_CODEL_LIMIT,
+	TCA_FQ_CODEL_INTERVAL,
+	TCA_FQ_CODEL_ECN,
+	TCA_FQ_CODEL_FLOWS,
+	TCA_FQ_CODEL_QUANTUM,
+	TCA_FQ_CODEL_CE_THRESHOLD,
+	TCA_FQ_CODEL_DROP_BATCH_SIZE,
+	TCA_FQ_CODEL_MEMORY_LIMIT,
+	__TCA_FQ_CODEL_MAX
+};
+
+#define TCA_FQ_CODEL_MAX	(__TCA_FQ_CODEL_MAX - 1)
+
+enum {
+	TCA_FQ_CODEL_XSTATS_QDISC,
+	TCA_FQ_CODEL_XSTATS_CLASS,
+};
+
+struct tc_fq_codel_qd_stats {
+	__u32	maxpacket;	/* largest packet we've seen so far */
+	__u32	drop_overlimit; /* number of time max qdisc
+				 * packet limit was hit
+				 */
+	__u32	ecn_mark;	/* number of packets we ECN marked
+				 * instead of being dropped
+				 */
+	__u32	new_flow_count; /* number of time packets
+				 * created a 'new flow'
+				 */
+	__u32	new_flows_len;	/* count of flows in new list */
+	__u32	old_flows_len;	/* count of flows in old list */
+	__u32	ce_mark;	/* packets above ce_threshold */
+	__u32	memory_usage;	/* in bytes */
+	__u32	drop_overmemory;
+};
+
+struct tc_fq_codel_cl_stats {
+	__s32	deficit;
+	__u32	ldelay;		/* in-queue delay seen by most recently
+				 * dequeued packet
+				 */
+	__u32	count;
+	__u32	lastcount;
+	__u32	dropping;
+	__s32	drop_next;
+};
+
+struct tc_fq_codel_xstats {
+	__u32	type;
+	union {
+		struct tc_fq_codel_qd_stats qdisc_stats;
+		struct tc_fq_codel_cl_stats class_stats;
+	};
+};
+
+/* FQ */
+
+enum {
+	TCA_FQ_UNSPEC,
+
+	TCA_FQ_PLIMIT,		/* limit of total number of packets in queue */
+
+	TCA_FQ_FLOW_PLIMIT,	/* limit of packets per flow */
+
+	TCA_FQ_QUANTUM,		/* RR quantum */
+
+	TCA_FQ_INITIAL_QUANTUM,		/* RR quantum for new flow */
+
+	TCA_FQ_RATE_ENABLE,	/* enable/disable rate limiting */
+
+	TCA_FQ_FLOW_DEFAULT_RATE,/* obsolete, do not use */
+
+	TCA_FQ_FLOW_MAX_RATE,	/* per flow max rate */
+
+	TCA_FQ_BUCKETS_LOG,	/* log2(number of buckets) */
+
+	TCA_FQ_FLOW_REFILL_DELAY,	/* flow credit refill delay in usec */
+
+	TCA_FQ_ORPHAN_MASK,	/* mask applied to orphaned skb hashes */
+
+	TCA_FQ_LOW_RATE_THRESHOLD, /* per packet delay under this rate */
+
+	__TCA_FQ_MAX
+};
+
+#define TCA_FQ_MAX	(__TCA_FQ_MAX - 1)
+
+struct tc_fq_qd_stats {
+	__u64	gc_flows;
+	__u64	highprio_packets;
+	__u64	tcp_retrans;
+	__u64	throttled;
+	__u64	flows_plimit;
+	__u64	pkts_too_long;
+	__u64	allocation_errors;
+	__s64	time_next_delayed_flow;
+	__u32	flows;
+	__u32	inactive_flows;
+	__u32	throttled_flows;
+	__u32	unthrottle_latency_ns;
+};
+
+/* Heavy-Hitter Filter */
+
+enum {
+	TCA_HHF_UNSPEC,
+	TCA_HHF_BACKLOG_LIMIT,
+	TCA_HHF_QUANTUM,
+	TCA_HHF_HH_FLOWS_LIMIT,
+	TCA_HHF_RESET_TIMEOUT,
+	TCA_HHF_ADMIT_BYTES,
+	TCA_HHF_EVICT_TIMEOUT,
+	TCA_HHF_NON_HH_WEIGHT,
+	__TCA_HHF_MAX
+};
+
+#define TCA_HHF_MAX	(__TCA_HHF_MAX - 1)
+
+struct tc_hhf_xstats {
+	__u32	drop_overlimit; /* number of times max qdisc packet limit
+				 * was hit
+				 */
+	__u32	hh_overlimit;   /* number of times max heavy-hitters was hit */
+	__u32	hh_tot_count;   /* number of captured heavy-hitters so far */
+	__u32	hh_cur_count;   /* number of current heavy-hitters */
+};
+
+/* PIE */
+enum {
+	TCA_PIE_UNSPEC,
+	TCA_PIE_TARGET,
+	TCA_PIE_LIMIT,
+	TCA_PIE_TUPDATE,
+	TCA_PIE_ALPHA,
+	TCA_PIE_BETA,
+	TCA_PIE_ECN,
+	TCA_PIE_BYTEMODE,
+	__TCA_PIE_MAX
+};
+#define TCA_PIE_MAX   (__TCA_PIE_MAX - 1)
+
+struct tc_pie_xstats {
+	__u32 prob;             /* current probability */
+	__u32 delay;            /* current delay in ms */
+	__u32 avg_dq_rate;      /* current average dq_rate in bits/pie_time */
+	__u32 packets_in;       /* total number of packets enqueued */
+	__u32 dropped;          /* packets dropped due to pie_action */
+	__u32 overlimit;        /* dropped due to lack of space in queue */
+	__u32 maxq;             /* maximum queue size */
+	__u32 ecn_mark;         /* packets marked with ecn*/
+};
+#endif
diff --git a/include/uapi/linux/posix_types.h b/include/uapi/linux/posix_types.h
new file mode 100644
index 0000000..988f76e
--- /dev/null
+++ b/include/uapi/linux/posix_types.h
@@ -0,0 +1,37 @@
+#ifndef _LINUX_POSIX_TYPES_H
+#define _LINUX_POSIX_TYPES_H
+
+#include <linux/stddef.h>
+
+/*
+ * This allows for 1024 file descriptors: if NR_OPEN is ever grown
+ * beyond that you'll have to change this too. But 1024 fd's seem to be
+ * enough even for such "real" unices like OSF/1, so hopefully this is
+ * one limit that doesn't have to be changed [again].
+ *
+ * Note that POSIX wants the FD_CLEAR(fd,fdsetp) defines to be in
+ * <sys/time.h> (and thus <linux/time.h>) - but this is a more logical
+ * place for them. Solved by having dummy defines in <sys/time.h>.
+ */
+
+/*
+ * This macro may have been defined in <gnu/types.h>. But we always
+ * use the one here.
+ */
+#undef __FD_SETSIZE
+#define __FD_SETSIZE	1024
+
+typedef struct {
+	unsigned long fds_bits[__FD_SETSIZE / (8 * sizeof(long))];
+} __kernel_fd_set;
+
+/* Type of a signal handler.  */
+typedef void (*__kernel_sighandler_t)(int);
+
+/* Type of a SYSV IPC key.  */
+typedef int __kernel_key_t;
+typedef int __kernel_mqd_t;
+
+#include <asm/posix_types.h>
+
+#endif /* _LINUX_POSIX_TYPES_H */
diff --git a/include/uapi/linux/rtnetlink.h b/include/uapi/linux/rtnetlink.h
new file mode 100644
index 0000000..813e9e0
--- /dev/null
+++ b/include/uapi/linux/rtnetlink.h
@@ -0,0 +1,718 @@
+#ifndef __LINUX_RTNETLINK_H
+#define __LINUX_RTNETLINK_H
+
+#include <linux/types.h>
+#include <linux/netlink.h>
+#include <linux/if_link.h>
+#include <linux/if_addr.h>
+#include <linux/neighbour.h>
+
+/* rtnetlink families. Values up to 127 are reserved for real address
+ * families, values above 128 may be used arbitrarily.
+ */
+#define RTNL_FAMILY_IPMR		128
+#define RTNL_FAMILY_IP6MR		129
+#define RTNL_FAMILY_MAX			129
+
+/****
+ *		Routing/neighbour discovery messages.
+ ****/
+
+/* Types of messages */
+
+enum {
+	RTM_BASE	= 16,
+#define RTM_BASE	RTM_BASE
+
+	RTM_NEWLINK	= 16,
+#define RTM_NEWLINK	RTM_NEWLINK
+	RTM_DELLINK,
+#define RTM_DELLINK	RTM_DELLINK
+	RTM_GETLINK,
+#define RTM_GETLINK	RTM_GETLINK
+	RTM_SETLINK,
+#define RTM_SETLINK	RTM_SETLINK
+
+	RTM_NEWADDR	= 20,
+#define RTM_NEWADDR	RTM_NEWADDR
+	RTM_DELADDR,
+#define RTM_DELADDR	RTM_DELADDR
+	RTM_GETADDR,
+#define RTM_GETADDR	RTM_GETADDR
+
+	RTM_NEWROUTE	= 24,
+#define RTM_NEWROUTE	RTM_NEWROUTE
+	RTM_DELROUTE,
+#define RTM_DELROUTE	RTM_DELROUTE
+	RTM_GETROUTE,
+#define RTM_GETROUTE	RTM_GETROUTE
+
+	RTM_NEWNEIGH	= 28,
+#define RTM_NEWNEIGH	RTM_NEWNEIGH
+	RTM_DELNEIGH,
+#define RTM_DELNEIGH	RTM_DELNEIGH
+	RTM_GETNEIGH,
+#define RTM_GETNEIGH	RTM_GETNEIGH
+
+	RTM_NEWRULE	= 32,
+#define RTM_NEWRULE	RTM_NEWRULE
+	RTM_DELRULE,
+#define RTM_DELRULE	RTM_DELRULE
+	RTM_GETRULE,
+#define RTM_GETRULE	RTM_GETRULE
+
+	RTM_NEWQDISC	= 36,
+#define RTM_NEWQDISC	RTM_NEWQDISC
+	RTM_DELQDISC,
+#define RTM_DELQDISC	RTM_DELQDISC
+	RTM_GETQDISC,
+#define RTM_GETQDISC	RTM_GETQDISC
+
+	RTM_NEWTCLASS	= 40,
+#define RTM_NEWTCLASS	RTM_NEWTCLASS
+	RTM_DELTCLASS,
+#define RTM_DELTCLASS	RTM_DELTCLASS
+	RTM_GETTCLASS,
+#define RTM_GETTCLASS	RTM_GETTCLASS
+
+	RTM_NEWTFILTER	= 44,
+#define RTM_NEWTFILTER	RTM_NEWTFILTER
+	RTM_DELTFILTER,
+#define RTM_DELTFILTER	RTM_DELTFILTER
+	RTM_GETTFILTER,
+#define RTM_GETTFILTER	RTM_GETTFILTER
+
+	RTM_NEWACTION	= 48,
+#define RTM_NEWACTION   RTM_NEWACTION
+	RTM_DELACTION,
+#define RTM_DELACTION   RTM_DELACTION
+	RTM_GETACTION,
+#define RTM_GETACTION   RTM_GETACTION
+
+	RTM_NEWPREFIX	= 52,
+#define RTM_NEWPREFIX	RTM_NEWPREFIX
+
+	RTM_GETMULTICAST = 58,
+#define RTM_GETMULTICAST RTM_GETMULTICAST
+
+	RTM_GETANYCAST	= 62,
+#define RTM_GETANYCAST	RTM_GETANYCAST
+
+	RTM_NEWNEIGHTBL	= 64,
+#define RTM_NEWNEIGHTBL	RTM_NEWNEIGHTBL
+	RTM_GETNEIGHTBL	= 66,
+#define RTM_GETNEIGHTBL	RTM_GETNEIGHTBL
+	RTM_SETNEIGHTBL,
+#define RTM_SETNEIGHTBL	RTM_SETNEIGHTBL
+
+	RTM_NEWNDUSEROPT = 68,
+#define RTM_NEWNDUSEROPT RTM_NEWNDUSEROPT
+
+	RTM_NEWADDRLABEL = 72,
+#define RTM_NEWADDRLABEL RTM_NEWADDRLABEL
+	RTM_DELADDRLABEL,
+#define RTM_DELADDRLABEL RTM_DELADDRLABEL
+	RTM_GETADDRLABEL,
+#define RTM_GETADDRLABEL RTM_GETADDRLABEL
+
+	RTM_GETDCB = 78,
+#define RTM_GETDCB RTM_GETDCB
+	RTM_SETDCB,
+#define RTM_SETDCB RTM_SETDCB
+
+	RTM_NEWNETCONF = 80,
+#define RTM_NEWNETCONF RTM_NEWNETCONF
+	RTM_DELNETCONF,
+#define RTM_DELNETCONF RTM_DELNETCONF
+	RTM_GETNETCONF = 82,
+#define RTM_GETNETCONF RTM_GETNETCONF
+
+	RTM_NEWMDB = 84,
+#define RTM_NEWMDB RTM_NEWMDB
+	RTM_DELMDB = 85,
+#define RTM_DELMDB RTM_DELMDB
+	RTM_GETMDB = 86,
+#define RTM_GETMDB RTM_GETMDB
+
+	RTM_NEWNSID = 88,
+#define RTM_NEWNSID RTM_NEWNSID
+	RTM_DELNSID = 89,
+#define RTM_DELNSID RTM_DELNSID
+	RTM_GETNSID = 90,
+#define RTM_GETNSID RTM_GETNSID
+
+	RTM_NEWSTATS = 92,
+#define RTM_NEWSTATS RTM_NEWSTATS
+	RTM_GETSTATS = 94,
+#define RTM_GETSTATS RTM_GETSTATS
+
+	RTM_NEWCACHEREPORT = 96,
+#define RTM_NEWCACHEREPORT RTM_NEWCACHEREPORT
+
+	__RTM_MAX,
+#define RTM_MAX		(((__RTM_MAX + 3) & ~3) - 1)
+};
+
+#define RTM_NR_MSGTYPES	(RTM_MAX + 1 - RTM_BASE)
+#define RTM_NR_FAMILIES	(RTM_NR_MSGTYPES >> 2)
+#define RTM_FAM(cmd)	(((cmd) - RTM_BASE) >> 2)
+
+/* 
+   Generic structure for encapsulation of optional route information.
+   It is reminiscent of sockaddr, but with sa_family replaced
+   with attribute type.
+ */
+
+struct rtattr {
+	unsigned short	rta_len;
+	unsigned short	rta_type;
+};
+
+/* Macros to handle rtattributes */
+
+#define RTA_ALIGNTO	4U
+#define RTA_ALIGN(len) ( ((len)+RTA_ALIGNTO-1) & ~(RTA_ALIGNTO-1) )
+#define RTA_OK(rta,len) ((len) >= (int)sizeof(struct rtattr) && \
+			 (rta)->rta_len >= sizeof(struct rtattr) && \
+			 (rta)->rta_len <= (len))
+#define RTA_NEXT(rta,attrlen)	((attrlen) -= RTA_ALIGN((rta)->rta_len), \
+				 (struct rtattr*)(((char*)(rta)) + RTA_ALIGN((rta)->rta_len)))
+#define RTA_LENGTH(len)	(RTA_ALIGN(sizeof(struct rtattr)) + (len))
+#define RTA_SPACE(len)	RTA_ALIGN(RTA_LENGTH(len))
+#define RTA_DATA(rta)   ((void*)(((char*)(rta)) + RTA_LENGTH(0)))
+#define RTA_PAYLOAD(rta) ((int)((rta)->rta_len) - RTA_LENGTH(0))
+
+
+
+
+/******************************************************************************
+ *		Definitions used in routing table administration.
+ ****/
+
+struct rtmsg {
+	unsigned char		rtm_family;
+	unsigned char		rtm_dst_len;
+	unsigned char		rtm_src_len;
+	unsigned char		rtm_tos;
+
+	unsigned char		rtm_table;	/* Routing table id */
+	unsigned char		rtm_protocol;	/* Routing protocol; see below	*/
+	unsigned char		rtm_scope;	/* See below */	
+	unsigned char		rtm_type;	/* See below	*/
+
+	unsigned		rtm_flags;
+};
+
+/* rtm_type */
+
+enum {
+	RTN_UNSPEC,
+	RTN_UNICAST,		/* Gateway or direct route	*/
+	RTN_LOCAL,		/* Accept locally		*/
+	RTN_BROADCAST,		/* Accept locally as broadcast,
+				   send as broadcast */
+	RTN_ANYCAST,		/* Accept locally as broadcast,
+				   but send as unicast */
+	RTN_MULTICAST,		/* Multicast route		*/
+	RTN_BLACKHOLE,		/* Drop				*/
+	RTN_UNREACHABLE,	/* Destination is unreachable   */
+	RTN_PROHIBIT,		/* Administratively prohibited	*/
+	RTN_THROW,		/* Not in this table		*/
+	RTN_NAT,		/* Translate this address	*/
+	RTN_XRESOLVE,		/* Use external resolver	*/
+	__RTN_MAX
+};
+
+#define RTN_MAX (__RTN_MAX - 1)
+
+
+/* rtm_protocol */
+
+#define RTPROT_UNSPEC	0
+#define RTPROT_REDIRECT	1	/* Route installed by ICMP redirects;
+				   not used by current IPv4 */
+#define RTPROT_KERNEL	2	/* Route installed by kernel		*/
+#define RTPROT_BOOT	3	/* Route installed during boot		*/
+#define RTPROT_STATIC	4	/* Route installed by administrator	*/
+
+/* Values of protocol >= RTPROT_STATIC are not interpreted by kernel;
+   they are just passed from user and back as is.
+   It will be used by hypothetical multiple routing daemons.
+   Note that protocol values should be standardized in order to
+   avoid conflicts.
+ */
+
+#define RTPROT_GATED	8	/* Apparently, GateD */
+#define RTPROT_RA	9	/* RDISC/ND router advertisements */
+#define RTPROT_MRT	10	/* Merit MRT */
+#define RTPROT_ZEBRA	11	/* Zebra */
+#define RTPROT_BIRD	12	/* BIRD */
+#define RTPROT_DNROUTED	13	/* DECnet routing daemon */
+#define RTPROT_XORP	14	/* XORP */
+#define RTPROT_NTK	15	/* Netsukuku */
+#define RTPROT_DHCP	16      /* DHCP client */
+#define RTPROT_MROUTED	17      /* Multicast daemon */
+#define RTPROT_BABEL	42      /* Babel daemon */
+
+/* rtm_scope
+
+   Really it is not scope, but sort of distance to the destination.
+   NOWHERE are reserved for not existing destinations, HOST is our
+   local addresses, LINK are destinations, located on directly attached
+   link and UNIVERSE is everywhere in the Universe.
+
+   Intermediate values are also possible f.e. interior routes
+   could be assigned a value between UNIVERSE and LINK.
+*/
+
+enum rt_scope_t {
+	RT_SCOPE_UNIVERSE=0,
+/* User defined values  */
+	RT_SCOPE_SITE=200,
+	RT_SCOPE_LINK=253,
+	RT_SCOPE_HOST=254,
+	RT_SCOPE_NOWHERE=255
+};
+
+/* rtm_flags */
+
+#define RTM_F_NOTIFY		0x100	/* Notify user of route change	*/
+#define RTM_F_CLONED		0x200	/* This route is cloned		*/
+#define RTM_F_EQUALIZE		0x400	/* Multipath equalizer: NI	*/
+#define RTM_F_PREFIX		0x800	/* Prefix addresses		*/
+#define RTM_F_LOOKUP_TABLE	0x1000	/* set rtm_table to FIB lookup result */
+#define RTM_F_FIB_MATCH	        0x2000	/* return full fib lookup match */
+
+/* Reserved table identifiers */
+
+enum rt_class_t {
+	RT_TABLE_UNSPEC=0,
+/* User defined values */
+	RT_TABLE_COMPAT=252,
+	RT_TABLE_DEFAULT=253,
+	RT_TABLE_MAIN=254,
+	RT_TABLE_LOCAL=255,
+	RT_TABLE_MAX=0xFFFFFFFF
+};
+
+
+/* Routing message attributes */
+
+enum rtattr_type_t {
+	RTA_UNSPEC,
+	RTA_DST,
+	RTA_SRC,
+	RTA_IIF,
+	RTA_OIF,
+	RTA_GATEWAY,
+	RTA_PRIORITY,
+	RTA_PREFSRC,
+	RTA_METRICS,
+	RTA_MULTIPATH,
+	RTA_PROTOINFO, /* no longer used */
+	RTA_FLOW,
+	RTA_CACHEINFO,
+	RTA_SESSION, /* no longer used */
+	RTA_MP_ALGO, /* no longer used */
+	RTA_TABLE,
+	RTA_MARK,
+	RTA_MFC_STATS,
+	RTA_VIA,
+	RTA_NEWDST,
+	RTA_PREF,
+	RTA_ENCAP_TYPE,
+	RTA_ENCAP,
+	RTA_EXPIRES,
+	RTA_PAD,
+	RTA_UID,
+	RTA_TTL_PROPAGATE,
+	__RTA_MAX
+};
+
+#define RTA_MAX (__RTA_MAX - 1)
+
+#define RTM_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct rtmsg))))
+#define RTM_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct rtmsg))
+
+/* RTM_MULTIPATH --- array of struct rtnexthop.
+ *
+ * "struct rtnexthop" describes all necessary nexthop information,
+ * i.e. parameters of path to a destination via this nexthop.
+ *
+ * At the moment it is impossible to set different prefsrc, mtu, window
+ * and rtt for different paths from multipath.
+ */
+
+struct rtnexthop {
+	unsigned short		rtnh_len;
+	unsigned char		rtnh_flags;
+	unsigned char		rtnh_hops;
+	int			rtnh_ifindex;
+};
+
+/* rtnh_flags */
+
+#define RTNH_F_DEAD		1	/* Nexthop is dead (used by multipath)	*/
+#define RTNH_F_PERVASIVE	2	/* Do recursive gateway lookup	*/
+#define RTNH_F_ONLINK		4	/* Gateway is forced on link	*/
+#define RTNH_F_OFFLOAD		8	/* offloaded route */
+#define RTNH_F_LINKDOWN		16	/* carrier-down on nexthop */
+#define RTNH_F_UNRESOLVED	32	/* The entry is unresolved (ipmr) */
+
+#define RTNH_COMPARE_MASK	(RTNH_F_DEAD | RTNH_F_LINKDOWN | RTNH_F_OFFLOAD)
+
+/* Macros to handle hexthops */
+
+#define RTNH_ALIGNTO	4
+#define RTNH_ALIGN(len) ( ((len)+RTNH_ALIGNTO-1) & ~(RTNH_ALIGNTO-1) )
+#define RTNH_OK(rtnh,len) ((rtnh)->rtnh_len >= sizeof(struct rtnexthop) && \
+			   ((int)(rtnh)->rtnh_len) <= (len))
+#define RTNH_NEXT(rtnh)	((struct rtnexthop*)(((char*)(rtnh)) + RTNH_ALIGN((rtnh)->rtnh_len)))
+#define RTNH_LENGTH(len) (RTNH_ALIGN(sizeof(struct rtnexthop)) + (len))
+#define RTNH_SPACE(len)	RTNH_ALIGN(RTNH_LENGTH(len))
+#define RTNH_DATA(rtnh)   ((struct rtattr*)(((char*)(rtnh)) + RTNH_LENGTH(0)))
+
+/* RTA_VIA */
+struct rtvia {
+	__kernel_sa_family_t	rtvia_family;
+	__u8			rtvia_addr[0];
+};
+
+/* RTM_CACHEINFO */
+
+struct rta_cacheinfo {
+	__u32	rta_clntref;
+	__u32	rta_lastuse;
+	__s32	rta_expires;
+	__u32	rta_error;
+	__u32	rta_used;
+
+#define RTNETLINK_HAVE_PEERINFO 1
+	__u32	rta_id;
+	__u32	rta_ts;
+	__u32	rta_tsage;
+};
+
+/* RTM_METRICS --- array of struct rtattr with types of RTAX_* */
+
+enum {
+	RTAX_UNSPEC,
+#define RTAX_UNSPEC RTAX_UNSPEC
+	RTAX_LOCK,
+#define RTAX_LOCK RTAX_LOCK
+	RTAX_MTU,
+#define RTAX_MTU RTAX_MTU
+	RTAX_WINDOW,
+#define RTAX_WINDOW RTAX_WINDOW
+	RTAX_RTT,
+#define RTAX_RTT RTAX_RTT
+	RTAX_RTTVAR,
+#define RTAX_RTTVAR RTAX_RTTVAR
+	RTAX_SSTHRESH,
+#define RTAX_SSTHRESH RTAX_SSTHRESH
+	RTAX_CWND,
+#define RTAX_CWND RTAX_CWND
+	RTAX_ADVMSS,
+#define RTAX_ADVMSS RTAX_ADVMSS
+	RTAX_REORDERING,
+#define RTAX_REORDERING RTAX_REORDERING
+	RTAX_HOPLIMIT,
+#define RTAX_HOPLIMIT RTAX_HOPLIMIT
+	RTAX_INITCWND,
+#define RTAX_INITCWND RTAX_INITCWND
+	RTAX_FEATURES,
+#define RTAX_FEATURES RTAX_FEATURES
+	RTAX_RTO_MIN,
+#define RTAX_RTO_MIN RTAX_RTO_MIN
+	RTAX_INITRWND,
+#define RTAX_INITRWND RTAX_INITRWND
+	RTAX_QUICKACK,
+#define RTAX_QUICKACK RTAX_QUICKACK
+	RTAX_CC_ALGO,
+#define RTAX_CC_ALGO RTAX_CC_ALGO
+	__RTAX_MAX
+};
+
+#define RTAX_MAX (__RTAX_MAX - 1)
+
+#define RTAX_FEATURE_ECN	(1 << 0)
+#define RTAX_FEATURE_SACK	(1 << 1)
+#define RTAX_FEATURE_TIMESTAMP	(1 << 2)
+#define RTAX_FEATURE_ALLFRAG	(1 << 3)
+
+#define RTAX_FEATURE_MASK	(RTAX_FEATURE_ECN | RTAX_FEATURE_SACK | \
+				 RTAX_FEATURE_TIMESTAMP | RTAX_FEATURE_ALLFRAG)
+
+struct rta_session {
+	__u8	proto;
+	__u8	pad1;
+	__u16	pad2;
+
+	union {
+		struct {
+			__u16	sport;
+			__u16	dport;
+		} ports;
+
+		struct {
+			__u8	type;
+			__u8	code;
+			__u16	ident;
+		} icmpt;
+
+		__u32		spi;
+	} u;
+};
+
+struct rta_mfc_stats {
+	__u64	mfcs_packets;
+	__u64	mfcs_bytes;
+	__u64	mfcs_wrong_if;
+};
+
+/****
+ *		General form of address family dependent message.
+ ****/
+
+struct rtgenmsg {
+	unsigned char		rtgen_family;
+};
+
+/*****************************************************************
+ *		Link layer specific messages.
+ ****/
+
+/* struct ifinfomsg
+ * passes link level specific information, not dependent
+ * on network protocol.
+ */
+
+struct ifinfomsg {
+	unsigned char	ifi_family;
+	unsigned char	__ifi_pad;
+	unsigned short	ifi_type;		/* ARPHRD_* */
+	int		ifi_index;		/* Link index	*/
+	unsigned	ifi_flags;		/* IFF_* flags	*/
+	unsigned	ifi_change;		/* IFF_* change mask */
+};
+
+/********************************************************************
+ *		prefix information 
+ ****/
+
+struct prefixmsg {
+	unsigned char	prefix_family;
+	unsigned char	prefix_pad1;
+	unsigned short	prefix_pad2;
+	int		prefix_ifindex;
+	unsigned char	prefix_type;
+	unsigned char	prefix_len;
+	unsigned char	prefix_flags;
+	unsigned char	prefix_pad3;
+};
+
+enum 
+{
+	PREFIX_UNSPEC,
+	PREFIX_ADDRESS,
+	PREFIX_CACHEINFO,
+	__PREFIX_MAX
+};
+
+#define PREFIX_MAX	(__PREFIX_MAX - 1)
+
+struct prefix_cacheinfo {
+	__u32	preferred_time;
+	__u32	valid_time;
+};
+
+
+/*****************************************************************
+ *		Traffic control messages.
+ ****/
+
+struct tcmsg {
+	unsigned char	tcm_family;
+	unsigned char	tcm__pad1;
+	unsigned short	tcm__pad2;
+	int		tcm_ifindex;
+	__u32		tcm_handle;
+	__u32		tcm_parent;
+	__u32		tcm_info;
+};
+
+enum {
+	TCA_UNSPEC,
+	TCA_KIND,
+	TCA_OPTIONS,
+	TCA_STATS,
+	TCA_XSTATS,
+	TCA_RATE,
+	TCA_FCNT,
+	TCA_STATS2,
+	TCA_STAB,
+	TCA_PAD,
+	TCA_DUMP_INVISIBLE,
+	TCA_CHAIN,
+	__TCA_MAX
+};
+
+#define TCA_MAX (__TCA_MAX - 1)
+
+#define TCA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct tcmsg))))
+#define TCA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct tcmsg))
+
+/********************************************************************
+ *		Neighbor Discovery userland options
+ ****/
+
+struct nduseroptmsg {
+	unsigned char	nduseropt_family;
+	unsigned char	nduseropt_pad1;
+	unsigned short	nduseropt_opts_len;	/* Total length of options */
+	int		nduseropt_ifindex;
+	__u8		nduseropt_icmp_type;
+	__u8		nduseropt_icmp_code;
+	unsigned short	nduseropt_pad2;
+	unsigned int	nduseropt_pad3;
+	/* Followed by one or more ND options */
+};
+
+enum {
+	NDUSEROPT_UNSPEC,
+	NDUSEROPT_SRCADDR,
+	__NDUSEROPT_MAX
+};
+
+#define NDUSEROPT_MAX	(__NDUSEROPT_MAX - 1)
+
+/* RTnetlink multicast groups - backwards compatibility for userspace */
+#define RTMGRP_LINK		1
+#define RTMGRP_NOTIFY		2
+#define RTMGRP_NEIGH		4
+#define RTMGRP_TC		8
+
+#define RTMGRP_IPV4_IFADDR	0x10
+#define RTMGRP_IPV4_MROUTE	0x20
+#define RTMGRP_IPV4_ROUTE	0x40
+#define RTMGRP_IPV4_RULE	0x80
+
+#define RTMGRP_IPV6_IFADDR	0x100
+#define RTMGRP_IPV6_MROUTE	0x200
+#define RTMGRP_IPV6_ROUTE	0x400
+#define RTMGRP_IPV6_IFINFO	0x800
+
+#define RTMGRP_DECnet_IFADDR    0x1000
+#define RTMGRP_DECnet_ROUTE     0x4000
+
+#define RTMGRP_IPV6_PREFIX	0x20000
+
+/* RTnetlink multicast groups */
+enum rtnetlink_groups {
+	RTNLGRP_NONE,
+#define RTNLGRP_NONE		RTNLGRP_NONE
+	RTNLGRP_LINK,
+#define RTNLGRP_LINK		RTNLGRP_LINK
+	RTNLGRP_NOTIFY,
+#define RTNLGRP_NOTIFY		RTNLGRP_NOTIFY
+	RTNLGRP_NEIGH,
+#define RTNLGRP_NEIGH		RTNLGRP_NEIGH
+	RTNLGRP_TC,
+#define RTNLGRP_TC		RTNLGRP_TC
+	RTNLGRP_IPV4_IFADDR,
+#define RTNLGRP_IPV4_IFADDR	RTNLGRP_IPV4_IFADDR
+	RTNLGRP_IPV4_MROUTE,
+#define	RTNLGRP_IPV4_MROUTE	RTNLGRP_IPV4_MROUTE
+	RTNLGRP_IPV4_ROUTE,
+#define RTNLGRP_IPV4_ROUTE	RTNLGRP_IPV4_ROUTE
+	RTNLGRP_IPV4_RULE,
+#define RTNLGRP_IPV4_RULE	RTNLGRP_IPV4_RULE
+	RTNLGRP_IPV6_IFADDR,
+#define RTNLGRP_IPV6_IFADDR	RTNLGRP_IPV6_IFADDR
+	RTNLGRP_IPV6_MROUTE,
+#define RTNLGRP_IPV6_MROUTE	RTNLGRP_IPV6_MROUTE
+	RTNLGRP_IPV6_ROUTE,
+#define RTNLGRP_IPV6_ROUTE	RTNLGRP_IPV6_ROUTE
+	RTNLGRP_IPV6_IFINFO,
+#define RTNLGRP_IPV6_IFINFO	RTNLGRP_IPV6_IFINFO
+	RTNLGRP_DECnet_IFADDR,
+#define RTNLGRP_DECnet_IFADDR	RTNLGRP_DECnet_IFADDR
+	RTNLGRP_NOP2,
+	RTNLGRP_DECnet_ROUTE,
+#define RTNLGRP_DECnet_ROUTE	RTNLGRP_DECnet_ROUTE
+	RTNLGRP_DECnet_RULE,
+#define RTNLGRP_DECnet_RULE	RTNLGRP_DECnet_RULE
+	RTNLGRP_NOP4,
+	RTNLGRP_IPV6_PREFIX,
+#define RTNLGRP_IPV6_PREFIX	RTNLGRP_IPV6_PREFIX
+	RTNLGRP_IPV6_RULE,
+#define RTNLGRP_IPV6_RULE	RTNLGRP_IPV6_RULE
+	RTNLGRP_ND_USEROPT,
+#define RTNLGRP_ND_USEROPT	RTNLGRP_ND_USEROPT
+	RTNLGRP_PHONET_IFADDR,
+#define RTNLGRP_PHONET_IFADDR	RTNLGRP_PHONET_IFADDR
+	RTNLGRP_PHONET_ROUTE,
+#define RTNLGRP_PHONET_ROUTE	RTNLGRP_PHONET_ROUTE
+	RTNLGRP_DCB,
+#define RTNLGRP_DCB		RTNLGRP_DCB
+	RTNLGRP_IPV4_NETCONF,
+#define RTNLGRP_IPV4_NETCONF	RTNLGRP_IPV4_NETCONF
+	RTNLGRP_IPV6_NETCONF,
+#define RTNLGRP_IPV6_NETCONF	RTNLGRP_IPV6_NETCONF
+	RTNLGRP_MDB,
+#define RTNLGRP_MDB		RTNLGRP_MDB
+	RTNLGRP_MPLS_ROUTE,
+#define RTNLGRP_MPLS_ROUTE	RTNLGRP_MPLS_ROUTE
+	RTNLGRP_NSID,
+#define RTNLGRP_NSID		RTNLGRP_NSID
+	RTNLGRP_MPLS_NETCONF,
+#define RTNLGRP_MPLS_NETCONF	RTNLGRP_MPLS_NETCONF
+	RTNLGRP_IPV4_MROUTE_R,
+#define RTNLGRP_IPV4_MROUTE_R	RTNLGRP_IPV4_MROUTE_R
+	RTNLGRP_IPV6_MROUTE_R,
+#define RTNLGRP_IPV6_MROUTE_R	RTNLGRP_IPV6_MROUTE_R
+	__RTNLGRP_MAX
+};
+#define RTNLGRP_MAX	(__RTNLGRP_MAX - 1)
+
+/* TC action piece */
+struct tcamsg {
+	unsigned char	tca_family;
+	unsigned char	tca__pad1;
+	unsigned short	tca__pad2;
+};
+
+enum {
+	TCA_ROOT_UNSPEC,
+	TCA_ROOT_TAB,
+#define TCA_ACT_TAB TCA_ROOT_TAB
+#define TCAA_MAX TCA_ROOT_TAB
+	TCA_ROOT_FLAGS,
+	TCA_ROOT_COUNT,
+	TCA_ROOT_TIME_DELTA, /* in msecs */
+	__TCA_ROOT_MAX,
+#define	TCA_ROOT_MAX (__TCA_ROOT_MAX - 1)
+};
+
+#define TA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct tcamsg))))
+#define TA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct tcamsg))
+/* tcamsg flags stored in attribute TCA_ROOT_FLAGS
+ *
+ * TCA_FLAG_LARGE_DUMP_ON user->kernel to request for larger than TCA_ACT_MAX_PRIO
+ * actions in a dump. All dump responses will contain the number of actions
+ * being dumped stored in for user app's consumption in TCA_ROOT_COUNT
+ *
+ */
+#define TCA_FLAG_LARGE_DUMP_ON		(1 << 0)
+
+/* New extended info filters for IFLA_EXT_MASK */
+#define RTEXT_FILTER_VF		(1 << 0)
+#define RTEXT_FILTER_BRVLAN	(1 << 1)
+#define RTEXT_FILTER_BRVLAN_COMPRESSED	(1 << 2)
+#define	RTEXT_FILTER_SKIP_STATS	(1 << 3)
+
+/* End of information exported to user level */
+
+
+
+#endif /* __LINUX_RTNETLINK_H */
diff --git a/include/uapi/linux/sctp.h b/include/uapi/linux/sctp.h
new file mode 100644
index 0000000..fec24c4
--- /dev/null
+++ b/include/uapi/linux/sctp.h
@@ -0,0 +1,1085 @@
+/* SCTP kernel implementation
+ * (C) Copyright IBM Corp. 2001, 2004
+ * Copyright (c) 1999-2000 Cisco, Inc.
+ * Copyright (c) 1999-2001 Motorola, Inc.
+ * Copyright (c) 2002 Intel Corp.
+ *
+ * This file is part of the SCTP kernel implementation
+ *
+ * This header represents the structures and constants needed to support
+ * the SCTP Extension to the Sockets API.
+ *
+ * This SCTP implementation is free software;
+ * you can redistribute it and/or modify it under the terms of
+ * the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This SCTP implementation is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ *                 ************************
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU CC; see the file COPYING.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ *
+ * Please send any bug reports or fixes you make to the
+ * email address(es):
+ *    lksctp developers <linux-sctp@vger.kernel.org>
+ *
+ * Or submit a bug report through the following website:
+ *    http://www.sf.net/projects/lksctp
+ *
+ * Written or modified by:
+ *    La Monte H.P. Yarroll    <piggy@acm.org>
+ *    R. Stewart               <randall@sctp.chicago.il.us>
+ *    K. Morneau               <kmorneau@cisco.com>
+ *    Q. Xie                   <qxie1@email.mot.com>
+ *    Karl Knutson             <karl@athena.chicago.il.us>
+ *    Jon Grimm                <jgrimm@us.ibm.com>
+ *    Daisy Chang              <daisyc@us.ibm.com>
+ *    Ryan Layer               <rmlayer@us.ibm.com>
+ *    Ardelle Fan              <ardelle.fan@intel.com>
+ *    Sridhar Samudrala        <sri@us.ibm.com>
+ *    Inaky Perez-Gonzalez     <inaky.gonzalez@intel.com>
+ *    Vlad Yasevich            <vladislav.yasevich@hp.com>
+ *
+ * Any bugs reported given to us we will try to fix... any fixes shared will
+ * be incorporated into the next SCTP release.
+ */
+
+#ifndef _SCTP_H
+#define _SCTP_H
+
+#include <linux/types.h>
+#include <linux/socket.h>
+
+typedef __s32 sctp_assoc_t;
+
+/* The following symbols come from the Sockets API Extensions for
+ * SCTP <draft-ietf-tsvwg-sctpsocket-07.txt>.
+ */
+#define SCTP_RTOINFO	0
+#define SCTP_ASSOCINFO  1
+#define SCTP_INITMSG	2
+#define SCTP_NODELAY	3		/* Get/set nodelay option. */
+#define SCTP_AUTOCLOSE	4
+#define SCTP_SET_PEER_PRIMARY_ADDR 5
+#define SCTP_PRIMARY_ADDR	6
+#define SCTP_ADAPTATION_LAYER	7
+#define SCTP_DISABLE_FRAGMENTS	8
+#define SCTP_PEER_ADDR_PARAMS	9
+#define SCTP_DEFAULT_SEND_PARAM	10
+#define SCTP_EVENTS	11
+#define SCTP_I_WANT_MAPPED_V4_ADDR 12	/* Turn on/off mapped v4 addresses  */
+#define SCTP_MAXSEG	13		/* Get/set maximum fragment. */
+#define SCTP_STATUS	14
+#define SCTP_GET_PEER_ADDR_INFO	15
+#define SCTP_DELAYED_ACK_TIME	16
+#define SCTP_DELAYED_ACK SCTP_DELAYED_ACK_TIME
+#define SCTP_DELAYED_SACK SCTP_DELAYED_ACK_TIME
+#define SCTP_CONTEXT	17
+#define SCTP_FRAGMENT_INTERLEAVE	18
+#define SCTP_PARTIAL_DELIVERY_POINT	19 /* Set/Get partial delivery point */
+#define SCTP_MAX_BURST	20		/* Set/Get max burst */
+#define SCTP_AUTH_CHUNK	21	/* Set only: add a chunk type to authenticate */
+#define SCTP_HMAC_IDENT	22
+#define SCTP_AUTH_KEY	23
+#define SCTP_AUTH_ACTIVE_KEY	24
+#define SCTP_AUTH_DELETE_KEY	25
+#define SCTP_PEER_AUTH_CHUNKS	26	/* Read only */
+#define SCTP_LOCAL_AUTH_CHUNKS	27	/* Read only */
+#define SCTP_GET_ASSOC_NUMBER	28	/* Read only */
+#define SCTP_GET_ASSOC_ID_LIST	29	/* Read only */
+#define SCTP_AUTO_ASCONF       30
+#define SCTP_PEER_ADDR_THLDS	31
+#define SCTP_RECVRCVINFO	32
+#define SCTP_RECVNXTINFO	33
+#define SCTP_DEFAULT_SNDINFO	34
+
+/* Internal Socket Options. Some of the sctp library functions are
+ * implemented using these socket options.
+ */
+#define SCTP_SOCKOPT_BINDX_ADD	100	/* BINDX requests for adding addrs */
+#define SCTP_SOCKOPT_BINDX_REM	101	/* BINDX requests for removing addrs. */
+#define SCTP_SOCKOPT_PEELOFF	102	/* peel off association. */
+/* Options 104-106 are deprecated and removed. Do not use this space */
+#define SCTP_SOCKOPT_CONNECTX_OLD	107	/* CONNECTX old requests. */
+#define SCTP_GET_PEER_ADDRS	108		/* Get all peer address. */
+#define SCTP_GET_LOCAL_ADDRS	109		/* Get all local address. */
+#define SCTP_SOCKOPT_CONNECTX	110		/* CONNECTX requests. */
+#define SCTP_SOCKOPT_CONNECTX3	111	/* CONNECTX requests (updated) */
+#define SCTP_GET_ASSOC_STATS	112	/* Read only */
+#define SCTP_PR_SUPPORTED	113
+#define SCTP_DEFAULT_PRINFO	114
+#define SCTP_PR_ASSOC_STATUS	115
+#define SCTP_PR_STREAM_STATUS	116
+#define SCTP_RECONFIG_SUPPORTED	117
+#define SCTP_ENABLE_STREAM_RESET	118
+#define SCTP_RESET_STREAMS	119
+#define SCTP_RESET_ASSOC	120
+#define SCTP_ADD_STREAMS	121
+#define SCTP_SOCKOPT_PEELOFF_FLAGS 122
+
+/* PR-SCTP policies */
+#define SCTP_PR_SCTP_NONE	0x0000
+#define SCTP_PR_SCTP_TTL	0x0010
+#define SCTP_PR_SCTP_RTX	0x0020
+#define SCTP_PR_SCTP_PRIO	0x0030
+#define SCTP_PR_SCTP_MAX	SCTP_PR_SCTP_PRIO
+#define SCTP_PR_SCTP_MASK	0x0030
+
+#define __SCTP_PR_INDEX(x)	((x >> 4) - 1)
+#define SCTP_PR_INDEX(x)	__SCTP_PR_INDEX(SCTP_PR_SCTP_ ## x)
+
+#define SCTP_PR_POLICY(x)	((x) & SCTP_PR_SCTP_MASK)
+#define SCTP_PR_SET_POLICY(flags, x)	\
+	do {				\
+		flags &= ~SCTP_PR_SCTP_MASK;	\
+		flags |= x;		\
+	} while (0)
+
+#define SCTP_PR_TTL_ENABLED(x)	(SCTP_PR_POLICY(x) == SCTP_PR_SCTP_TTL)
+#define SCTP_PR_RTX_ENABLED(x)	(SCTP_PR_POLICY(x) == SCTP_PR_SCTP_RTX)
+#define SCTP_PR_PRIO_ENABLED(x)	(SCTP_PR_POLICY(x) == SCTP_PR_SCTP_PRIO)
+
+/* For enable stream reset */
+#define SCTP_ENABLE_RESET_STREAM_REQ	0x01
+#define SCTP_ENABLE_RESET_ASSOC_REQ	0x02
+#define SCTP_ENABLE_CHANGE_ASSOC_REQ	0x04
+#define SCTP_ENABLE_STRRESET_MASK	0x07
+
+#define SCTP_STREAM_RESET_INCOMING	0x01
+#define SCTP_STREAM_RESET_OUTGOING	0x02
+
+/* These are bit fields for msghdr->msg_flags.  See section 5.1.  */
+/* On user space Linux, these live in <bits/socket.h> as an enum.  */
+enum sctp_msg_flags {
+	MSG_NOTIFICATION = 0x8000,
+#define MSG_NOTIFICATION MSG_NOTIFICATION
+};
+
+/* 5.3.1 SCTP Initiation Structure (SCTP_INIT)
+ *
+ *   This cmsghdr structure provides information for initializing new
+ *   SCTP associations with sendmsg().  The SCTP_INITMSG socket option
+ *   uses this same data structure.  This structure is not used for
+ *   recvmsg().
+ *
+ *   cmsg_level    cmsg_type      cmsg_data[]
+ *   ------------  ------------   ----------------------
+ *   IPPROTO_SCTP  SCTP_INIT      struct sctp_initmsg
+ */
+struct sctp_initmsg {
+	__u16 sinit_num_ostreams;
+	__u16 sinit_max_instreams;
+	__u16 sinit_max_attempts;
+	__u16 sinit_max_init_timeo;
+};
+
+/* 5.3.2 SCTP Header Information Structure (SCTP_SNDRCV)
+ *
+ *   This cmsghdr structure specifies SCTP options for sendmsg() and
+ *   describes SCTP header information about a received message through
+ *   recvmsg().
+ *
+ *   cmsg_level    cmsg_type      cmsg_data[]
+ *   ------------  ------------   ----------------------
+ *   IPPROTO_SCTP  SCTP_SNDRCV    struct sctp_sndrcvinfo
+ */
+struct sctp_sndrcvinfo {
+	__u16 sinfo_stream;
+	__u16 sinfo_ssn;
+	__u16 sinfo_flags;
+	__u32 sinfo_ppid;
+	__u32 sinfo_context;
+	__u32 sinfo_timetolive;
+	__u32 sinfo_tsn;
+	__u32 sinfo_cumtsn;
+	sctp_assoc_t sinfo_assoc_id;
+};
+
+/* 5.3.4 SCTP Send Information Structure (SCTP_SNDINFO)
+ *
+ *   This cmsghdr structure specifies SCTP options for sendmsg().
+ *
+ *   cmsg_level    cmsg_type      cmsg_data[]
+ *   ------------  ------------   -------------------
+ *   IPPROTO_SCTP  SCTP_SNDINFO   struct sctp_sndinfo
+ */
+struct sctp_sndinfo {
+	__u16 snd_sid;
+	__u16 snd_flags;
+	__u32 snd_ppid;
+	__u32 snd_context;
+	sctp_assoc_t snd_assoc_id;
+};
+
+/* 5.3.5 SCTP Receive Information Structure (SCTP_RCVINFO)
+ *
+ *   This cmsghdr structure describes SCTP receive information
+ *   about a received message through recvmsg().
+ *
+ *   cmsg_level    cmsg_type      cmsg_data[]
+ *   ------------  ------------   -------------------
+ *   IPPROTO_SCTP  SCTP_RCVINFO   struct sctp_rcvinfo
+ */
+struct sctp_rcvinfo {
+	__u16 rcv_sid;
+	__u16 rcv_ssn;
+	__u16 rcv_flags;
+	__u32 rcv_ppid;
+	__u32 rcv_tsn;
+	__u32 rcv_cumtsn;
+	__u32 rcv_context;
+	sctp_assoc_t rcv_assoc_id;
+};
+
+/* 5.3.6 SCTP Next Receive Information Structure (SCTP_NXTINFO)
+ *
+ *   This cmsghdr structure describes SCTP receive information
+ *   of the next message that will be delivered through recvmsg()
+ *   if this information is already available when delivering
+ *   the current message.
+ *
+ *   cmsg_level    cmsg_type      cmsg_data[]
+ *   ------------  ------------   -------------------
+ *   IPPROTO_SCTP  SCTP_NXTINFO   struct sctp_nxtinfo
+ */
+struct sctp_nxtinfo {
+	__u16 nxt_sid;
+	__u16 nxt_flags;
+	__u32 nxt_ppid;
+	__u32 nxt_length;
+	sctp_assoc_t nxt_assoc_id;
+};
+
+/*
+ *  sinfo_flags: 16 bits (unsigned integer)
+ *
+ *   This field may contain any of the following flags and is composed of
+ *   a bitwise OR of these values.
+ */
+enum sctp_sinfo_flags {
+	SCTP_UNORDERED		= (1 << 0), /* Send/receive message unordered. */
+	SCTP_ADDR_OVER		= (1 << 1), /* Override the primary destination. */
+	SCTP_ABORT		= (1 << 2), /* Send an ABORT message to the peer. */
+	SCTP_SACK_IMMEDIATELY	= (1 << 3), /* SACK should be sent without delay. */
+	SCTP_NOTIFICATION	= MSG_NOTIFICATION, /* Next message is not user msg but notification. */
+	SCTP_EOF		= MSG_FIN,  /* Initiate graceful shutdown process. */
+};
+
+typedef union {
+	__u8   			raw;
+	struct sctp_initmsg	init;
+	struct sctp_sndrcvinfo	sndrcv;
+} sctp_cmsg_data_t;
+
+/* These are cmsg_types.  */
+typedef enum sctp_cmsg_type {
+	SCTP_INIT,		/* 5.2.1 SCTP Initiation Structure */
+#define SCTP_INIT	SCTP_INIT
+	SCTP_SNDRCV,		/* 5.2.2 SCTP Header Information Structure */
+#define SCTP_SNDRCV	SCTP_SNDRCV
+	SCTP_SNDINFO,		/* 5.3.4 SCTP Send Information Structure */
+#define SCTP_SNDINFO	SCTP_SNDINFO
+	SCTP_RCVINFO,		/* 5.3.5 SCTP Receive Information Structure */
+#define SCTP_RCVINFO	SCTP_RCVINFO
+	SCTP_NXTINFO,		/* 5.3.6 SCTP Next Receive Information Structure */
+#define SCTP_NXTINFO	SCTP_NXTINFO
+} sctp_cmsg_t;
+
+/*
+ * 5.3.1.1 SCTP_ASSOC_CHANGE
+ *
+ *   Communication notifications inform the ULP that an SCTP association
+ *   has either begun or ended. The identifier for a new association is
+ *   provided by this notificaion. The notification information has the
+ *   following format:
+ *
+ */
+struct sctp_assoc_change {
+	__u16 sac_type;
+	__u16 sac_flags;
+	__u32 sac_length;
+	__u16 sac_state;
+	__u16 sac_error;
+	__u16 sac_outbound_streams;
+	__u16 sac_inbound_streams;
+	sctp_assoc_t sac_assoc_id;
+	__u8 sac_info[0];
+};
+
+/*
+ *   sac_state: 32 bits (signed integer)
+ *
+ *   This field holds one of a number of values that communicate the
+ *   event that happened to the association.  They include:
+ *
+ *   Note:  The following state names deviate from the API draft as
+ *   the names clash too easily with other kernel symbols.
+ */
+enum sctp_sac_state {
+	SCTP_COMM_UP,
+	SCTP_COMM_LOST,
+	SCTP_RESTART,
+	SCTP_SHUTDOWN_COMP,
+	SCTP_CANT_STR_ASSOC,
+};
+
+/*
+ * 5.3.1.2 SCTP_PEER_ADDR_CHANGE
+ *
+ *   When a destination address on a multi-homed peer encounters a change
+ *   an interface details event is sent.  The information has the
+ *   following structure:
+ */
+struct sctp_paddr_change {
+	__u16 spc_type;
+	__u16 spc_flags;
+	__u32 spc_length;
+	struct sockaddr_storage spc_aaddr;
+	int spc_state;
+	int spc_error;
+	sctp_assoc_t spc_assoc_id;
+} __attribute__((packed, aligned(4)));
+
+/*
+ *    spc_state:  32 bits (signed integer)
+ *
+ *   This field holds one of a number of values that communicate the
+ *   event that happened to the address.  They include:
+ */
+enum sctp_spc_state {
+	SCTP_ADDR_AVAILABLE,
+	SCTP_ADDR_UNREACHABLE,
+	SCTP_ADDR_REMOVED,
+	SCTP_ADDR_ADDED,
+	SCTP_ADDR_MADE_PRIM,
+	SCTP_ADDR_CONFIRMED,
+};
+
+
+/*
+ * 5.3.1.3 SCTP_REMOTE_ERROR
+ *
+ *   A remote peer may send an Operational Error message to its peer.
+ *   This message indicates a variety of error conditions on an
+ *   association. The entire error TLV as it appears on the wire is
+ *   included in a SCTP_REMOTE_ERROR event.  Please refer to the SCTP
+ *   specification [SCTP] and any extensions for a list of possible
+ *   error formats. SCTP error TLVs have the format:
+ */
+struct sctp_remote_error {
+	__u16 sre_type;
+	__u16 sre_flags;
+	__u32 sre_length;
+	__u16 sre_error;
+	sctp_assoc_t sre_assoc_id;
+	__u8 sre_data[0];
+};
+
+
+/*
+ * 5.3.1.4 SCTP_SEND_FAILED
+ *
+ *   If SCTP cannot deliver a message it may return the message as a
+ *   notification.
+ */
+struct sctp_send_failed {
+	__u16 ssf_type;
+	__u16 ssf_flags;
+	__u32 ssf_length;
+	__u32 ssf_error;
+	struct sctp_sndrcvinfo ssf_info;
+	sctp_assoc_t ssf_assoc_id;
+	__u8 ssf_data[0];
+};
+
+/*
+ *   ssf_flags: 16 bits (unsigned integer)
+ *
+ *   The flag value will take one of the following values
+ *
+ *   SCTP_DATA_UNSENT  - Indicates that the data was never put on
+ *                       the wire.
+ *
+ *   SCTP_DATA_SENT    - Indicates that the data was put on the wire.
+ *                       Note that this does not necessarily mean that the
+ *                       data was (or was not) successfully delivered.
+ */
+enum sctp_ssf_flags {
+	SCTP_DATA_UNSENT,
+	SCTP_DATA_SENT,
+};
+
+/*
+ * 5.3.1.5 SCTP_SHUTDOWN_EVENT
+ *
+ *   When a peer sends a SHUTDOWN, SCTP delivers this notification to
+ *   inform the application that it should cease sending data.
+ */
+struct sctp_shutdown_event {
+	__u16 sse_type;
+	__u16 sse_flags;
+	__u32 sse_length;
+	sctp_assoc_t sse_assoc_id;
+};
+
+/*
+ * 5.3.1.6 SCTP_ADAPTATION_INDICATION
+ *
+ *   When a peer sends a Adaptation Layer Indication parameter , SCTP
+ *   delivers this notification to inform the application
+ *   that of the peers requested adaptation layer.
+ */
+struct sctp_adaptation_event {
+	__u16 sai_type;
+	__u16 sai_flags;
+	__u32 sai_length;
+	__u32 sai_adaptation_ind;
+	sctp_assoc_t sai_assoc_id;
+};
+
+/*
+ * 5.3.1.7 SCTP_PARTIAL_DELIVERY_EVENT
+ *
+ *   When a receiver is engaged in a partial delivery of a
+ *   message this notification will be used to indicate
+ *   various events.
+ */
+struct sctp_pdapi_event {
+	__u16 pdapi_type;
+	__u16 pdapi_flags;
+	__u32 pdapi_length;
+	__u32 pdapi_indication;
+	sctp_assoc_t pdapi_assoc_id;
+};
+
+enum { SCTP_PARTIAL_DELIVERY_ABORTED=0, };
+
+/*
+ * 5.3.1.8.  SCTP_AUTHENTICATION_EVENT
+ *
+ *  When a receiver is using authentication this message will provide
+ *  notifications regarding new keys being made active as well as errors.
+ */
+struct sctp_authkey_event {
+	__u16 auth_type;
+	__u16 auth_flags;
+	__u32 auth_length;
+	__u16 auth_keynumber;
+	__u16 auth_altkeynumber;
+	__u32 auth_indication;
+	sctp_assoc_t auth_assoc_id;
+};
+
+enum { SCTP_AUTH_NEWKEY = 0, };
+
+/*
+ * 6.1.9. SCTP_SENDER_DRY_EVENT
+ *
+ * When the SCTP stack has no more user data to send or retransmit, this
+ * notification is given to the user. Also, at the time when a user app
+ * subscribes to this event, if there is no data to be sent or
+ * retransmit, the stack will immediately send up this notification.
+ */
+struct sctp_sender_dry_event {
+	__u16 sender_dry_type;
+	__u16 sender_dry_flags;
+	__u32 sender_dry_length;
+	sctp_assoc_t sender_dry_assoc_id;
+};
+
+#define SCTP_STREAM_RESET_INCOMING_SSN	0x0001
+#define SCTP_STREAM_RESET_OUTGOING_SSN	0x0002
+#define SCTP_STREAM_RESET_DENIED	0x0004
+#define SCTP_STREAM_RESET_FAILED	0x0008
+struct sctp_stream_reset_event {
+	__u16 strreset_type;
+	__u16 strreset_flags;
+	__u32 strreset_length;
+	sctp_assoc_t strreset_assoc_id;
+	__u16 strreset_stream_list[];
+};
+
+#define SCTP_ASSOC_RESET_DENIED		0x0004
+#define SCTP_ASSOC_RESET_FAILED		0x0008
+struct sctp_assoc_reset_event {
+	__u16 assocreset_type;
+	__u16 assocreset_flags;
+	__u32 assocreset_length;
+	sctp_assoc_t assocreset_assoc_id;
+	__u32 assocreset_local_tsn;
+	__u32 assocreset_remote_tsn;
+};
+
+#define SCTP_ASSOC_CHANGE_DENIED	0x0004
+#define SCTP_ASSOC_CHANGE_FAILED	0x0008
+struct sctp_stream_change_event {
+	__u16 strchange_type;
+	__u16 strchange_flags;
+	__u32 strchange_length;
+	sctp_assoc_t strchange_assoc_id;
+	__u16 strchange_instrms;
+	__u16 strchange_outstrms;
+};
+
+/*
+ * Described in Section 7.3
+ *   Ancillary Data and Notification Interest Options
+ */
+struct sctp_event_subscribe {
+	__u8 sctp_data_io_event;
+	__u8 sctp_association_event;
+	__u8 sctp_address_event;
+	__u8 sctp_send_failure_event;
+	__u8 sctp_peer_error_event;
+	__u8 sctp_shutdown_event;
+	__u8 sctp_partial_delivery_event;
+	__u8 sctp_adaptation_layer_event;
+	__u8 sctp_authentication_event;
+	__u8 sctp_sender_dry_event;
+	__u8 sctp_stream_reset_event;
+	__u8 sctp_assoc_reset_event;
+	__u8 sctp_stream_change_event;
+};
+
+/*
+ * 5.3.1 SCTP Notification Structure
+ *
+ *   The notification structure is defined as the union of all
+ *   notification types.
+ *
+ */
+union sctp_notification {
+	struct {
+		__u16 sn_type;             /* Notification type. */
+		__u16 sn_flags;
+		__u32 sn_length;
+	} sn_header;
+	struct sctp_assoc_change sn_assoc_change;
+	struct sctp_paddr_change sn_paddr_change;
+	struct sctp_remote_error sn_remote_error;
+	struct sctp_send_failed sn_send_failed;
+	struct sctp_shutdown_event sn_shutdown_event;
+	struct sctp_adaptation_event sn_adaptation_event;
+	struct sctp_pdapi_event sn_pdapi_event;
+	struct sctp_authkey_event sn_authkey_event;
+	struct sctp_sender_dry_event sn_sender_dry_event;
+	struct sctp_stream_reset_event sn_strreset_event;
+	struct sctp_assoc_reset_event sn_assocreset_event;
+	struct sctp_stream_change_event sn_strchange_event;
+};
+
+/* Section 5.3.1
+ * All standard values for sn_type flags are greater than 2^15.
+ * Values from 2^15 and down are reserved.
+ */
+
+enum sctp_sn_type {
+	SCTP_SN_TYPE_BASE     = (1<<15),
+	SCTP_ASSOC_CHANGE,
+#define SCTP_ASSOC_CHANGE		SCTP_ASSOC_CHANGE
+	SCTP_PEER_ADDR_CHANGE,
+#define SCTP_PEER_ADDR_CHANGE		SCTP_PEER_ADDR_CHANGE
+	SCTP_SEND_FAILED,
+#define SCTP_SEND_FAILED		SCTP_SEND_FAILED
+	SCTP_REMOTE_ERROR,
+#define SCTP_REMOTE_ERROR		SCTP_REMOTE_ERROR
+	SCTP_SHUTDOWN_EVENT,
+#define SCTP_SHUTDOWN_EVENT		SCTP_SHUTDOWN_EVENT
+	SCTP_PARTIAL_DELIVERY_EVENT,
+#define SCTP_PARTIAL_DELIVERY_EVENT	SCTP_PARTIAL_DELIVERY_EVENT
+	SCTP_ADAPTATION_INDICATION,
+#define SCTP_ADAPTATION_INDICATION	SCTP_ADAPTATION_INDICATION
+	SCTP_AUTHENTICATION_EVENT,
+#define SCTP_AUTHENTICATION_INDICATION	SCTP_AUTHENTICATION_EVENT
+	SCTP_SENDER_DRY_EVENT,
+#define SCTP_SENDER_DRY_EVENT		SCTP_SENDER_DRY_EVENT
+	SCTP_STREAM_RESET_EVENT,
+#define SCTP_STREAM_RESET_EVENT		SCTP_STREAM_RESET_EVENT
+	SCTP_ASSOC_RESET_EVENT,
+#define SCTP_ASSOC_RESET_EVENT		SCTP_ASSOC_RESET_EVENT
+	SCTP_STREAM_CHANGE_EVENT,
+#define SCTP_STREAM_CHANGE_EVENT	SCTP_STREAM_CHANGE_EVENT
+};
+
+/* Notification error codes used to fill up the error fields in some
+ * notifications.
+ * SCTP_PEER_ADDRESS_CHAGE 	: spc_error
+ * SCTP_ASSOC_CHANGE		: sac_error
+ * These names should be potentially included in the draft 04 of the SCTP
+ * sockets API specification.
+ */
+typedef enum sctp_sn_error {
+	SCTP_FAILED_THRESHOLD,
+	SCTP_RECEIVED_SACK,
+	SCTP_HEARTBEAT_SUCCESS,
+	SCTP_RESPONSE_TO_USER_REQ,
+	SCTP_INTERNAL_ERROR,
+	SCTP_SHUTDOWN_GUARD_EXPIRES,
+	SCTP_PEER_FAULTY,
+} sctp_sn_error_t;
+
+/*
+ * 7.1.1 Retransmission Timeout Parameters (SCTP_RTOINFO)
+ *
+ *   The protocol parameters used to initialize and bound retransmission
+ *   timeout (RTO) are tunable.  See [SCTP] for more information on how
+ *   these parameters are used in RTO calculation.
+ */
+struct sctp_rtoinfo {
+	sctp_assoc_t	srto_assoc_id;
+	__u32		srto_initial;
+	__u32		srto_max;
+	__u32		srto_min;
+};
+
+/*
+ * 7.1.2 Association Parameters (SCTP_ASSOCINFO)
+ *
+ *   This option is used to both examine and set various association and
+ *   endpoint parameters.
+ */
+struct sctp_assocparams {
+	sctp_assoc_t	sasoc_assoc_id;
+	__u16		sasoc_asocmaxrxt;
+	__u16		sasoc_number_peer_destinations;
+	__u32		sasoc_peer_rwnd;
+	__u32		sasoc_local_rwnd;
+	__u32		sasoc_cookie_life;
+};
+
+/*
+ * 7.1.9 Set Peer Primary Address (SCTP_SET_PEER_PRIMARY_ADDR)
+ *
+ *  Requests that the peer mark the enclosed address as the association
+ *  primary. The enclosed address must be one of the association's
+ *  locally bound addresses. The following structure is used to make a
+ *   set primary request:
+ */
+struct sctp_setpeerprim {
+	sctp_assoc_t            sspp_assoc_id;
+	struct sockaddr_storage sspp_addr;
+} __attribute__((packed, aligned(4)));
+
+/*
+ * 7.1.10 Set Primary Address (SCTP_PRIMARY_ADDR)
+ *
+ *  Requests that the local SCTP stack use the enclosed peer address as
+ *  the association primary. The enclosed address must be one of the
+ *  association peer's addresses. The following structure is used to
+ *  make a set peer primary request:
+ */
+struct sctp_prim {
+	sctp_assoc_t            ssp_assoc_id;
+	struct sockaddr_storage ssp_addr;
+} __attribute__((packed, aligned(4)));
+
+/* For backward compatibility use, define the old name too */
+#define sctp_setprim	sctp_prim
+
+/*
+ * 7.1.11 Set Adaptation Layer Indicator (SCTP_ADAPTATION_LAYER)
+ *
+ * Requests that the local endpoint set the specified Adaptation Layer
+ * Indication parameter for all future INIT and INIT-ACK exchanges.
+ */
+struct sctp_setadaptation {
+	__u32	ssb_adaptation_ind;
+};
+
+/*
+ * 7.1.13 Peer Address Parameters  (SCTP_PEER_ADDR_PARAMS)
+ *
+ *   Applications can enable or disable heartbeats for any peer address
+ *   of an association, modify an address's heartbeat interval, force a
+ *   heartbeat to be sent immediately, and adjust the address's maximum
+ *   number of retransmissions sent before an address is considered
+ *   unreachable. The following structure is used to access and modify an
+ *   address's parameters:
+ */
+enum  sctp_spp_flags {
+	SPP_HB_ENABLE = 1<<0,		/*Enable heartbeats*/
+	SPP_HB_DISABLE = 1<<1,		/*Disable heartbeats*/
+	SPP_HB = SPP_HB_ENABLE | SPP_HB_DISABLE,
+	SPP_HB_DEMAND = 1<<2,		/*Send heartbeat immediately*/
+	SPP_PMTUD_ENABLE = 1<<3,	/*Enable PMTU discovery*/
+	SPP_PMTUD_DISABLE = 1<<4,	/*Disable PMTU discovery*/
+	SPP_PMTUD = SPP_PMTUD_ENABLE | SPP_PMTUD_DISABLE,
+	SPP_SACKDELAY_ENABLE = 1<<5,	/*Enable SACK*/
+	SPP_SACKDELAY_DISABLE = 1<<6,	/*Disable SACK*/
+	SPP_SACKDELAY = SPP_SACKDELAY_ENABLE | SPP_SACKDELAY_DISABLE,
+	SPP_HB_TIME_IS_ZERO = 1<<7,	/* Set HB delay to 0 */
+};
+
+struct sctp_paddrparams {
+	sctp_assoc_t		spp_assoc_id;
+	struct sockaddr_storage	spp_address;
+	__u32			spp_hbinterval;
+	__u16			spp_pathmaxrxt;
+	__u32			spp_pathmtu;
+	__u32			spp_sackdelay;
+	__u32			spp_flags;
+} __attribute__((packed, aligned(4)));
+
+/*
+ * 7.1.18.  Add a chunk that must be authenticated (SCTP_AUTH_CHUNK)
+ *
+ * This set option adds a chunk type that the user is requesting to be
+ * received only in an authenticated way.  Changes to the list of chunks
+ * will only effect future associations on the socket.
+ */
+struct sctp_authchunk {
+	__u8		sauth_chunk;
+};
+
+/*
+ * 7.1.19.  Get or set the list of supported HMAC Identifiers (SCTP_HMAC_IDENT)
+ *
+ * This option gets or sets the list of HMAC algorithms that the local
+ * endpoint requires the peer to use.
+ */
+/* This here is only used by user space as is. It might not be a good idea
+ * to export/reveal the whole structure with reserved fields etc.
+ */
+enum {
+	SCTP_AUTH_HMAC_ID_SHA1 = 1,
+	SCTP_AUTH_HMAC_ID_SHA256 = 3,
+};
+
+struct sctp_hmacalgo {
+	__u32		shmac_num_idents;
+	__u16		shmac_idents[];
+};
+
+/* Sadly, user and kernel space have different names for
+ * this structure member, so this is to not break anything.
+ */
+#define shmac_number_of_idents	shmac_num_idents
+
+/*
+ * 7.1.20.  Set a shared key (SCTP_AUTH_KEY)
+ *
+ * This option will set a shared secret key which is used to build an
+ * association shared key.
+ */
+struct sctp_authkey {
+	sctp_assoc_t	sca_assoc_id;
+	__u16		sca_keynumber;
+	__u16		sca_keylength;
+	__u8		sca_key[];
+};
+
+/*
+ * 7.1.21.  Get or set the active shared key (SCTP_AUTH_ACTIVE_KEY)
+ *
+ * This option will get or set the active shared key to be used to build
+ * the association shared key.
+ */
+
+struct sctp_authkeyid {
+	sctp_assoc_t	scact_assoc_id;
+	__u16		scact_keynumber;
+};
+
+
+/*
+ * 7.1.23.  Get or set delayed ack timer (SCTP_DELAYED_SACK)
+ *
+ * This option will effect the way delayed acks are performed.  This
+ * option allows you to get or set the delayed ack time, in
+ * milliseconds.  It also allows changing the delayed ack frequency.
+ * Changing the frequency to 1 disables the delayed sack algorithm.  If
+ * the assoc_id is 0, then this sets or gets the endpoints default
+ * values.  If the assoc_id field is non-zero, then the set or get
+ * effects the specified association for the one to many model (the
+ * assoc_id field is ignored by the one to one model).  Note that if
+ * sack_delay or sack_freq are 0 when setting this option, then the
+ * current values will remain unchanged.
+ */
+struct sctp_sack_info {
+	sctp_assoc_t	sack_assoc_id;
+	uint32_t	sack_delay;
+	uint32_t	sack_freq;
+};
+
+struct sctp_assoc_value {
+    sctp_assoc_t            assoc_id;
+    uint32_t                assoc_value;
+};
+
+/*
+ * 7.2.2 Peer Address Information
+ *
+ *   Applications can retrieve information about a specific peer address
+ *   of an association, including its reachability state, congestion
+ *   window, and retransmission timer values.  This information is
+ *   read-only. The following structure is used to access this
+ *   information:
+ */
+struct sctp_paddrinfo {
+	sctp_assoc_t		spinfo_assoc_id;
+	struct sockaddr_storage	spinfo_address;
+	__s32			spinfo_state;
+	__u32			spinfo_cwnd;
+	__u32			spinfo_srtt;
+	__u32			spinfo_rto;
+	__u32			spinfo_mtu;
+} __attribute__((packed, aligned(4)));
+
+/* Peer addresses's state. */
+/* UNKNOWN: Peer address passed by the upper layer in sendmsg or connect[x]
+ * calls.
+ * UNCONFIRMED: Peer address received in INIT/INIT-ACK address parameters.
+ *              Not yet confirmed by a heartbeat and not available for data
+ *		transfers.
+ * ACTIVE : Peer address confirmed, active and available for data transfers.
+ * INACTIVE: Peer address inactive and not available for data transfers.
+ */
+enum sctp_spinfo_state {
+	SCTP_INACTIVE,
+	SCTP_PF,
+	SCTP_ACTIVE,
+	SCTP_UNCONFIRMED,
+	SCTP_UNKNOWN = 0xffff  /* Value used for transport state unknown */
+};
+
+/*
+ * 7.2.1 Association Status (SCTP_STATUS)
+ *
+ *   Applications can retrieve current status information about an
+ *   association, including association state, peer receiver window size,
+ *   number of unacked data chunks, and number of data chunks pending
+ *   receipt.  This information is read-only.  The following structure is
+ *   used to access this information:
+ */
+struct sctp_status {
+	sctp_assoc_t		sstat_assoc_id;
+	__s32			sstat_state;
+	__u32			sstat_rwnd;
+	__u16			sstat_unackdata;
+	__u16			sstat_penddata;
+	__u16			sstat_instrms;
+	__u16			sstat_outstrms;
+	__u32			sstat_fragmentation_point;
+	struct sctp_paddrinfo	sstat_primary;
+};
+
+/*
+ * 7.2.3.  Get the list of chunks the peer requires to be authenticated
+ *         (SCTP_PEER_AUTH_CHUNKS)
+ *
+ * This option gets a list of chunks for a specified association that
+ * the peer requires to be received authenticated only.
+ */
+struct sctp_authchunks {
+	sctp_assoc_t	gauth_assoc_id;
+	__u32		gauth_number_of_chunks;
+	uint8_t		gauth_chunks[];
+};
+
+/* The broken spelling has been released already in lksctp-tools header,
+ * so don't break anyone, now that it's fixed.
+ */
+#define guth_number_of_chunks	gauth_number_of_chunks
+
+/* Association states.  */
+enum sctp_sstat_state {
+	SCTP_EMPTY                = 0,
+	SCTP_CLOSED               = 1,
+	SCTP_COOKIE_WAIT          = 2,
+	SCTP_COOKIE_ECHOED        = 3,
+	SCTP_ESTABLISHED          = 4,
+	SCTP_SHUTDOWN_PENDING     = 5,
+	SCTP_SHUTDOWN_SENT        = 6,
+	SCTP_SHUTDOWN_RECEIVED    = 7,
+	SCTP_SHUTDOWN_ACK_SENT    = 8,
+};
+
+/*
+ * 8.2.6. Get the Current Identifiers of Associations
+ *        (SCTP_GET_ASSOC_ID_LIST)
+ *
+ * This option gets the current list of SCTP association identifiers of
+ * the SCTP associations handled by a one-to-many style socket.
+ */
+struct sctp_assoc_ids {
+	__u32		gaids_number_of_ids;
+	sctp_assoc_t	gaids_assoc_id[];
+};
+
+/*
+ * 8.3, 8.5 get all peer/local addresses in an association.
+ * This parameter struct is used by SCTP_GET_PEER_ADDRS and
+ * SCTP_GET_LOCAL_ADDRS socket options used internally to implement
+ * sctp_getpaddrs() and sctp_getladdrs() API.
+ */
+struct sctp_getaddrs_old {
+	sctp_assoc_t            assoc_id;
+	int			addr_num;
+	struct sockaddr		*addrs;
+};
+
+struct sctp_getaddrs {
+	sctp_assoc_t		assoc_id; /*input*/
+	__u32			addr_num; /*output*/
+	__u8			addrs[0]; /*output, variable size*/
+};
+
+/* A socket user request obtained via SCTP_GET_ASSOC_STATS that retrieves
+ * association stats. All stats are counts except sas_maxrto and
+ * sas_obs_rto_ipaddr. maxrto is the max observed rto + transport since
+ * the last call. Will return 0 when RTO was not update since last call
+ */
+struct sctp_assoc_stats {
+	sctp_assoc_t	sas_assoc_id;    /* Input */
+					 /* Transport of observed max RTO */
+	struct sockaddr_storage sas_obs_rto_ipaddr;
+	__u64		sas_maxrto;      /* Maximum Observed RTO for period */
+	__u64		sas_isacks;	 /* SACKs received */
+	__u64		sas_osacks;	 /* SACKs sent */
+	__u64		sas_opackets;	 /* Packets sent */
+	__u64		sas_ipackets;	 /* Packets received */
+	__u64		sas_rtxchunks;   /* Retransmitted Chunks */
+	__u64		sas_outofseqtsns;/* TSN received > next expected */
+	__u64		sas_idupchunks;  /* Dups received (ordered+unordered) */
+	__u64		sas_gapcnt;      /* Gap Acknowledgements Received */
+	__u64		sas_ouodchunks;  /* Unordered data chunks sent */
+	__u64		sas_iuodchunks;  /* Unordered data chunks received */
+	__u64		sas_oodchunks;	 /* Ordered data chunks sent */
+	__u64		sas_iodchunks;	 /* Ordered data chunks received */
+	__u64		sas_octrlchunks; /* Control chunks sent */
+	__u64		sas_ictrlchunks; /* Control chunks received */
+};
+
+/*
+ * 8.1 sctp_bindx()
+ *
+ * The flags parameter is formed from the bitwise OR of zero or more of the
+ * following currently defined flags:
+ */
+#define SCTP_BINDX_ADD_ADDR 0x01
+#define SCTP_BINDX_REM_ADDR 0x02
+
+/* This is the structure that is passed as an argument(optval) to
+ * getsockopt(SCTP_SOCKOPT_PEELOFF).
+ */
+typedef struct {
+	sctp_assoc_t associd;
+	int sd;
+} sctp_peeloff_arg_t;
+
+typedef struct {
+	sctp_peeloff_arg_t p_arg;
+	unsigned flags;
+} sctp_peeloff_flags_arg_t;
+
+/*
+ *  Peer Address Thresholds socket option
+ */
+struct sctp_paddrthlds {
+	sctp_assoc_t spt_assoc_id;
+	struct sockaddr_storage spt_address;
+	__u16 spt_pathmaxrxt;
+	__u16 spt_pathpfthld;
+};
+
+/*
+ * Socket Option for Getting the Association/Stream-Specific PR-SCTP Status
+ */
+struct sctp_prstatus {
+	sctp_assoc_t sprstat_assoc_id;
+	__u16 sprstat_sid;
+	__u16 sprstat_policy;
+	__u64 sprstat_abandoned_unsent;
+	__u64 sprstat_abandoned_sent;
+};
+
+struct sctp_default_prinfo {
+	sctp_assoc_t pr_assoc_id;
+	__u32 pr_value;
+	__u16 pr_policy;
+};
+
+struct sctp_info {
+	__u32	sctpi_tag;
+	__u32	sctpi_state;
+	__u32	sctpi_rwnd;
+	__u16	sctpi_unackdata;
+	__u16	sctpi_penddata;
+	__u16	sctpi_instrms;
+	__u16	sctpi_outstrms;
+	__u32	sctpi_fragmentation_point;
+	__u32	sctpi_inqueue;
+	__u32	sctpi_outqueue;
+	__u32	sctpi_overall_error;
+	__u32	sctpi_max_burst;
+	__u32	sctpi_maxseg;
+	__u32	sctpi_peer_rwnd;
+	__u32	sctpi_peer_tag;
+	__u8	sctpi_peer_capable;
+	__u8	sctpi_peer_sack;
+	__u16	__reserved1;
+
+	/* assoc status info */
+	__u64	sctpi_isacks;
+	__u64	sctpi_osacks;
+	__u64	sctpi_opackets;
+	__u64	sctpi_ipackets;
+	__u64	sctpi_rtxchunks;
+	__u64	sctpi_outofseqtsns;
+	__u64	sctpi_idupchunks;
+	__u64	sctpi_gapcnt;
+	__u64	sctpi_ouodchunks;
+	__u64	sctpi_iuodchunks;
+	__u64	sctpi_oodchunks;
+	__u64	sctpi_iodchunks;
+	__u64	sctpi_octrlchunks;
+	__u64	sctpi_ictrlchunks;
+
+	/* primary transport info */
+	struct sockaddr_storage	sctpi_p_address;
+	__s32	sctpi_p_state;
+	__u32	sctpi_p_cwnd;
+	__u32	sctpi_p_srtt;
+	__u32	sctpi_p_rto;
+	__u32	sctpi_p_hbinterval;
+	__u32	sctpi_p_pathmaxrxt;
+	__u32	sctpi_p_sackdelay;
+	__u32	sctpi_p_sackfreq;
+	__u32	sctpi_p_ssthresh;
+	__u32	sctpi_p_partial_bytes_acked;
+	__u32	sctpi_p_flight_size;
+	__u16	sctpi_p_error;
+	__u16	__reserved2;
+
+	/* sctp sock info */
+	__u32	sctpi_s_autoclose;
+	__u32	sctpi_s_adaptation_ind;
+	__u32	sctpi_s_pd_point;
+	__u8	sctpi_s_nodelay;
+	__u8	sctpi_s_disable_fragments;
+	__u8	sctpi_s_v4mapped;
+	__u8	sctpi_s_frag_interleave;
+	__u32	sctpi_s_type;
+	__u32	__reserved3;
+};
+
+struct sctp_reset_streams {
+	sctp_assoc_t srs_assoc_id;
+	uint16_t srs_flags;
+	uint16_t srs_number_streams;	/* 0 == ALL */
+	uint16_t srs_stream_list[];	/* list if srs_num_streams is not 0 */
+};
+
+struct sctp_add_streams {
+	sctp_assoc_t sas_assoc_id;
+	uint16_t sas_instrms;
+	uint16_t sas_outstrms;
+};
+
+#endif /* _SCTP_H */
diff --git a/include/uapi/linux/seg6.h b/include/uapi/linux/seg6.h
new file mode 100644
index 0000000..0715279
--- /dev/null
+++ b/include/uapi/linux/seg6.h
@@ -0,0 +1,54 @@
+/*
+ *  SR-IPv6 implementation
+ *
+ *  Author:
+ *  David Lebrun <david.lebrun@uclouvain.be>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _LINUX_SEG6_H
+#define _LINUX_SEG6_H
+
+#include <linux/types.h>
+#include <linux/in6.h>		/* For struct in6_addr. */
+
+/*
+ * SRH
+ */
+struct ipv6_sr_hdr {
+	__u8	nexthdr;
+	__u8	hdrlen;
+	__u8	type;
+	__u8	segments_left;
+	__u8	first_segment;
+	__u8	flags;
+	__u16	reserved;
+
+	struct in6_addr segments[0];
+};
+
+#define SR6_FLAG1_PROTECTED	(1 << 6)
+#define SR6_FLAG1_OAM		(1 << 5)
+#define SR6_FLAG1_ALERT		(1 << 4)
+#define SR6_FLAG1_HMAC		(1 << 3)
+
+#define SR6_TLV_INGRESS		1
+#define SR6_TLV_EGRESS		2
+#define SR6_TLV_OPAQUE		3
+#define SR6_TLV_PADDING		4
+#define SR6_TLV_HMAC		5
+
+#define sr_has_hmac(srh) ((srh)->flags & SR6_FLAG1_HMAC)
+
+struct sr6_tlv {
+	__u8 type;
+	__u8 len;
+	__u8 data[0];
+};
+
+#endif
diff --git a/include/uapi/linux/seg6_genl.h b/include/uapi/linux/seg6_genl.h
new file mode 100644
index 0000000..99382f9
--- /dev/null
+++ b/include/uapi/linux/seg6_genl.h
@@ -0,0 +1,32 @@
+#ifndef _LINUX_SEG6_GENL_H
+#define _LINUX_SEG6_GENL_H
+
+#define SEG6_GENL_NAME		"SEG6"
+#define SEG6_GENL_VERSION	0x1
+
+enum {
+	SEG6_ATTR_UNSPEC,
+	SEG6_ATTR_DST,
+	SEG6_ATTR_DSTLEN,
+	SEG6_ATTR_HMACKEYID,
+	SEG6_ATTR_SECRET,
+	SEG6_ATTR_SECRETLEN,
+	SEG6_ATTR_ALGID,
+	SEG6_ATTR_HMACINFO,
+	__SEG6_ATTR_MAX,
+};
+
+#define SEG6_ATTR_MAX (__SEG6_ATTR_MAX - 1)
+
+enum {
+	SEG6_CMD_UNSPEC,
+	SEG6_CMD_SETHMAC,
+	SEG6_CMD_DUMPHMAC,
+	SEG6_CMD_SET_TUNSRC,
+	SEG6_CMD_GET_TUNSRC,
+	__SEG6_CMD_MAX,
+};
+
+#define SEG6_CMD_MAX (__SEG6_CMD_MAX - 1)
+
+#endif
diff --git a/include/uapi/linux/seg6_hmac.h b/include/uapi/linux/seg6_hmac.h
new file mode 100644
index 0000000..704f93e
--- /dev/null
+++ b/include/uapi/linux/seg6_hmac.h
@@ -0,0 +1,22 @@
+#ifndef _LINUX_SEG6_HMAC_H
+#define _LINUX_SEG6_HMAC_H
+
+#include <linux/types.h>
+#include <linux/seg6.h>
+
+#define SEG6_HMAC_SECRET_LEN	64
+#define SEG6_HMAC_FIELD_LEN	32
+
+struct sr6_tlv_hmac {
+	struct sr6_tlv tlvhdr;
+	__u16 reserved;
+	__be32 hmackeyid;
+	__u8 hmac[SEG6_HMAC_FIELD_LEN];
+};
+
+enum {
+	SEG6_HMAC_ALGO_SHA1 = 1,
+	SEG6_HMAC_ALGO_SHA256 = 2,
+};
+
+#endif
diff --git a/include/uapi/linux/seg6_iptunnel.h b/include/uapi/linux/seg6_iptunnel.h
new file mode 100644
index 0000000..a5dc05a
--- /dev/null
+++ b/include/uapi/linux/seg6_iptunnel.h
@@ -0,0 +1,40 @@
+/*
+ *  SR-IPv6 implementation
+ *
+ *  Author:
+ *  David Lebrun <david.lebrun@uclouvain.be>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _LINUX_SEG6_IPTUNNEL_H
+#define _LINUX_SEG6_IPTUNNEL_H
+
+#include <linux/seg6.h>		/* For struct ipv6_sr_hdr. */
+
+enum {
+	SEG6_IPTUNNEL_UNSPEC,
+	SEG6_IPTUNNEL_SRH,
+	__SEG6_IPTUNNEL_MAX,
+};
+#define SEG6_IPTUNNEL_MAX (__SEG6_IPTUNNEL_MAX - 1)
+
+struct seg6_iptunnel_encap {
+	int mode;
+	struct ipv6_sr_hdr srh[0];
+};
+
+#define SEG6_IPTUN_ENCAP_SIZE(x) ((sizeof(*x)) + (((x)->srh->hdrlen + 1) << 3))
+
+enum {
+	SEG6_IPTUN_MODE_INLINE,
+	SEG6_IPTUN_MODE_ENCAP,
+	SEG6_IPTUN_MODE_L2ENCAP,
+};
+
+
+#endif
diff --git a/include/uapi/linux/seg6_local.h b/include/uapi/linux/seg6_local.h
new file mode 100644
index 0000000..76b90d6
--- /dev/null
+++ b/include/uapi/linux/seg6_local.h
@@ -0,0 +1,68 @@
+/*
+ *  SR-IPv6 implementation
+ *
+ *  Author:
+ *  David Lebrun <david.lebrun@uclouvain.be>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _LINUX_SEG6_LOCAL_H
+#define _LINUX_SEG6_LOCAL_H
+
+#include <linux/seg6.h>
+
+enum {
+	SEG6_LOCAL_UNSPEC,
+	SEG6_LOCAL_ACTION,
+	SEG6_LOCAL_SRH,
+	SEG6_LOCAL_TABLE,
+	SEG6_LOCAL_NH4,
+	SEG6_LOCAL_NH6,
+	SEG6_LOCAL_IIF,
+	SEG6_LOCAL_OIF,
+	__SEG6_LOCAL_MAX,
+};
+#define SEG6_LOCAL_MAX (__SEG6_LOCAL_MAX - 1)
+
+enum {
+	SEG6_LOCAL_ACTION_UNSPEC	= 0,
+	/* node segment */
+	SEG6_LOCAL_ACTION_END		= 1,
+	/* adjacency segment (IPv6 cross-connect) */
+	SEG6_LOCAL_ACTION_END_X		= 2,
+	/* lookup of next seg NH in table */
+	SEG6_LOCAL_ACTION_END_T		= 3,
+	/* decap and L2 cross-connect */
+	SEG6_LOCAL_ACTION_END_DX2	= 4,
+	/* decap and IPv6 cross-connect */
+	SEG6_LOCAL_ACTION_END_DX6	= 5,
+	/* decap and IPv4 cross-connect */
+	SEG6_LOCAL_ACTION_END_DX4	= 6,
+	/* decap and lookup of DA in v6 table */
+	SEG6_LOCAL_ACTION_END_DT6	= 7,
+	/* decap and lookup of DA in v4 table */
+	SEG6_LOCAL_ACTION_END_DT4	= 8,
+	/* binding segment with insertion */
+	SEG6_LOCAL_ACTION_END_B6	= 9,
+	/* binding segment with encapsulation */
+	SEG6_LOCAL_ACTION_END_B6_ENCAP	= 10,
+	/* binding segment with MPLS encap */
+	SEG6_LOCAL_ACTION_END_BM	= 11,
+	/* lookup last seg in table */
+	SEG6_LOCAL_ACTION_END_S		= 12,
+	/* forward to SR-unaware VNF with static proxy */
+	SEG6_LOCAL_ACTION_END_AS	= 13,
+	/* forward to SR-unaware VNF with masquerading */
+	SEG6_LOCAL_ACTION_END_AM	= 14,
+
+	__SEG6_LOCAL_ACTION_MAX,
+};
+
+#define SEG6_LOCAL_ACTION_MAX (__SEG6_LOCAL_ACTION_MAX - 1)
+
+#endif
diff --git a/include/uapi/linux/sock_diag.h b/include/uapi/linux/sock_diag.h
new file mode 100644
index 0000000..901231e
--- /dev/null
+++ b/include/uapi/linux/sock_diag.h
@@ -0,0 +1,38 @@
+#ifndef __SOCK_DIAG_H__
+#define __SOCK_DIAG_H__
+
+#include <linux/types.h>
+
+#define SOCK_DIAG_BY_FAMILY 20
+#define SOCK_DESTROY 21
+
+struct sock_diag_req {
+	__u8	sdiag_family;
+	__u8	sdiag_protocol;
+};
+
+enum {
+	SK_MEMINFO_RMEM_ALLOC,
+	SK_MEMINFO_RCVBUF,
+	SK_MEMINFO_WMEM_ALLOC,
+	SK_MEMINFO_SNDBUF,
+	SK_MEMINFO_FWD_ALLOC,
+	SK_MEMINFO_WMEM_QUEUED,
+	SK_MEMINFO_OPTMEM,
+	SK_MEMINFO_BACKLOG,
+	SK_MEMINFO_DROPS,
+
+	SK_MEMINFO_VARS,
+};
+
+enum sknetlink_groups {
+	SKNLGRP_NONE,
+	SKNLGRP_INET_TCP_DESTROY,
+	SKNLGRP_INET_UDP_DESTROY,
+	SKNLGRP_INET6_TCP_DESTROY,
+	SKNLGRP_INET6_UDP_DESTROY,
+	__SKNLGRP_MAX,
+};
+#define SKNLGRP_MAX	(__SKNLGRP_MAX - 1)
+
+#endif /* __SOCK_DIAG_H__ */
diff --git a/include/uapi/linux/socket.h b/include/uapi/linux/socket.h
new file mode 100644
index 0000000..8c1e501
--- /dev/null
+++ b/include/uapi/linux/socket.h
@@ -0,0 +1,21 @@
+#ifndef _LINUX_SOCKET_H
+#define _LINUX_SOCKET_H
+
+/*
+ * Desired design of maximum size and alignment (see RFC2553)
+ */
+#define _K_SS_MAXSIZE	128	/* Implementation specific max size */
+#define _K_SS_ALIGNSIZE	(__alignof__ (struct sockaddr *))
+				/* Implementation specific desired alignment */
+
+typedef unsigned short __kernel_sa_family_t;
+
+struct __kernel_sockaddr_storage {
+	__kernel_sa_family_t	ss_family;		/* address family */
+	/* Following field(s) are implementation specific */
+	char		__data[_K_SS_MAXSIZE - sizeof(unsigned short)];
+				/* space to achieve desired size, */
+				/* _SS_MAXSIZE value minus size of ss_family */
+} __attribute__ ((aligned(_K_SS_ALIGNSIZE)));	/* force desired alignment */
+
+#endif /* _LINUX_SOCKET_H */
diff --git a/include/uapi/linux/sockios.h b/include/uapi/linux/sockios.h
new file mode 100644
index 0000000..79d029d
--- /dev/null
+++ b/include/uapi/linux/sockios.h
@@ -0,0 +1,152 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Definitions of the socket-level I/O control calls.
+ *
+ * Version:	@(#)sockios.h	1.0.2	03/09/93
+ *
+ * Authors:	Ross Biro
+ *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_SOCKIOS_H
+#define _LINUX_SOCKIOS_H
+
+#include <asm/sockios.h>
+
+/* Linux-specific socket ioctls */
+#define SIOCINQ		FIONREAD
+#define SIOCOUTQ	TIOCOUTQ        /* output queue size (not sent + not acked) */
+
+#define SOCK_IOC_TYPE	0x89
+
+/* Routing table calls. */
+#define SIOCADDRT	0x890B		/* add routing table entry	*/
+#define SIOCDELRT	0x890C		/* delete routing table entry	*/
+#define SIOCRTMSG	0x890D		/* unused			*/
+
+/* Socket configuration controls. */
+#define SIOCGIFNAME	0x8910		/* get iface name		*/
+#define SIOCSIFLINK	0x8911		/* set iface channel		*/
+#define SIOCGIFCONF	0x8912		/* get iface list		*/
+#define SIOCGIFFLAGS	0x8913		/* get flags			*/
+#define SIOCSIFFLAGS	0x8914		/* set flags			*/
+#define SIOCGIFADDR	0x8915		/* get PA address		*/
+#define SIOCSIFADDR	0x8916		/* set PA address		*/
+#define SIOCGIFDSTADDR	0x8917		/* get remote PA address	*/
+#define SIOCSIFDSTADDR	0x8918		/* set remote PA address	*/
+#define SIOCGIFBRDADDR	0x8919		/* get broadcast PA address	*/
+#define SIOCSIFBRDADDR	0x891a		/* set broadcast PA address	*/
+#define SIOCGIFNETMASK	0x891b		/* get network PA mask		*/
+#define SIOCSIFNETMASK	0x891c		/* set network PA mask		*/
+#define SIOCGIFMETRIC	0x891d		/* get metric			*/
+#define SIOCSIFMETRIC	0x891e		/* set metric			*/
+#define SIOCGIFMEM	0x891f		/* get memory address (BSD)	*/
+#define SIOCSIFMEM	0x8920		/* set memory address (BSD)	*/
+#define SIOCGIFMTU	0x8921		/* get MTU size			*/
+#define SIOCSIFMTU	0x8922		/* set MTU size			*/
+#define SIOCSIFNAME	0x8923		/* set interface name */
+#define	SIOCSIFHWADDR	0x8924		/* set hardware address 	*/
+#define SIOCGIFENCAP	0x8925		/* get/set encapsulations       */
+#define SIOCSIFENCAP	0x8926		
+#define SIOCGIFHWADDR	0x8927		/* Get hardware address		*/
+#define SIOCGIFSLAVE	0x8929		/* Driver slaving support	*/
+#define SIOCSIFSLAVE	0x8930
+#define SIOCADDMULTI	0x8931		/* Multicast address lists	*/
+#define SIOCDELMULTI	0x8932
+#define SIOCGIFINDEX	0x8933		/* name -> if_index mapping	*/
+#define SIOGIFINDEX	SIOCGIFINDEX	/* misprint compatibility :-)	*/
+#define SIOCSIFPFLAGS	0x8934		/* set/get extended flags set	*/
+#define SIOCGIFPFLAGS	0x8935
+#define SIOCDIFADDR	0x8936		/* delete PA address		*/
+#define	SIOCSIFHWBROADCAST	0x8937	/* set hardware broadcast addr	*/
+#define SIOCGIFCOUNT	0x8938		/* get number of devices */
+
+#define SIOCGIFBR	0x8940		/* Bridging support		*/
+#define SIOCSIFBR	0x8941		/* Set bridging options 	*/
+
+#define SIOCGIFTXQLEN	0x8942		/* Get the tx queue length	*/
+#define SIOCSIFTXQLEN	0x8943		/* Set the tx queue length 	*/
+
+/* SIOCGIFDIVERT was:	0x8944		Frame diversion support */
+/* SIOCSIFDIVERT was:	0x8945		Set frame diversion options */
+
+#define SIOCETHTOOL	0x8946		/* Ethtool interface		*/
+
+#define SIOCGMIIPHY	0x8947		/* Get address of MII PHY in use. */
+#define SIOCGMIIREG	0x8948		/* Read MII PHY register.	*/
+#define SIOCSMIIREG	0x8949		/* Write MII PHY register.	*/
+
+#define SIOCWANDEV	0x894A		/* get/set netdev parameters	*/
+
+#define SIOCOUTQNSD	0x894B		/* output queue size (not sent only) */
+#define SIOCGSKNS	0x894C		/* get socket network namespace */
+
+/* ARP cache control calls. */
+		    /*  0x8950 - 0x8952  * obsolete calls, don't re-use */
+#define SIOCDARP	0x8953		/* delete ARP table entry	*/
+#define SIOCGARP	0x8954		/* get ARP table entry		*/
+#define SIOCSARP	0x8955		/* set ARP table entry		*/
+
+/* RARP cache control calls. */
+#define SIOCDRARP	0x8960		/* delete RARP table entry	*/
+#define SIOCGRARP	0x8961		/* get RARP table entry		*/
+#define SIOCSRARP	0x8962		/* set RARP table entry		*/
+
+/* Driver configuration calls */
+
+#define SIOCGIFMAP	0x8970		/* Get device parameters	*/
+#define SIOCSIFMAP	0x8971		/* Set device parameters	*/
+
+/* DLCI configuration calls */
+
+#define SIOCADDDLCI	0x8980		/* Create new DLCI device	*/
+#define SIOCDELDLCI	0x8981		/* Delete DLCI device		*/
+
+#define SIOCGIFVLAN	0x8982		/* 802.1Q VLAN support		*/
+#define SIOCSIFVLAN	0x8983		/* Set 802.1Q VLAN options 	*/
+
+/* bonding calls */
+
+#define SIOCBONDENSLAVE	0x8990		/* enslave a device to the bond */
+#define SIOCBONDRELEASE 0x8991		/* release a slave from the bond*/
+#define SIOCBONDSETHWADDR      0x8992	/* set the hw addr of the bond  */
+#define SIOCBONDSLAVEINFOQUERY 0x8993   /* rtn info about slave state   */
+#define SIOCBONDINFOQUERY      0x8994	/* rtn info about bond state    */
+#define SIOCBONDCHANGEACTIVE   0x8995   /* update to a new active slave */
+			
+/* bridge calls */
+#define SIOCBRADDBR     0x89a0		/* create new bridge device     */
+#define SIOCBRDELBR     0x89a1		/* remove bridge device         */
+#define SIOCBRADDIF	0x89a2		/* add interface to bridge      */
+#define SIOCBRDELIF	0x89a3		/* remove interface from bridge */
+
+/* hardware time stamping: parameters in linux/net_tstamp.h */
+#define SIOCSHWTSTAMP	0x89b0		/* set and get config		*/
+#define SIOCGHWTSTAMP	0x89b1		/* get config			*/
+
+/* Device private ioctl calls */
+
+/*
+ *	These 16 ioctls are available to devices via the do_ioctl() device
+ *	vector. Each device should include this file and redefine these names
+ *	as their own. Because these are device dependent it is a good idea
+ *	_NOT_ to issue them to random objects and hope.
+ *
+ *	THESE IOCTLS ARE _DEPRECATED_ AND WILL DISAPPEAR IN 2.5.X -DaveM
+ */
+ 
+#define SIOCDEVPRIVATE	0x89F0	/* to 89FF */
+
+/*
+ *	These 16 ioctl calls are protocol private
+ */
+ 
+#define SIOCPROTOPRIVATE 0x89E0 /* to 89EF */
+#endif	/* _LINUX_SOCKIOS_H */
diff --git a/include/uapi/linux/stddef.h b/include/uapi/linux/stddef.h
new file mode 100644
index 0000000..4bb69de
--- /dev/null
+++ b/include/uapi/linux/stddef.h
@@ -0,0 +1,5 @@
+
+
+#ifndef __always_inline
+#define __always_inline __inline__
+#endif
diff --git a/include/uapi/linux/sysinfo.h b/include/uapi/linux/sysinfo.h
new file mode 100644
index 0000000..934335a
--- /dev/null
+++ b/include/uapi/linux/sysinfo.h
@@ -0,0 +1,24 @@
+#ifndef _LINUX_SYSINFO_H
+#define _LINUX_SYSINFO_H
+
+#include <linux/types.h>
+
+#define SI_LOAD_SHIFT	16
+struct sysinfo {
+	__kernel_long_t uptime;		/* Seconds since boot */
+	__kernel_ulong_t loads[3];	/* 1, 5, and 15 minute load averages */
+	__kernel_ulong_t totalram;	/* Total usable main memory size */
+	__kernel_ulong_t freeram;	/* Available memory size */
+	__kernel_ulong_t sharedram;	/* Amount of shared memory */
+	__kernel_ulong_t bufferram;	/* Memory used by buffers */
+	__kernel_ulong_t totalswap;	/* Total swap space size */
+	__kernel_ulong_t freeswap;	/* swap space still available */
+	__u16 procs;		   	/* Number of current processes */
+	__u16 pad;		   	/* Explicit padding for m68k */
+	__kernel_ulong_t totalhigh;	/* Total high memory size */
+	__kernel_ulong_t freehigh;	/* Available high memory size */
+	__u32 mem_unit;			/* Memory unit size in bytes */
+	char _f[20-2*sizeof(__kernel_ulong_t)-sizeof(__u32)];	/* Padding: libc5 uses this.. */
+};
+
+#endif /* _LINUX_SYSINFO_H */
diff --git a/include/uapi/linux/tc_act/tc_bpf.h b/include/uapi/linux/tc_act/tc_bpf.h
new file mode 100644
index 0000000..8dc2ac0
--- /dev/null
+++ b/include/uapi/linux/tc_act/tc_bpf.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2015 Jiri Pirko <jiri@resnulli.us>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __LINUX_TC_BPF_H
+#define __LINUX_TC_BPF_H
+
+#include <linux/pkt_cls.h>
+
+#define TCA_ACT_BPF 13
+
+struct tc_act_bpf {
+	tc_gen;
+};
+
+enum {
+	TCA_ACT_BPF_UNSPEC,
+	TCA_ACT_BPF_TM,
+	TCA_ACT_BPF_PARMS,
+	TCA_ACT_BPF_OPS_LEN,
+	TCA_ACT_BPF_OPS,
+	TCA_ACT_BPF_FD,
+	TCA_ACT_BPF_NAME,
+	TCA_ACT_BPF_PAD,
+	TCA_ACT_BPF_TAG,
+	TCA_ACT_BPF_ID,
+	__TCA_ACT_BPF_MAX,
+};
+#define TCA_ACT_BPF_MAX (__TCA_ACT_BPF_MAX - 1)
+
+#endif
diff --git a/include/uapi/linux/tc_act/tc_connmark.h b/include/uapi/linux/tc_act/tc_connmark.h
new file mode 100644
index 0000000..62a5e94
--- /dev/null
+++ b/include/uapi/linux/tc_act/tc_connmark.h
@@ -0,0 +1,23 @@
+#ifndef __UAPI_TC_CONNMARK_H
+#define __UAPI_TC_CONNMARK_H
+
+#include <linux/types.h>
+#include <linux/pkt_cls.h>
+
+#define TCA_ACT_CONNMARK 14
+
+struct tc_connmark {
+	tc_gen;
+	__u16 zone;
+};
+
+enum {
+	TCA_CONNMARK_UNSPEC,
+	TCA_CONNMARK_PARMS,
+	TCA_CONNMARK_TM,
+	TCA_CONNMARK_PAD,
+	__TCA_CONNMARK_MAX
+};
+#define TCA_CONNMARK_MAX (__TCA_CONNMARK_MAX - 1)
+
+#endif
diff --git a/include/uapi/linux/tc_act/tc_csum.h b/include/uapi/linux/tc_act/tc_csum.h
new file mode 100644
index 0000000..a11bb35
--- /dev/null
+++ b/include/uapi/linux/tc_act/tc_csum.h
@@ -0,0 +1,34 @@
+#ifndef __LINUX_TC_CSUM_H
+#define __LINUX_TC_CSUM_H
+
+#include <linux/types.h>
+#include <linux/pkt_cls.h>
+
+#define TCA_ACT_CSUM 16
+
+enum {
+	TCA_CSUM_UNSPEC,
+	TCA_CSUM_PARMS,
+	TCA_CSUM_TM,
+	TCA_CSUM_PAD,
+	__TCA_CSUM_MAX
+};
+#define TCA_CSUM_MAX (__TCA_CSUM_MAX - 1)
+
+enum {
+	TCA_CSUM_UPDATE_FLAG_IPV4HDR = 1,
+	TCA_CSUM_UPDATE_FLAG_ICMP    = 2,
+	TCA_CSUM_UPDATE_FLAG_IGMP    = 4,
+	TCA_CSUM_UPDATE_FLAG_TCP     = 8,
+	TCA_CSUM_UPDATE_FLAG_UDP     = 16,
+	TCA_CSUM_UPDATE_FLAG_UDPLITE = 32,
+	TCA_CSUM_UPDATE_FLAG_SCTP    = 64,
+};
+
+struct tc_csum {
+	tc_gen;
+
+	__u32 update_flags;
+};
+
+#endif /* __LINUX_TC_CSUM_H */
diff --git a/include/uapi/linux/tc_act/tc_defact.h b/include/uapi/linux/tc_act/tc_defact.h
new file mode 100644
index 0000000..d2a3abb
--- /dev/null
+++ b/include/uapi/linux/tc_act/tc_defact.h
@@ -0,0 +1,20 @@
+#ifndef __LINUX_TC_DEF_H
+#define __LINUX_TC_DEF_H
+
+#include <linux/pkt_cls.h>
+
+struct tc_defact {
+	tc_gen;
+};
+
+enum {
+	TCA_DEF_UNSPEC,
+	TCA_DEF_TM,
+	TCA_DEF_PARMS,
+	TCA_DEF_DATA,
+	TCA_DEF_PAD,
+	__TCA_DEF_MAX
+};
+#define TCA_DEF_MAX (__TCA_DEF_MAX - 1)
+
+#endif
diff --git a/include/uapi/linux/tc_act/tc_gact.h b/include/uapi/linux/tc_act/tc_gact.h
new file mode 100644
index 0000000..70b536a
--- /dev/null
+++ b/include/uapi/linux/tc_act/tc_gact.h
@@ -0,0 +1,33 @@
+#ifndef __LINUX_TC_GACT_H
+#define __LINUX_TC_GACT_H
+
+#include <linux/types.h>
+#include <linux/pkt_cls.h>
+
+#define TCA_ACT_GACT 5
+struct tc_gact {
+	tc_gen;
+
+};
+
+struct tc_gact_p {
+#define PGACT_NONE              0
+#define PGACT_NETRAND           1
+#define PGACT_DETERM            2
+#define MAX_RAND                (PGACT_DETERM + 1 )
+	__u16                 ptype;
+	__u16                 pval;
+	int                   paction;
+};
+ 
+enum {
+	TCA_GACT_UNSPEC,
+	TCA_GACT_TM,
+	TCA_GACT_PARMS,
+	TCA_GACT_PROB,
+	TCA_GACT_PAD,
+	__TCA_GACT_MAX
+};
+#define TCA_GACT_MAX (__TCA_GACT_MAX - 1)
+ 
+#endif
diff --git a/include/uapi/linux/tc_act/tc_ife.h b/include/uapi/linux/tc_act/tc_ife.h
new file mode 100644
index 0000000..7c28178
--- /dev/null
+++ b/include/uapi/linux/tc_act/tc_ife.h
@@ -0,0 +1,32 @@
+#ifndef __UAPI_TC_IFE_H
+#define __UAPI_TC_IFE_H
+
+#include <linux/types.h>
+#include <linux/pkt_cls.h>
+#include <linux/ife.h>
+
+#define TCA_ACT_IFE 25
+/* Flag bits for now just encoding/decoding; mutually exclusive */
+#define IFE_ENCODE 1
+#define IFE_DECODE 0
+
+struct tc_ife {
+	tc_gen;
+	__u16 flags;
+};
+
+/*XXX: We need to encode the total number of bytes consumed */
+enum {
+	TCA_IFE_UNSPEC,
+	TCA_IFE_PARMS,
+	TCA_IFE_TM,
+	TCA_IFE_DMAC,
+	TCA_IFE_SMAC,
+	TCA_IFE_TYPE,
+	TCA_IFE_METALST,
+	TCA_IFE_PAD,
+	__TCA_IFE_MAX
+};
+#define TCA_IFE_MAX (__TCA_IFE_MAX - 1)
+
+#endif
diff --git a/include/uapi/linux/tc_act/tc_ipt.h b/include/uapi/linux/tc_act/tc_ipt.h
new file mode 100644
index 0000000..7c6e155
--- /dev/null
+++ b/include/uapi/linux/tc_act/tc_ipt.h
@@ -0,0 +1,22 @@
+#ifndef __LINUX_TC_IPT_H
+#define __LINUX_TC_IPT_H
+
+#include <linux/pkt_cls.h>
+
+#define TCA_ACT_IPT 6
+#define TCA_ACT_XT 10
+
+enum {
+	TCA_IPT_UNSPEC,
+	TCA_IPT_TABLE,
+	TCA_IPT_HOOK,
+	TCA_IPT_INDEX,
+	TCA_IPT_CNT,
+	TCA_IPT_TM,
+	TCA_IPT_TARG,
+	TCA_IPT_PAD,
+	__TCA_IPT_MAX
+};
+#define TCA_IPT_MAX (__TCA_IPT_MAX - 1)
+                                                                                
+#endif
diff --git a/include/uapi/linux/tc_act/tc_mirred.h b/include/uapi/linux/tc_act/tc_mirred.h
new file mode 100644
index 0000000..3d7a2b3
--- /dev/null
+++ b/include/uapi/linux/tc_act/tc_mirred.h
@@ -0,0 +1,28 @@
+#ifndef __LINUX_TC_MIR_H
+#define __LINUX_TC_MIR_H
+
+#include <linux/types.h>
+#include <linux/pkt_cls.h>
+
+#define TCA_ACT_MIRRED 8
+#define TCA_EGRESS_REDIR 1  /* packet redirect to EGRESS*/
+#define TCA_EGRESS_MIRROR 2 /* mirror packet to EGRESS */
+#define TCA_INGRESS_REDIR 3  /* packet redirect to INGRESS*/
+#define TCA_INGRESS_MIRROR 4 /* mirror packet to INGRESS */
+                                                                                
+struct tc_mirred {
+	tc_gen;
+	int                     eaction;   /* one of IN/EGRESS_MIRROR/REDIR */
+	__u32                   ifindex;  /* ifindex of egress port */
+};
+                                                                                
+enum {
+	TCA_MIRRED_UNSPEC,
+	TCA_MIRRED_TM,
+	TCA_MIRRED_PARMS,
+	TCA_MIRRED_PAD,
+	__TCA_MIRRED_MAX
+};
+#define TCA_MIRRED_MAX (__TCA_MIRRED_MAX - 1)
+                                                                                
+#endif
diff --git a/include/uapi/linux/tc_act/tc_nat.h b/include/uapi/linux/tc_act/tc_nat.h
new file mode 100644
index 0000000..923457c
--- /dev/null
+++ b/include/uapi/linux/tc_act/tc_nat.h
@@ -0,0 +1,28 @@
+#ifndef __LINUX_TC_NAT_H
+#define __LINUX_TC_NAT_H
+
+#include <linux/pkt_cls.h>
+#include <linux/types.h>
+
+#define TCA_ACT_NAT 9
+
+enum {
+	TCA_NAT_UNSPEC,
+	TCA_NAT_PARMS,
+	TCA_NAT_TM,
+	TCA_NAT_PAD,
+	__TCA_NAT_MAX
+};
+#define TCA_NAT_MAX (__TCA_NAT_MAX - 1)
+
+#define TCA_NAT_FLAG_EGRESS 1
+
+struct tc_nat {
+	tc_gen;
+	__be32 old_addr;
+	__be32 new_addr;
+	__be32 mask;
+	__u32 flags;
+};
+
+#endif
diff --git a/include/uapi/linux/tc_act/tc_pedit.h b/include/uapi/linux/tc_act/tc_pedit.h
new file mode 100644
index 0000000..143d2b3
--- /dev/null
+++ b/include/uapi/linux/tc_act/tc_pedit.h
@@ -0,0 +1,66 @@
+#ifndef __LINUX_TC_PED_H
+#define __LINUX_TC_PED_H
+
+#include <linux/types.h>
+#include <linux/pkt_cls.h>
+
+#define TCA_ACT_PEDIT 7
+
+enum {
+	TCA_PEDIT_UNSPEC,
+	TCA_PEDIT_TM,
+	TCA_PEDIT_PARMS,
+	TCA_PEDIT_PAD,
+	TCA_PEDIT_PARMS_EX,
+	TCA_PEDIT_KEYS_EX,
+	TCA_PEDIT_KEY_EX,
+	__TCA_PEDIT_MAX
+};
+#define TCA_PEDIT_MAX (__TCA_PEDIT_MAX - 1)
+                                                                                
+enum {
+	TCA_PEDIT_KEY_EX_HTYPE = 1,
+	TCA_PEDIT_KEY_EX_CMD = 2,
+	__TCA_PEDIT_KEY_EX_MAX
+};
+#define TCA_PEDIT_KEY_EX_MAX (__TCA_PEDIT_KEY_EX_MAX - 1)
+
+ /* TCA_PEDIT_KEY_EX_HDR_TYPE_NETWROK is a special case for legacy users. It
+  * means no specific header type - offset is relative to the network layer
+  */
+enum pedit_header_type {
+	TCA_PEDIT_KEY_EX_HDR_TYPE_NETWORK = 0,
+	TCA_PEDIT_KEY_EX_HDR_TYPE_ETH = 1,
+	TCA_PEDIT_KEY_EX_HDR_TYPE_IP4 = 2,
+	TCA_PEDIT_KEY_EX_HDR_TYPE_IP6 = 3,
+	TCA_PEDIT_KEY_EX_HDR_TYPE_TCP = 4,
+	TCA_PEDIT_KEY_EX_HDR_TYPE_UDP = 5,
+	__PEDIT_HDR_TYPE_MAX,
+};
+#define TCA_PEDIT_HDR_TYPE_MAX (__PEDIT_HDR_TYPE_MAX - 1)
+
+enum pedit_cmd {
+	TCA_PEDIT_KEY_EX_CMD_SET = 0,
+	TCA_PEDIT_KEY_EX_CMD_ADD = 1,
+	__PEDIT_CMD_MAX,
+};
+#define TCA_PEDIT_CMD_MAX (__PEDIT_CMD_MAX - 1)
+
+struct tc_pedit_key {
+	__u32           mask;  /* AND */
+	__u32           val;   /*XOR */
+	__u32           off;  /*offset */
+	__u32           at;
+	__u32           offmask;
+	__u32           shift;
+};
+                                                                                
+struct tc_pedit_sel {
+	tc_gen;
+	unsigned char           nkeys;
+	unsigned char           flags;
+	struct tc_pedit_key     keys[0];
+};
+#define tc_pedit tc_pedit_sel
+
+#endif
diff --git a/include/uapi/linux/tc_act/tc_sample.h b/include/uapi/linux/tc_act/tc_sample.h
new file mode 100644
index 0000000..edc9058
--- /dev/null
+++ b/include/uapi/linux/tc_act/tc_sample.h
@@ -0,0 +1,26 @@
+#ifndef __LINUX_TC_SAMPLE_H
+#define __LINUX_TC_SAMPLE_H
+
+#include <linux/types.h>
+#include <linux/pkt_cls.h>
+#include <linux/if_ether.h>
+
+#define TCA_ACT_SAMPLE 26
+
+struct tc_sample {
+	tc_gen;
+};
+
+enum {
+	TCA_SAMPLE_UNSPEC,
+	TCA_SAMPLE_TM,
+	TCA_SAMPLE_PARMS,
+	TCA_SAMPLE_RATE,
+	TCA_SAMPLE_TRUNC_SIZE,
+	TCA_SAMPLE_PSAMPLE_GROUP,
+	TCA_SAMPLE_PAD,
+	__TCA_SAMPLE_MAX
+};
+#define TCA_SAMPLE_MAX (__TCA_SAMPLE_MAX - 1)
+
+#endif
diff --git a/include/uapi/linux/tc_act/tc_skbedit.h b/include/uapi/linux/tc_act/tc_skbedit.h
new file mode 100644
index 0000000..2884425
--- /dev/null
+++ b/include/uapi/linux/tc_act/tc_skbedit.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2008, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * Author: Alexander Duyck <alexander.h.duyck@intel.com>
+ */
+
+#ifndef __LINUX_TC_SKBEDIT_H
+#define __LINUX_TC_SKBEDIT_H
+
+#include <linux/pkt_cls.h>
+
+#define TCA_ACT_SKBEDIT 11
+
+#define SKBEDIT_F_PRIORITY		0x1
+#define SKBEDIT_F_QUEUE_MAPPING		0x2
+#define SKBEDIT_F_MARK			0x4
+#define SKBEDIT_F_PTYPE			0x8
+#define SKBEDIT_F_MASK			0x10
+
+struct tc_skbedit {
+	tc_gen;
+};
+
+enum {
+	TCA_SKBEDIT_UNSPEC,
+	TCA_SKBEDIT_TM,
+	TCA_SKBEDIT_PARMS,
+	TCA_SKBEDIT_PRIORITY,
+	TCA_SKBEDIT_QUEUE_MAPPING,
+	TCA_SKBEDIT_MARK,
+	TCA_SKBEDIT_PAD,
+	TCA_SKBEDIT_PTYPE,
+	TCA_SKBEDIT_MASK,
+	__TCA_SKBEDIT_MAX
+};
+#define TCA_SKBEDIT_MAX (__TCA_SKBEDIT_MAX - 1)
+
+#endif
diff --git a/include/uapi/linux/tc_act/tc_skbmod.h b/include/uapi/linux/tc_act/tc_skbmod.h
new file mode 100644
index 0000000..10fc07d
--- /dev/null
+++ b/include/uapi/linux/tc_act/tc_skbmod.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2016, Jamal Hadi Salim
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+*/
+
+#ifndef __LINUX_TC_SKBMOD_H
+#define __LINUX_TC_SKBMOD_H
+
+#include <linux/pkt_cls.h>
+
+#define TCA_ACT_SKBMOD 15
+
+#define SKBMOD_F_DMAC	0x1
+#define SKBMOD_F_SMAC	0x2
+#define SKBMOD_F_ETYPE	0x4
+#define SKBMOD_F_SWAPMAC 0x8
+
+struct tc_skbmod {
+	tc_gen;
+	__u64 flags;
+};
+
+enum {
+	TCA_SKBMOD_UNSPEC,
+	TCA_SKBMOD_TM,
+	TCA_SKBMOD_PARMS,
+	TCA_SKBMOD_DMAC,
+	TCA_SKBMOD_SMAC,
+	TCA_SKBMOD_ETYPE,
+	TCA_SKBMOD_PAD,
+	__TCA_SKBMOD_MAX
+};
+#define TCA_SKBMOD_MAX (__TCA_SKBMOD_MAX - 1)
+
+#endif
diff --git a/include/uapi/linux/tc_act/tc_tunnel_key.h b/include/uapi/linux/tc_act/tc_tunnel_key.h
new file mode 100644
index 0000000..afcd4be
--- /dev/null
+++ b/include/uapi/linux/tc_act/tc_tunnel_key.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2016, Amir Vadai <amir@vadai.me>
+ * Copyright (c) 2016, Mellanox Technologies. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __LINUX_TC_TUNNEL_KEY_H
+#define __LINUX_TC_TUNNEL_KEY_H
+
+#include <linux/pkt_cls.h>
+
+#define TCA_ACT_TUNNEL_KEY 17
+
+#define TCA_TUNNEL_KEY_ACT_SET	    1
+#define TCA_TUNNEL_KEY_ACT_RELEASE  2
+
+struct tc_tunnel_key {
+	tc_gen;
+	int t_action;
+};
+
+enum {
+	TCA_TUNNEL_KEY_UNSPEC,
+	TCA_TUNNEL_KEY_TM,
+	TCA_TUNNEL_KEY_PARMS,
+	TCA_TUNNEL_KEY_ENC_IPV4_SRC,	/* be32 */
+	TCA_TUNNEL_KEY_ENC_IPV4_DST,	/* be32 */
+	TCA_TUNNEL_KEY_ENC_IPV6_SRC,	/* struct in6_addr */
+	TCA_TUNNEL_KEY_ENC_IPV6_DST,	/* struct in6_addr */
+	TCA_TUNNEL_KEY_ENC_KEY_ID,	/* be64 */
+	TCA_TUNNEL_KEY_PAD,
+	TCA_TUNNEL_KEY_ENC_DST_PORT,	/* be16 */
+	TCA_TUNNEL_KEY_NO_CSUM,		/* u8 */
+	__TCA_TUNNEL_KEY_MAX,
+};
+
+#define TCA_TUNNEL_KEY_MAX (__TCA_TUNNEL_KEY_MAX - 1)
+
+#endif
diff --git a/include/uapi/linux/tc_act/tc_vlan.h b/include/uapi/linux/tc_act/tc_vlan.h
new file mode 100644
index 0000000..bddb272
--- /dev/null
+++ b/include/uapi/linux/tc_act/tc_vlan.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2014 Jiri Pirko <jiri@resnulli.us>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __LINUX_TC_VLAN_H
+#define __LINUX_TC_VLAN_H
+
+#include <linux/pkt_cls.h>
+
+#define TCA_ACT_VLAN 12
+
+#define TCA_VLAN_ACT_POP	1
+#define TCA_VLAN_ACT_PUSH	2
+#define TCA_VLAN_ACT_MODIFY	3
+
+struct tc_vlan {
+	tc_gen;
+	int v_action;
+};
+
+enum {
+	TCA_VLAN_UNSPEC,
+	TCA_VLAN_TM,
+	TCA_VLAN_PARMS,
+	TCA_VLAN_PUSH_VLAN_ID,
+	TCA_VLAN_PUSH_VLAN_PROTOCOL,
+	TCA_VLAN_PAD,
+	TCA_VLAN_PUSH_VLAN_PRIORITY,
+	__TCA_VLAN_MAX,
+};
+#define TCA_VLAN_MAX (__TCA_VLAN_MAX - 1)
+
+#endif
diff --git a/include/uapi/linux/tc_ematch/tc_em_cmp.h b/include/uapi/linux/tc_ematch/tc_em_cmp.h
new file mode 100644
index 0000000..f34bb1b
--- /dev/null
+++ b/include/uapi/linux/tc_ematch/tc_em_cmp.h
@@ -0,0 +1,25 @@
+#ifndef __LINUX_TC_EM_CMP_H
+#define __LINUX_TC_EM_CMP_H
+
+#include <linux/types.h>
+#include <linux/pkt_cls.h>
+
+struct tcf_em_cmp {
+	__u32		val;
+	__u32		mask;
+	__u16		off;
+	__u8		align:4;
+	__u8		flags:4;
+	__u8		layer:4;
+	__u8		opnd:4;
+};
+
+enum {
+	TCF_EM_ALIGN_U8  = 1,
+	TCF_EM_ALIGN_U16 = 2,
+	TCF_EM_ALIGN_U32 = 4
+};
+
+#define TCF_EM_CMP_TRANS	1
+
+#endif
diff --git a/include/uapi/linux/tc_ematch/tc_em_meta.h b/include/uapi/linux/tc_ematch/tc_em_meta.h
new file mode 100644
index 0000000..b11f8ce
--- /dev/null
+++ b/include/uapi/linux/tc_ematch/tc_em_meta.h
@@ -0,0 +1,92 @@
+#ifndef __LINUX_TC_EM_META_H
+#define __LINUX_TC_EM_META_H
+
+#include <linux/types.h>
+#include <linux/pkt_cls.h>
+
+enum {
+	TCA_EM_META_UNSPEC,
+	TCA_EM_META_HDR,
+	TCA_EM_META_LVALUE,
+	TCA_EM_META_RVALUE,
+	__TCA_EM_META_MAX
+};
+#define TCA_EM_META_MAX (__TCA_EM_META_MAX - 1)
+
+struct tcf_meta_val {
+	__u16			kind;
+	__u8			shift;
+	__u8			op;
+};
+
+#define TCF_META_TYPE_MASK	(0xf << 12)
+#define TCF_META_TYPE(kind)	(((kind) & TCF_META_TYPE_MASK) >> 12)
+#define TCF_META_ID_MASK	0x7ff
+#define TCF_META_ID(kind)	((kind) & TCF_META_ID_MASK)
+
+enum {
+	TCF_META_TYPE_VAR,
+	TCF_META_TYPE_INT,
+	__TCF_META_TYPE_MAX
+};
+#define TCF_META_TYPE_MAX (__TCF_META_TYPE_MAX - 1)
+
+enum {
+	TCF_META_ID_VALUE,
+	TCF_META_ID_RANDOM,
+	TCF_META_ID_LOADAVG_0,
+	TCF_META_ID_LOADAVG_1,
+	TCF_META_ID_LOADAVG_2,
+	TCF_META_ID_DEV,
+	TCF_META_ID_PRIORITY,
+	TCF_META_ID_PROTOCOL,
+	TCF_META_ID_PKTTYPE,
+	TCF_META_ID_PKTLEN,
+	TCF_META_ID_DATALEN,
+	TCF_META_ID_MACLEN,
+	TCF_META_ID_NFMARK,
+	TCF_META_ID_TCINDEX,
+	TCF_META_ID_RTCLASSID,
+	TCF_META_ID_RTIIF,
+	TCF_META_ID_SK_FAMILY,
+	TCF_META_ID_SK_STATE,
+	TCF_META_ID_SK_REUSE,
+	TCF_META_ID_SK_BOUND_IF,
+	TCF_META_ID_SK_REFCNT,
+	TCF_META_ID_SK_SHUTDOWN,
+	TCF_META_ID_SK_PROTO,
+	TCF_META_ID_SK_TYPE,
+	TCF_META_ID_SK_RCVBUF,
+	TCF_META_ID_SK_RMEM_ALLOC,
+	TCF_META_ID_SK_WMEM_ALLOC,
+	TCF_META_ID_SK_OMEM_ALLOC,
+	TCF_META_ID_SK_WMEM_QUEUED,
+	TCF_META_ID_SK_RCV_QLEN,
+	TCF_META_ID_SK_SND_QLEN,
+ 	TCF_META_ID_SK_ERR_QLEN,
+	TCF_META_ID_SK_FORWARD_ALLOCS,
+	TCF_META_ID_SK_SNDBUF,
+ 	TCF_META_ID_SK_ALLOCS,
+	__TCF_META_ID_SK_ROUTE_CAPS,	/* unimplemented but in ABI already */
+ 	TCF_META_ID_SK_HASH,
+ 	TCF_META_ID_SK_LINGERTIME,
+ 	TCF_META_ID_SK_ACK_BACKLOG,
+ 	TCF_META_ID_SK_MAX_ACK_BACKLOG,
+ 	TCF_META_ID_SK_PRIO,
+ 	TCF_META_ID_SK_RCVLOWAT,
+ 	TCF_META_ID_SK_RCVTIMEO,
+ 	TCF_META_ID_SK_SNDTIMEO,
+ 	TCF_META_ID_SK_SENDMSG_OFF,
+ 	TCF_META_ID_SK_WRITE_PENDING,
+	TCF_META_ID_VLAN_TAG,
+	TCF_META_ID_RXHASH,
+	__TCF_META_ID_MAX
+};
+#define TCF_META_ID_MAX (__TCF_META_ID_MAX - 1)
+
+struct tcf_meta_hdr {
+	struct tcf_meta_val	left;
+	struct tcf_meta_val	right;
+};
+
+#endif
diff --git a/include/uapi/linux/tc_ematch/tc_em_nbyte.h b/include/uapi/linux/tc_ematch/tc_em_nbyte.h
new file mode 100644
index 0000000..7172cfb
--- /dev/null
+++ b/include/uapi/linux/tc_ematch/tc_em_nbyte.h
@@ -0,0 +1,13 @@
+#ifndef __LINUX_TC_EM_NBYTE_H
+#define __LINUX_TC_EM_NBYTE_H
+
+#include <linux/types.h>
+#include <linux/pkt_cls.h>
+
+struct tcf_em_nbyte {
+	__u16		off;
+	__u16		len:12;
+	__u8		layer:4;
+};
+
+#endif
diff --git a/include/uapi/linux/tcp.h b/include/uapi/linux/tcp.h
new file mode 100644
index 0000000..8edad3f
--- /dev/null
+++ b/include/uapi/linux/tcp.h
@@ -0,0 +1,268 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Definitions for the TCP protocol.
+ *
+ * Version:	@(#)tcp.h	1.0.2	04/28/93
+ *
+ * Author:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_TCP_H
+#define _LINUX_TCP_H
+
+#include <linux/types.h>
+#include <asm/byteorder.h>
+#include <linux/socket.h>
+
+struct tcphdr {
+	__be16	source;
+	__be16	dest;
+	__be32	seq;
+	__be32	ack_seq;
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u16	res1:4,
+		doff:4,
+		fin:1,
+		syn:1,
+		rst:1,
+		psh:1,
+		ack:1,
+		urg:1,
+		ece:1,
+		cwr:1;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	__u16	doff:4,
+		res1:4,
+		cwr:1,
+		ece:1,
+		urg:1,
+		ack:1,
+		psh:1,
+		rst:1,
+		syn:1,
+		fin:1;
+#else
+#error	"Adjust your <asm/byteorder.h> defines"
+#endif	
+	__be16	window;
+	__sum16	check;
+	__be16	urg_ptr;
+};
+
+/*
+ *	The union cast uses a gcc extension to avoid aliasing problems
+ *  (union is compatible to any of its members)
+ *  This means this part of the code is -fstrict-aliasing safe now.
+ */
+union tcp_word_hdr { 
+	struct tcphdr hdr;
+	__be32 		  words[5];
+}; 
+
+#define tcp_flag_word(tp) ( ((union tcp_word_hdr *)(tp))->words [3]) 
+
+enum { 
+	TCP_FLAG_CWR = __constant_cpu_to_be32(0x00800000),
+	TCP_FLAG_ECE = __constant_cpu_to_be32(0x00400000),
+	TCP_FLAG_URG = __constant_cpu_to_be32(0x00200000),
+	TCP_FLAG_ACK = __constant_cpu_to_be32(0x00100000),
+	TCP_FLAG_PSH = __constant_cpu_to_be32(0x00080000),
+	TCP_FLAG_RST = __constant_cpu_to_be32(0x00040000),
+	TCP_FLAG_SYN = __constant_cpu_to_be32(0x00020000),
+	TCP_FLAG_FIN = __constant_cpu_to_be32(0x00010000),
+	TCP_RESERVED_BITS = __constant_cpu_to_be32(0x0F000000),
+	TCP_DATA_OFFSET = __constant_cpu_to_be32(0xF0000000)
+}; 
+
+/*
+ * TCP general constants
+ */
+#define TCP_MSS_DEFAULT		 536U	/* IPv4 (RFC1122, RFC2581) */
+#define TCP_MSS_DESIRED		1220U	/* IPv6 (tunneled), EDNS0 (RFC3226) */
+
+/* TCP socket options */
+#define TCP_NODELAY		1	/* Turn off Nagle's algorithm. */
+#define TCP_MAXSEG		2	/* Limit MSS */
+#define TCP_CORK		3	/* Never send partially complete segments */
+#define TCP_KEEPIDLE		4	/* Start keeplives after this period */
+#define TCP_KEEPINTVL		5	/* Interval between keepalives */
+#define TCP_KEEPCNT		6	/* Number of keepalives before death */
+#define TCP_SYNCNT		7	/* Number of SYN retransmits */
+#define TCP_LINGER2		8	/* Life time of orphaned FIN-WAIT-2 state */
+#define TCP_DEFER_ACCEPT	9	/* Wake up listener only when data arrive */
+#define TCP_WINDOW_CLAMP	10	/* Bound advertised window */
+#define TCP_INFO		11	/* Information about this connection. */
+#define TCP_QUICKACK		12	/* Block/reenable quick acks */
+#define TCP_CONGESTION		13	/* Congestion control algorithm */
+#define TCP_MD5SIG		14	/* TCP MD5 Signature (RFC2385) */
+#define TCP_THIN_LINEAR_TIMEOUTS 16      /* Use linear timeouts for thin streams*/
+#define TCP_THIN_DUPACK         17      /* Fast retrans. after 1 dupack */
+#define TCP_USER_TIMEOUT	18	/* How long for loss retry before timeout */
+#define TCP_REPAIR		19	/* TCP sock is under repair right now */
+#define TCP_REPAIR_QUEUE	20
+#define TCP_QUEUE_SEQ		21
+#define TCP_REPAIR_OPTIONS	22
+#define TCP_FASTOPEN		23	/* Enable FastOpen on listeners */
+#define TCP_TIMESTAMP		24
+#define TCP_NOTSENT_LOWAT	25	/* limit number of unsent bytes in write queue */
+#define TCP_CC_INFO		26	/* Get Congestion Control (optional) info */
+#define TCP_SAVE_SYN		27	/* Record SYN headers for new connections */
+#define TCP_SAVED_SYN		28	/* Get SYN headers recorded for connection */
+#define TCP_REPAIR_WINDOW	29	/* Get/set window parameters */
+#define TCP_FASTOPEN_CONNECT	30	/* Attempt FastOpen with connect */
+#define TCP_ULP			31	/* Attach a ULP to a TCP connection */
+#define TCP_MD5SIG_EXT		32	/* TCP MD5 Signature with extensions */
+
+struct tcp_repair_opt {
+	__u32	opt_code;
+	__u32	opt_val;
+};
+
+struct tcp_repair_window {
+	__u32	snd_wl1;
+	__u32	snd_wnd;
+	__u32	max_window;
+
+	__u32	rcv_wnd;
+	__u32	rcv_wup;
+};
+
+enum {
+	TCP_NO_QUEUE,
+	TCP_RECV_QUEUE,
+	TCP_SEND_QUEUE,
+	TCP_QUEUES_NR,
+};
+
+/* for TCP_INFO socket option */
+#define TCPI_OPT_TIMESTAMPS	1
+#define TCPI_OPT_SACK		2
+#define TCPI_OPT_WSCALE		4
+#define TCPI_OPT_ECN		8 /* ECN was negociated at TCP session init */
+#define TCPI_OPT_ECN_SEEN	16 /* we received at least one packet with ECT */
+#define TCPI_OPT_SYN_DATA	32 /* SYN-ACK acked data in SYN sent or rcvd */
+
+enum tcp_ca_state {
+	TCP_CA_Open = 0,
+#define TCPF_CA_Open	(1<<TCP_CA_Open)
+	TCP_CA_Disorder = 1,
+#define TCPF_CA_Disorder (1<<TCP_CA_Disorder)
+	TCP_CA_CWR = 2,
+#define TCPF_CA_CWR	(1<<TCP_CA_CWR)
+	TCP_CA_Recovery = 3,
+#define TCPF_CA_Recovery (1<<TCP_CA_Recovery)
+	TCP_CA_Loss = 4
+#define TCPF_CA_Loss	(1<<TCP_CA_Loss)
+};
+
+struct tcp_info {
+	__u8	tcpi_state;
+	__u8	tcpi_ca_state;
+	__u8	tcpi_retransmits;
+	__u8	tcpi_probes;
+	__u8	tcpi_backoff;
+	__u8	tcpi_options;
+	__u8	tcpi_snd_wscale : 4, tcpi_rcv_wscale : 4;
+	__u8	tcpi_delivery_rate_app_limited:1;
+
+	__u32	tcpi_rto;
+	__u32	tcpi_ato;
+	__u32	tcpi_snd_mss;
+	__u32	tcpi_rcv_mss;
+
+	__u32	tcpi_unacked;
+	__u32	tcpi_sacked;
+	__u32	tcpi_lost;
+	__u32	tcpi_retrans;
+	__u32	tcpi_fackets;
+
+	/* Times. */
+	__u32	tcpi_last_data_sent;
+	__u32	tcpi_last_ack_sent;     /* Not remembered, sorry. */
+	__u32	tcpi_last_data_recv;
+	__u32	tcpi_last_ack_recv;
+
+	/* Metrics. */
+	__u32	tcpi_pmtu;
+	__u32	tcpi_rcv_ssthresh;
+	__u32	tcpi_rtt;
+	__u32	tcpi_rttvar;
+	__u32	tcpi_snd_ssthresh;
+	__u32	tcpi_snd_cwnd;
+	__u32	tcpi_advmss;
+	__u32	tcpi_reordering;
+
+	__u32	tcpi_rcv_rtt;
+	__u32	tcpi_rcv_space;
+
+	__u32	tcpi_total_retrans;
+
+	__u64	tcpi_pacing_rate;
+	__u64	tcpi_max_pacing_rate;
+	__u64	tcpi_bytes_acked;    /* RFC4898 tcpEStatsAppHCThruOctetsAcked */
+	__u64	tcpi_bytes_received; /* RFC4898 tcpEStatsAppHCThruOctetsReceived */
+	__u32	tcpi_segs_out;	     /* RFC4898 tcpEStatsPerfSegsOut */
+	__u32	tcpi_segs_in;	     /* RFC4898 tcpEStatsPerfSegsIn */
+
+	__u32	tcpi_notsent_bytes;
+	__u32	tcpi_min_rtt;
+	__u32	tcpi_data_segs_in;	/* RFC4898 tcpEStatsDataSegsIn */
+	__u32	tcpi_data_segs_out;	/* RFC4898 tcpEStatsDataSegsOut */
+
+	__u64   tcpi_delivery_rate;
+
+	__u64	tcpi_busy_time;      /* Time (usec) busy sending data */
+	__u64	tcpi_rwnd_limited;   /* Time (usec) limited by receive window */
+	__u64	tcpi_sndbuf_limited; /* Time (usec) limited by send buffer */
+};
+
+/* netlink attributes types for SCM_TIMESTAMPING_OPT_STATS */
+enum {
+	TCP_NLA_PAD,
+	TCP_NLA_BUSY,		/* Time (usec) busy sending data */
+	TCP_NLA_RWND_LIMITED,	/* Time (usec) limited by receive window */
+	TCP_NLA_SNDBUF_LIMITED,	/* Time (usec) limited by send buffer */
+	TCP_NLA_DATA_SEGS_OUT,	/* Data pkts sent including retransmission */
+	TCP_NLA_TOTAL_RETRANS,	/* Data pkts retransmitted */
+	TCP_NLA_PACING_RATE,    /* Pacing rate in bytes per second */
+	TCP_NLA_DELIVERY_RATE,  /* Delivery rate in bytes per second */
+	TCP_NLA_SND_CWND,       /* Sending congestion window */
+	TCP_NLA_REORDERING,     /* Reordering metric */
+	TCP_NLA_MIN_RTT,        /* minimum RTT */
+	TCP_NLA_RECUR_RETRANS,  /* Recurring retransmits for the current pkt */
+	TCP_NLA_DELIVERY_RATE_APP_LMT, /* delivery rate application limited ? */
+
+};
+
+/* for TCP_MD5SIG socket option */
+#define TCP_MD5SIG_MAXKEYLEN	80
+
+/* tcp_md5sig extension flags for TCP_MD5SIG_EXT */
+#define TCP_MD5SIG_FLAG_PREFIX		1	/* address prefix length */
+
+struct tcp_md5sig {
+	struct __kernel_sockaddr_storage tcpm_addr;	/* address associated */
+	__u8	tcpm_flags;				/* extension flags */
+	__u8	tcpm_prefixlen;				/* address prefix */
+	__u16	tcpm_keylen;				/* key length */
+	__u32	__tcpm_pad;				/* zero */
+	__u8	tcpm_key[TCP_MD5SIG_MAXKEYLEN];		/* key (binary) */
+};
+
+/* INET_DIAG_MD5SIG */
+struct tcp_diag_md5sig {
+	__u8	tcpm_family;
+	__u8	tcpm_prefixlen;
+	__u16	tcpm_keylen;
+	__be32	tcpm_addr[4];
+	__u8	tcpm_key[TCP_MD5SIG_MAXKEYLEN];
+};
+
+#endif /* _LINUX_TCP_H */
diff --git a/include/uapi/linux/tcp_metrics.h b/include/uapi/linux/tcp_metrics.h
new file mode 100644
index 0000000..80ad90d
--- /dev/null
+++ b/include/uapi/linux/tcp_metrics.h
@@ -0,0 +1,60 @@
+/* tcp_metrics.h - TCP Metrics Interface */
+
+#ifndef _LINUX_TCP_METRICS_H
+#define _LINUX_TCP_METRICS_H
+
+#include <linux/types.h>
+
+/* NETLINK_GENERIC related info
+ */
+#define TCP_METRICS_GENL_NAME		"tcp_metrics"
+#define TCP_METRICS_GENL_VERSION	0x1
+
+enum tcp_metric_index {
+	TCP_METRIC_RTT,		/* in ms units */
+	TCP_METRIC_RTTVAR,	/* in ms units */
+	TCP_METRIC_SSTHRESH,
+	TCP_METRIC_CWND,
+	TCP_METRIC_REORDERING,
+
+	TCP_METRIC_RTT_US,	/* in usec units */
+	TCP_METRIC_RTTVAR_US,	/* in usec units */
+
+	/* Always last.  */
+	__TCP_METRIC_MAX,
+};
+
+#define TCP_METRIC_MAX	(__TCP_METRIC_MAX - 1)
+
+enum {
+	TCP_METRICS_ATTR_UNSPEC,
+	TCP_METRICS_ATTR_ADDR_IPV4,		/* u32 */
+	TCP_METRICS_ATTR_ADDR_IPV6,		/* binary */
+	TCP_METRICS_ATTR_AGE,			/* msecs */
+	TCP_METRICS_ATTR_TW_TSVAL,		/* u32, raw, rcv tsval */
+	TCP_METRICS_ATTR_TW_TS_STAMP,		/* s32, sec age */
+	TCP_METRICS_ATTR_VALS,			/* nested +1, u32 */
+	TCP_METRICS_ATTR_FOPEN_MSS,		/* u16 */
+	TCP_METRICS_ATTR_FOPEN_SYN_DROPS,	/* u16, count of drops */
+	TCP_METRICS_ATTR_FOPEN_SYN_DROP_TS,	/* msecs age */
+	TCP_METRICS_ATTR_FOPEN_COOKIE,		/* binary */
+	TCP_METRICS_ATTR_SADDR_IPV4,		/* u32 */
+	TCP_METRICS_ATTR_SADDR_IPV6,		/* binary */
+	TCP_METRICS_ATTR_PAD,
+
+	__TCP_METRICS_ATTR_MAX,
+};
+
+#define TCP_METRICS_ATTR_MAX	(__TCP_METRICS_ATTR_MAX - 1)
+
+enum {
+	TCP_METRICS_CMD_UNSPEC,
+	TCP_METRICS_CMD_GET,
+	TCP_METRICS_CMD_DEL,
+
+	__TCP_METRICS_CMD_MAX,
+};
+
+#define TCP_METRICS_CMD_MAX	(__TCP_METRICS_CMD_MAX - 1)
+
+#endif /* _LINUX_TCP_METRICS_H */
diff --git a/include/uapi/linux/tipc.h b/include/uapi/linux/tipc.h
new file mode 100644
index 0000000..924fb5c
--- /dev/null
+++ b/include/uapi/linux/tipc.h
@@ -0,0 +1,256 @@
+/*
+ * include/uapi/linux/tipc.h: Header for TIPC socket interface
+ *
+ * Copyright (c) 2003-2006, 2015-2016 Ericsson AB
+ * Copyright (c) 2005, 2010-2011, Wind River Systems
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the names of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LINUX_TIPC_H_
+#define _LINUX_TIPC_H_
+
+#include <linux/types.h>
+#include <linux/sockios.h>
+
+/*
+ * TIPC addressing primitives
+ */
+
+struct tipc_portid {
+	__u32 ref;
+	__u32 node;
+};
+
+struct tipc_name {
+	__u32 type;
+	__u32 instance;
+};
+
+struct tipc_name_seq {
+	__u32 type;
+	__u32 lower;
+	__u32 upper;
+};
+
+/* TIPC Address Size, Offset, Mask specification for Z.C.N
+ */
+#define TIPC_NODE_BITS          12
+#define TIPC_CLUSTER_BITS       12
+#define TIPC_ZONE_BITS          8
+
+#define TIPC_NODE_OFFSET        0
+#define TIPC_CLUSTER_OFFSET     TIPC_NODE_BITS
+#define TIPC_ZONE_OFFSET        (TIPC_CLUSTER_OFFSET + TIPC_CLUSTER_BITS)
+
+#define TIPC_NODE_SIZE          ((1UL << TIPC_NODE_BITS) - 1)
+#define TIPC_CLUSTER_SIZE       ((1UL << TIPC_CLUSTER_BITS) - 1)
+#define TIPC_ZONE_SIZE          ((1UL << TIPC_ZONE_BITS) - 1)
+
+#define TIPC_NODE_MASK		(TIPC_NODE_SIZE << TIPC_NODE_OFFSET)
+#define TIPC_CLUSTER_MASK	(TIPC_CLUSTER_SIZE << TIPC_CLUSTER_OFFSET)
+#define TIPC_ZONE_MASK		(TIPC_ZONE_SIZE << TIPC_ZONE_OFFSET)
+
+#define TIPC_ZONE_CLUSTER_MASK (TIPC_ZONE_MASK | TIPC_CLUSTER_MASK)
+
+static __inline__ __u32 tipc_addr(unsigned int zone,
+			      unsigned int cluster,
+			      unsigned int node)
+{
+	return (zone << TIPC_ZONE_OFFSET) |
+		(cluster << TIPC_CLUSTER_OFFSET) |
+		node;
+}
+
+static __inline__ unsigned int tipc_zone(__u32 addr)
+{
+	return addr >> TIPC_ZONE_OFFSET;
+}
+
+static __inline__ unsigned int tipc_cluster(__u32 addr)
+{
+	return (addr & TIPC_CLUSTER_MASK) >> TIPC_CLUSTER_OFFSET;
+}
+
+static __inline__ unsigned int tipc_node(__u32 addr)
+{
+	return addr & TIPC_NODE_MASK;
+}
+
+/*
+ * Application-accessible port name types
+ */
+
+#define TIPC_CFG_SRV		0	/* configuration service name type */
+#define TIPC_TOP_SRV		1	/* topology service name type */
+#define TIPC_LINK_STATE		2	/* link state name type */
+#define TIPC_RESERVED_TYPES	64	/* lowest user-publishable name type */
+
+/*
+ * Publication scopes when binding port names and port name sequences
+ */
+
+#define TIPC_ZONE_SCOPE		1
+#define TIPC_CLUSTER_SCOPE	2
+#define TIPC_NODE_SCOPE		3
+
+/*
+ * Limiting values for messages
+ */
+
+#define TIPC_MAX_USER_MSG_SIZE	66000U
+
+/*
+ * Message importance levels
+ */
+
+#define TIPC_LOW_IMPORTANCE		0
+#define TIPC_MEDIUM_IMPORTANCE		1
+#define TIPC_HIGH_IMPORTANCE		2
+#define TIPC_CRITICAL_IMPORTANCE	3
+
+/*
+ * Msg rejection/connection shutdown reasons
+ */
+
+#define TIPC_OK			0
+#define TIPC_ERR_NO_NAME	1
+#define TIPC_ERR_NO_PORT	2
+#define TIPC_ERR_NO_NODE	3
+#define TIPC_ERR_OVERLOAD	4
+#define TIPC_CONN_SHUTDOWN	5
+
+/*
+ * TIPC topology subscription service definitions
+ */
+
+#define TIPC_SUB_PORTS		0x01	/* filter for port availability */
+#define TIPC_SUB_SERVICE	0x02	/* filter for service availability */
+#define TIPC_SUB_CANCEL		0x04	/* cancel a subscription */
+
+#define TIPC_WAIT_FOREVER	(~0)	/* timeout for permanent subscription */
+
+struct tipc_subscr {
+	struct tipc_name_seq seq;	/* name sequence of interest */
+	__u32 timeout;			/* subscription duration (in ms) */
+	__u32 filter;			/* bitmask of filter options */
+	char usr_handle[8];		/* available for subscriber use */
+};
+
+#define TIPC_PUBLISHED		1	/* publication event */
+#define TIPC_WITHDRAWN		2	/* withdraw event */
+#define TIPC_SUBSCR_TIMEOUT	3	/* subscription timeout event */
+
+struct tipc_event {
+	__u32 event;			/* event type */
+	__u32 found_lower;		/* matching name seq instances */
+	__u32 found_upper;		/*    "      "    "     "      */
+	struct tipc_portid port;	/* associated port */
+	struct tipc_subscr s;		/* associated subscription */
+};
+
+/*
+ * Socket API
+ */
+
+#ifndef AF_TIPC
+#define AF_TIPC		30
+#endif
+
+#ifndef PF_TIPC
+#define PF_TIPC		AF_TIPC
+#endif
+
+#ifndef SOL_TIPC
+#define SOL_TIPC	271
+#endif
+
+#define TIPC_ADDR_NAMESEQ	1
+#define TIPC_ADDR_MCAST		1
+#define TIPC_ADDR_NAME		2
+#define TIPC_ADDR_ID		3
+
+struct sockaddr_tipc {
+	unsigned short family;
+	unsigned char  addrtype;
+	signed   char  scope;
+	union {
+		struct tipc_portid id;
+		struct tipc_name_seq nameseq;
+		struct {
+			struct tipc_name name;
+			__u32 domain;
+		} name;
+	} addr;
+};
+
+/*
+ * Ancillary data objects supported by recvmsg()
+ */
+
+#define TIPC_ERRINFO	1	/* error info */
+#define TIPC_RETDATA	2	/* returned data */
+#define TIPC_DESTNAME	3	/* destination name */
+
+/*
+ * TIPC-specific socket option names
+ */
+
+#define TIPC_IMPORTANCE		127	/* Default: TIPC_LOW_IMPORTANCE */
+#define TIPC_SRC_DROPPABLE	128	/* Default: based on socket type */
+#define TIPC_DEST_DROPPABLE	129	/* Default: based on socket type */
+#define TIPC_CONN_TIMEOUT	130	/* Default: 8000 (ms)  */
+#define TIPC_NODE_RECVQ_DEPTH	131	/* Default: none (read only) */
+#define TIPC_SOCK_RECVQ_DEPTH	132	/* Default: none (read only) */
+#define TIPC_MCAST_BROADCAST    133     /* Default: TIPC selects. No arg */
+#define TIPC_MCAST_REPLICAST    134     /* Default: TIPC selects. No arg */
+
+/*
+ * Maximum sizes of TIPC bearer-related names (including terminating NULL)
+ * The string formatting for each name element is:
+ * media: media
+ * interface: media:interface name
+ * link: Z.C.N:interface-Z.C.N:interface
+ *
+ */
+
+#define TIPC_MAX_MEDIA_NAME	16
+#define TIPC_MAX_IF_NAME	16
+#define TIPC_MAX_BEARER_NAME	32
+#define TIPC_MAX_LINK_NAME	60
+
+#define SIOCGETLINKNAME		SIOCPROTOPRIVATE
+
+struct tipc_sioc_ln_req {
+	__u32 peer;
+	__u32 bearer_id;
+	char linkname[TIPC_MAX_LINK_NAME];
+};
+#endif
diff --git a/include/uapi/linux/tipc_netlink.h b/include/uapi/linux/tipc_netlink.h
new file mode 100644
index 0000000..f9edd20
--- /dev/null
+++ b/include/uapi/linux/tipc_netlink.h
@@ -0,0 +1,294 @@
+/*
+ * Copyright (c) 2014, Ericsson AB
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the names of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _LINUX_TIPC_NETLINK_H_
+#define _LINUX_TIPC_NETLINK_H_
+
+#define TIPC_GENL_V2_NAME      "TIPCv2"
+#define TIPC_GENL_V2_VERSION   0x1
+
+/* Netlink commands */
+enum {
+	TIPC_NL_UNSPEC,
+	TIPC_NL_LEGACY,
+	TIPC_NL_BEARER_DISABLE,
+	TIPC_NL_BEARER_ENABLE,
+	TIPC_NL_BEARER_GET,
+	TIPC_NL_BEARER_SET,
+	TIPC_NL_SOCK_GET,
+	TIPC_NL_PUBL_GET,
+	TIPC_NL_LINK_GET,
+	TIPC_NL_LINK_SET,
+	TIPC_NL_LINK_RESET_STATS,
+	TIPC_NL_MEDIA_GET,
+	TIPC_NL_MEDIA_SET,
+	TIPC_NL_NODE_GET,
+	TIPC_NL_NET_GET,
+	TIPC_NL_NET_SET,
+	TIPC_NL_NAME_TABLE_GET,
+	TIPC_NL_MON_SET,
+	TIPC_NL_MON_GET,
+	TIPC_NL_MON_PEER_GET,
+	TIPC_NL_PEER_REMOVE,
+	TIPC_NL_BEARER_ADD,
+	TIPC_NL_UDP_GET_REMOTEIP,
+
+	__TIPC_NL_CMD_MAX,
+	TIPC_NL_CMD_MAX = __TIPC_NL_CMD_MAX - 1
+};
+
+/* Top level netlink attributes */
+enum {
+	TIPC_NLA_UNSPEC,
+	TIPC_NLA_BEARER,		/* nest */
+	TIPC_NLA_SOCK,			/* nest */
+	TIPC_NLA_PUBL,			/* nest */
+	TIPC_NLA_LINK,			/* nest */
+	TIPC_NLA_MEDIA,			/* nest */
+	TIPC_NLA_NODE,			/* nest */
+	TIPC_NLA_NET,			/* nest */
+	TIPC_NLA_NAME_TABLE,		/* nest */
+	TIPC_NLA_MON,			/* nest */
+	TIPC_NLA_MON_PEER,		/* nest */
+
+	__TIPC_NLA_MAX,
+	TIPC_NLA_MAX = __TIPC_NLA_MAX - 1
+};
+
+/* Bearer info */
+enum {
+	TIPC_NLA_BEARER_UNSPEC,
+	TIPC_NLA_BEARER_NAME,		/* string */
+	TIPC_NLA_BEARER_PROP,		/* nest */
+	TIPC_NLA_BEARER_DOMAIN,		/* u32 */
+	TIPC_NLA_BEARER_UDP_OPTS,	/* nest */
+
+	__TIPC_NLA_BEARER_MAX,
+	TIPC_NLA_BEARER_MAX = __TIPC_NLA_BEARER_MAX - 1
+};
+
+enum {
+	TIPC_NLA_UDP_UNSPEC,
+	TIPC_NLA_UDP_LOCAL,		/* sockaddr_storage */
+	TIPC_NLA_UDP_REMOTE,		/* sockaddr_storage */
+	TIPC_NLA_UDP_MULTI_REMOTEIP,	/* flag */
+
+	__TIPC_NLA_UDP_MAX,
+	TIPC_NLA_UDP_MAX = __TIPC_NLA_UDP_MAX - 1
+};
+/* Socket info */
+enum {
+	TIPC_NLA_SOCK_UNSPEC,
+	TIPC_NLA_SOCK_ADDR,		/* u32 */
+	TIPC_NLA_SOCK_REF,		/* u32 */
+	TIPC_NLA_SOCK_CON,		/* nest */
+	TIPC_NLA_SOCK_HAS_PUBL,		/* flag */
+
+	__TIPC_NLA_SOCK_MAX,
+	TIPC_NLA_SOCK_MAX = __TIPC_NLA_SOCK_MAX - 1
+};
+
+/* Link info */
+enum {
+	TIPC_NLA_LINK_UNSPEC,
+	TIPC_NLA_LINK_NAME,		/* string */
+	TIPC_NLA_LINK_DEST,		/* u32 */
+	TIPC_NLA_LINK_MTU,		/* u32 */
+	TIPC_NLA_LINK_BROADCAST,	/* flag */
+	TIPC_NLA_LINK_UP,		/* flag */
+	TIPC_NLA_LINK_ACTIVE,		/* flag */
+	TIPC_NLA_LINK_PROP,		/* nest */
+	TIPC_NLA_LINK_STATS,		/* nest */
+	TIPC_NLA_LINK_RX,		/* u32 */
+	TIPC_NLA_LINK_TX,		/* u32 */
+
+	__TIPC_NLA_LINK_MAX,
+	TIPC_NLA_LINK_MAX = __TIPC_NLA_LINK_MAX - 1
+};
+
+/* Media info */
+enum {
+	TIPC_NLA_MEDIA_UNSPEC,
+	TIPC_NLA_MEDIA_NAME,		/* string */
+	TIPC_NLA_MEDIA_PROP,		/* nest */
+
+	__TIPC_NLA_MEDIA_MAX,
+	TIPC_NLA_MEDIA_MAX = __TIPC_NLA_MEDIA_MAX - 1
+};
+
+/* Node info */
+enum {
+	TIPC_NLA_NODE_UNSPEC,
+	TIPC_NLA_NODE_ADDR,		/* u32 */
+	TIPC_NLA_NODE_UP,		/* flag */
+
+	__TIPC_NLA_NODE_MAX,
+	TIPC_NLA_NODE_MAX = __TIPC_NLA_NODE_MAX - 1
+};
+
+/* Net info */
+enum {
+	TIPC_NLA_NET_UNSPEC,
+	TIPC_NLA_NET_ID,		/* u32 */
+	TIPC_NLA_NET_ADDR,		/* u32 */
+
+	__TIPC_NLA_NET_MAX,
+	TIPC_NLA_NET_MAX = __TIPC_NLA_NET_MAX - 1
+};
+
+/* Name table info */
+enum {
+	TIPC_NLA_NAME_TABLE_UNSPEC,
+	TIPC_NLA_NAME_TABLE_PUBL,	/* nest */
+
+	__TIPC_NLA_NAME_TABLE_MAX,
+	TIPC_NLA_NAME_TABLE_MAX = __TIPC_NLA_NAME_TABLE_MAX - 1
+};
+
+/* Monitor info */
+enum {
+	TIPC_NLA_MON_UNSPEC,
+	TIPC_NLA_MON_ACTIVATION_THRESHOLD,	/* u32 */
+	TIPC_NLA_MON_REF,			/* u32 */
+	TIPC_NLA_MON_ACTIVE,			/* flag */
+	TIPC_NLA_MON_BEARER_NAME,		/* string */
+	TIPC_NLA_MON_PEERCNT,			/* u32 */
+	TIPC_NLA_MON_LISTGEN,			/* u32 */
+
+	__TIPC_NLA_MON_MAX,
+	TIPC_NLA_MON_MAX = __TIPC_NLA_MON_MAX - 1
+};
+
+/* Publication info */
+enum {
+	TIPC_NLA_PUBL_UNSPEC,
+
+	TIPC_NLA_PUBL_TYPE,		/* u32 */
+	TIPC_NLA_PUBL_LOWER,		/* u32 */
+	TIPC_NLA_PUBL_UPPER,		/* u32 */
+	TIPC_NLA_PUBL_SCOPE,		/* u32 */
+	TIPC_NLA_PUBL_NODE,		/* u32 */
+	TIPC_NLA_PUBL_REF,		/* u32 */
+	TIPC_NLA_PUBL_KEY,		/* u32 */
+
+	__TIPC_NLA_PUBL_MAX,
+	TIPC_NLA_PUBL_MAX = __TIPC_NLA_PUBL_MAX - 1
+};
+
+/* Monitor peer info */
+enum {
+	TIPC_NLA_MON_PEER_UNSPEC,
+
+	TIPC_NLA_MON_PEER_ADDR,			/* u32 */
+	TIPC_NLA_MON_PEER_DOMGEN,		/* u32 */
+	TIPC_NLA_MON_PEER_APPLIED,		/* u32 */
+	TIPC_NLA_MON_PEER_UPMAP,		/* u64 */
+	TIPC_NLA_MON_PEER_MEMBERS,		/* tlv */
+	TIPC_NLA_MON_PEER_UP,			/* flag */
+	TIPC_NLA_MON_PEER_HEAD,			/* flag */
+	TIPC_NLA_MON_PEER_LOCAL,		/* flag */
+	TIPC_NLA_MON_PEER_PAD,			/* flag */
+
+	__TIPC_NLA_MON_PEER_MAX,
+	TIPC_NLA_MON_PEER_MAX = __TIPC_NLA_MON_PEER_MAX - 1
+};
+
+/* Nest, connection info */
+enum {
+	TIPC_NLA_CON_UNSPEC,
+
+	TIPC_NLA_CON_FLAG,		/* flag */
+	TIPC_NLA_CON_NODE,		/* u32 */
+	TIPC_NLA_CON_SOCK,		/* u32 */
+	TIPC_NLA_CON_TYPE,		/* u32 */
+	TIPC_NLA_CON_INST,		/* u32 */
+
+	__TIPC_NLA_CON_MAX,
+	TIPC_NLA_CON_MAX = __TIPC_NLA_CON_MAX - 1
+};
+
+/* Nest, link propreties. Valid for link, media and bearer */
+enum {
+	TIPC_NLA_PROP_UNSPEC,
+
+	TIPC_NLA_PROP_PRIO,		/* u32 */
+	TIPC_NLA_PROP_TOL,		/* u32 */
+	TIPC_NLA_PROP_WIN,		/* u32 */
+
+	__TIPC_NLA_PROP_MAX,
+	TIPC_NLA_PROP_MAX = __TIPC_NLA_PROP_MAX - 1
+};
+
+/* Nest, statistics info */
+enum {
+	TIPC_NLA_STATS_UNSPEC,
+
+	TIPC_NLA_STATS_RX_INFO,		/* u32 */
+	TIPC_NLA_STATS_RX_FRAGMENTS,	/* u32 */
+	TIPC_NLA_STATS_RX_FRAGMENTED,	/* u32 */
+	TIPC_NLA_STATS_RX_BUNDLES,	/* u32 */
+	TIPC_NLA_STATS_RX_BUNDLED,	/* u32 */
+	TIPC_NLA_STATS_TX_INFO,		/* u32 */
+	TIPC_NLA_STATS_TX_FRAGMENTS,	/* u32 */
+	TIPC_NLA_STATS_TX_FRAGMENTED,	/* u32 */
+	TIPC_NLA_STATS_TX_BUNDLES,	/* u32 */
+	TIPC_NLA_STATS_TX_BUNDLED,	/* u32 */
+	TIPC_NLA_STATS_MSG_PROF_TOT,	/* u32 */
+	TIPC_NLA_STATS_MSG_LEN_CNT,	/* u32 */
+	TIPC_NLA_STATS_MSG_LEN_TOT,	/* u32 */
+	TIPC_NLA_STATS_MSG_LEN_P0,	/* u32 */
+	TIPC_NLA_STATS_MSG_LEN_P1,	/* u32 */
+	TIPC_NLA_STATS_MSG_LEN_P2,	/* u32 */
+	TIPC_NLA_STATS_MSG_LEN_P3,	/* u32 */
+	TIPC_NLA_STATS_MSG_LEN_P4,	/* u32 */
+	TIPC_NLA_STATS_MSG_LEN_P5,	/* u32 */
+	TIPC_NLA_STATS_MSG_LEN_P6,	/* u32 */
+	TIPC_NLA_STATS_RX_STATES,	/* u32 */
+	TIPC_NLA_STATS_RX_PROBES,	/* u32 */
+	TIPC_NLA_STATS_RX_NACKS,	/* u32 */
+	TIPC_NLA_STATS_RX_DEFERRED,	/* u32 */
+	TIPC_NLA_STATS_TX_STATES,	/* u32 */
+	TIPC_NLA_STATS_TX_PROBES,	/* u32 */
+	TIPC_NLA_STATS_TX_NACKS,	/* u32 */
+	TIPC_NLA_STATS_TX_ACKS,		/* u32 */
+	TIPC_NLA_STATS_RETRANSMITTED,	/* u32 */
+	TIPC_NLA_STATS_DUPLICATES,	/* u32 */
+	TIPC_NLA_STATS_LINK_CONGS,	/* u32 */
+	TIPC_NLA_STATS_MAX_QUEUE,	/* u32 */
+	TIPC_NLA_STATS_AVG_QUEUE,	/* u32 */
+
+	__TIPC_NLA_STATS_MAX,
+	TIPC_NLA_STATS_MAX = __TIPC_NLA_STATS_MAX - 1
+};
+
+#endif
diff --git a/include/uapi/linux/types.h b/include/uapi/linux/types.h
new file mode 100644
index 0000000..c640657
--- /dev/null
+++ b/include/uapi/linux/types.h
@@ -0,0 +1,47 @@
+#ifndef _LINUX_TYPES_H
+#define _LINUX_TYPES_H
+
+#include <asm/types.h>
+
+#ifndef __ASSEMBLY__
+
+#include <linux/posix_types.h>
+
+
+/*
+ * Below are truly Linux-specific types that should never collide with
+ * any application/library that wants linux/types.h.
+ */
+
+#ifdef __CHECKER__
+#define __bitwise__ __attribute__((bitwise))
+#else
+#define __bitwise__
+#endif
+#define __bitwise __bitwise__
+
+typedef __u16 __bitwise __le16;
+typedef __u16 __bitwise __be16;
+typedef __u32 __bitwise __le32;
+typedef __u32 __bitwise __be32;
+typedef __u64 __bitwise __le64;
+typedef __u64 __bitwise __be64;
+
+typedef __u16 __bitwise __sum16;
+typedef __u32 __bitwise __wsum;
+
+/*
+ * aligned_u64 should be used in defining kernel<->userspace ABIs to avoid
+ * common 32/64-bit compat problems.
+ * 64-bit values align to 4-byte boundaries on x86_32 (and possibly other
+ * architectures) and to 8-byte boundaries on 64-bit architectures.  The new
+ * aligned_64 type enforces 8-byte alignment so that structs containing
+ * aligned_64 values have the same alignment on 32-bit and 64-bit architectures.
+ * No conversions are necessary between 32-bit user-space and a 64-bit kernel.
+ */
+#define __aligned_u64 __u64 __attribute__((aligned(8)))
+#define __aligned_be64 __be64 __attribute__((aligned(8)))
+#define __aligned_le64 __le64 __attribute__((aligned(8)))
+
+#endif /*  __ASSEMBLY__ */
+#endif /* _LINUX_TYPES_H */
diff --git a/include/uapi/linux/unix_diag.h b/include/uapi/linux/unix_diag.h
new file mode 100644
index 0000000..1eb0b8d
--- /dev/null
+++ b/include/uapi/linux/unix_diag.h
@@ -0,0 +1,58 @@
+#ifndef __UNIX_DIAG_H__
+#define __UNIX_DIAG_H__
+
+#include <linux/types.h>
+
+struct unix_diag_req {
+	__u8	sdiag_family;
+	__u8	sdiag_protocol;
+	__u16	pad;
+	__u32	udiag_states;
+	__u32	udiag_ino;
+	__u32	udiag_show;
+	__u32	udiag_cookie[2];
+};
+
+#define UDIAG_SHOW_NAME		0x00000001	/* show name (not path) */
+#define UDIAG_SHOW_VFS		0x00000002	/* show VFS inode info */
+#define UDIAG_SHOW_PEER		0x00000004	/* show peer socket info */
+#define UDIAG_SHOW_ICONS	0x00000008	/* show pending connections */
+#define UDIAG_SHOW_RQLEN	0x00000010	/* show skb receive queue len */
+#define UDIAG_SHOW_MEMINFO	0x00000020	/* show memory info of a socket */
+
+struct unix_diag_msg {
+	__u8	udiag_family;
+	__u8	udiag_type;
+	__u8	udiag_state;
+	__u8	pad;
+
+	__u32	udiag_ino;
+	__u32	udiag_cookie[2];
+};
+
+enum {
+	/* UNIX_DIAG_NONE, standard nl API requires this attribute!  */
+	UNIX_DIAG_NAME,
+	UNIX_DIAG_VFS,
+	UNIX_DIAG_PEER,
+	UNIX_DIAG_ICONS,
+	UNIX_DIAG_RQLEN,
+	UNIX_DIAG_MEMINFO,
+	UNIX_DIAG_SHUTDOWN,
+
+	__UNIX_DIAG_MAX,
+};
+
+#define UNIX_DIAG_MAX (__UNIX_DIAG_MAX - 1)
+
+struct unix_diag_vfs {
+	__u32	udiag_vfs_ino;
+	__u32	udiag_vfs_dev;
+};
+
+struct unix_diag_rqlen {
+	__u32	udiag_rqueue;
+	__u32	udiag_wqueue;
+};
+
+#endif
diff --git a/include/uapi/linux/veth.h b/include/uapi/linux/veth.h
new file mode 100644
index 0000000..3354c1e
--- /dev/null
+++ b/include/uapi/linux/veth.h
@@ -0,0 +1,12 @@
+#ifndef __NET_VETH_H_
+#define __NET_VETH_H_
+
+enum {
+	VETH_INFO_UNSPEC,
+	VETH_INFO_PEER,
+
+	__VETH_INFO_MAX
+#define VETH_INFO_MAX	(__VETH_INFO_MAX - 1)
+};
+
+#endif
diff --git a/include/uapi/linux/xfrm.h b/include/uapi/linux/xfrm.h
new file mode 100644
index 0000000..5790293
--- /dev/null
+++ b/include/uapi/linux/xfrm.h
@@ -0,0 +1,536 @@
+#ifndef _LINUX_XFRM_H
+#define _LINUX_XFRM_H
+
+#include <linux/in6.h>
+#include <linux/types.h>
+
+/* All of the structures in this file may not change size as they are
+ * passed into the kernel from userspace via netlink sockets.
+ */
+
+/* Structure to encapsulate addresses. I do not want to use
+ * "standard" structure. My apologies.
+ */
+typedef union {
+	__be32		a4;
+	__be32		a6[4];
+	struct in6_addr	in6;
+} xfrm_address_t;
+
+/* Ident of a specific xfrm_state. It is used on input to lookup
+ * the state by (spi,daddr,ah/esp) or to store information about
+ * spi, protocol and tunnel address on output.
+ */
+struct xfrm_id {
+	xfrm_address_t	daddr;
+	__be32		spi;
+	__u8		proto;
+};
+
+struct xfrm_sec_ctx {
+	__u8	ctx_doi;
+	__u8	ctx_alg;
+	__u16	ctx_len;
+	__u32	ctx_sid;
+	char	ctx_str[0];
+};
+
+/* Security Context Domains of Interpretation */
+#define XFRM_SC_DOI_RESERVED 0
+#define XFRM_SC_DOI_LSM 1
+
+/* Security Context Algorithms */
+#define XFRM_SC_ALG_RESERVED 0
+#define XFRM_SC_ALG_SELINUX 1
+
+/* Selector, used as selector both on policy rules (SPD) and SAs. */
+
+struct xfrm_selector {
+	xfrm_address_t	daddr;
+	xfrm_address_t	saddr;
+	__be16	dport;
+	__be16	dport_mask;
+	__be16	sport;
+	__be16	sport_mask;
+	__u16	family;
+	__u8	prefixlen_d;
+	__u8	prefixlen_s;
+	__u8	proto;
+	int	ifindex;
+	__kernel_uid32_t	user;
+};
+
+#define XFRM_INF (~(__u64)0)
+
+struct xfrm_lifetime_cfg {
+	__u64	soft_byte_limit;
+	__u64	hard_byte_limit;
+	__u64	soft_packet_limit;
+	__u64	hard_packet_limit;
+	__u64	soft_add_expires_seconds;
+	__u64	hard_add_expires_seconds;
+	__u64	soft_use_expires_seconds;
+	__u64	hard_use_expires_seconds;
+};
+
+struct xfrm_lifetime_cur {
+	__u64	bytes;
+	__u64	packets;
+	__u64	add_time;
+	__u64	use_time;
+};
+
+struct xfrm_replay_state {
+	__u32	oseq;
+	__u32	seq;
+	__u32	bitmap;
+};
+
+#define XFRMA_REPLAY_ESN_MAX	4096
+
+struct xfrm_replay_state_esn {
+	unsigned int	bmp_len;
+	__u32		oseq;
+	__u32		seq;
+	__u32		oseq_hi;
+	__u32		seq_hi;
+	__u32		replay_window;
+	__u32		bmp[0];
+};
+
+struct xfrm_algo {
+	char		alg_name[64];
+	unsigned int	alg_key_len;    /* in bits */
+	char		alg_key[0];
+};
+
+struct xfrm_algo_auth {
+	char		alg_name[64];
+	unsigned int	alg_key_len;    /* in bits */
+	unsigned int	alg_trunc_len;  /* in bits */
+	char		alg_key[0];
+};
+
+struct xfrm_algo_aead {
+	char		alg_name[64];
+	unsigned int	alg_key_len;	/* in bits */
+	unsigned int	alg_icv_len;	/* in bits */
+	char		alg_key[0];
+};
+
+struct xfrm_stats {
+	__u32	replay_window;
+	__u32	replay;
+	__u32	integrity_failed;
+};
+
+enum {
+	XFRM_POLICY_TYPE_MAIN	= 0,
+	XFRM_POLICY_TYPE_SUB	= 1,
+	XFRM_POLICY_TYPE_MAX	= 2,
+	XFRM_POLICY_TYPE_ANY	= 255
+};
+
+enum {
+	XFRM_POLICY_IN	= 0,
+	XFRM_POLICY_OUT	= 1,
+	XFRM_POLICY_FWD	= 2,
+	XFRM_POLICY_MASK = 3,
+	XFRM_POLICY_MAX	= 3
+};
+
+enum {
+	XFRM_SHARE_ANY,		/* No limitations */
+	XFRM_SHARE_SESSION,	/* For this session only */
+	XFRM_SHARE_USER,	/* For this user only */
+	XFRM_SHARE_UNIQUE	/* Use once */
+};
+
+#define XFRM_MODE_TRANSPORT 0
+#define XFRM_MODE_TUNNEL 1
+#define XFRM_MODE_ROUTEOPTIMIZATION 2
+#define XFRM_MODE_IN_TRIGGER 3
+#define XFRM_MODE_BEET 4
+#define XFRM_MODE_MAX 5
+
+/* Netlink configuration messages.  */
+enum {
+	XFRM_MSG_BASE = 0x10,
+
+	XFRM_MSG_NEWSA = 0x10,
+#define XFRM_MSG_NEWSA XFRM_MSG_NEWSA
+	XFRM_MSG_DELSA,
+#define XFRM_MSG_DELSA XFRM_MSG_DELSA
+	XFRM_MSG_GETSA,
+#define XFRM_MSG_GETSA XFRM_MSG_GETSA
+
+	XFRM_MSG_NEWPOLICY,
+#define XFRM_MSG_NEWPOLICY XFRM_MSG_NEWPOLICY
+	XFRM_MSG_DELPOLICY,
+#define XFRM_MSG_DELPOLICY XFRM_MSG_DELPOLICY
+	XFRM_MSG_GETPOLICY,
+#define XFRM_MSG_GETPOLICY XFRM_MSG_GETPOLICY
+
+	XFRM_MSG_ALLOCSPI,
+#define XFRM_MSG_ALLOCSPI XFRM_MSG_ALLOCSPI
+	XFRM_MSG_ACQUIRE,
+#define XFRM_MSG_ACQUIRE XFRM_MSG_ACQUIRE
+	XFRM_MSG_EXPIRE,
+#define XFRM_MSG_EXPIRE XFRM_MSG_EXPIRE
+
+	XFRM_MSG_UPDPOLICY,
+#define XFRM_MSG_UPDPOLICY XFRM_MSG_UPDPOLICY
+	XFRM_MSG_UPDSA,
+#define XFRM_MSG_UPDSA XFRM_MSG_UPDSA
+
+	XFRM_MSG_POLEXPIRE,
+#define XFRM_MSG_POLEXPIRE XFRM_MSG_POLEXPIRE
+
+	XFRM_MSG_FLUSHSA,
+#define XFRM_MSG_FLUSHSA XFRM_MSG_FLUSHSA
+	XFRM_MSG_FLUSHPOLICY,
+#define XFRM_MSG_FLUSHPOLICY XFRM_MSG_FLUSHPOLICY
+
+	XFRM_MSG_NEWAE,
+#define XFRM_MSG_NEWAE XFRM_MSG_NEWAE
+	XFRM_MSG_GETAE,
+#define XFRM_MSG_GETAE XFRM_MSG_GETAE
+
+	XFRM_MSG_REPORT,
+#define XFRM_MSG_REPORT XFRM_MSG_REPORT
+
+	XFRM_MSG_MIGRATE,
+#define XFRM_MSG_MIGRATE XFRM_MSG_MIGRATE
+
+	XFRM_MSG_NEWSADINFO,
+#define XFRM_MSG_NEWSADINFO XFRM_MSG_NEWSADINFO
+	XFRM_MSG_GETSADINFO,
+#define XFRM_MSG_GETSADINFO XFRM_MSG_GETSADINFO
+
+	XFRM_MSG_NEWSPDINFO,
+#define XFRM_MSG_NEWSPDINFO XFRM_MSG_NEWSPDINFO
+	XFRM_MSG_GETSPDINFO,
+#define XFRM_MSG_GETSPDINFO XFRM_MSG_GETSPDINFO
+
+	XFRM_MSG_MAPPING,
+#define XFRM_MSG_MAPPING XFRM_MSG_MAPPING
+	__XFRM_MSG_MAX
+};
+#define XFRM_MSG_MAX (__XFRM_MSG_MAX - 1)
+
+#define XFRM_NR_MSGTYPES (XFRM_MSG_MAX + 1 - XFRM_MSG_BASE)
+
+/*
+ * Generic LSM security context for comunicating to user space
+ * NOTE: Same format as sadb_x_sec_ctx
+ */
+struct xfrm_user_sec_ctx {
+	__u16			len;
+	__u16			exttype;
+	__u8			ctx_alg;  /* LSMs: e.g., selinux == 1 */
+	__u8			ctx_doi;
+	__u16			ctx_len;
+};
+
+struct xfrm_user_tmpl {
+	struct xfrm_id		id;
+	__u16			family;
+	xfrm_address_t		saddr;
+	__u32			reqid;
+	__u8			mode;
+	__u8			share;
+	__u8			optional;
+	__u32			aalgos;
+	__u32			ealgos;
+	__u32			calgos;
+};
+
+struct xfrm_encap_tmpl {
+	__u16		encap_type;
+	__be16		encap_sport;
+	__be16		encap_dport;
+	xfrm_address_t	encap_oa;
+};
+
+/* AEVENT flags  */
+enum xfrm_ae_ftype_t {
+	XFRM_AE_UNSPEC,
+	XFRM_AE_RTHR=1,	/* replay threshold*/
+	XFRM_AE_RVAL=2, /* replay value */
+	XFRM_AE_LVAL=4, /* lifetime value */
+	XFRM_AE_ETHR=8, /* expiry timer threshold */
+	XFRM_AE_CR=16, /* Event cause is replay update */
+	XFRM_AE_CE=32, /* Event cause is timer expiry */
+	XFRM_AE_CU=64, /* Event cause is policy update */
+	__XFRM_AE_MAX
+
+#define XFRM_AE_MAX (__XFRM_AE_MAX - 1)
+};
+
+struct xfrm_userpolicy_type {
+	__u8		type;
+	__u16		reserved1;
+	__u8		reserved2;
+};
+
+/* Netlink message attributes.  */
+enum xfrm_attr_type_t {
+	XFRMA_UNSPEC,
+	XFRMA_ALG_AUTH,		/* struct xfrm_algo */
+	XFRMA_ALG_CRYPT,	/* struct xfrm_algo */
+	XFRMA_ALG_COMP,		/* struct xfrm_algo */
+	XFRMA_ENCAP,		/* struct xfrm_algo + struct xfrm_encap_tmpl */
+	XFRMA_TMPL,		/* 1 or more struct xfrm_user_tmpl */
+	XFRMA_SA,		/* struct xfrm_usersa_info  */
+	XFRMA_POLICY,		/*struct xfrm_userpolicy_info */
+	XFRMA_SEC_CTX,		/* struct xfrm_sec_ctx */
+	XFRMA_LTIME_VAL,
+	XFRMA_REPLAY_VAL,
+	XFRMA_REPLAY_THRESH,
+	XFRMA_ETIMER_THRESH,
+	XFRMA_SRCADDR,		/* xfrm_address_t */
+	XFRMA_COADDR,		/* xfrm_address_t */
+	XFRMA_LASTUSED,		/* unsigned long  */
+	XFRMA_POLICY_TYPE,	/* struct xfrm_userpolicy_type */
+	XFRMA_MIGRATE,
+	XFRMA_ALG_AEAD,		/* struct xfrm_algo_aead */
+	XFRMA_KMADDRESS,        /* struct xfrm_user_kmaddress */
+	XFRMA_ALG_AUTH_TRUNC,	/* struct xfrm_algo_auth */
+	XFRMA_MARK,		/* struct xfrm_mark */
+	XFRMA_TFCPAD,		/* __u32 */
+	XFRMA_REPLAY_ESN_VAL,	/* struct xfrm_replay_state_esn */
+	XFRMA_SA_EXTRA_FLAGS,	/* __u32 */
+	XFRMA_PROTO,		/* __u8 */
+	XFRMA_ADDRESS_FILTER,	/* struct xfrm_address_filter */
+	XFRMA_PAD,
+	XFRMA_OFFLOAD_DEV,	/* struct xfrm_state_offload */
+	XFRMA_OUTPUT_MARK,	/* __u32 */
+	__XFRMA_MAX
+
+#define XFRMA_MAX (__XFRMA_MAX - 1)
+};
+
+struct xfrm_mark {
+	__u32           v; /* value */
+	__u32           m; /* mask */
+};
+
+enum xfrm_sadattr_type_t {
+	XFRMA_SAD_UNSPEC,
+	XFRMA_SAD_CNT,
+	XFRMA_SAD_HINFO,
+	__XFRMA_SAD_MAX
+
+#define XFRMA_SAD_MAX (__XFRMA_SAD_MAX - 1)
+};
+
+struct xfrmu_sadhinfo {
+	__u32 sadhcnt; /* current hash bkts */
+	__u32 sadhmcnt; /* max allowed hash bkts */
+};
+
+enum xfrm_spdattr_type_t {
+	XFRMA_SPD_UNSPEC,
+	XFRMA_SPD_INFO,
+	XFRMA_SPD_HINFO,
+	XFRMA_SPD_IPV4_HTHRESH,
+	XFRMA_SPD_IPV6_HTHRESH,
+	__XFRMA_SPD_MAX
+
+#define XFRMA_SPD_MAX (__XFRMA_SPD_MAX - 1)
+};
+
+struct xfrmu_spdinfo {
+	__u32 incnt;
+	__u32 outcnt;
+	__u32 fwdcnt;
+	__u32 inscnt;
+	__u32 outscnt;
+	__u32 fwdscnt;
+};
+
+struct xfrmu_spdhinfo {
+	__u32 spdhcnt;
+	__u32 spdhmcnt;
+};
+
+struct xfrmu_spdhthresh {
+	__u8 lbits;
+	__u8 rbits;
+};
+
+struct xfrm_usersa_info {
+	struct xfrm_selector		sel;
+	struct xfrm_id			id;
+	xfrm_address_t			saddr;
+	struct xfrm_lifetime_cfg	lft;
+	struct xfrm_lifetime_cur	curlft;
+	struct xfrm_stats		stats;
+	__u32				seq;
+	__u32				reqid;
+	__u16				family;
+	__u8				mode;		/* XFRM_MODE_xxx */
+	__u8				replay_window;
+	__u8				flags;
+#define XFRM_STATE_NOECN	1
+#define XFRM_STATE_DECAP_DSCP	2
+#define XFRM_STATE_NOPMTUDISC	4
+#define XFRM_STATE_WILDRECV	8
+#define XFRM_STATE_ICMP		16
+#define XFRM_STATE_AF_UNSPEC	32
+#define XFRM_STATE_ALIGN4	64
+#define XFRM_STATE_ESN		128
+};
+
+#define XFRM_SA_XFLAG_DONT_ENCAP_DSCP	1
+
+struct xfrm_usersa_id {
+	xfrm_address_t			daddr;
+	__be32				spi;
+	__u16				family;
+	__u8				proto;
+};
+
+struct xfrm_aevent_id {
+	struct xfrm_usersa_id		sa_id;
+	xfrm_address_t			saddr;
+	__u32				flags;
+	__u32				reqid;
+};
+
+struct xfrm_userspi_info {
+	struct xfrm_usersa_info		info;
+	__u32				min;
+	__u32				max;
+};
+
+struct xfrm_userpolicy_info {
+	struct xfrm_selector		sel;
+	struct xfrm_lifetime_cfg	lft;
+	struct xfrm_lifetime_cur	curlft;
+	__u32				priority;
+	__u32				index;
+	__u8				dir;
+	__u8				action;
+#define XFRM_POLICY_ALLOW	0
+#define XFRM_POLICY_BLOCK	1
+	__u8				flags;
+#define XFRM_POLICY_LOCALOK	1	/* Allow user to override global policy */
+	/* Automatically expand selector to include matching ICMP payloads. */
+#define XFRM_POLICY_ICMP	2
+	__u8				share;
+};
+
+struct xfrm_userpolicy_id {
+	struct xfrm_selector		sel;
+	__u32				index;
+	__u8				dir;
+};
+
+struct xfrm_user_acquire {
+	struct xfrm_id			id;
+	xfrm_address_t			saddr;
+	struct xfrm_selector		sel;
+	struct xfrm_userpolicy_info	policy;
+	__u32				aalgos;
+	__u32				ealgos;
+	__u32				calgos;
+	__u32				seq;
+};
+
+struct xfrm_user_expire {
+	struct xfrm_usersa_info		state;
+	__u8				hard;
+};
+
+struct xfrm_user_polexpire {
+	struct xfrm_userpolicy_info	pol;
+	__u8				hard;
+};
+
+struct xfrm_usersa_flush {
+	__u8				proto;
+};
+
+struct xfrm_user_report {
+	__u8				proto;
+	struct xfrm_selector		sel;
+};
+
+/* Used by MIGRATE to pass addresses IKE should use to perform
+ * SA negotiation with the peer */
+struct xfrm_user_kmaddress {
+	xfrm_address_t                  local;
+	xfrm_address_t                  remote;
+	__u32				reserved;
+	__u16				family;
+};
+
+struct xfrm_user_migrate {
+	xfrm_address_t			old_daddr;
+	xfrm_address_t			old_saddr;
+	xfrm_address_t			new_daddr;
+	xfrm_address_t			new_saddr;
+	__u8				proto;
+	__u8				mode;
+	__u16				reserved;
+	__u32				reqid;
+	__u16				old_family;
+	__u16				new_family;
+};
+
+struct xfrm_user_mapping {
+	struct xfrm_usersa_id		id;
+	__u32				reqid;
+	xfrm_address_t			old_saddr;
+	xfrm_address_t			new_saddr;
+	__be16				old_sport;
+	__be16				new_sport;
+};
+
+struct xfrm_address_filter {
+	xfrm_address_t			saddr;
+	xfrm_address_t			daddr;
+	__u16				family;
+	__u8				splen;
+	__u8				dplen;
+};
+
+struct xfrm_user_offload {
+	int				ifindex;
+	__u8				flags;
+};
+#define XFRM_OFFLOAD_IPV6	1
+#define XFRM_OFFLOAD_INBOUND	2
+
+/* backwards compatibility for userspace */
+#define XFRMGRP_ACQUIRE		1
+#define XFRMGRP_EXPIRE		2
+#define XFRMGRP_SA		4
+#define XFRMGRP_POLICY		8
+#define XFRMGRP_REPORT		0x20
+
+enum xfrm_nlgroups {
+	XFRMNLGRP_NONE,
+#define XFRMNLGRP_NONE		XFRMNLGRP_NONE
+	XFRMNLGRP_ACQUIRE,
+#define XFRMNLGRP_ACQUIRE	XFRMNLGRP_ACQUIRE
+	XFRMNLGRP_EXPIRE,
+#define XFRMNLGRP_EXPIRE	XFRMNLGRP_EXPIRE
+	XFRMNLGRP_SA,
+#define XFRMNLGRP_SA		XFRMNLGRP_SA
+	XFRMNLGRP_POLICY,
+#define XFRMNLGRP_POLICY	XFRMNLGRP_POLICY
+	XFRMNLGRP_AEVENTS,
+#define XFRMNLGRP_AEVENTS	XFRMNLGRP_AEVENTS
+	XFRMNLGRP_REPORT,
+#define XFRMNLGRP_REPORT	XFRMNLGRP_REPORT
+	XFRMNLGRP_MIGRATE,
+#define XFRMNLGRP_MIGRATE	XFRMNLGRP_MIGRATE
+	XFRMNLGRP_MAPPING,
+#define XFRMNLGRP_MAPPING	XFRMNLGRP_MAPPING
+	__XFRMNLGRP_MAX
+};
+#define XFRMNLGRP_MAX	(__XFRMNLGRP_MAX - 1)
+
+#endif /* _LINUX_XFRM_H */
-- 
1.8.3.1

