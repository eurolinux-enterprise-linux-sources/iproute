From 3072b81b5f71121d587679f5644ccab0ed71da09 Mon Sep 17 00:00:00 2001
From: Phil Sutter <psutter@redhat.com>
Date: Tue, 28 Feb 2017 16:11:51 +0100
Subject: [PATCH] iplink: Add support for IFLA_BR_VLAN_PROTOCOL attribute

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1417289
Upstream Status: iproute2.git commit 1eea5c46ec59d

commit 1eea5c46ec59d732d47df7f2be1e84fa534f9ce5
Author: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
Date:   Mon Aug 31 18:48:46 2015 +0900

    iplink: Add support for IFLA_BR_VLAN_PROTOCOL attribute

    This patch adds support for bridge vlan_protocol.

    Example:
    $ ip link set br0 type bridge vlan_protocol 802.1ad
    $ ip -d link show br0
    4: br0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state
    UP mode DEFAULT group default qlen 1000
        link/ether 44:37:e6:ab:cd:ef brd ff:ff:ff:ff:ff:ff promiscuity 0
        bridge forward_delay 0 hello_time 200 max_age 2000 ageing_time 30000
    stp_state 0 priority 32768 vlan_filtering 0 vlan_protocol 802.1ad
    addrgenmode eui64

    Signed-off-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
---
 ip/iplink_bridge.c | 21 +++++++++++++++++++++
 1 file changed, 21 insertions(+)

diff --git a/ip/iplink_bridge.c b/ip/iplink_bridge.c
index a8bc840..1c71f2e 100644
--- a/ip/iplink_bridge.c
+++ b/ip/iplink_bridge.c
@@ -14,6 +14,7 @@
 #include <string.h>
 #include <linux/if_link.h>
 
+#include "rt_names.h"
 #include "utils.h"
 #include "ip_common.h"
 
@@ -27,6 +28,9 @@ static void print_explain(FILE *f)
 		"                  [ stp_state STP_STATE ]\n"
 		"                  [ priority PRIORITY ]\n"
 		"                  [ vlan_filtering VLAN_FILTERING ]\n"
+		"                  [ vlan_protocol VLAN_PROTOCOL ]\n"
+		"\n"
+		"Where: VLAN_PROTOCOL := { 802.1Q | 802.1ad }\n"
 	);
 }
 
@@ -94,6 +98,15 @@ static int bridge_parse_opt(struct link_util *lu, int argc, char **argv,
 				return -1;
 			}
 			addattr8(n, 1024, IFLA_BR_VLAN_FILTERING, vlan_filter);
+		} else if (matches(*argv, "vlan_protocol") == 0) {
+			__u16 vlan_proto;
+
+			NEXT_ARG();
+			if (ll_proto_a2n(&vlan_proto, *argv)) {
+				invarg("invalid vlan_protocol", *argv);
+				return -1;
+			}
+			addattr16(n, 1024, IFLA_BR_VLAN_PROTOCOL, vlan_proto);
 		} else if (matches(*argv, "help") == 0) {
 			explain();
 			return -1;
@@ -140,6 +153,14 @@ static void bridge_print_opt(struct link_util *lu, FILE *f, struct rtattr *tb[])
 	if (tb[IFLA_BR_VLAN_FILTERING])
 		fprintf(f, "vlan_filtering %u ",
 			rta_getattr_u8(tb[IFLA_BR_VLAN_FILTERING]));
+
+	if (tb[IFLA_BR_VLAN_PROTOCOL]) {
+		SPRINT_BUF(b1);
+
+		fprintf(f, "vlan_protocol %s ",
+			ll_proto_n2a(rta_getattr_u16(tb[IFLA_BR_VLAN_PROTOCOL]),
+				     b1, sizeof(b1)));
+	}
 }
 
 static void bridge_print_help(struct link_util *lu, int argc, char **argv,
-- 
1.8.3.1

