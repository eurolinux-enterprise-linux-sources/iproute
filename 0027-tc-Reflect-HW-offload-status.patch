From 724d67b36f9e6bbbfac88b29fee019c05284a888 Mon Sep 17 00:00:00 2001
From: Kamal Heib <kheib@redhat.com>
Date: Thu, 9 Nov 2017 04:44:32 -0500
Subject: [PATCH] tc: Reflect HW offload status

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1456539

commit e57285b81a098ed705d683ce94f9abd1cc53438a
Author: Or Gerlitz <ogerlitz@mellanox.com>
Date:   Thu May 4 16:15:15 2017 +0300

    tc: Reflect HW offload status

    Currently there is no way of querying whether a filter is
    offloaded to HW or not when using "both" policy (where none
    of skip_sw or skip_hw flags are set by user-space).

    Add two new flags, "in hw" and "not in hw" such that user
    space can determine if a filter is actually offloaded to
    hw or not. The "in hw" UAPI semantics was chosen so it's
    similar to the "skip hw" flag logic.

    If none of these two flags are set, this signals running
    over older kernel.

    Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
    Reviewed-by: Jiri Pirko <jiri@mellanox.com>
    Reviewed-by: Simon Horman <simon.horman@netronome.com>

Signed-off-by: Kamal Heib <kheib@redhat.com>
---
 tc/f_bpf.c      | 5 +++++
 tc/f_flower.c   | 5 +++++
 tc/f_matchall.c | 5 +++++
 tc/f_u32.c      | 5 +++++
 4 files changed, 20 insertions(+)

diff --git a/tc/f_bpf.c b/tc/f_bpf.c
index df8a259..75c44c0 100644
--- a/tc/f_bpf.c
+++ b/tc/f_bpf.c
@@ -210,6 +210,11 @@ static int bpf_print_opt(struct filter_util *qu, FILE *f,
 			fprintf(f, "skip_hw ");
 		if (flags & TCA_CLS_FLAGS_SKIP_SW)
 			fprintf(f, "skip_sw ");
+
+		if (flags & TCA_CLS_FLAGS_IN_HW)
+			fprintf(f, "in_hw ");
+		else if (flags & TCA_CLS_FLAGS_NOT_IN_HW)
+			fprintf(f, "not_in_hw ");
 	}
 
 	if (tb[TCA_BPF_OPS] && tb[TCA_BPF_OPS_LEN])
diff --git a/tc/f_flower.c b/tc/f_flower.c
index 5aac4a0..ebc63ca 100644
--- a/tc/f_flower.c
+++ b/tc/f_flower.c
@@ -1171,6 +1171,11 @@ static int flower_print_opt(struct filter_util *qu, FILE *f,
 			fprintf(f, "\n  skip_hw");
 		if (flags & TCA_CLS_FLAGS_SKIP_SW)
 			fprintf(f, "\n  skip_sw");
+
+		if (flags & TCA_CLS_FLAGS_IN_HW)
+			fprintf(f, "\n  in_hw");
+		else if (flags & TCA_CLS_FLAGS_NOT_IN_HW)
+			fprintf(f, "\n  not_in_hw");
 	}
 
 	if (tb[TCA_FLOWER_ACT])
diff --git a/tc/f_matchall.c b/tc/f_matchall.c
index ac48630..5a51e75 100644
--- a/tc/f_matchall.c
+++ b/tc/f_matchall.c
@@ -137,6 +137,11 @@ static int matchall_print_opt(struct filter_util *qu, FILE *f,
 			fprintf(f, "\n  skip_hw");
 		if (flags & TCA_CLS_FLAGS_SKIP_SW)
 			fprintf(f, "\n  skip_sw");
+
+		if (flags & TCA_CLS_FLAGS_IN_HW)
+			fprintf(f, "\n  in_hw");
+		else if (flags & TCA_CLS_FLAGS_NOT_IN_HW)
+			fprintf(f, "\n  not_in_hw");
 	}
 
 	if (tb[TCA_MATCHALL_ACT])
diff --git a/tc/f_u32.c b/tc/f_u32.c
index 92c1fcd..ff700e9 100644
--- a/tc/f_u32.c
+++ b/tc/f_u32.c
@@ -1264,6 +1264,11 @@ static int u32_print_opt(struct filter_util *qu, FILE *f, struct rtattr *opt,
 			fprintf(f, "skip_hw ");
 		if (flags & TCA_CLS_FLAGS_SKIP_SW)
 			fprintf(f, "skip_sw ");
+
+		if (flags & TCA_CLS_FLAGS_IN_HW)
+			fprintf(f, "in_hw ");
+		else if (flags & TCA_CLS_FLAGS_NOT_IN_HW)
+			fprintf(f, "not_in_hw ");
 	}
 
 	if (tb[TCA_U32_PCNT]) {
-- 
1.8.3.1

