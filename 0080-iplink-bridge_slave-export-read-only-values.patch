From 6eda4d7ea7eda19e7a67b0ae0892993fff9bd573 Mon Sep 17 00:00:00 2001
From: Phil Sutter <psutter@redhat.com>
Date: Tue, 28 Feb 2017 16:12:02 +0100
Subject: [PATCH] iplink: bridge_slave: export read-only values

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1417289
Upstream Status: iproute2.git commit 3069539fb8efd
Conflicts: Changed context due to other backports in that area.

commit 3069539fb8efd8353d46a6be1a501f77871888ca
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Tue Feb 16 16:08:51 2016 +0100

    iplink: bridge_slave: export read-only values

    Export all the read-only values that get returned about a bridge port
    such as the timers, the ids, designated_port and cost,
    topology_change_ack and config_pending. For the bridge ids the
    br_dump_bridge_id function is exported from iplink_bridge.

    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
---
 ip/ip_common.h           |  2 ++
 ip/iplink_bridge.c       |  3 +--
 ip/iplink_bridge_slave.c | 69 ++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 72 insertions(+), 2 deletions(-)

diff --git a/ip/ip_common.h b/ip/ip_common.h
index 286f61f..abab49d 100644
--- a/ip/ip_common.h
+++ b/ip/ip_common.h
@@ -89,6 +89,8 @@ struct link_util
 struct link_util *get_link_kind(const char *kind);
 struct link_util *get_link_slave_kind(const char *slave_kind);
 
+void br_dump_bridge_id(const struct ifla_bridge_id *id, char *buf, size_t len);
+
 #ifndef	INFINITY_LIFE_TIME
 #define     INFINITY_LIFE_TIME      0xFFFFFFFFU
 #endif
diff --git a/ip/iplink_bridge.c b/ip/iplink_bridge.c
index 2c8f351..7cec078 100644
--- a/ip/iplink_bridge.c
+++ b/ip/iplink_bridge.c
@@ -57,8 +57,7 @@ static void explain(void)
 	print_explain(stderr);
 }
 
-static void br_dump_bridge_id(const struct ifla_bridge_id *id, char *buf,
-			      size_t len)
+void br_dump_bridge_id(const struct ifla_bridge_id *id, char *buf, size_t len)
 {
 	char eaddr[32];
 
diff --git a/ip/iplink_bridge_slave.c b/ip/iplink_bridge_slave.c
index 3538176..3ec2bba 100644
--- a/ip/iplink_bridge_slave.c
+++ b/ip/iplink_bridge_slave.c
@@ -103,6 +103,75 @@ static void bridge_slave_print_opt(struct link_util *lu, FILE *f,
 		print_onoff(f, "flood",
 			rta_getattr_u8(tb[IFLA_BRPORT_UNICAST_FLOOD]));
 
+	if (tb[IFLA_BRPORT_ID])
+		fprintf(f, "port_id 0x%x ",
+			rta_getattr_u16(tb[IFLA_BRPORT_ID]));
+
+	if (tb[IFLA_BRPORT_NO])
+		fprintf(f, "port_no 0x%x ",
+			rta_getattr_u16(tb[IFLA_BRPORT_NO]));
+
+	if (tb[IFLA_BRPORT_DESIGNATED_PORT])
+		fprintf(f, "designated_port %u ",
+			rta_getattr_u16(tb[IFLA_BRPORT_DESIGNATED_PORT]));
+
+	if (tb[IFLA_BRPORT_DESIGNATED_COST])
+		fprintf(f, "designated_cost %u ",
+			rta_getattr_u16(tb[IFLA_BRPORT_DESIGNATED_COST]));
+
+	if (tb[IFLA_BRPORT_BRIDGE_ID]) {
+		char bridge_id[32];
+
+		br_dump_bridge_id(RTA_DATA(tb[IFLA_BRPORT_BRIDGE_ID]),
+				  bridge_id, sizeof(bridge_id));
+		fprintf(f, "designated_bridge %s ", bridge_id);
+	}
+
+	if (tb[IFLA_BRPORT_ROOT_ID]) {
+		char root_id[32];
+
+		br_dump_bridge_id(RTA_DATA(tb[IFLA_BRPORT_ROOT_ID]),
+				  root_id, sizeof(root_id));
+		fprintf(f, "designated_root %s ", root_id);
+	}
+
+	if (tb[IFLA_BRPORT_HOLD_TIMER]) {
+		struct timeval tv;
+		__u64 htimer;
+
+		htimer = rta_getattr_u64(tb[IFLA_BRPORT_HOLD_TIMER]);
+		__jiffies_to_tv(&tv, htimer);
+		fprintf(f, "hold_timer %4i.%.2i ", (int)tv.tv_sec,
+			(int)tv.tv_usec/10000);
+	}
+
+	if (tb[IFLA_BRPORT_MESSAGE_AGE_TIMER]) {
+		struct timeval tv;
+		__u64 agetimer;
+
+		agetimer = rta_getattr_u64(tb[IFLA_BRPORT_MESSAGE_AGE_TIMER]);
+		__jiffies_to_tv(&tv, agetimer);
+		fprintf(f, "message_age_timer %4i.%.2i ", (int)tv.tv_sec,
+			(int)tv.tv_usec/10000);
+	}
+
+	if (tb[IFLA_BRPORT_FORWARD_DELAY_TIMER]) {
+		struct timeval tv;
+		__u64 fwdtimer;
+
+		fwdtimer = rta_getattr_u64(tb[IFLA_BRPORT_FORWARD_DELAY_TIMER]);
+		__jiffies_to_tv(&tv, fwdtimer);
+		fprintf(f, "forward_delay_timer %4i.%.2i ", (int)tv.tv_sec,
+			(int)tv.tv_usec/10000);
+	}
+
+	if (tb[IFLA_BRPORT_TOPOLOGY_CHANGE_ACK])
+		fprintf(f, "topology_change_ack %u ",
+			rta_getattr_u8(tb[IFLA_BRPORT_TOPOLOGY_CHANGE_ACK]));
+
+	if (tb[IFLA_BRPORT_CONFIG_PENDING])
+		fprintf(f, "config_pending %u ",
+			rta_getattr_u8(tb[IFLA_BRPORT_CONFIG_PENDING]));
 	if (tb[IFLA_BRPORT_PROXYARP])
 		print_onoff(f, "proxy_arp",
 			    rta_getattr_u8(tb[IFLA_BRPORT_PROXYARP]));
-- 
1.8.3.1

