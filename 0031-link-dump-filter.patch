From a8851ce90a891abe9c45dd9d79e8d673b7258646 Mon Sep 17 00:00:00 2001
From: Phil Sutter <psutter@redhat.com>
Date: Tue, 28 Feb 2017 16:09:08 +0100
Subject: [PATCH] link dump filter

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1417289
Upstream Status: iproute2.git commit 50b9950dd9011
Conflicts: Manually applied changes to added code from previously
	   backported commit c079e121a73af ("libnetlink: add size
	   argument to rtnl_talk").

commit 50b9950dd90114609e10298c0fa32a9371250687
Author: Roopa Prabhu <roopa@cumulusnetworks.com>
Date:   Wed Jul 16 07:13:25 2014 -0700

    link dump filter

    This patch avoids a full link wildump request when the user has specified
    a single link. Uses RTM_GETLINK without the NLM_F_DUMP flag.

    This helps on a system with large number of interfaces.

    This patch currently only uses the link ifindex in the filter.
    Hoping to provide a subsequent kernel patch to do link dump filtering on
    other attributes in the kernel.

    In iplink_get, to be safe, this patch currently sets the answer buffer
    size to the max size that libnetlink rtnl_talk can copy. The current api
    does not seem to provide a way to indicate the answer buf size.

    changelog from RFC to v1:
        - incorporated comments from stephen (fixed comment and fixed if/else block)

    changelog from v1 to v2:
        - fix whitespaces error

    Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
---
 ip/ip_common.h |  1 +
 ip/ipaddress.c | 13 +++++++++++++
 ip/iplink.c    | 35 +++++++++++++++++++++++++++++++++++
 3 files changed, 49 insertions(+)

diff --git a/ip/ip_common.h b/ip/ip_common.h
index 42eda66..286f61f 100644
--- a/ip/ip_common.h
+++ b/ip/ip_common.h
@@ -56,6 +56,7 @@ extern int do_ipl2tp(int argc, char **argv);
 extern int do_tcp_metrics(int argc, char **argv);
 extern int do_ipnetconf(int argc, char **argv);
 extern int do_iptoken(int argc, char **argv);
+extern int iplink_get(unsigned int flags, char *name, __u32 filt_mask);
 
 static inline int rtm_get_table(struct rtmsg *r, struct rtattr **tb)
 {
diff --git a/ip/ipaddress.c b/ip/ipaddress.c
index 0c741ff..b24b103 100644
--- a/ip/ipaddress.c
+++ b/ip/ipaddress.c
@@ -1392,6 +1392,19 @@ static int ipaddr_list_flush_or_save(int argc, char **argv, int action)
 		exit(0);
 	}
 
+	/*
+	 * If only filter_dev present and none of the other
+	 * link filters are present, use RTM_GETLINK to get
+	 * the link device
+	 */
+	if (filter_dev && filter.group == -1 && do_link == 1) {
+		if (iplink_get(0, filter_dev, RTEXT_FILTER_VF) < 0) {
+			perror("Cannot send link get request");
+			exit(1);
+		}
+		exit(0);
+	}
+
 	if (rtnl_wilddump_request(&rth, preferred_family, RTM_GETLINK) < 0) {
 		perror("Cannot send dump request");
 		exit(1);
diff --git a/ip/iplink.c b/ip/iplink.c
index f75193f..10f97af 100644
--- a/ip/iplink.c
+++ b/ip/iplink.c
@@ -829,6 +829,41 @@ static int iplink_modify(int cmd, unsigned int flags, int argc, char **argv)
 	return 0;
 }
 
+int iplink_get(unsigned int flags, char *name, __u32 filt_mask)
+{
+	int len;
+	struct iplink_req req;
+	struct {
+		struct nlmsghdr n;
+		char buf[16384];
+	} answer;
+
+	memset(&req, 0, sizeof(req));
+
+	req.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
+	req.n.nlmsg_flags = NLM_F_REQUEST|flags;
+	req.n.nlmsg_type = RTM_GETLINK;
+	req.i.ifi_family = preferred_family;
+
+	if (name) {
+		len = strlen(name) + 1;
+		if (len == 1)
+			invarg("\"\" is not a valid device identifier\n",
+				   "name");
+		if (len > IFNAMSIZ)
+			invarg("\"name\" too long\n", name);
+		addattr_l(&req.n, sizeof(req), IFLA_IFNAME, name, len);
+	}
+	addattr32(&req.n, sizeof(req), IFLA_EXT_MASK, filt_mask);
+
+	if (rtnl_talk(&rth, &req.n, &answer.n, sizeof(answer)) < 0)
+		return -2;
+
+	print_linkinfo(NULL, &answer.n, stdout);
+
+	return 0;
+}
+
 #if IPLINK_IOCTL_COMPAT
 static int get_ctl_fd(void)
 {
-- 
1.8.3.1

