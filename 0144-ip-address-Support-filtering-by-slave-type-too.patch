From eff77a8493746b837f0a544cab5bcc87870fe9f6 Mon Sep 17 00:00:00 2001
From: Phil Sutter <psutter@redhat.com>
Date: Fri, 17 Mar 2017 13:38:43 +0100
Subject: [PATCH] ip-address: Support filtering by slave type, too

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1375434
Upstream Status: iproute2.git commit e0513807f6dbb
Conflicts: Dropped changes to non-existent print_linkinfo_brief().

commit e0513807f6dbbd4631fdbb27f0bd6bbce138e8cd
Author: Phil Sutter <phil@nwl.cc>
Date:   Tue Jun 28 15:07:16 2016 +0200

    ip-address: Support filtering by slave type, too

    This patch allows to query all interfaces enslaved to a bridge or bond
    using the following syntax:

    | ip addr show type bridge_slave

    Filtering has to be done in userspace since the kernel does not support
    filtering on IFLA_INFO_SLAVE_KIND.

    Functionality introduced in this patch is not fully complete since it
    does not allow to match on type and slave type at the same time, but it
    doesn't prevent implementing a dedicated slave_type match, either.

    Signed-off-by: Phil Sutter <phil@nwl.cc>
---
 ip/ipaddress.c | 39 ++++++++++++++++++++++++++-------------
 1 file changed, 26 insertions(+), 13 deletions(-)

diff --git a/ip/ipaddress.c b/ip/ipaddress.c
index 5f08cde..fe04a28 100644
--- a/ip/ipaddress.c
+++ b/ip/ipaddress.c
@@ -59,6 +59,7 @@ static struct
 	int group;
 	int master;
 	char *kind;
+	char *slave_kind;
 } filter;
 
 static int do_link;
@@ -198,18 +199,27 @@ static void print_linkmode(FILE *f, struct rtattr *tb)
 		fprintf(f, "mode %s ", link_modes[mode]);
 }
 
-static char *parse_link_kind(struct rtattr *tb)
+static char *parse_link_kind(struct rtattr *tb, bool slave)
 {
 	struct rtattr *linkinfo[IFLA_INFO_MAX+1];
+	int attr = slave ? IFLA_INFO_SLAVE_KIND : IFLA_INFO_KIND;
 
 	parse_rtattr_nested(linkinfo, IFLA_INFO_MAX, tb);
 
-	if (linkinfo[IFLA_INFO_KIND])
-		return RTA_DATA(linkinfo[IFLA_INFO_KIND]);
+	if (linkinfo[attr])
+		return RTA_DATA(linkinfo[attr]);
 
 	return "";
 }
 
+static int match_link_kind(struct rtattr **tb, char *kind, bool slave)
+{
+	if (!tb[IFLA_LINKINFO])
+		return -1;
+
+	return strcmp(parse_link_kind(tb[IFLA_LINKINFO], slave), kind);
+}
+
 static void print_linktype(FILE *fp, struct rtattr *tb)
 {
 	struct rtattr *linkinfo[IFLA_INFO_MAX+1];
@@ -590,16 +600,11 @@ int print_linkinfo(const struct sockaddr_nl *who,
 	else if (filter.master > 0)
 		return -1;
 
-	if (filter.kind) {
-		if (tb[IFLA_LINKINFO]) {
-			char *kind = parse_link_kind(tb[IFLA_LINKINFO]);
+	if (filter.kind && match_link_kind(tb, filter.kind, 0))
+		return -1;
 
-			if (strcmp(kind, filter.kind))
-				return -1;
-		} else {
-			return -1;
-		}
-	}
+	if (filter.slave_kind && match_link_kind(tb, filter.slave_kind, 1))
+		return -1;
 
 	if (n->nlmsg_type == RTM_DELLINK)
 		fprintf(fp, "Deleted ");
@@ -1357,8 +1362,16 @@ static int ipaddr_list_flush_or_save(int argc, char **argv, int action)
 				invarg("Device does not exist\n", *argv);
 			filter.master = ifindex;
 		} else if (strcmp(*argv, "type") == 0) {
+			int soff;
+
 			NEXT_ARG();
-			filter.kind = *argv;
+			soff = strlen(*argv) - strlen("_slave");
+			if (!strcmp(*argv + soff, "_slave")) {
+				(*argv)[soff] = '\0';
+				filter.slave_kind = *argv;
+			} else {
+				filter.kind = *argv;
+			}
 		} else {
 			if (strcmp(*argv, "dev") == 0) {
 				NEXT_ARG();
-- 
1.8.3.1

